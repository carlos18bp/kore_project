{"id":"d35780fcbf834e3e1d90f4d75edf446b51d0f6c7","url":"http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_17643121._.js","source":"(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === \"object\" ? document.currentScript : undefined,\n\"[project]/node_modules/next/dist/client/asset-prefix.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getAssetPrefix\", {\n    enumerable: true,\n    get: function() {\n        return getAssetPrefix;\n    }\n});\nconst _invarianterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)\");\nfunction getAssetPrefix() {\n    const currentScript = document.currentScript;\n    if (!(currentScript instanceof HTMLScriptElement)) {\n        throw Object.defineProperty(new _invarianterror.InvariantError(`Expected document.currentScript to be a <script> element. Received ${currentScript} instead.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E783\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { pathname } = new URL(currentScript.src);\n    const nextIndex = pathname.indexOf('/_next/');\n    if (nextIndex === -1) {\n        throw Object.defineProperty(new _invarianterror.InvariantError(`Expected document.currentScript src to contain '/_next/'. Received ${currentScript.src} instead.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E784\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return pathname.slice(0, nextIndex);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=asset-prefix.js.map\n}),\n\"[project]/node_modules/next/dist/client/set-attributes-from-props.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"setAttributesFromProps\", {\n    enumerable: true,\n    get: function() {\n        return setAttributesFromProps;\n    }\n});\nconst DOMAttributeNames = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv',\n    noModule: 'noModule'\n};\nconst ignoreProps = [\n    'onLoad',\n    'onReady',\n    'dangerouslySetInnerHTML',\n    'children',\n    'onError',\n    'strategy',\n    'stylesheets'\n];\nfunction isBooleanScriptAttribute(attr) {\n    return [\n        'async',\n        'defer',\n        'noModule'\n    ].includes(attr);\n}\nfunction setAttributesFromProps(el, props) {\n    for (const [p, value] of Object.entries(props)){\n        if (!props.hasOwnProperty(p)) continue;\n        if (ignoreProps.includes(p)) continue;\n        // we don't render undefined props to the DOM\n        if (value === undefined) {\n            continue;\n        }\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n            // Correctly assign boolean script attributes\n            // https://github.com/vercel/next.js/pull/20748\n            ;\n            el[attr] = !!value;\n        } else {\n            el.setAttribute(attr, String(value));\n        }\n        // Remove falsy non-zero boolean attributes so they are correctly interpreted\n        // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n        if (value === false || el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr) && (!value || value === 'false')) {\n            // Call setAttribute before, as we need to set and unset the attribute to override force async:\n            // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n            el.setAttribute(attr, '');\n            el.removeAttribute(attr);\n        }\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-attributes-from-props.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-bootstrap.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"appBootstrap\", {\n    enumerable: true,\n    get: function() {\n        return appBootstrap;\n    }\n});\nconst _assetprefix = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/asset-prefix.js [app-client] (ecmascript)\");\nconst _setattributesfromprops = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/set-attributes-from-props.js [app-client] (ecmascript)\");\nconst version = \"16.1.6\";\nwindow.next = {\n    version,\n    appDir: true\n};\nfunction loadScriptsInSequence(scripts, hydrate) {\n    if (!scripts || !scripts.length) {\n        return hydrate();\n    }\n    return scripts.reduce((promise, [src, props])=>{\n        return promise.then(()=>{\n            return new Promise((resolve, reject)=>{\n                const el = document.createElement('script');\n                if (props) {\n                    (0, _setattributesfromprops.setAttributesFromProps)(el, props);\n                }\n                if (src) {\n                    el.src = src;\n                    el.onload = ()=>resolve();\n                    el.onerror = reject;\n                } else if (props) {\n                    el.innerHTML = props.children;\n                    setTimeout(resolve);\n                }\n                document.head.appendChild(el);\n            });\n        });\n    }, Promise.resolve()).catch((err)=>{\n        console.error(err);\n    // Still try to hydrate even if there's an error.\n    }).then(()=>{\n        hydrate();\n    });\n}\nfunction appBootstrap(hydrate) {\n    const assetPrefix = (0, _assetprefix.getAssetPrefix)();\n    loadScriptsInSequence(self.__next_s, ()=>{\n        // If the static shell is being debugged, skip hydration if the\n        // `__nextppronly` query is present. This is only enabled when the\n        // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n        // set to `1`. Otherwise the following is optimized out.\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        hydrate(assetPrefix);\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-bootstrap.js.map\n}),\n\"[project]/node_modules/next/dist/client/react-client-callbacks/report-global-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"reportGlobalError\", {\n    enumerable: true,\n    get: function() {\n        return reportGlobalError;\n    }\n});\nconst reportGlobalError = typeof reportError === 'function' ? reportError : (error)=>{\n    // TODO: Dispatch error event\n    globalThis.console.error(error);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=report-global-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n// This module can be shared between both pages router and app router\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    isRecoverableError: null,\n    onRecoverableError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isRecoverableError: function() {\n        return isRecoverableError;\n    },\n    onRecoverableError: function() {\n        return onRecoverableError;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _bailouttocsr = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)\"));\nconst _reportglobalerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/react-client-callbacks/report-global-error.js [app-client] (ecmascript)\");\nconst recoverableErrors = new WeakSet();\nfunction isRecoverableError(error) {\n    return recoverableErrors.has(error);\n}\nconst onRecoverableError = (error)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    let cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { decorateDevError } = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)\");\n        const causeError = decorateDevError(cause);\n        recoverableErrors.add(causeError);\n        cause = causeError;\n    }\n    (0, _reportglobalerror.reportGlobalError)(cause);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-recoverable-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    HTTPAccessErrorStatus: null,\n    HTTP_ERROR_FALLBACK_ERROR_CODE: null,\n    getAccessFallbackErrorTypeByStatus: null,\n    getAccessFallbackHTTPStatus: null,\n    isHTTPAccessFallbackError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    HTTPAccessErrorStatus: function() {\n        return HTTPAccessErrorStatus;\n    },\n    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {\n        return HTTP_ERROR_FALLBACK_ERROR_CODE;\n    },\n    getAccessFallbackErrorTypeByStatus: function() {\n        return getAccessFallbackErrorTypeByStatus;\n    },\n    getAccessFallbackHTTPStatus: function() {\n        return getAccessFallbackHTTPStatus;\n    },\n    isHTTPAccessFallbackError: function() {\n        return isHTTPAccessFallbackError;\n    }\n});\nconst HTTPAccessErrorStatus = {\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    UNAUTHORIZED: 401\n};\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));\nconst HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';\nfunction isHTTPAccessFallbackError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const [prefix, httpStatus] = error.digest.split(';');\n    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));\n}\nfunction getAccessFallbackHTTPStatus(error) {\n    const httpStatus = error.digest.split(';')[1];\n    return Number(httpStatus);\n}\nfunction getAccessFallbackErrorTypeByStatus(status) {\n    switch(status){\n        case 401:\n            return 'unauthorized';\n        case 403:\n            return 'forbidden';\n        case 404:\n            return 'not-found';\n        default:\n            return;\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=http-access-fallback.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"RedirectStatusCode\", {\n    enumerable: true,\n    get: function() {\n        return RedirectStatusCode;\n    }\n});\nvar RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {\n    RedirectStatusCode[RedirectStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\n    RedirectStatusCode[RedirectStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    RedirectStatusCode[RedirectStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    return RedirectStatusCode;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=redirect-status-code.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    REDIRECT_ERROR_CODE: null,\n    RedirectType: null,\n    isRedirectError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    REDIRECT_ERROR_CODE: function() {\n        return REDIRECT_ERROR_CODE;\n    },\n    RedirectType: function() {\n        return RedirectType;\n    },\n    isRedirectError: function() {\n        return isRedirectError;\n    }\n});\nconst _redirectstatuscode = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-client] (ecmascript)\");\nconst REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';\nvar RedirectType = /*#__PURE__*/ function(RedirectType) {\n    RedirectType[\"push\"] = \"push\";\n    RedirectType[\"replace\"] = \"replace\";\n    return RedirectType;\n}({});\nfunction isRedirectError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const digest = error.digest.split(';');\n    const [errorCode, type] = digest;\n    const destination = digest.slice(2, -2).join(';');\n    const status = digest.at(-2);\n    const statusCode = Number(status);\n    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=redirect-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isNextRouterError\", {\n    enumerable: true,\n    get: function() {\n        return isNextRouterError;\n    }\n});\nconst _httpaccessfallback = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)\");\nconst _redirecterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\");\nfunction isNextRouterError(error) {\n    return (0, _redirecterror.isRedirectError)(error) || (0, _httpaccessfallback.isHTTPAccessFallbackError)(error);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-next-router-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/lib/console.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    formatConsoleArgs: null,\n    parseConsoleArgs: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatConsoleArgs: function() {\n        return formatConsoleArgs;\n    },\n    parseConsoleArgs: function() {\n        return parseConsoleArgs;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)\"));\nfunction formatObject(arg, depth) {\n    switch(typeof arg){\n        case 'object':\n            if (arg === null) {\n                return 'null';\n            } else if (Array.isArray(arg)) {\n                let result = '[';\n                if (depth < 1) {\n                    for(let i = 0; i < arg.length; i++){\n                        if (result !== '[') {\n                            result += ',';\n                        }\n                        if (Object.prototype.hasOwnProperty.call(arg, i)) {\n                            result += formatObject(arg[i], depth + 1);\n                        }\n                    }\n                } else {\n                    result += arg.length > 0 ? '...' : '';\n                }\n                result += ']';\n                return result;\n            } else if (arg instanceof Error) {\n                return arg + '';\n            } else {\n                const keys = Object.keys(arg);\n                let result = '{';\n                if (depth < 1) {\n                    for(let i = 0; i < keys.length; i++){\n                        const key = keys[i];\n                        const desc = Object.getOwnPropertyDescriptor(arg, 'key');\n                        if (desc && !desc.get && !desc.set) {\n                            const jsonKey = JSON.stringify(key);\n                            if (jsonKey !== '\"' + key + '\"') {\n                                result += jsonKey + ': ';\n                            } else {\n                                result += key + ': ';\n                            }\n                            result += formatObject(desc.value, depth + 1);\n                        }\n                    }\n                } else {\n                    result += keys.length > 0 ? '...' : '';\n                }\n                result += '}';\n                return result;\n            }\n        case 'string':\n            return JSON.stringify(arg);\n        case 'number':\n        case 'bigint':\n        case 'boolean':\n        case 'symbol':\n        case 'undefined':\n        case 'function':\n        default:\n            return String(arg);\n    }\n}\nfunction formatConsoleArgs(args) {\n    let message;\n    let idx;\n    if (typeof args[0] === 'string') {\n        message = args[0];\n        idx = 1;\n    } else {\n        message = '';\n        idx = 0;\n    }\n    let result = '';\n    let startQuote = false;\n    for(let i = 0; i < message.length; ++i){\n        const char = message[i];\n        if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n            result += char;\n            continue;\n        }\n        const code = message[++i];\n        switch(code){\n            case 'c':\n                {\n                    // TODO: We should colorize with HTML instead of turning into a string.\n                    // Ignore for now.\n                    result = startQuote ? `${result}]` : `[${result}`;\n                    startQuote = !startQuote;\n                    idx++;\n                    break;\n                }\n            case 'O':\n            case 'o':\n                {\n                    result += formatObject(args[idx++], 0);\n                    break;\n                }\n            case 'd':\n            case 'i':\n                {\n                    result += parseInt(args[idx++], 10);\n                    break;\n                }\n            case 'f':\n                {\n                    result += parseFloat(args[idx++]);\n                    break;\n                }\n            case 's':\n                {\n                    result += String(args[idx++]);\n                    break;\n                }\n            default:\n                result += '%' + code;\n        }\n    }\n    for(; idx < args.length; idx++){\n        result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0);\n    }\n    return result;\n}\nfunction parseConsoleArgs(args) {\n    // See\n    // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n    //\n    // Logs replayed from the server look like this:\n    // [\n    //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n    //   \"background: #e6e6e6; ...\",\n    //   \" Server \", // can also be e.g. \" Prerender \"\n    //   \"\",\n    //   Error,\n    //   \"The above error occurred in the <Page> component.\",\n    //   ...\n    // ]\n    if (args.length > 3 && typeof args[0] === 'string' && args[0].startsWith('%c%s%c') && typeof args[1] === 'string' && typeof args[2] === 'string' && typeof args[3] === 'string') {\n        const environmentName = args[2];\n        const maybeError = args[4];\n        return {\n            environmentName: environmentName.trim(),\n            error: (0, _iserror.default)(maybeError) ? maybeError : null\n        };\n    }\n    return {\n        environmentName: null,\n        error: null\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=console.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-globals.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n// imports polyfill from `@next/polyfill-module` after build.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n__turbopack_context__.r(\"[project]/node_modules/next/dist/build/polyfills/polyfill-module.js [app-client] (ecmascript)\");\n// Only setup devtools in development\nif (\"TURBOPACK compile-time truthy\", 1) {\n    __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-setup.js [app-client] (ecmascript)\");\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-globals.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/readonly-url-search-params.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\n/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */ /** @internal */ Object.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ReadonlyURLSearchParams\", {\n    enumerable: true,\n    get: function() {\n        return ReadonlyURLSearchParams;\n    }\n});\nclass ReadonlyURLSearchParamsError extends Error {\n    constructor(){\n        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');\n    }\n}\nclass ReadonlyURLSearchParams extends URLSearchParams {\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=readonly-url-search-params.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HEADER: null,\n    FLIGHT_HEADERS: null,\n    NEXT_ACTION_NOT_FOUND_HEADER: null,\n    NEXT_ACTION_REVALIDATED_HEADER: null,\n    NEXT_DID_POSTPONE_HEADER: null,\n    NEXT_HMR_REFRESH_HASH_COOKIE: null,\n    NEXT_HMR_REFRESH_HEADER: null,\n    NEXT_HTML_REQUEST_ID_HEADER: null,\n    NEXT_IS_PRERENDER_HEADER: null,\n    NEXT_REQUEST_ID_HEADER: null,\n    NEXT_REWRITTEN_PATH_HEADER: null,\n    NEXT_REWRITTEN_QUERY_HEADER: null,\n    NEXT_ROUTER_PREFETCH_HEADER: null,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: null,\n    NEXT_ROUTER_STALE_TIME_HEADER: null,\n    NEXT_ROUTER_STATE_TREE_HEADER: null,\n    NEXT_RSC_UNION_QUERY: null,\n    NEXT_URL: null,\n    RSC_CONTENT_TYPE_HEADER: null,\n    RSC_HEADER: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HEADER: function() {\n        return ACTION_HEADER;\n    },\n    FLIGHT_HEADERS: function() {\n        return FLIGHT_HEADERS;\n    },\n    NEXT_ACTION_NOT_FOUND_HEADER: function() {\n        return NEXT_ACTION_NOT_FOUND_HEADER;\n    },\n    NEXT_ACTION_REVALIDATED_HEADER: function() {\n        return NEXT_ACTION_REVALIDATED_HEADER;\n    },\n    NEXT_DID_POSTPONE_HEADER: function() {\n        return NEXT_DID_POSTPONE_HEADER;\n    },\n    NEXT_HMR_REFRESH_HASH_COOKIE: function() {\n        return NEXT_HMR_REFRESH_HASH_COOKIE;\n    },\n    NEXT_HMR_REFRESH_HEADER: function() {\n        return NEXT_HMR_REFRESH_HEADER;\n    },\n    NEXT_HTML_REQUEST_ID_HEADER: function() {\n        return NEXT_HTML_REQUEST_ID_HEADER;\n    },\n    NEXT_IS_PRERENDER_HEADER: function() {\n        return NEXT_IS_PRERENDER_HEADER;\n    },\n    NEXT_REQUEST_ID_HEADER: function() {\n        return NEXT_REQUEST_ID_HEADER;\n    },\n    NEXT_REWRITTEN_PATH_HEADER: function() {\n        return NEXT_REWRITTEN_PATH_HEADER;\n    },\n    NEXT_REWRITTEN_QUERY_HEADER: function() {\n        return NEXT_REWRITTEN_QUERY_HEADER;\n    },\n    NEXT_ROUTER_PREFETCH_HEADER: function() {\n        return NEXT_ROUTER_PREFETCH_HEADER;\n    },\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {\n        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;\n    },\n    NEXT_ROUTER_STALE_TIME_HEADER: function() {\n        return NEXT_ROUTER_STALE_TIME_HEADER;\n    },\n    NEXT_ROUTER_STATE_TREE_HEADER: function() {\n        return NEXT_ROUTER_STATE_TREE_HEADER;\n    },\n    NEXT_RSC_UNION_QUERY: function() {\n        return NEXT_RSC_UNION_QUERY;\n    },\n    NEXT_URL: function() {\n        return NEXT_URL;\n    },\n    RSC_CONTENT_TYPE_HEADER: function() {\n        return RSC_CONTENT_TYPE_HEADER;\n    },\n    RSC_HEADER: function() {\n        return RSC_HEADER;\n    }\n});\nconst RSC_HEADER = 'rsc';\nconst ACTION_HEADER = 'next-action';\nconst NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\nconst NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\nconst NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\nconst NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\nconst NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\nconst NEXT_URL = 'next-url';\nconst RSC_CONTENT_TYPE_HEADER = 'text/x-component';\nconst FLIGHT_HEADERS = [\n    RSC_HEADER,\n    NEXT_ROUTER_STATE_TREE_HEADER,\n    NEXT_ROUTER_PREFETCH_HEADER,\n    NEXT_HMR_REFRESH_HEADER,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n];\nconst NEXT_RSC_UNION_QUERY = '_rsc';\nconst NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\nconst NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\nconst NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\nconst NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\nconst NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\nconst NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\nconst NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id';\nconst NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id';\nconst NEXT_ACTION_REVALIDATED_HEADER = 'x-action-revalidated';\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-headers.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"useUntrackedPathname\", {\n    enumerable: true,\n    get: function() {\n        return useUntrackedPathname;\n    }\n});\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _hooksclientcontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)\");\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */ function hasFallbackRouteParams() {\n    if (typeof window === 'undefined') {\n        // AsyncLocalStorage should not be included in the client bundle.\n        const { workUnitAsyncStorage } = __turbopack_context__.r(\"[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)\");\n        const workUnitStore = workUnitAsyncStorage.getStore();\n        if (!workUnitStore) return false;\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n                const fallbackParams = workUnitStore.fallbackRouteParams;\n                return fallbackParams ? fallbackParams.size > 0 : false;\n            case 'prerender-legacy':\n            case 'request':\n            case 'prerender-runtime':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n        return false;\n    }\n    return false;\n}\nfunction useUntrackedPathname() {\n    // If there are any unknown route parameters we would typically throw\n    // an error, but this internal method allows us to return a null value instead\n    // for components that do not propagate the pathname to the static shell (like\n    // the error boundary).\n    if (hasFallbackRouteParams()) {\n        return null;\n    }\n    // This shouldn't cause any issues related to conditional rendering because\n    // the environment will be consistent for the render.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation-untracked.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createHrefFromUrl\", {\n    enumerable: true,\n    get: function() {\n        return createHrefFromUrl;\n    }\n});\nfunction createHrefFromUrl(url, includeHash = true) {\n    return url.pathname + url.search + (includeHash ? url.hash : '');\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-href-from-url.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    handleHardNavError: null,\n    useNavFailureHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleHardNavError: function() {\n        return handleHardNavError;\n    },\n    useNavFailureHandler: function() {\n        return useNavFailureHandler;\n    }\n});\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nfunction handleHardNavError(error) {\n    if (error && typeof window !== 'undefined' && window.next.__pendingUrl && (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== (0, _createhreffromurl.createHrefFromUrl)(window.next.__pendingUrl)) {\n        console.error(`Error occurred during navigation, falling back to hard navigation`, error);\n        window.location.href = window.next.__pendingUrl.toString();\n        return true;\n    }\n    return false;\n}\nfunction useNavFailureHandler() {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=nav-failure-handler.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"HandleISRError\", {\n    enumerable: true,\n    get: function() {\n        return HandleISRError;\n    }\n});\nconst workAsyncStorage = typeof window === 'undefined' ? __turbopack_context__.r(\"[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)\").workAsyncStorage : undefined;\nfunction HandleISRError({ error }) {\n    if (workAsyncStorage) {\n        const store = workAsyncStorage.getStore();\n        if (store?.isStaticGeneration) {\n            if (error) {\n                console.error(error);\n            }\n            throw error;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-isr-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ErrorBoundary: null,\n    ErrorBoundaryHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ErrorBoundary: function() {\n        return ErrorBoundary;\n    },\n    ErrorBoundaryHandler: function() {\n        return ErrorBoundaryHandler;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _navigationuntracked = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)\");\nconst _isnextroutererror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)\");\nconst _navfailurehandler = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-client] (ecmascript)\");\nconst _handleisrerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-client] (ecmascript)\");\nconst _isbot = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)\");\nconst isBotUserAgent = typeof window !== 'undefined' && (0, _isbot.isBot)(window.navigator.userAgent);\nclass ErrorBoundaryHandler extends _react.default.Component {\n    constructor(props){\n        super(props), this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null,\n            previousPathname: this.props.pathname\n        };\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _isnextroutererror.isNextRouterError)(error)) {\n            // Re-throw if an expected internal Next.js router error occurs\n            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n            throw error;\n        }\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        const { error } = state;\n        // if we encounter an error while\n        // a navigation is pending we shouldn't render\n        // the error boundary and instead should fallback\n        // to a hard navigation to attempt recovering\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.error) {\n            return {\n                error: null,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            error: state.error,\n            previousPathname: props.pathname\n        };\n    }\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n    render() {\n        //When it's bot request, segment level error boundary will keep rendering the children,\n        // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n        if (this.state.error && !isBotUserAgent) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {\n                        error: this.state.error\n                    }),\n                    this.props.errorStyles,\n                    this.props.errorScripts,\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(this.props.errorComponent, {\n                        error: this.state.error,\n                        reset: this.reset\n                    })\n                ]\n            });\n        }\n        return this.props.children;\n    }\n}\nfunction ErrorBoundary({ errorComponent, errorStyles, errorScripts, children }) {\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these errors can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    if (errorComponent) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryHandler, {\n            pathname: pathname,\n            errorComponent: errorComponent,\n            errorStyles: errorStyles,\n            errorScripts: errorScripts,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // supplied custom global error signatures.\n\"default\", {\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n});\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _handleisrerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-client] (ecmascript)\");\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: 'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        height: '100vh',\n        textAlign: 'center',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center'\n    },\n    text: {\n        fontSize: '14px',\n        fontWeight: 400,\n        lineHeight: '28px',\n        margin: '0 8px'\n    }\n};\nfunction DefaultGlobalError({ error }) {\n    const digest = error?.digest;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"html\", {\n        id: \"__next_error__\",\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"head\", {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"body\", {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {\n                        error: error\n                    }),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n                        style: styles.error,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"h2\", {\n                                    style: styles.text,\n                                    children: [\n                                        \"Application error: a \",\n                                        digest ? 'server' : 'client',\n                                        \"-side exception has occurred while loading \",\n                                        window.location.hostname,\n                                        \" (see the\",\n                                        ' ',\n                                        digest ? 'server logs' : 'browser console',\n                                        \" for more information).\"\n                                    ]\n                                }),\n                                digest ? /*#__PURE__*/ (0, _jsxruntime.jsx)(\"p\", {\n                                    style: styles.text,\n                                    children: `Digest: ${digest}`\n                                }) : null\n                            ]\n                        })\n                    })\n                ]\n            })\n        ]\n    });\n}\nconst _default = DefaultGlobalError;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=global-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"RuntimeErrorHandler\", {\n    enumerable: true,\n    get: function() {\n        return RuntimeErrorHandler;\n    }\n});\nconst RuntimeErrorHandler = {\n    hadRuntimeError: false\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=runtime-error-handler.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/not-found.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"notFound\", {\n    enumerable: true,\n    get: function() {\n        return notFound;\n    }\n});\nconst _httpaccessfallback = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)\");\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};404`;\nfunction notFound() {\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=not-found.js.map\n}),\n\"[project]/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n// This file is only used in app router due to the specific error state handling.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    onCaughtError: null,\n    onUncaughtError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _isnextroutererror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)\");\nconst _bailouttocsr = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)\");\nconst _reportglobalerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/react-client-callbacks/report-global-error.js [app-client] (ecmascript)\");\nconst _errorboundary = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)\");\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)\"));\nconst devToolErrorMod = (\"TURBOPACK compile-time truthy\", 1) ? __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/index.js [app-client] (ecmascript)\") : \"TURBOPACK unreachable\";\nfunction onCaughtError(thrownValue, errorInfo) {\n    const errorBoundaryComponent = errorInfo.errorBoundary?.constructor;\n    let isImplicitErrorBoundary;\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { AppDevOverlayErrorBoundary } = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-client] (ecmascript)\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _globalerror.default;\n    // Skip the segment explorer triggered error\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)\");\n        if (thrownValue instanceof Error && thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {\n            return;\n        }\n    }\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(thrownValue);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const errorBoundaryName = errorBoundaryComponent?.displayName || errorBoundaryComponent?.name || 'Unknown';\n        const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1];\n        // Match chrome or safari stack trace\n        const matches = // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`;\n        const componentErrorMessage = (\"TURBOPACK compile-time truthy\", 1) ? `The above error occurred in the <${componentThatErroredName}> component.` : \"TURBOPACK unreachable\";\n        const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`;\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // Log and report the error with location but without modifying the error stack\n        devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation);\n        devToolErrorMod.handleClientError(error);\n    } else //TURBOPACK unreachable\n    ;\n}\nfunction onUncaughtError(thrownValue) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(error);\n    } else //TURBOPACK unreachable\n    ;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HMR_REFRESH: null,\n    ACTION_NAVIGATE: null,\n    ACTION_REFRESH: null,\n    ACTION_RESTORE: null,\n    ACTION_SERVER_ACTION: null,\n    ACTION_SERVER_PATCH: null,\n    PrefetchKind: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    return PrefetchKind;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    dispatchAppRouterAction: null,\n    useActionQueue: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dispatchAppRouterAction: function() {\n        return dispatchAppRouterAction;\n    },\n    useActionQueue: function() {\n        return useActionQueue;\n    }\n});\nconst _interop_require_wildcard = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _isthenable = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-client] (ecmascript)\");\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch = null;\nfunction dispatchAppRouterAction(action) {\n    if (dispatch === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    dispatch(action);\n}\nconst __DEV__ = (\"TURBOPACK compile-time value\", \"development\") !== 'production';\nconst promisesWithDebugInfo = (\"TURBOPACK compile-time truthy\", 1) ? new WeakMap() : \"TURBOPACK unreachable\";\nfunction useActionQueue(actionQueue) {\n    const [state, setState] = _react.default.useState(actionQueue.state);\n    // Because of a known issue that requires to decode Flight streams inside the\n    // render phase, we have to be a bit clever and assign the dispatch method to\n    // a module-level variable upon initialization. The useState hook in this\n    // module only exists to synchronize state that lives outside of React.\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\n    // this is conceptually how we're modeling the app router state, despite the\n    // weird implementation details.\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { useAppDevRenderingIndicator } = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-client] (ecmascript)\");\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const appDevRenderingIndicator = useAppDevRenderingIndicator();\n        dispatch = (action)=>{\n            appDevRenderingIndicator(()=>{\n                actionQueue.dispatch(action, setState);\n            });\n        };\n    } else //TURBOPACK unreachable\n    ;\n    // When navigating to a non-prefetched route, then App Router state will be\n    // blocked until the server responds. We need to transfer the `_debugInfo`\n    // from the underlying Flight response onto the top-level promise that is\n    // passed to React (via `use`) so that the latency is accurately represented\n    // in the React DevTools.\n    const stateWithDebugInfo = (0, _react.useMemo)(()=>{\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        if ((0, _isthenable.isThenable)(state)) {\n            // useMemo can't be used to cache a Promise since the memoized value is thrown\n            // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n            let promiseWithDebugInfo = promisesWithDebugInfo.get(state);\n            if (promiseWithDebugInfo === undefined) {\n                const debugInfo = [];\n                promiseWithDebugInfo = Promise.resolve(state).then((asyncState)=>{\n                    if (asyncState.debugInfo !== null) {\n                        debugInfo.push(...asyncState.debugInfo);\n                    }\n                    return asyncState;\n                });\n                promiseWithDebugInfo._debugInfo = debugInfo;\n                promisesWithDebugInfo.set(state, promiseWithDebugInfo);\n            }\n            return promiseWithDebugInfo;\n        }\n        return state;\n    }, [\n        state\n    ]);\n    return (0, _isthenable.isThenable)(stateWithDebugInfo) ? (0, _react.use)(stateWithDebugInfo) : stateWithDebugInfo;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-action-queue.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"callServer\", {\n    enumerable: true,\n    get: function() {\n        return callServer;\n    }\n});\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _routerreducertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)\");\nconst _useactionqueue = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)\");\nasync function callServer(actionId, actionArgs) {\n    return new Promise((resolve, reject)=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_SERVER_ACTION,\n                actionId,\n                actionArgs,\n                resolve,\n                reject\n            });\n        });\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-call-server.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"findSourceMapURL\", {\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n});\nconst basePath = (\"TURBOPACK compile-time value\", \"\") || '';\nconst pathname = `${basePath}/__nextjs_source-map`;\nconst findSourceMapURL = (\"TURBOPACK compile-time truthy\", 1) ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return `${filename}.map`;\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : \"TURBOPACK unreachable\";\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-find-source-map-url.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"matchSegment\", {\n    enumerable: true,\n    get: function() {\n        return matchSegment;\n    }\n});\nconst matchSegment = (existingSegment, segment)=>{\n    // segment is either Array or string\n    if (typeof existingSegment === 'string') {\n        if (typeof segment === 'string') {\n            // Common case: segment is just a string\n            return existingSegment === segment;\n        }\n        return false;\n    }\n    if (typeof segment === 'string') {\n        return false;\n    }\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=match-segments.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    computeChangedPath: null,\n    extractPathFromFlightRouterState: null,\n    getSelectedParams: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    computeChangedPath: function() {\n        return computeChangedPath;\n    },\n    extractPathFromFlightRouterState: function() {\n        return extractPathFromFlightRouterState;\n    },\n    getSelectedParams: function() {\n        return getSelectedParams;\n    }\n});\nconst _interceptionroutes = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-client] (ecmascript)\");\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _matchsegments = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)\");\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === '/' ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === 'string') {\n        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n        if (segment === 'children') return '';\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === '' || (0, _segment.isGroupSegment)(segment)) {\n            return acc;\n        }\n        return `${acc}/${segment}`;\n    }, '') || '/';\n}\nfunction extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return '';\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    const parallelRoutes = flightRouterState[1] ?? {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === 'children') continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return '';\n    }\n    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return extractPathFromFlightRouterState(treeB) ?? '';\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return `${segmentToPathname(segmentB)}/${changedPath}`;\n            }\n        }\n    }\n    return null;\n}\nfunction computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === '/') {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split('/'));\n}\nfunction getSelectedParams(currentTree, params = {}) {\n    const parallelRoutes = currentTree[1];\n    for (const parallelRoute of Object.values(parallelRoutes)){\n        const segment = parallelRoute[0];\n        const isDynamicParameter = Array.isArray(segment);\n        const segmentValue = isDynamicParameter ? segment[1] : segment;\n        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;\n        // Ensure catchAll and optional catchall are turned into an array\n        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');\n        if (isCatchAll) {\n            params[segment[0]] = segment[1].split('/');\n        } else if (isDynamicParameter) {\n            params[segment[0]] = segment[1];\n        }\n        params = getSelectedParams(parallelRoute, params);\n    }\n    return params;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=compute-changed-path.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"handleMutable\", {\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n});\nconst _computechangedpath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)\");\nfunction isNotUndefined(value) {\n    return typeof value !== 'undefined';\n}\nfunction handleMutable(state, mutable) {\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = mutable.shouldScroll ?? true;\n    let previousNextUrl = state.previousNextUrl;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            previousNextUrl = nextUrl;\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    return {\n        // Set href.\n        canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n        renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable?.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: mutable.onlyHashChange || false,\n            hashFragment: shouldScroll ? mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl,\n        previousNextUrl: previousNextUrl,\n        debugInfo: mutable.collectedDebugInfo ?? null\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-mutable.js.map\n}),\n\"[project]/node_modules/next/dist/client/route-params.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    doesStaticSegmentAppearInURL: null,\n    getCacheKeyForDynamicParam: null,\n    getParamValueFromCacheKey: null,\n    getRenderedPathname: null,\n    getRenderedSearch: null,\n    parseDynamicParamFromURLPart: null,\n    urlSearchParamsToParsedUrlQuery: null,\n    urlToUrlWithoutFlightMarker: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlSearchParamsToParsedUrlQuery: function() {\n        return urlSearchParamsToParsedUrlQuery;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _segmentvalueencoding = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js [app-client] (ecmascript)\");\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nfunction urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-params.js.map\n}),\n\"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createInitialRSCPayloadFromFallbackPrerender: null,\n    getFlightDataPartsFromPath: null,\n    getNextFlightSegmentPath: null,\n    normalizeFlightData: null,\n    prepareFlightRouterStateForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createInitialRSCPayloadFromFallbackPrerender: function() {\n        return createInitialRSCPayloadFromFallbackPrerender;\n    },\n    getFlightDataPartsFromPath: function() {\n        return getFlightDataPartsFromPath;\n    },\n    getNextFlightSegmentPath: function() {\n        return getNextFlightSegmentPath;\n    },\n    normalizeFlightData: function() {\n        return normalizeFlightData;\n    },\n    prepareFlightRouterStateForRequest: function() {\n        return prepareFlightRouterStateForRequest;\n    }\n});\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _routeparams = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/route-params.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nfunction getFlightDataPartsFromPath(flightDataPath) {\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n    const flightDataPathLength = 4;\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\n    return {\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\n        pathToSegment: segmentPath.slice(0, -1),\n        segmentPath,\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n        // in which case we default to ''.\n        segment: segmentPath[segmentPath.length - 1] ?? '',\n        tree,\n        seedData,\n        head,\n        isHeadPartial,\n        isRootRender: flightDataPath.length === flightDataPathLength\n    };\n}\nfunction createInitialRSCPayloadFromFallbackPrerender(response, fallbackInitialRSCPayload) {\n    // This is a static fallback page. In order to hydrate the page, we need to\n    // parse the client params from the URL, but to account for the possibility\n    // that the page was rewritten, we need to check the response headers\n    // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n    // we can't access the headers of the initial document response, the client\n    // performs a fetch request to the current location. Since it's possible that\n    // the fetch request will be dynamically rewritten to a different path than\n    // the initial document, this fetch request delivers _all_ the hydration data\n    // for the page; it was not inlined into the document, like it normally\n    // would be.\n    //\n    // TODO: Consider treating the case where fetch is rewritten to a different\n    // path from the document as a special deopt case. We should optimistically\n    // assume this won't happen, inline the data into the document, and perform\n    // a minimal request (like a HEAD or range request) to verify that the\n    // response matches. Tricky to get right because we need to account for\n    // all the different deployment environments we support, like output:\n    // \"export\" mode, where we currently don't assume that custom response\n    // headers are present.\n    // Patch the Flight data sent by the server with the correct params parsed\n    // from the URL + response object.\n    const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(new URL(location.href));\n    const originalFlightDataPath = fallbackInitialRSCPayload.f[0];\n    const originalFlightRouterState = originalFlightDataPath[0];\n    return {\n        b: fallbackInitialRSCPayload.b,\n        c: canonicalUrl.split('/'),\n        q: renderedSearch,\n        i: fallbackInitialRSCPayload.i,\n        f: [\n            [\n                fillInFallbackFlightRouterState(originalFlightRouterState, renderedPathname, renderedSearch),\n                originalFlightDataPath[1],\n                originalFlightDataPath[2],\n                originalFlightDataPath[2]\n            ]\n        ],\n        m: fallbackInitialRSCPayload.m,\n        G: fallbackInitialRSCPayload.G,\n        S: fallbackInitialRSCPayload.S\n    };\n}\nfunction fillInFallbackFlightRouterState(flightRouterState, renderedPathname, renderedSearch) {\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    return fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, index);\n}\nfunction fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, pathnamePartsIndex) {\n    const originalSegment = flightRouterState[0];\n    let newSegment;\n    let doesAppearInURL;\n    if (typeof originalSegment === 'string') {\n        newSegment = originalSegment;\n        doesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(originalSegment);\n    } else {\n        const paramName = originalSegment[0];\n        const paramType = originalSegment[2];\n        const paramValue = (0, _routeparams.parseDynamicParamFromURLPart)(paramType, pathnameParts, pathnamePartsIndex);\n        const cacheKey = (0, _routeparams.getCacheKeyForDynamicParam)(paramValue, renderedSearch);\n        newSegment = [\n            paramName,\n            cacheKey,\n            paramType\n        ];\n        doesAppearInURL = true;\n    }\n    // Only increment the index if the segment appears in the URL. If it's a\n    // \"virtual\" segment, like a route group, it remains the same.\n    const childPathnamePartsIndex = doesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n    const children = flightRouterState[1];\n    const newChildren = {};\n    for(let key in children){\n        const childFlightRouterState = children[key];\n        newChildren[key] = fillInFallbackFlightRouterStateImpl(childFlightRouterState, renderedSearch, pathnameParts, childPathnamePartsIndex);\n    }\n    const newState = [\n        newSegment,\n        newChildren,\n        null,\n        flightRouterState[3],\n        flightRouterState[4]\n    ];\n    return newState;\n}\nfunction getNextFlightSegmentPath(flightSegmentPath) {\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n    // to get the next segment path.\n    return flightSegmentPath.slice(2);\n}\nfunction normalizeFlightData(flightData) {\n    // FlightData can be a string when the server didn't respond with a proper flight response,\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n    if (typeof flightData === 'string') {\n        return flightData;\n    }\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\n}\nfunction prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\n    // HMR requests need the complete, unmodified state for proper functionality\n    if (isHmrRefresh) {\n        return encodeURIComponent(JSON.stringify(flightRouterState));\n    }\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\n}\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\n    // __PAGE__ segments are always fetched from the server, so there's\n    // no need to send them up\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\n    // Recursively process parallel routes\n    const cleanedParallelRoutes = {};\n    for (const [key, childState] of Object.entries(parallelRoutes)){\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\n    }\n    const result = [\n        cleanedSegment,\n        cleanedParallelRoutes,\n        null,\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\n    ];\n    // Append optional fields if present\n    if (isRootLayout !== undefined) {\n        result[4] = isRootLayout;\n    }\n    if (hasLoadingBoundary !== undefined) {\n        result[5] = hasLoadingBoundary;\n    }\n    return result;\n}\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */ function stripSearchParamsFromPageSegment(segment) {\n    if (typeof segment === 'string' && segment.startsWith(_segment.PAGE_SEGMENT_KEY + '?')) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */ function shouldPreserveRefreshMarker(refreshMarker) {\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=flight-data-helpers.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\n// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getAppBuildId: null,\n    setAppBuildId: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getAppBuildId: function() {\n        return getAppBuildId;\n    },\n    setAppBuildId: function() {\n        return setAppBuildId;\n    }\n});\nlet globalBuildId = '';\nfunction setAppBuildId(buildId) {\n    globalBuildId = buildId;\n}\nfunction getAppBuildId() {\n    return globalBuildId;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-build-id.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    setCacheBustingSearchParam: null,\n    setCacheBustingSearchParamWithHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    setCacheBustingSearchParam: function() {\n        return setCacheBustingSearchParam;\n    },\n    setCacheBustingSearchParamWithHash: function() {\n        return setCacheBustingSearchParamWithHash;\n    }\n});\nconst _cachebustingsearchparam = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-client] (ecmascript)\");\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);\n    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);\n};\nconst setCacheBustingSearchParamWithHash = (url, hash)=>{\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    // Always remove any existing cache busting param and add a fresh one to ensure\n    // we have the correct value based on current request headers\n    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=`));\n    if (hash.length > 0) {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=${hash}`);\n    } else {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}`);\n    }\n    url.search = pairs.length ? `?${pairs.join('&')}` : '';\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-cache-busting-search-param.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createFetch: null,\n    createFromNextReadableStream: null,\n    fetchServerResponse: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)\");\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nconst _appcallserver = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)\");\nconst _appfindsourcemapurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)\");\nconst _flightdatahelpers = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)\");\nconst _appbuildid = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)\");\nconst _setcachebustingsearchparam = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-client] (ecmascript)\");\nconst _routeparams = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/route-params.js [app-client] (ecmascript)\");\nconst _deploymentid = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/deployment-id.js [app-client] (ecmascript)\");\nconst createFromReadableStream = _client.createFromReadableStream;\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n;\nfunction doMpaNavigation(url) {\n    return (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString();\n}\nlet isPageUnloading = false;\nif (typeof window !== 'undefined') {\n    // Track when the page is unloading, e.g. due to reloading the page or\n    // performing hard navigations. This allows us to suppress error logging when\n    // the browser cancels in-flight requests during page unload.\n    window.addEventListener('pagehide', ()=>{\n        isPageUnloading = true;\n    });\n    // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n    // execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        isPageUnloading = false;\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    if ((\"TURBOPACK compile-time value\", \"development\") === 'development' && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    // In static export mode, we need to modify the URL to request the .txt file,\n    // but we should preserve the original URL for the canonical URL and error handling.\n    const originalUrl = url;\n    try {\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        // Typically, during a navigation, we decode the response using Flight's\n        // `createFromFetch` API, which accepts a `fetch` promise.\n        // TODO: Remove this check once the old PPR flag is removed\n        const isLegacyPPR = (\"TURBOPACK compile-time value\", false) && !(\"TURBOPACK compile-time value\", false);\n        const shouldImmediatelyDecode = !isLegacyPPR;\n        const res = await createFetch(url, headers, 'auto', shouldImmediatelyDecode);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!res.headers.get('vary')?.includes(_approuterheaders.NEXT_URL);\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        // TODO: This needs to happen in the Flight Client.\n        // Or Webpack needs to include the runtime update in the Flight response as\n        // a blocking script.\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        let flightResponsePromise = res.flightResponse;\n        if (flightResponsePromise === null) {\n            // Typically, `createFetch` would have already started decoding the\n            // Flight response. If it hasn't, though, we need to decode it now.\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n            // without Cache Components). Remove this branch once legacy PPR\n            // is deleted.\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\n        }\n        const flightResponse = await flightResponsePromise;\n        if ((0, _appbuildid.getAppBuildId)() !== flightResponse.b) {\n            return doMpaNavigation(res.url);\n        }\n        const normalizedFlightData = (0, _flightdatahelpers.normalizeFlightData)(flightResponse.f);\n        if (typeof normalizedFlightData === 'string') {\n            return doMpaNavigation(normalizedFlightData);\n        }\n        return {\n            flightData: normalizedFlightData,\n            canonicalUrl: canonicalUrl,\n            renderedSearch: (0, _routeparams.getRenderedSearch)(res),\n            couldBeIntercepted: interception,\n            prerendered: flightResponse.S,\n            postponed,\n            staleTime,\n            debugInfo: flightResponsePromise._debugInfo ?? null\n        };\n    } catch (err) {\n        if (!isPageUnloading) {\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return originalUrl.toString();\n    }\n}\nasync function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    if (deploymentId) {\n        headers['x-deployment-id'] = deploymentId;\n    }\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\n    // Immediately pass the fetch promise to the Flight client so that the debug\n    // info includes the latency from the client to the server. The internal timer\n    // in React starts as soon as `createFromFetch` is called.\n    //\n    // The only case where we don't do this is during a prefetch, because we have\n    // to do some extra processing of the response stream (see\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n    // prefetch response never blocks a navigation; if it hasn't already been\n    // written into the cache by the time the navigation happens, the router will\n    // go straight to a dynamic request.\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n    let browserResponse = await fetchPromise;\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid  when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status,\n        // This is the exact promise returned by `createFromFetch`. It contains\n        // debug information that we need to transfer to any derived promises that\n        // are later rendered by React.\n        flightResponse: flightResponsePromise\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream, requestHeaders) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\n    return createFromFetch(promiseForResponse, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createRouterCacheKey\", {\n    enumerable: true,\n    get: function() {\n        return createRouterCacheKey;\n    }\n});\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nfunction createRouterCacheKey(segment, withoutSearchParameters = false) {\n    // if the segment is an array, it means it's a dynamic segment\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n    if (Array.isArray(segment)) {\n        return `${segment[0]}|${segment[1]}|${segment[2]}`;\n    }\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\n    // When `withoutSearchParameters` is true, we only want to return the page segment\n    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-router-cache-key.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isNavigatingToNewRootLayout\", {\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n});\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    FreshnessPolicy: null,\n    createInitialCacheNodeForHydration: null,\n    isDeferredRsc: null,\n    spawnDynamicRequests: null,\n    startPPRNavigation: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    FreshnessPolicy: function() {\n        return FreshnessPolicy;\n    },\n    createInitialCacheNodeForHydration: function() {\n        return createInitialCacheNodeForHydration;\n    },\n    isDeferredRsc: function() {\n        return isDeferredRsc;\n    },\n    spawnDynamicRequests: function() {\n        return spawnDynamicRequests;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    }\n});\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _matchsegments = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _createroutercachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)\");\nconst _fetchserverresponse = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)\");\nconst _useactionqueue = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)\");\nconst _routerreducertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)\");\nconst _isnavigatingtonewrootlayout = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)\");\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nconst _navigation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/navigation.js [app-client] (ecmascript)\");\nvar FreshnessPolicy = /*#__PURE__*/ function(FreshnessPolicy) {\n    FreshnessPolicy[FreshnessPolicy[\"Default\"] = 0] = \"Default\";\n    FreshnessPolicy[FreshnessPolicy[\"Hydration\"] = 1] = \"Hydration\";\n    FreshnessPolicy[FreshnessPolicy[\"HistoryTraversal\"] = 2] = \"HistoryTraversal\";\n    FreshnessPolicy[FreshnessPolicy[\"RefreshAll\"] = 3] = \"RefreshAll\";\n    FreshnessPolicy[FreshnessPolicy[\"HMRRefresh\"] = 4] = \"HMRRefresh\";\n    return FreshnessPolicy;\n}({});\nconst noop = ()=>{};\nfunction createInitialCacheNodeForHydration(navigatedAt, initialTree, seedData, seedHead) {\n    // Create the initial cache node tree, using the data embedded into the\n    // HTML document.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const task = createCacheNodeOnNavigation(navigatedAt, initialTree, undefined, 1, seedData, seedHead, null, null, false, null, null, false, accumulation);\n    // NOTE: We intentionally don't check if any data needs to be fetched from the\n    // server. We assume the initial hydration payload is sufficient to render\n    // the page.\n    //\n    // The completeness of the initial data is an important property that we rely\n    // on as a last-ditch mechanism for recovering the app; we must always be able\n    // to reload a fresh HTML document to get to a consistent state.\n    //\n    // In the future, there may be cases where the server intentionally sends\n    // partial data and expects the client to fill in the rest, in which case this\n    // logic may change. (There already is a similar case where the server sends\n    // _no_ hydration data in the HTML document at all, and the client fetches it\n    // separately, but that's different because we still end up hydrating with a\n    // complete tree.)\n    return task.node;\n}\nfunction startPPRNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, freshness, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, accumulation) {\n    const didFindRootLayout = false;\n    const parentNeedsDynamicRequest = false;\n    const parentRefreshUrl = null;\n    return updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode !== null ? oldCacheNode : undefined, oldRouterState, newRouterState, freshness, didFindRootLayout, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, null, null, parentNeedsDynamicRequest, parentRefreshUrl, accumulation);\n}\nfunction updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, freshness, didFindRootLayout, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, parentSegmentPath, parentParallelRouteKey, parentNeedsDynamicRequest, parentRefreshUrl, accumulation) {\n    // Check if this segment matches the one in the previous route.\n    const oldSegment = oldRouterState[0];\n    const newSegment = newRouterState[0];\n    if (!(0, _matchsegments.matchSegment)(newSegment, oldSegment)) {\n        // This segment does not match the previous route. We're now entering the\n        // new part of the target route. Switch to the \"create\" path.\n        if (// highest-level layout in a route tree is referred to as the \"root\"\n        // layout.) This could mean that we're navigating between two different\n        // root layouts. When this happens, we perform a full-page (MPA-style)\n        // navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just\n        // because we're re-rendering a segment outside of the root layout does\n        // not mean we should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments\n        // are considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is\n        // unchanged. We also only need to compare the subtree that is not\n        // shared. In the common case, this branch is skipped completely.\n        !didFindRootLayout && (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState) || // The global Not Found route (app/global-not-found.tsx) is a special\n        // case, because it acts like a root layout, but in the router tree, it\n        // is rendered in the same position as app/layout.tsx.\n        //\n        // Any navigation to the global Not Found route should trigger a\n        // full-page navigation.\n        //\n        // TODO: We should probably model this by changing the key of the root\n        // segment when this happens. Then the root layout check would work\n        // as expected, without a special case.\n        newSegment === _segment.NOT_FOUND_SEGMENT_KEY) {\n            return null;\n        }\n        if (parentSegmentPath === null || parentParallelRouteKey === null) {\n            // The root should never mismatch. If it does, it suggests an internal\n            // Next.js error, or a malformed server response. Trigger a full-\n            // page navigation.\n            return null;\n        }\n        return createCacheNodeOnNavigation(navigatedAt, newRouterState, oldCacheNode, freshness, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, parentSegmentPath, parentParallelRouteKey, parentNeedsDynamicRequest, accumulation);\n    }\n    // TODO: The segment paths are tracked so that LayoutRouter knows which\n    // segments to scroll to after a navigation. But we should just mark this\n    // information on the CacheNode directly. It used to be necessary to do this\n    // separately because CacheNodes were created lazily during render, not when\n    // rather than when creating the route tree.\n    const segmentPath = parentParallelRouteKey !== null && parentSegmentPath !== null ? parentSegmentPath.concat([\n        parentParallelRouteKey,\n        newSegment\n    ]) : [];\n    const newRouterStateChildren = newRouterState[1];\n    const oldRouterStateChildren = oldRouterState[1];\n    const seedDataChildren = seedData !== null ? seedData[1] : null;\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation.\n    const isRootLayout = newRouterState[4] === true;\n    const childDidFindRootLayout = didFindRootLayout || isRootLayout;\n    const oldParallelRoutes = oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    let shouldDropSiblingCaches = false;\n    let shouldRefreshDynamicData = false;\n    switch(freshness){\n        case 0:\n        case 2:\n        case 1:\n            // We should never drop dynamic data in shared layouts, except during\n            // a refresh.\n            shouldDropSiblingCaches = false;\n            shouldRefreshDynamicData = false;\n            break;\n        case 3:\n        case 4:\n            shouldDropSiblingCaches = true;\n            shouldRefreshDynamicData = true;\n            break;\n        default:\n            freshness;\n            break;\n    }\n    const newParallelRoutes = new Map(shouldDropSiblingCaches ? undefined : oldParallelRoutes);\n    // TODO: We're not consistent about how we do this check. Some places\n    // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n    // check if there any any children, which is why I'm doing it here. We\n    // should probably encode an empty children set as `null` though. Either\n    // way, we should update all the checks to be consistent.\n    const isLeafSegment = Object.keys(newRouterStateChildren).length === 0;\n    // Get the data for this segment. Since it was part of the previous route,\n    // usually we just clone the data from the old CacheNode. However, during a\n    // refresh or a revalidation, there won't be any existing CacheNode. So we\n    // may need to consult the prefetch cache, like we would for a new segment.\n    let newCacheNode;\n    let needsDynamicRequest;\n    if (oldCacheNode !== undefined && !shouldRefreshDynamicData && // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)) {\n        // Reuse the existing CacheNode\n        const dropPrefetchRsc = false;\n        newCacheNode = reuseDynamicCacheNode(dropPrefetchRsc, oldCacheNode, newParallelRoutes);\n        needsDynamicRequest = false;\n    } else if (seedData !== null && seedData[0] !== null) {\n        // If this navigation was the result of an action, then check if the\n        // server sent back data in the action response. We should favor using\n        // that, rather than performing a separate request. This is both better\n        // for performance and it's more likely to be consistent with any\n        // writes that were just performed by the action, compared to a\n        // separate request.\n        const seedRsc = seedData[0];\n        const seedLoading = seedData[2];\n        const isSeedRscPartial = false;\n        const isSeedHeadPartial = seedHead === null;\n        newCacheNode = readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isLeafSegment && isSeedHeadPartial;\n    } else if (prefetchData !== null) {\n        // Consult the prefetch cache.\n        const prefetchRsc = prefetchData[0];\n        const prefetchLoading = prefetchData[2];\n        const isPrefetchRSCPartial = prefetchData[3];\n        newCacheNode = readCacheNodeFromSeedData(prefetchRsc, prefetchLoading, isPrefetchRSCPartial, prefetchHead, isPrefetchHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isPrefetchRSCPartial || isLeafSegment && isPrefetchHeadPartial;\n    } else {\n        // Spawn a request to fetch new data from the server.\n        newCacheNode = spawnNewCacheNode(newParallelRoutes, isLeafSegment, navigatedAt, freshness);\n        needsDynamicRequest = true;\n    }\n    // During a refresh navigation, there's a special case that happens when\n    // entering a \"default\" slot. The default slot may not be part of the\n    // current route; it may have been reused from an older route. If so,\n    // we need to fetch its data from the old route's URL rather than current\n    // route's URL. Keep track of this as we traverse the tree.\n    const href = newRouterState[2];\n    const refreshUrl = typeof href === 'string' && newRouterState[3] === 'refresh' ? href : parentRefreshUrl;\n    // If this segment itself needs to fetch new data from the server, then by\n    // definition it is being refreshed. Track its refresh URL so we know which\n    // URL to request the data from.\n    if (needsDynamicRequest && refreshUrl !== null) {\n        accumulateRefreshUrl(accumulation, refreshUrl);\n    }\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server  for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let childNeedsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n    // at the end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        let newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        if (oldRouterStateChild === undefined) {\n            // This should never happen, but if it does, it suggests a malformed\n            // server response. Trigger a full-page navigation.\n            return null;\n        }\n        const oldSegmentMapChild = oldParallelRoutes !== undefined ? oldParallelRoutes.get(parallelRouteKey) : undefined;\n        let seedDataChild = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;\n        let prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        let newSegmentChild = newRouterStateChild[0];\n        let seedHeadChild = seedHead;\n        let prefetchHeadChild = prefetchHead;\n        let isPrefetchHeadPartialChild = isPrefetchHeadPartial;\n        if (// was stashed in the history entry as-is.\n        freshness !== 2 && newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is a \"default\" segment. These are never sent by the server during\n            // a soft navigation; instead, the client reuses whatever segment was\n            // already active in that slot on the previous route.\n            newRouterStateChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild);\n            newSegmentChild = newRouterStateChild[0];\n            // Since we're switching to a different route tree, these are no\n            // longer valid, because they correspond to the outer tree.\n            seedDataChild = null;\n            seedHeadChild = null;\n            prefetchDataChild = null;\n            prefetchHeadChild = null;\n            isPrefetchHeadPartialChild = false;\n        }\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        const taskChild = updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, freshness, childDidFindRootLayout, seedDataChild ?? null, seedHeadChild, prefetchDataChild ?? null, prefetchHeadChild, isPrefetchHeadPartialChild, isSamePageNavigation, segmentPath, parallelRouteKey, parentNeedsDynamicRequest || needsDynamicRequest, refreshUrl, accumulation);\n        if (taskChild === null) {\n            // One of the child tasks discovered a change to the root layout.\n            // Immediately unwind from this recursive traversal. This will trigger a\n            // full-page navigation.\n            return null;\n        }\n        // Recursively propagate up the child tasks.\n        if (taskChildren === null) {\n            taskChildren = new Map();\n        }\n        taskChildren.set(parallelRouteKey, taskChild);\n        const newCacheNodeChild = taskChild.node;\n        if (newCacheNodeChild !== null) {\n            const newSegmentMapChild = new Map(shouldDropSiblingCaches ? undefined : oldSegmentMapChild);\n            newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n            newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n        }\n        // The child tree's route state may be different from the prefetched\n        // route sent by the server. We need to clone it as we traverse back up\n        // the tree.\n        const taskChildRoute = taskChild.route;\n        patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n        const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n        if (dynamicRequestTreeChild !== null) {\n            // Something in the child tree is dynamic.\n            childNeedsDynamicRequest = true;\n            dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n        } else {\n            dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n        }\n    }\n    return {\n        status: needsDynamicRequest ? 0 : 1,\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: createDynamicRequestTree(newRouterState, dynamicRequestTreeChildren, needsDynamicRequest, childNeedsDynamicRequest, parentNeedsDynamicRequest),\n        refreshUrl,\n        children: taskChildren\n    };\n}\nfunction createCacheNodeOnNavigation(navigatedAt, newRouterState, oldCacheNode, freshness, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, parentSegmentPath, parentParallelRouteKey, parentNeedsDynamicRequest, accumulation) {\n    // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n    // path once we reach the part of the tree that was not in the previous route.\n    // We don't need to diff against the old tree, we just need to create a new\n    // one. We also don't need to worry about any refresh-related logic.\n    //\n    // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n    // change that happens in this function likely needs to be applied to that\n    // one, too. However there are some places where the behavior intentionally\n    // diverges, which is why we keep them separate.\n    const newSegment = newRouterState[0];\n    const segmentPath = parentParallelRouteKey !== null && parentSegmentPath !== null ? parentSegmentPath.concat([\n        parentParallelRouteKey,\n        newSegment\n    ]) : [];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const seedDataChildren = seedData !== null ? seedData[1] : null;\n    const oldParallelRoutes = oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined;\n    let shouldDropSiblingCaches = false;\n    let shouldRefreshDynamicData = false;\n    let dropPrefetchRsc = false;\n    switch(freshness){\n        case 0:\n            // We should never drop dynamic data in sibling caches except during\n            // a refresh.\n            shouldDropSiblingCaches = false;\n            // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n            // is set, and the data is not stale. (This is not a recommended API with\n            // Cache Components, but it's supported for backwards compatibility. Use\n            // cacheLife instead.)\n            //\n            // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n            shouldRefreshDynamicData = oldCacheNode === undefined || navigatedAt - oldCacheNode.navigatedAt >= _navigatereducer.DYNAMIC_STALETIME_MS;\n            dropPrefetchRsc = false;\n            break;\n        case 1:\n            // During hydration, we assume the data sent by the server is both\n            // consistent and complete.\n            shouldRefreshDynamicData = false;\n            shouldDropSiblingCaches = false;\n            dropPrefetchRsc = false;\n            break;\n        case 2:\n            // During back/forward navigations, we reuse the dynamic data regardless\n            // of how stale it may be.\n            shouldRefreshDynamicData = false;\n            shouldRefreshDynamicData = false;\n            // Only show prefetched data if the dynamic data is still pending. This\n            // avoids a flash back to the prefetch state in a case where it's highly\n            // likely to have already streamed in.\n            //\n            // Tehnically, what we're actually checking is whether the dynamic network\n            // response was received. But since it's a streaming response, this does\n            // not mean that all the dynamic data has fully streamed in. It just means\n            // that _some_ of the dynamic data was received. But as a heuristic, we\n            // assume that the rest dynamic data will stream in quickly, so it's still\n            // better to skip the prefetch state.\n            if (oldCacheNode !== undefined) {\n                const oldRsc = oldCacheNode.rsc;\n                const oldRscDidResolve = !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending';\n                dropPrefetchRsc = oldRscDidResolve;\n            } else {\n                dropPrefetchRsc = false;\n            }\n            break;\n        case 3:\n        case 4:\n            // Drop all dynamic data.\n            shouldRefreshDynamicData = true;\n            shouldDropSiblingCaches = true;\n            dropPrefetchRsc = false;\n            break;\n        default:\n            freshness;\n            break;\n    }\n    const newParallelRoutes = new Map(shouldDropSiblingCaches ? undefined : oldParallelRoutes);\n    const isLeafSegment = Object.keys(newRouterStateChildren).length === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        //\n        // This only happens for new pages, not for refreshed pages.\n        //\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        if (accumulation.scrollableSegments === null) {\n            accumulation.scrollableSegments = [];\n        }\n        accumulation.scrollableSegments.push(segmentPath);\n    }\n    let newCacheNode;\n    let needsDynamicRequest;\n    if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n        // Reuse the existing CacheNode\n        newCacheNode = reuseDynamicCacheNode(dropPrefetchRsc, oldCacheNode, newParallelRoutes);\n        needsDynamicRequest = false;\n    } else if (seedData !== null && seedData[0] !== null) {\n        // If this navigation was the result of an action, then check if the\n        // server sent back data in the action response. We should favor using\n        // that, rather than performing a separate request. This is both better\n        // for performance and it's more likely to be consistent with any\n        // writes that were just performed by the action, compared to a\n        // separate request.\n        const seedRsc = seedData[0];\n        const seedLoading = seedData[2];\n        const isSeedRscPartial = false;\n        const isSeedHeadPartial = seedHead === null && freshness !== 1;\n        newCacheNode = readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isLeafSegment && isSeedHeadPartial;\n    } else if (freshness === 1 && isLeafSegment && seedHead !== null) {\n        // This is another weird case related to \"not found\" pages and hydration.\n        // There will be a head sent by the server, but no page seed data.\n        // TODO: We really should get rid of all these \"not found\" specific quirks\n        // and make sure the tree is always consistent.\n        const seedRsc = null;\n        const seedLoading = null;\n        const isSeedRscPartial = false;\n        const isSeedHeadPartial = false;\n        newCacheNode = readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = false;\n    } else if (freshness !== 1 && prefetchData !== null) {\n        // Consult the prefetch cache.\n        const prefetchRsc = prefetchData[0];\n        const prefetchLoading = prefetchData[2];\n        const isPrefetchRSCPartial = prefetchData[3];\n        newCacheNode = readCacheNodeFromSeedData(prefetchRsc, prefetchLoading, isPrefetchRSCPartial, prefetchHead, isPrefetchHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isPrefetchRSCPartial || isLeafSegment && isPrefetchHeadPartial;\n    } else {\n        // Spawn a request to fetch new data from the server.\n        newCacheNode = spawnNewCacheNode(newParallelRoutes, isLeafSegment, navigatedAt, freshness);\n        needsDynamicRequest = true;\n    }\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    let childNeedsDynamicRequest = false;\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes !== undefined ? oldParallelRoutes.get(parallelRouteKey) : undefined;\n        const seedDataChild = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        const taskChild = createCacheNodeOnNavigation(navigatedAt, newRouterStateChild, oldCacheNodeChild, freshness, seedDataChild ?? null, seedHead, prefetchDataChild ?? null, prefetchHead, isPrefetchHeadPartial, segmentPath, parallelRouteKey, parentNeedsDynamicRequest || needsDynamicRequest, accumulation);\n        if (taskChildren === null) {\n            taskChildren = new Map();\n        }\n        taskChildren.set(parallelRouteKey, taskChild);\n        const newCacheNodeChild = taskChild.node;\n        if (newCacheNodeChild !== null) {\n            const newSegmentMapChild = new Map(shouldDropSiblingCaches ? undefined : oldSegmentMapChild);\n            newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n            newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n        }\n        const taskChildRoute = taskChild.route;\n        patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n        const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n        if (dynamicRequestTreeChild !== null) {\n            childNeedsDynamicRequest = true;\n            dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n        } else {\n            dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n        }\n    }\n    return {\n        status: needsDynamicRequest ? 0 : 1,\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: createDynamicRequestTree(newRouterState, dynamicRequestTreeChildren, needsDynamicRequest, childNeedsDynamicRequest, parentNeedsDynamicRequest),\n        // This route is not part of the current tree, so there's no reason to\n        // track the refresh URL.\n        refreshUrl: null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction createDynamicRequestTree(newRouterState, dynamicRequestTreeChildren, needsDynamicRequest, childNeedsDynamicRequest, parentNeedsDynamicRequest) {\n    // Create a FlightRouterState that instructs the server how to render the\n    // requested segment.\n    //\n    // Or, if neither this segment nor any of the children require a new data,\n    // then we return `null` to skip the request.\n    let dynamicRequestTree = null;\n    if (needsDynamicRequest) {\n        dynamicRequestTree = patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren);\n        // The \"refetch\" marker is set on the top-most segment that requires new\n        // data. We can omit it if a parent was already marked.\n        if (!parentNeedsDynamicRequest) {\n            dynamicRequestTree[3] = 'refetch';\n        }\n    } else if (childNeedsDynamicRequest) {\n        // This segment does not request new data, but at least one of its\n        // children does.\n        dynamicRequestTree = patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren);\n    } else {\n        dynamicRequestTree = null;\n    }\n    return dynamicRequestTree;\n}\nfunction accumulateRefreshUrl(accumulation, refreshUrl) {\n    // This is a refresh navigation, and we're inside a \"default\" slot that's\n    // not part of the current route; it was reused from an older route. In\n    // order to get fresh data for this reused route, we need to issue a\n    // separate request using the old route's URL.\n    //\n    // Track these extra URLs in the accumulated result. Later, we'll construct\n    // an appropriate request for each unique URL in the final set. The reason\n    // we don't do it immediately here is so we can deduplicate multiple\n    // instances of the same URL into a single request. See\n    // listenForDynamicRequest for more details.\n    const separateRefreshUrls = accumulation.separateRefreshUrls;\n    if (separateRefreshUrls === null) {\n        accumulation.separateRefreshUrls = new Set([\n            refreshUrl\n        ]);\n    } else {\n        separateRefreshUrls.add(refreshUrl);\n    }\n}\nfunction reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterState) {\n    // This is a \"default\" segment. These are never sent by the server during a\n    // soft navigation; instead, the client reuses whatever segment was already\n    // active in that slot on the previous route. This means if we later need to\n    // refresh the segment, it will have to be refetched from the previous route's\n    // URL. We store it in the Flight Router State.\n    //\n    // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n    // get rid of that eventually by making sure we only add URLs to page segments\n    // that are reused. Then the presence of the URL alone is enough.\n    let reusedRouterState;\n    const oldRefreshMarker = oldRouterState[3];\n    if (oldRefreshMarker === 'refresh') {\n        // This segment was already reused from an even older route. Keep its\n        // existing URL and refresh marker.\n        reusedRouterState = oldRouterState;\n    } else {\n        // This segment was not previously reused, and it's not on the new route.\n        // So it must have been delivered in the old route.\n        reusedRouterState = patchRouterStateWithNewChildren(oldRouterState, oldRouterState[1]);\n        reusedRouterState[2] = (0, _createhreffromurl.createHrefFromUrl)(oldUrl);\n        reusedRouterState[3] = 'refresh';\n    }\n    return reusedRouterState;\n}\nfunction reuseDynamicCacheNode(dropPrefetchRsc, existingCacheNode, parallelRoutes) {\n    // Clone an existing CacheNode's data, with (possibly) new children.\n    const cacheNode = {\n        rsc: existingCacheNode.rsc,\n        prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n        head: existingCacheNode.head,\n        prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n        loading: existingCacheNode.loading,\n        parallelRoutes,\n        // Don't update the navigatedAt timestamp, since we're reusing\n        // existing data.\n        navigatedAt: existingCacheNode.navigatedAt\n    };\n    return cacheNode;\n}\nfunction readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isPageSegment, parallelRoutes, navigatedAt) {\n    // TODO: Currently this is threaded through the navigation logic using the\n    // CacheNodeSeedData type, but in the future this will read directly from\n    // the Segment Cache. See readRenderSnapshotFromCache.\n    let rsc;\n    let prefetchRsc;\n    if (isSeedRscPartial) {\n        // The prefetched data contains dynamic holes. Create a pending promise that\n        // will be fulfilled when the dynamic data is received from the server.\n        prefetchRsc = seedRsc;\n        rsc = createDeferredRsc();\n    } else {\n        // The prefetched data is complete. Use it directly.\n        prefetchRsc = null;\n        rsc = seedRsc;\n    }\n    // If this is a page segment, also read the head.\n    let prefetchHead;\n    let head;\n    if (isPageSegment) {\n        if (isSeedHeadPartial) {\n            prefetchHead = seedHead;\n            head = createDeferredRsc();\n        } else {\n            prefetchHead = null;\n            head = seedHead;\n        }\n    } else {\n        prefetchHead = null;\n        head = null;\n    }\n    const cacheNode = {\n        rsc,\n        prefetchRsc,\n        head,\n        prefetchHead,\n        // TODO: Technically, a loading boundary could contain dynamic data. We\n        // should have separate `loading` and `prefetchLoading` fields to handle\n        // this, like we do for the segment data and head.\n        loading: seedLoading,\n        parallelRoutes,\n        navigatedAt\n    };\n    return cacheNode;\n}\nfunction spawnNewCacheNode(parallelRoutes, isLeafSegment, navigatedAt, freshness) {\n    // We should never spawn network requests during hydration. We must treat the\n    // initial payload as authoritative, because the initial page load is used\n    // as a last-ditch mechanism for recovering the app.\n    //\n    // This is also an important safety check because if this leaks into the\n    // server rendering path (which theoretically it never should because\n    // the server payload should be consistent), the server would hang because\n    // these promises would never resolve.\n    //\n    // TODO: There is an existing case where the global \"not found\" boundary\n    // triggers this path. But it does render correctly despite that. That's an\n    // unusual render path so it's not surprising, but we should look into\n    // modeling it in a more consistent way. See also the /_notFound special\n    // case in updateCacheNodeOnNavigation.\n    const isHydration = freshness === 1;\n    const cacheNode = {\n        rsc: !isHydration ? createDeferredRsc() : null,\n        prefetchRsc: null,\n        head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n        prefetchHead: null,\n        loading: !isHydration ? createDeferredRsc() : null,\n        parallelRoutes,\n        navigatedAt\n    };\n    return cacheNode;\n}\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false;\nfunction spawnDynamicRequests(task, primaryUrl, nextUrl, freshnessPolicy, accumulation) {\n    const dynamicRequestTree = task.dynamicRequestTree;\n    if (dynamicRequestTree === null) {\n        // This navigation was fully cached. There are no dynamic requests to spawn.\n        previousNavigationDidMismatch = false;\n        return;\n    }\n    // This is intentionally not an async function to discourage the caller from\n    // awaiting the result. Any subsequent async operations spawned by this\n    // function should result in a separate navigation task, rather than\n    // block the original one.\n    //\n    // In this function we spawn (but do not await) all the network requests that\n    // block the navigation, and collect the promises. The next function,\n    // `finishNavigationTask`, can await the promises in any order without\n    // accidentally introducing a network waterfall.\n    const primaryRequestPromise = fetchMissingDynamicData(task, dynamicRequestTree, primaryUrl, nextUrl, freshnessPolicy);\n    const separateRefreshUrls = accumulation.separateRefreshUrls;\n    let refreshRequestPromises = null;\n    if (separateRefreshUrls !== null) {\n        // There are multiple URLs that we need to request the data from. This\n        // happens when a \"default\" parallel route slot is present in the tree, and\n        // its data cannot be fetched from the current route. We need to split the\n        // combined dynamic request tree into separate requests per URL.\n        // TODO: Create a scoped dynamic request tree that omits anything that\n        // is not relevant to the given URL. Without doing this, the server may\n        // sometimes render more data than necessary; this is not a regression\n        // compared to the pre-Segment Cache implementation, though, just an\n        // optimization we can make in the future.\n        // Construct a request tree for each additional refresh URL. This will\n        // prune away everything except the parts of the tree that match the\n        // given refresh URL.\n        refreshRequestPromises = [];\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(primaryUrl);\n        for (const refreshUrl of separateRefreshUrls){\n            if (refreshUrl === canonicalUrl) {\n                continue;\n            }\n            // TODO: Create a scoped dynamic request tree that omits anything that\n            // is not relevant to the given URL. Without doing this, the server may\n            // sometimes render more data than necessary; this is not a regression\n            // compared to the pre-Segment Cache implementation, though, just an\n            // optimization we can make in the future.\n            // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n            const scopedDynamicRequestTree = dynamicRequestTree;\n            if (scopedDynamicRequestTree !== null) {\n                refreshRequestPromises.push(fetchMissingDynamicData(task, scopedDynamicRequestTree, new URL(refreshUrl, location.origin), // time the refresh URL was set, not the current Next-Url. Need to\n                // start tracking this alongside the refresh URL. In the meantime,\n                // if a refresh fails due to a mismatch, it will trigger a\n                // hard refresh.\n                nextUrl, freshnessPolicy));\n            }\n        }\n    }\n    // Further async operations are moved into this separate function to\n    // discourage sequential network requests.\n    const voidPromise = finishNavigationTask(task, nextUrl, primaryRequestPromise, refreshRequestPromises);\n    // `finishNavigationTask` is responsible for error handling, so we can attach\n    // noop callbacks to this promise.\n    voidPromise.then(noop, noop);\n}\nasync function finishNavigationTask(task, nextUrl, primaryRequestPromise, refreshRequestPromises) {\n    // Wait for all the requests to finish, or for the first one to fail.\n    let exitStatus = await waitForRequestsToFinish(primaryRequestPromise, refreshRequestPromises);\n    // Once the all the requests have finished, check the tree for any remaining\n    // pending tasks. If anything is still pending, it means the server response\n    // does not match the client, and we must refresh to get back to a consistent\n    // state. We can skip this step if we already detected a mismatch during the\n    // first phase; it doesn't matter in that case because we're going to refresh\n    // the whole tree regardless.\n    if (exitStatus === 0) {\n        exitStatus = abortRemainingPendingTasks(task, null, null);\n    }\n    switch(exitStatus){\n        case 0:\n            {\n                // The task has completely finished. There's no missing data. Exit.\n                previousNavigationDidMismatch = false;\n                return;\n            }\n        case 1:\n            {\n                // Some data failed to finish loading. Trigger a soft retry.\n                // TODO: As an extra precaution against soft retry loops, consider\n                // tracking whether a navigation was itself triggered by a retry. If two\n                // happen in a row, fall back to a hard retry.\n                const isHardRetry = false;\n                const primaryRequestResult = await primaryRequestPromise;\n                dispatchRetryDueToTreeMismatch(isHardRetry, primaryRequestResult.url, nextUrl, primaryRequestResult.seed, task.route);\n                return;\n            }\n        case 2:\n            {\n                // Some data failed to finish loading in a non-recoverable way, such as a\n                // network error. Trigger an MPA navigation.\n                //\n                // Hard navigating/refreshing is how we prevent an infinite retry loop\n                // caused by a network error  when the network fails, we fall back to the\n                // browser behavior for offline navigations. In the future, Next.js may\n                // introduce its own custom handling of offline navigations, but that\n                // doesn't exist yet.\n                const isHardRetry = true;\n                const primaryRequestResult = await primaryRequestPromise;\n                dispatchRetryDueToTreeMismatch(isHardRetry, primaryRequestResult.url, nextUrl, primaryRequestResult.seed, task.route);\n                return;\n            }\n        default:\n            {\n                return exitStatus;\n            }\n    }\n}\nfunction waitForRequestsToFinish(primaryRequestPromise, refreshRequestPromises) {\n    // Custom async combinator logic. This could be replaced by Promise.any but\n    // we don't assume that's available.\n    //\n    // Each promise resolves once the server responsds and the data is written\n    // into the CacheNode tree. Resolve the combined promise once all the\n    // requests finish.\n    //\n    // Or, resolve as soon as one of the requests fails, without waiting for the\n    // others to finish.\n    return new Promise((resolve)=>{\n        const onFulfill = (result)=>{\n            if (result.exitStatus === 0) {\n                remainingCount--;\n                if (remainingCount === 0) {\n                    // All the requests finished successfully.\n                    resolve(0);\n                }\n            } else {\n                // One of the requests failed. Exit with a failing status.\n                // NOTE: It's possible for one of the requests to fail with SoftRetry\n                // and a later one to fail with HardRetry. In this case, we choose to\n                // retry immediately, rather than delay the retry until all the requests\n                // finish. If it fails again, we will hard retry on the next\n                // attempt, anyway.\n                resolve(result.exitStatus);\n            }\n        };\n        // onReject shouldn't ever be called because fetchMissingDynamicData's\n        // entire body is wrapped in a try/catch. This is just defensive.\n        const onReject = ()=>resolve(2);\n        // Attach the listeners to the promises.\n        let remainingCount = 1;\n        primaryRequestPromise.then(onFulfill, onReject);\n        if (refreshRequestPromises !== null) {\n            remainingCount += refreshRequestPromises.length;\n            refreshRequestPromises.forEach((refreshRequestPromise)=>refreshRequestPromise.then(onFulfill, onReject));\n        }\n    });\n}\nfunction dispatchRetryDueToTreeMismatch(isHardRetry, retryUrl, retryNextUrl, seed, baseTree) {\n    // If this is the second time in a row that a navigation resulted in a\n    // mismatch, fall back to a hard (MPA) refresh.\n    isHardRetry = isHardRetry || previousNavigationDidMismatch;\n    previousNavigationDidMismatch = true;\n    const retryAction = {\n        type: _routerreducertypes.ACTION_SERVER_PATCH,\n        previousTree: baseTree,\n        url: retryUrl,\n        nextUrl: retryNextUrl,\n        seed,\n        mpa: isHardRetry\n    };\n    (0, _useactionqueue.dispatchAppRouterAction)(retryAction);\n}\nasync function fetchMissingDynamicData(task, dynamicRequestTree, url, nextUrl, freshnessPolicy) {\n    try {\n        const result = await (0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: dynamicRequestTree,\n            nextUrl,\n            isHmrRefresh: freshnessPolicy === 4\n        });\n        if (typeof result === 'string') {\n            // fetchServerResponse will return an href to indicate that the SPA\n            // navigation failed. For example, if the server triggered a hard\n            // redirect, or the fetch request errored. Initiate an MPA navigation\n            // to the given href.\n            return {\n                exitStatus: 2,\n                url: new URL(result, location.origin),\n                seed: null\n            };\n        }\n        const seed = (0, _navigation.convertServerPatchToFullTree)(task.route, result.flightData, result.renderedSearch);\n        const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(task, seed.tree, seed.data, seed.head, result.debugInfo);\n        return {\n            exitStatus: didReceiveUnknownParallelRoute ? 1 : 0,\n            url: new URL(result.canonicalUrl, location.origin),\n            seed\n        };\n    } catch  {\n        // This shouldn't happen because fetchServerResponse's entire body is\n        // wrapped in a try/catch. If it does, though, it implies the server failed\n        // to respond with any tree at all. So we must fall back to a hard retry.\n        return {\n            exitStatus: 2,\n            url: url,\n            seed: null\n        };\n    }\n}\nfunction writeDynamicDataIntoNavigationTask(task, serverRouterState, dynamicData, dynamicHead, debugInfo) {\n    if (task.status === 0 && dynamicData !== null) {\n        task.status = 1;\n        finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo);\n    }\n    const taskChildren = task.children;\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null;\n    // Detect whether the server sends a parallel route slot that the client\n    // doesn't know about.\n    let didReceiveUnknownParallelRoute = false;\n    if (taskChildren !== null) {\n        for(const parallelRouteKey in serverChildren){\n            const serverRouterStateChild = serverChildren[parallelRouteKey];\n            const dynamicDataChild = dynamicDataChildren !== null ? dynamicDataChildren[parallelRouteKey] : null;\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild === undefined) {\n                // The server sent a child segment that the client doesn't know about.\n                //\n                // When we receive an unknown parallel route, we must consider it a\n                // mismatch. This is unlike the case where the segment itself\n                // mismatches, because multiple routes can be active simultaneously.\n                // But a given layout should never have a mismatching set of\n                // child slots.\n                //\n                // Theoretically, this should only happen in development during an HMR\n                // refresh, because the set of parallel routes for a layout does not\n                // change over the lifetime of a build/deployment. In production, we\n                // should have already mismatched on either the build id or the segment\n                // path. But as an extra precaution, we validate in prod, too.\n                didReceiveUnknownParallelRoute = true;\n            } else {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    const childDidReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead, debugInfo);\n                    if (childDidReceiveUnknownParallelRoute) {\n                        didReceiveUnknownParallelRoute = true;\n                    }\n                }\n            }\n        }\n    }\n    return didReceiveUnknownParallelRoute;\n}\nfunction finishPendingCacheNode(cacheNode, dynamicData, dynamicHead, debugInfo) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety  it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[0];\n    if (dynamicSegmentData === null) {\n        // This is an empty CacheNode; this particular server request did not\n        // render this segment. There may be a separate pending request that will,\n        // though, so we won't abort the task until all pending requests finish.\n        return;\n    }\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData, debugInfo);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n    // Fulfill it using the dynamic response so that we can display the loading boundary.\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        const dynamicLoading = dynamicData[2];\n        loading.resolve(dynamicLoading, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead, debugInfo);\n    }\n}\nfunction abortRemainingPendingTasks(task, error, debugInfo) {\n    let exitStatus;\n    if (task.status === 0) {\n        // The data for this segment is still missing.\n        task.status = 2;\n        abortPendingCacheNode(task.node, error, debugInfo);\n        // If the server failed to fulfill the data for this segment, it implies\n        // that the route tree received from the server mismatched the tree that\n        // was previously prefetched.\n        //\n        // In an app with fully static routes and no proxy-driven redirects or\n        // rewrites, this should never happen, because the route for a URL would\n        // always be the same across multiple requests. So, this implies that some\n        // runtime routing condition changed, likely in a proxy, without being\n        // pushed to the client.\n        //\n        // When this happens, we treat this the same as a refresh(). The entire\n        // tree will be re-rendered from the root.\n        if (task.refreshUrl === null) {\n            // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n            // in a Server Action.\n            exitStatus = 1;\n        } else {\n            // The mismatch was discovered inside an inactive parallel route. This\n            // implies the inactive parallel route is no longer reachable at the URL\n            // that originally rendered it. Fall back to an MPA refresh.\n            // TODO: An alternative could be to trigger a soft refresh but to _not_\n            // re-use the inactive parallel routes this time. Similar to what would\n            // happen if were to do a hard refrehs, but without the HTML page.\n            exitStatus = 2;\n        }\n    } else {\n        // This segment finished. (An error here is treated as Done because they are\n        // surfaced to the application during render.)\n        exitStatus = 0;\n    }\n    const taskChildren = task.children;\n    if (taskChildren !== null) {\n        for (const [, taskChild] of taskChildren){\n            const childExitStatus = abortRemainingPendingTasks(taskChild, error, debugInfo);\n            // Propagate the exit status up the tree. The statuses are ordered by\n            // their precedence.\n            if (childExitStatus > exitStatus) {\n                exitStatus = childExitStatus;\n            }\n        }\n    }\n    return exitStatus;\n}\nfunction abortPendingCacheNode(cacheNode, error, debugInfo) {\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null, debugInfo);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error, debugInfo);\n        }\n    }\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        loading.resolve(null, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null, debugInfo);\n    }\n}\nconst DEFERRED = Symbol();\nfunction isDeferredRsc(value) {\n    return value && typeof value === 'object' && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    // Create an unresolved promise that represents data derived from a Flight\n    // response. The promise will be resolved later as soon as we start receiving\n    // data from the server, i.e. as soon as the Flight client decodes and returns\n    // the top-level response object.\n    // The `_debugInfo` field contains profiling information. Promises that are\n    // created by Flight already have this info added by React; for any derived\n    // promise created by the router, we need to transfer the Flight debug info\n    // onto the derived promise.\n    //\n    // The debug info represents the latency between the start of the navigation\n    // and the start of rendering. (It does not represent the time it takes for\n    // whole stream to finish.)\n    const debugInfo = [];\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    pendingRsc._debugInfo = debugInfo;\n    return pendingRsc;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\n/**\n * Shared types and constants for the Segment Cache.\n */ Object.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    FetchStrategy: null,\n    NavigationResultTag: null,\n    PrefetchPriority: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    FetchStrategy: function() {\n        return FetchStrategy;\n    },\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    }\n});\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\nvar FetchStrategy = /*#__PURE__*/ function(FetchStrategy) {\n    // Deliberately ordered so we can easily compare two segments\n    // and determine if one segment is \"more specific\" than another\n    // (i.e. if it's likely that it contains more data)\n    FetchStrategy[FetchStrategy[\"LoadingBoundary\"] = 0] = \"LoadingBoundary\";\n    FetchStrategy[FetchStrategy[\"PPR\"] = 1] = \"PPR\";\n    FetchStrategy[FetchStrategy[\"PPRRuntime\"] = 2] = \"PPRRuntime\";\n    FetchStrategy[FetchStrategy[\"Full\"] = 3] = \"Full\";\n    return FetchStrategy;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=types.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/lru.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    deleteFromLru: null,\n    lruPut: null,\n    updateLruSize: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    deleteFromLru: function() {\n        return deleteFromLru;\n    },\n    lruPut: function() {\n        return lruPut;\n    },\n    updateLruSize: function() {\n        return updateLruSize;\n    }\n});\nconst _cachemap = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-map.js [app-client] (ecmascript)\");\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\nlet head = null;\nlet didScheduleCleanup = false;\nlet lruSize = 0;\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n;\nfunction lruPut(node) {\n    if (head === node) {\n        // Already at the head\n        return;\n    }\n    const prev = node.prev;\n    const next = node.next;\n    if (next === null || prev === null) {\n        // This is an insertion\n        lruSize += node.size;\n        // Whenever we add an entry, we need to check if we've exceeded the\n        // max size. We don't evict entries immediately; they're evicted later in\n        // an asynchronous task.\n        ensureCleanupIsScheduled();\n    } else {\n        // This is a move. Remove from its current position.\n        prev.next = next;\n        next.prev = prev;\n    }\n    // Move to the front of the list\n    if (head === null) {\n        // This is the first entry\n        node.prev = node;\n        node.next = node;\n    } else {\n        // Add to the front of the list\n        const tail = head.prev;\n        node.prev = tail;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            tail.next = node;\n        }\n        node.next = head;\n        head.prev = node;\n    }\n    head = node;\n}\nfunction updateLruSize(node, newNodeSize) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size;\n    node.size = newNodeSize;\n    if (node.next === null) {\n        // This entry is not currently being tracked by the LRU.\n        return;\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize;\n    ensureCleanupIsScheduled();\n}\nfunction deleteFromLru(deleted) {\n    const next = deleted.next;\n    const prev = deleted.prev;\n    if (next !== null && prev !== null) {\n        lruSize -= deleted.size;\n        deleted.next = null;\n        deleted.prev = null;\n        // Remove from the list\n        if (head === deleted) {\n            // Update the head\n            if (next === head) {\n                // This was the last entry\n                head = null;\n            } else {\n                head = next;\n                prev.next = next;\n                next.prev = prev;\n            }\n        } else {\n            prev.next = next;\n            next.prev = prev;\n        }\n    } else {\n    // Already deleted\n    }\n}\nfunction ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n        return;\n    }\n    didScheduleCleanup = true;\n    requestCleanupCallback(cleanup);\n}\nfunction cleanup() {\n    didScheduleCleanup = false;\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteFromLru` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9;\n    while(lruSize > ninetyPercentMax && head !== null){\n        const tail = head.prev;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            // Delete the entry from the map. In turn, this will remove it from\n            // the LRU.\n            (0, _cachemap.deleteMapEntry)(tail);\n        }\n    }\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=lru.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/cache-map.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    Fallback: null,\n    createCacheMap: null,\n    deleteFromCacheMap: null,\n    deleteMapEntry: null,\n    getFromCacheMap: null,\n    isValueExpired: null,\n    setInCacheMap: null,\n    setSizeInCacheMap: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Fallback: function() {\n        return Fallback;\n    },\n    createCacheMap: function() {\n        return createCacheMap;\n    },\n    deleteFromCacheMap: function() {\n        return deleteFromCacheMap;\n    },\n    deleteMapEntry: function() {\n        return deleteMapEntry;\n    },\n    getFromCacheMap: function() {\n        return getFromCacheMap;\n    },\n    isValueExpired: function() {\n        return isValueExpired;\n    },\n    setInCacheMap: function() {\n        return setInCacheMap;\n    },\n    setSizeInCacheMap: function() {\n        return setSizeInCacheMap;\n    }\n});\nconst _lru = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/lru.js [app-client] (ecmascript)\");\nconst Fallback = {};\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {};\nfunction createCacheMap() {\n    const cacheMap = {\n        parent: null,\n        key: null,\n        value: null,\n        map: null,\n        // LRU-related fields\n        prev: null,\n        next: null,\n        size: 0\n    };\n    return cacheMap;\n}\nfunction getOrInitialize(cacheMap, keys, isRevalidation) {\n    // Go through each level of keys until we find the entry that matches, or\n    // create a new entry if one doesn't exist.\n    //\n    // This function will only return entries that match the keypath _exactly_.\n    // Unlike getWithFallback, it will not access fallback entries unless it's\n    // explicitly part of the keypath.\n    let entry = cacheMap;\n    let remainingKeys = keys;\n    let key = null;\n    while(true){\n        const previousKey = key;\n        if (remainingKeys !== null) {\n            key = remainingKeys.value;\n            remainingKeys = remainingKeys.parent;\n        } else if (isRevalidation && previousKey !== Revalidation) {\n            // During a revalidation, we append an internal \"Revalidation\" key to\n            // the end of the keypath. The \"normal\" entry is its parent.\n            // However, if the parent entry is currently empty, we don't need to store\n            // this as a revalidation entry. Just insert the revalidation into the\n            // normal slot.\n            if (entry.value === null) {\n                return entry;\n            }\n            // Otheriwse, create a child entry.\n            key = Revalidation;\n        } else {\n            break;\n        }\n        let map = entry.map;\n        if (map !== null) {\n            const existingEntry = map.get(key);\n            if (existingEntry !== undefined) {\n                // Found a match. Keep going.\n                entry = existingEntry;\n                continue;\n            }\n        } else {\n            map = new Map();\n            entry.map = map;\n        }\n        // No entry exists yet at this level. Create a new one.\n        const newEntry = {\n            parent: entry,\n            key,\n            value: null,\n            map: null,\n            // LRU-related fields\n            prev: null,\n            next: null,\n            size: 0\n        };\n        map.set(key, newEntry);\n        entry = newEntry;\n    }\n    return entry;\n}\nfunction getFromCacheMap(now, currentCacheVersion, rootEntry, keys, isRevalidation) {\n    const entry = getEntryWithFallbackImpl(now, currentCacheVersion, rootEntry, keys, isRevalidation, 0);\n    if (entry === null || entry.value === null) {\n        return null;\n    }\n    // This is an LRU access. Move the entry to the front of the list.\n    (0, _lru.lruPut)(entry);\n    return entry.value;\n}\nfunction isValueExpired(now, currentCacheVersion, value) {\n    return value.staleAt <= now || value.version < currentCacheVersion;\n}\nfunction lazilyEvictIfNeeded(now, currentCacheVersion, entry) {\n    // We have a matching entry, but before we can return it, we need to check if\n    // it's still fresh. Otherwise it should be treated the same as a cache miss.\n    if (entry.value === null) {\n        // This entry has no value, so there's nothing to evict.\n        return entry;\n    }\n    const value = entry.value;\n    if (isValueExpired(now, currentCacheVersion, value)) {\n        // The value expired. Lazily evict it from the cache, and return null. This\n        // is conceptually the same as a cache miss.\n        deleteMapEntry(entry);\n        return null;\n    }\n    // The matched entry has not expired. Return it.\n    return entry;\n}\nfunction getEntryWithFallbackImpl(now, currentCacheVersion, entry, keys, isRevalidation, previousKey) {\n    // This is similar to getExactEntry, but if an exact match is not found for\n    // a key, it will return the fallback entry instead. This is recursive at\n    // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n    // valid match for [a, b, c, d].\n    //\n    // It will return the most specific match available.\n    let key;\n    let remainingKeys;\n    if (keys !== null) {\n        key = keys.value;\n        remainingKeys = keys.parent;\n    } else if (isRevalidation && previousKey !== Revalidation) {\n        // During a revalidation, we append an internal \"Revalidation\" key to\n        // the end of the keypath.\n        key = Revalidation;\n        remainingKeys = null;\n    } else {\n        // There are no more keys. This is the terminal entry.\n        // TODO: When performing a lookup during a navigation, as opposed to a\n        // prefetch, we may want to skip entries that are Pending if there's also\n        // a Fulfilled fallback entry. Tricky to say, though, since if it's\n        // already pending, it's likely to stream in soon. Maybe we could do this\n        // just on slow connections and offline mode.\n        return lazilyEvictIfNeeded(now, currentCacheVersion, entry);\n    }\n    const map = entry.map;\n    if (map !== null) {\n        const existingEntry = map.get(key);\n        if (existingEntry !== undefined) {\n            // Found an exact match for this key. Keep searching.\n            const result = getEntryWithFallbackImpl(now, currentCacheVersion, existingEntry, remainingKeys, isRevalidation, key);\n            if (result !== null) {\n                return result;\n            }\n        }\n        // No match found for this key. Check if there's a fallback.\n        const fallbackEntry = map.get(Fallback);\n        if (fallbackEntry !== undefined) {\n            // Found a fallback for this key. Keep searching.\n            return getEntryWithFallbackImpl(now, currentCacheVersion, fallbackEntry, remainingKeys, isRevalidation, key);\n        }\n    }\n    return null;\n}\nfunction setInCacheMap(cacheMap, keys, value, isRevalidation) {\n    // Add a value to the map at the given keypath. If the value is already\n    // part of the map, it's removed from its previous keypath. (NOTE: This is\n    // unlike a regular JS map, but the behavior is intentional.)\n    const entry = getOrInitialize(cacheMap, keys, isRevalidation);\n    setMapEntryValue(entry, value);\n    // This is an LRU access. Move the entry to the front of the list.\n    (0, _lru.lruPut)(entry);\n    (0, _lru.updateLruSize)(entry, value.size);\n}\nfunction setMapEntryValue(entry, value) {\n    if (entry.value !== null) {\n        // There's already a value at the given keypath. Disconnect the old value\n        // from the map. We're not calling `deleteMapEntry` here because the\n        // entry itself is still in the map. We just want to overwrite its value.\n        dropRef(entry.value);\n        entry.value = null;\n    }\n    // This value may already be in the map at a different keypath.\n    // Grab a reference before we overwrite it.\n    const oldEntry = value.ref;\n    entry.value = value;\n    value.ref = entry;\n    (0, _lru.updateLruSize)(entry, value.size);\n    if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n        // This value is already in the map at a different keypath in the map.\n        // Values only exist at a single keypath at a time. Remove it from the\n        // previous keypath.\n        //\n        // Note that only the internal map entry is garbage collected; we don't\n        // call `dropRef` here because it's still in the map, just\n        // at a new keypath (the one we just set, above).\n        deleteMapEntry(oldEntry);\n    }\n}\nfunction deleteFromCacheMap(value) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    dropRef(value);\n    deleteMapEntry(entry);\n}\nfunction dropRef(value) {\n    // Drop the value from the map by setting its `ref` backpointer to\n    // null. This is a separate operation from `deleteMapEntry` because when\n    // re-keying a value we need to be able to delete the old, internal map\n    // entry without garbage collecting the value itself.\n    value.ref = null;\n}\nfunction deleteMapEntry(entry) {\n    // Delete the entry from the cache.\n    entry.value = null;\n    (0, _lru.deleteFromLru)(entry);\n    // Check if we can garbage collect the entry.\n    const map = entry.map;\n    if (map === null) {\n        // Since this entry has no value, and also no child entries, we can\n        // garbage collect it. Remove it from its parent, and keep garbage\n        // collecting the parents until we reach a non-empty entry.\n        let parent = entry.parent;\n        let key = entry.key;\n        while(parent !== null){\n            const parentMap = parent.map;\n            if (parentMap !== null) {\n                parentMap.delete(key);\n                if (parentMap.size === 0) {\n                    // We just removed the last entry in the parent map.\n                    parent.map = null;\n                    if (parent.value === null) {\n                        // The parent node has no child entries, nor does it have a value\n                        // on itself. It can be garbage collected. Keep going.\n                        key = parent.key;\n                        parent = parent.parent;\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n    } else {\n        // Check if there's a revalidating entry. If so, promote it to a\n        // \"normal\" entry, since the normal one was just deleted.\n        const revalidatingEntry = map.get(Revalidation);\n        if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n            setMapEntryValue(entry, revalidatingEntry.value);\n        }\n    }\n}\nfunction setSizeInCacheMap(value, size) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    // Except during initialization (when the size is set to 0), this is the only\n    // place the `size` field should be updated, to ensure it's in sync with the\n    // the LRU.\n    value.size = size;\n    (0, _lru.updateLruSize)(entry, size);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=cache-map.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/vary-path.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    appendLayoutVaryPath: null,\n    clonePageVaryPathWithNewSearchParams: null,\n    finalizeLayoutVaryPath: null,\n    finalizeMetadataVaryPath: null,\n    finalizePageVaryPath: null,\n    getFulfilledRouteVaryPath: null,\n    getRouteVaryPath: null,\n    getSegmentVaryPathForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    appendLayoutVaryPath: function() {\n        return appendLayoutVaryPath;\n    },\n    clonePageVaryPathWithNewSearchParams: function() {\n        return clonePageVaryPathWithNewSearchParams;\n    },\n    finalizeLayoutVaryPath: function() {\n        return finalizeLayoutVaryPath;\n    },\n    finalizeMetadataVaryPath: function() {\n        return finalizeMetadataVaryPath;\n    },\n    finalizePageVaryPath: function() {\n        return finalizePageVaryPath;\n    },\n    getFulfilledRouteVaryPath: function() {\n        return getFulfilledRouteVaryPath;\n    },\n    getRouteVaryPath: function() {\n        return getRouteVaryPath;\n    },\n    getSegmentVaryPathForRequest: function() {\n        return getSegmentVaryPathForRequest;\n    }\n});\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nconst _cachemap = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-map.js [app-client] (ecmascript)\");\nconst _segmentvalueencoding = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js [app-client] (ecmascript)\");\nfunction getRouteVaryPath(pathname, search, nextUrl) {\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: nextUrl,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nfunction getFulfilledRouteVaryPath(pathname, search, nextUrl, couldBeIntercepted) {\n    // This is called when a route's data is fulfilled. The cache entry will be\n    // re-keyed based on which inputs the response varies by.\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: couldBeIntercepted ? nextUrl : _cachemap.Fallback,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nfunction appendLayoutVaryPath(parentPath, cacheKey) {\n    const varyPathPart = {\n        value: cacheKey,\n        parent: parentPath\n    };\n    return varyPathPart;\n}\nfunction finalizeLayoutVaryPath(requestKey, varyPath) {\n    const layoutVaryPath = {\n        value: requestKey,\n        parent: varyPath\n    };\n    return layoutVaryPath;\n}\nfunction finalizePageVaryPath(requestKey, renderedSearch, varyPath) {\n    // Unlike layouts, a page segment's vary path also includes the search string.\n    // requestKey -> searchParams -> pathParams\n    const pageVaryPath = {\n        value: requestKey,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nfunction finalizeMetadataVaryPath(pageRequestKey, renderedSearch, varyPath) {\n    // The metadata \"segment\" is not a real segment because it doesn't exist in\n    // the normal structure of the route tree, but in terms of caching, it\n    // behaves like a page segment because it varies by all the same params as\n    // a page.\n    //\n    // To keep the protocol for querying the server simple, the request key for\n    // the metadata does not include any path information. It's unnecessary from\n    // the server's perspective, because unlike page segments, there's only one\n    // metadata response per URL, i.e. there's no need to distinguish multiple\n    // parallel pages.\n    //\n    // However, this means the metadata request key is insufficient for\n    // caching the the metadata in the client cache, because on the client we\n    // use the request key to distinguish the metadata entry from all other\n    // page's metadata entries.\n    //\n    // So instead we create a simulated request key based on the page segment.\n    // Conceptually this is equivalent to the request key the server would have\n    // assigned the metadata segment if it treated it as part of the actual\n    // route structure.\n    // If there are multiple parallel pages, we use whichever is the first one.\n    // This is fine because the only difference between request keys for\n    // different parallel pages are things like route groups and parallel\n    // route slots. As long as it's always the same one, it doesn't matter.\n    const pageVaryPath = {\n        // Append the actual metadata request key to the page request key. Note\n        // that we're not using a separate vary path part; it's unnecessary because\n        // these are not conceptually separate inputs.\n        value: pageRequestKey + _segmentvalueencoding.HEAD_REQUEST_KEY,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nfunction getSegmentVaryPathForRequest(fetchStrategy, tree) {\n    // This is used for storing pending requests in the cache. We want to choose\n    // the most generic vary path based on the strategy used to fetch it, i.e.\n    // static/PPR versus runtime prefetching, so that it can be reused as much\n    // as possible.\n    //\n    // We may be able to re-key the response to something even more generic once\n    // we receive it  for example, if the server tells us that the response\n    // doesn't vary on a particular param  but even before we send the request,\n    // we know some params are reusable based on the fetch strategy alone. For\n    // example, a static prefetch will never vary on search params.\n    //\n    // The original vary path with all the params filled in is stored on the\n    // route tree object. We will clone this one to create a new vary path\n    // where certain params are replaced with Fallback.\n    //\n    // This result of this function is not stored anywhere. It's only used to\n    // access the cache a single time.\n    //\n    // TODO: Rather than create a new list object just to access the cache, the\n    // plan is to add the concept of a \"vary mask\". This will represent all the\n    // params that can be treated as Fallback. (Or perhaps the inverse.)\n    const originalVaryPath = tree.varyPath;\n    // Only page segments (and the special \"metadata\" segment, which is treated\n    // like a page segment for the purposes of caching) may contain search\n    // params. There's no reason to include them in the vary path otherwise.\n    if (tree.isPage) {\n        // Only a runtime prefetch will include search params in the vary path.\n        // Static prefetches never include search params, so they can be reused\n        // across all possible search param values.\n        const doesVaryOnSearchParams = fetchStrategy === _types.FetchStrategy.Full || fetchStrategy === _types.FetchStrategy.PPRRuntime;\n        if (!doesVaryOnSearchParams) {\n            // The response from the the server will not vary on search params. Clone\n            // the end of the original vary path to replace the search params\n            // with Fallback.\n            //\n            // requestKey -> searchParams -> pathParams\n            //               ^ This part gets replaced with Fallback\n            const searchParamsVaryPath = originalVaryPath.parent;\n            const pathParamsVaryPath = searchParamsVaryPath.parent;\n            const patchedVaryPath = {\n                value: originalVaryPath.value,\n                parent: {\n                    value: _cachemap.Fallback,\n                    parent: pathParamsVaryPath\n                }\n            };\n            return patchedVaryPath;\n        }\n    }\n    // The request does vary on search params. We don't need to modify anything.\n    return originalVaryPath;\n}\nfunction clonePageVaryPathWithNewSearchParams(originalVaryPath, newSearch) {\n    // requestKey -> searchParams -> pathParams\n    //               ^ This part gets replaced with newSearch\n    const searchParamsVaryPath = originalVaryPath.parent;\n    const clonedVaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n            value: newSearch,\n            parent: searchParamsVaryPath.parent\n        }\n    };\n    return clonedVaryPath;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=vary-path.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/cache-key.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\n// TypeScript trick to simulate opaque types, like in Flow.\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createCacheKey\", {\n    enumerable: true,\n    get: function() {\n        return createCacheKey;\n    }\n});\nfunction createCacheKey(originalHref, nextUrl) {\n    const originalUrl = new URL(originalHref);\n    const cacheKey = {\n        pathname: originalUrl.pathname,\n        search: originalUrl.search,\n        nextUrl: nextUrl\n    };\n    return cacheKey;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=cache-key.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/scheduler.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    cancelPrefetchTask: null,\n    isPrefetchTaskDirty: null,\n    pingPrefetchTask: null,\n    reschedulePrefetchTask: null,\n    schedulePrefetchTask: null,\n    startRevalidationCooldown: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    isPrefetchTaskDirty: function() {\n        return isPrefetchTaskDirty;\n    },\n    pingPrefetchTask: function() {\n        return pingPrefetchTask;\n    },\n    reschedulePrefetchTask: function() {\n        return reschedulePrefetchTask;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    },\n    startRevalidationCooldown: function() {\n        return startRevalidationCooldown;\n    }\n});\nconst _approutertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-types.js [app-client] (ecmascript)\");\nconst _matchsegments = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)\");\nconst _cache = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache.js [app-client] (ecmascript)\");\nconst _varypath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/vary-path.js [app-client] (ecmascript)\");\nconst _cachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-key.js [app-client] (ecmascript)\");\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn)=>Promise.resolve().then(fn).catch((error)=>setTimeout(()=>{\n            throw error;\n        }));\nconst taskHeap = [];\nlet inProgressRequests = 0;\nlet sortIdCounter = 0;\nlet didScheduleMicrotask = false;\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink = null;\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300;\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle = null;\nfunction startRevalidationCooldown() {\n    // Clear any existing timeout in case multiple revalidations happen\n    // in quick succession.\n    if (revalidationCooldownTimeoutHandle !== null) {\n        clearTimeout(revalidationCooldownTimeoutHandle);\n    }\n    // Schedule the cooldown to expire after the delay.\n    revalidationCooldownTimeoutHandle = setTimeout(()=>{\n        revalidationCooldownTimeoutHandle = null;\n        // Retry the prefetch queue now that the cooldown has expired.\n        ensureWorkIsScheduled();\n    }, REVALIDATION_COOLDOWN_MS);\n}\nfunction schedulePrefetchTask(key, treeAtTimeOfPrefetch, fetchStrategy, priority, onInvalidate) {\n    // Spawn a new prefetch task\n    const task = {\n        key,\n        treeAtTimeOfPrefetch,\n        cacheVersion: (0, _cache.getCurrentCacheVersion)(),\n        priority,\n        phase: 1,\n        hasBackgroundWork: false,\n        spawnedRuntimePrefetches: null,\n        fetchStrategy,\n        sortId: sortIdCounter++,\n        isCanceled: false,\n        onInvalidate,\n        _heapIndex: -1\n    };\n    trackMostRecentlyHoveredLink(task);\n    heapPush(taskHeap, task);\n    // Schedule an async task to process the queue.\n    //\n    // The main reason we process the queue in an async task is for batching.\n    // It's common for a single JS task/event to trigger multiple prefetches.\n    // By deferring to a microtask, we only process the queue once per JS task.\n    // If they have different priorities, it also ensures they are processed in\n    // the optimal order.\n    ensureWorkIsScheduled();\n    return task;\n}\nfunction cancelPrefetchTask(task) {\n    // Remove the prefetch task from the queue. If the task already completed,\n    // then this is a no-op.\n    //\n    // We must also explicitly mark the task as canceled so that a blocked task\n    // does not get added back to the queue when it's pinged by the network.\n    task.isCanceled = true;\n    heapDelete(taskHeap, task);\n}\nfunction reschedulePrefetchTask(task, treeAtTimeOfPrefetch, fetchStrategy, priority) {\n    // Bump the prefetch task to the top of the queue, as if it were a fresh\n    // task. This is essentially the same as canceling the task and scheduling\n    // a new one, except it reuses the original object.\n    //\n    // The primary use case is to increase the priority of a Link-initated\n    // prefetch on hover.\n    // Un-cancel the task, in case it was previously canceled.\n    task.isCanceled = false;\n    task.phase = 1;\n    // Assign a new sort ID to move it ahead of all other tasks at the same\n    // priority level. (Higher sort IDs are processed first.)\n    task.sortId = sortIdCounter++;\n    task.priority = // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? _types.PrefetchPriority.Intent : priority;\n    task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch;\n    task.fetchStrategy = fetchStrategy;\n    trackMostRecentlyHoveredLink(task);\n    if (task._heapIndex !== -1) {\n        // The task is already in the queue.\n        heapResift(taskHeap, task);\n    } else {\n        heapPush(taskHeap, task);\n    }\n    ensureWorkIsScheduled();\n}\nfunction isPrefetchTaskDirty(task, nextUrl, tree) {\n    // This is used to quickly bail out of a prefetch task if the result is\n    // guaranteed to not have changed since the task was initiated. This is\n    // strictly an optimization  theoretically, if it always returned true, no\n    // behavior should change because a full prefetch task will effectively\n    // perform the same checks.\n    const currentCacheVersion = (0, _cache.getCurrentCacheVersion)();\n    return task.cacheVersion !== currentCacheVersion || task.treeAtTimeOfPrefetch !== tree || task.key.nextUrl !== nextUrl;\n}\nfunction trackMostRecentlyHoveredLink(task) {\n    // Track the mostly recently hovered link, i.e. the most recently scheduled\n    // task at Intent priority. There must only be one such task at a time.\n    if (task.priority === _types.PrefetchPriority.Intent && task !== mostRecentlyHoveredLink) {\n        if (mostRecentlyHoveredLink !== null) {\n            // Bump the previously hovered link's priority down to Default.\n            if (mostRecentlyHoveredLink.priority !== _types.PrefetchPriority.Background) {\n                mostRecentlyHoveredLink.priority = _types.PrefetchPriority.Default;\n                heapResift(taskHeap, mostRecentlyHoveredLink);\n            }\n        }\n        mostRecentlyHoveredLink = task;\n    }\n}\nfunction ensureWorkIsScheduled() {\n    if (didScheduleMicrotask) {\n        // Already scheduled a task to process the queue\n        return;\n    }\n    didScheduleMicrotask = true;\n    scheduleMicrotask(processQueueInMicrotask);\n}\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */ function hasNetworkBandwidth(task) {\n    // Check if we're within the revalidation cooldown window\n    if (revalidationCooldownTimeoutHandle !== null) {\n        // We're within the cooldown window. Return false to prevent prefetching.\n        // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n        // to retry the queue.\n        return false;\n    }\n    // TODO: Also check if there's an in-progress navigation. We should never\n    // add prefetch requests to the network queue if an actual navigation is\n    // taking place, to ensure there's sufficient bandwidth for render-blocking\n    // data and resources.\n    // TODO: Consider reserving some amount of bandwidth for static prefetches.\n    if (task.priority === _types.PrefetchPriority.Intent) {\n        // The most recently hovered link is allowed to exceed the default limit.\n        //\n        // The goal is to always have enough bandwidth to start a new prefetch\n        // request when hovering over a link.\n        //\n        // However, because we don't abort in-progress requests, it's still possible\n        // we'll run out of bandwidth. When links are hovered in quick succession,\n        // there could be multiple hover requests running simultaneously.\n        return inProgressRequests < 12;\n    }\n    // The default limit is lower than the limit for a hovered link.\n    return inProgressRequests < 4;\n}\nfunction spawnPrefetchSubtask(prefetchSubtask) {\n    // When the scheduler spawns an async task, we don't await its result.\n    // Instead, the async task writes its result directly into the cache, then\n    // pings the scheduler to continue.\n    //\n    // We process server responses streamingly, so the prefetch subtask will\n    // likely resolve before we're finished receiving all the data. The subtask\n    // result includes a promise that resolves once the network connection is\n    // closed. The scheduler uses this to control network bandwidth by tracking\n    // and limiting the number of concurrent requests.\n    inProgressRequests++;\n    return prefetchSubtask.then((result)=>{\n        if (result === null) {\n            // The prefetch task errored before it could start processing the\n            // network stream. Assume the connection is closed.\n            onPrefetchConnectionClosed();\n            return null;\n        }\n        // Wait for the connection to close before freeing up more bandwidth.\n        result.closed.then(onPrefetchConnectionClosed);\n        return result.value;\n    });\n}\nfunction onPrefetchConnectionClosed() {\n    inProgressRequests--;\n    // Notify the scheduler that we have more bandwidth, and can continue\n    // processing tasks.\n    ensureWorkIsScheduled();\n}\nfunction pingPrefetchTask(task) {\n    // \"Ping\" a prefetch that's already in progress to notify it of new data.\n    if (task.isCanceled || // Check if prefetch is already queued.\n    task._heapIndex !== -1) {\n        return;\n    }\n    // Add the task back to the queue.\n    heapPush(taskHeap, task);\n    ensureWorkIsScheduled();\n}\nfunction processQueueInMicrotask() {\n    didScheduleMicrotask = false;\n    // We aim to minimize how often we read the current time. Since nearly all\n    // functions in the prefetch scheduler are synchronous, we can read the time\n    // once and pass it as an argument wherever it's needed.\n    const now = Date.now();\n    // Process the task queue until we run out of network bandwidth.\n    let task = heapPeek(taskHeap);\n    while(task !== null && hasNetworkBandwidth(task)){\n        task.cacheVersion = (0, _cache.getCurrentCacheVersion)();\n        const exitStatus = pingRoute(now, task);\n        // These fields are only valid for a single attempt. Reset them after each\n        // iteration of the task queue.\n        const hasBackgroundWork = task.hasBackgroundWork;\n        task.hasBackgroundWork = false;\n        task.spawnedRuntimePrefetches = null;\n        switch(exitStatus){\n            case 0:\n                // The task yielded because there are too many requests in progress.\n                // Stop processing tasks until we have more bandwidth.\n                return;\n            case 1:\n                // The task is blocked. It needs more data before it can proceed.\n                // Keep the task out of the queue until the server responds.\n                heapPop(taskHeap);\n                // Continue to the next task\n                task = heapPeek(taskHeap);\n                continue;\n            case 2:\n                if (task.phase === 1) {\n                    // Finished prefetching the route tree. Proceed to prefetching\n                    // the segments.\n                    task.phase = 0;\n                    heapResift(taskHeap, task);\n                } else if (hasBackgroundWork) {\n                    // The task spawned additional background work. Reschedule the task\n                    // at background priority.\n                    task.priority = _types.PrefetchPriority.Background;\n                    heapResift(taskHeap, task);\n                } else {\n                    // The prefetch is complete. Continue to the next task.\n                    heapPop(taskHeap);\n                }\n                task = heapPeek(taskHeap);\n                continue;\n            default:\n                exitStatus;\n        }\n    }\n}\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */ function background(task) {\n    if (task.priority === _types.PrefetchPriority.Background) {\n        return true;\n    }\n    task.hasBackgroundWork = true;\n    return false;\n}\nfunction pingRoute(now, task) {\n    const key = task.key;\n    const route = (0, _cache.readOrCreateRouteCacheEntry)(now, task, key);\n    const exitStatus = pingRootRouteTree(now, task, route);\n    if (exitStatus !== 0 && key.search !== '') {\n        // If the URL has a non-empty search string, also prefetch the pathname\n        // without the search string. We use the searchless route tree as a base for\n        // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n        //\n        // Note that we don't need to prefetch any of the segment data. Just the\n        // route tree.\n        //\n        // TODO: This is a temporary solution; the plan is to replace this by adding\n        // a wildcard lookup method to the TupleMap implementation. This is\n        // non-trivial to implement because it needs to account for things like\n        // fallback route entries, hence this temporary workaround.\n        const url = new URL(key.pathname, location.origin);\n        const keyWithoutSearch = (0, _cachekey.createCacheKey)(url.href, key.nextUrl);\n        const routeWithoutSearch = (0, _cache.readOrCreateRouteCacheEntry)(now, task, keyWithoutSearch);\n        switch(routeWithoutSearch.status){\n            case _cache.EntryStatus.Empty:\n                {\n                    if (background(task)) {\n                        routeWithoutSearch.status = _cache.EntryStatus.Pending;\n                        spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(routeWithoutSearch, task, keyWithoutSearch));\n                    }\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                {\n                    break;\n                }\n            default:\n                routeWithoutSearch;\n        }\n    }\n    return exitStatus;\n}\nfunction pingRootRouteTree(now, task, route) {\n    switch(route.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // Route is not yet cached, and there's no request already in progress.\n                // Spawn a task to request the route, load it into the cache, and ping\n                // the task to continue.\n                // TODO: There are multiple strategies in the <Link> API for prefetching\n                // a route. Currently we've only implemented the main one: per-segment,\n                // static-data only.\n                //\n                // There's also `<Link prefetch={true}>`\n                // which prefetch both static *and* dynamic data.\n                // Similarly, we need to fallback to the old, per-page\n                // behavior if PPR is disabled for a route (via the incremental opt-in).\n                //\n                // Those cases will be handled here.\n                spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(route, task, task.key));\n                // If the request takes longer than a minute, a subsequent request should\n                // retry instead of waiting for this one. When the response is received,\n                // this value will be replaced by a new value based on the stale time sent\n                // from the server.\n                // TODO: We should probably also manually abort the fetch task, to reclaim\n                // server bandwidth.\n                route.staleAt = now + 60 * 1000;\n                // Upgrade to Pending so we know there's already a request in progress\n                route.status = _cache.EntryStatus.Pending;\n            // Intentional fallthrough to the Pending branch\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                // Still pending. We can't start prefetching the segments until the route\n                // tree has loaded. Add the task to the set of blocked tasks so that it\n                // is notified when the route tree is ready.\n                const blockedTasks = route.blockedTasks;\n                if (blockedTasks === null) {\n                    route.blockedTasks = new Set([\n                        task\n                    ]);\n                } else {\n                    blockedTasks.add(task);\n                }\n                return 1;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // Route tree failed to load. Treat as a 404.\n                return 2;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                if (task.phase !== 0) {\n                    // Do not prefetch segment data until we've entered the segment phase.\n                    return 2;\n                }\n                // Recursively fill in the segment tree.\n                if (!hasNetworkBandwidth(task)) {\n                    // Stop prefetching segments until there's more bandwidth.\n                    return 0;\n                }\n                const tree = route.tree;\n                // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n                // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n                // We don't need to do this for runtime prefetches, because those are only available in\n                // `cacheComponents`, where every route is PPR.\n                const fetchStrategy = task.fetchStrategy === _types.FetchStrategy.PPR ? route.isPPREnabled ? _types.FetchStrategy.PPR : _types.FetchStrategy.LoadingBoundary : task.fetchStrategy;\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                        {\n                            // For Cache Components pages, each segment may be prefetched\n                            // statically or using a runtime request, based on various\n                            // configurations and heuristics. We'll do this in two passes: first\n                            // traverse the tree and perform all the static prefetches.\n                            //\n                            // Then, if there are any segments that need a runtime request,\n                            // do another pass to perform a runtime prefetch.\n                            pingStaticHead(now, task, route);\n                            const exitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, task.treeAtTimeOfPrefetch, tree);\n                            if (exitStatus === 0) {\n                                // Child yielded without finishing.\n                                return 0;\n                            }\n                            const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches;\n                            if (spawnedRuntimePrefetches !== null) {\n                                // During the first pass, we discovered segments that require a\n                                // runtime prefetch. Do a second pass to construct a request tree.\n                                const spawnedEntries = new Map();\n                                pingRuntimeHead(now, task, route, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n                                const requestTree = pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries);\n                                let needsDynamicRequest = spawnedEntries.size > 0;\n                                if (needsDynamicRequest) {\n                                    // Perform a dynamic prefetch request and populate the cache with\n                                    // the result.\n                                    spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, _types.FetchStrategy.PPRRuntime, requestTree, spawnedEntries));\n                                }\n                            }\n                            return 2;\n                        }\n                    case _types.FetchStrategy.Full:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // Prefetch multiple segments using a single dynamic request.\n                            // TODO: We can consolidate this branch with previous one by modeling\n                            // it as if the first segment in the new tree has runtime prefetching\n                            // enabled. Will do this as a follow-up refactor. Might want to remove\n                            // the special metatdata case below first. In the meantime, it's not\n                            // really that much duplication, just would be nice to remove one of\n                            // these codepaths.\n                            const spawnedEntries = new Map();\n                            pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy);\n                            const dynamicRequestTree = diffRouteTreeAgainstCurrent(now, task, route, task.treeAtTimeOfPrefetch, tree, spawnedEntries, fetchStrategy);\n                            let needsDynamicRequest = spawnedEntries.size > 0;\n                            if (needsDynamicRequest) {\n                                spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries));\n                            }\n                            return 2;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n                break;\n            }\n        default:\n            {\n                route;\n            }\n    }\n    return 2;\n}\nfunction pingStaticHead(now, task, route) {\n    // The Head data for a page (metadata, viewport) is not really a route\n    // segment, in the sense that it doesn't appear in the route tree. But we\n    // store it in the cache as if it were, using a special key.\n    pingStaticSegmentData(now, task, route, (0, _cache.readOrCreateSegmentCacheEntry)(now, _types.FetchStrategy.PPR, route, route.metadata), task.key, route.metadata);\n}\nfunction pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy) {\n    pingRouteTreeAndIncludeDynamicData(now, task, route, route.metadata, false, spawnedEntries, // and LoadingBoundary\n    fetchStrategy === _types.FetchStrategy.LoadingBoundary ? _types.FetchStrategy.Full : fetchStrategy);\n}\n// TODO: Rename dynamic -> runtime throughout this module\nfunction pingSharedPartOfCacheComponentsTree(now, task, route, oldTree, newTree) {\n    // When Cache Components is enabled (or PPR, or a fully static route when PPR\n    // is disabled; those cases are treated equivalently to Cache Components), we\n    // start by prefetching each segment individually. Once we reach the \"new\"\n    // part of the tree  the part that doesn't exist on the current page  we\n    // may choose to switch to a runtime prefetch instead, based on the\n    // information sent by the server in the route tree.\n    //\n    // The traversal starts in the \"shared\" part of the tree. Once we reach the\n    // \"new\" part of the tree, we switch to a different traversal,\n    // pingNewPartOfCacheComponentsTree.\n    // Prefetch this segment's static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, newTree);\n    pingStaticSegmentData(now, task, route, segment, task.key, newTree);\n    // Recursively ping the children.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            if (!hasNetworkBandwidth(task)) {\n                // Stop prefetching segments until there's more bandwidth.\n                return 0;\n            }\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            let childExitStatus;\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // We're still in the \"shared\" part of the tree.\n                childExitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, oldTreeChild, newTreeChild);\n            } else {\n                // We've entered the \"new\" part of the tree. Switch\n                // traversal functions.\n                childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, newTreeChild);\n            }\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    return 2;\n}\nfunction pingNewPartOfCacheComponentsTree(now, task, route, tree) {\n    // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n    // exist on the current page. (In other words, we're deeper than the\n    // shared layouts.) Segments in here default to being prefetched statically.\n    // However, if the server instructs us to, we may switch to a runtime\n    // prefetch instead. Traverse the tree and check at each segment.\n    if (tree.hasRuntimePrefetch) {\n        // This route has a runtime prefetch response. Since we're below the shared\n        // layout, everything from this point should be prefetched using a single,\n        // combined runtime request, rather than using per-segment static requests.\n        // This is true even if some of the child segments are known to be fully\n        // static  once we've decided to perform a runtime prefetch, we might as\n        // well respond with the static segments in the same roundtrip. (That's how\n        // regular navigations work, too.) We'll still skip over segments that are\n        // already cached, though.\n        //\n        // It's the server's responsibility to set a reasonable value of\n        // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n        // server may send a value of `false` even if the user opts in, if it\n        // determines during build that the route is always fully static. There are\n        // more optimizations we can do once we implement fallback param\n        // tracking, too.\n        //\n        // Use the task object to collect the segments that need a runtime prefetch.\n        // This will signal to the outer task queue that a second traversal is\n        // required to construct a request tree.\n        if (task.spawnedRuntimePrefetches === null) {\n            task.spawnedRuntimePrefetches = new Set([\n                tree.requestKey\n            ]);\n        } else {\n            task.spawnedRuntimePrefetches.add(tree.requestKey);\n        }\n        // Then exit the traversal without prefetching anything further.\n        return 2;\n    }\n    // This segment should not be runtime prefetched. Prefetch its static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    pingStaticSegmentData(now, task, route, segment, task.key, tree);\n    if (tree.slots !== null) {\n        if (!hasNetworkBandwidth(task)) {\n            // Stop prefetching segments until there's more bandwidth.\n            return 0;\n        }\n        // Recursively ping the children.\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            const childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, childTree);\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    // This segment and all its children have finished prefetching.\n    return 2;\n}\nfunction diffRouteTreeAgainstCurrent(now, task, route, oldTree, newTree, spawnedEntries, fetchStrategy) {\n    // This is a single recursive traversal that does multiple things:\n    // - Finds the parts of the target route (newTree) that are not part of\n    //   of the current page (oldTree) by diffing them, using the same algorithm\n    //   as a real navigation.\n    // - Constructs a request tree (FlightRouterState) that describes which\n    //   segments need to be prefetched and which ones are already cached.\n    // - Creates a set of pending cache entries for the segments that need to\n    //   be prefetched, so that a subsequent prefetch task does not request the\n    //   same segments again.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    let requestTreeChildren = {};\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // This segment is already part of the current route. Keep traversing.\n                const requestTreeChild = diffRouteTreeAgainstCurrent(now, task, route, oldTreeChild, newTreeChild, spawnedEntries, fetchStrategy);\n                requestTreeChildren[parallelRouteKey] = requestTreeChild;\n            } else {\n                // This segment is not part of the current route. We're entering a\n                // part of the tree that we need to prefetch (unless everything is\n                // already cached).\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // When PPR is disabled, we can't prefetch per segment. We must\n                            // fallback to the old prefetch behavior and send a dynamic request.\n                            // Only routes that include a loading boundary can be prefetched in\n                            // this way.\n                            //\n                            // This is simlar to a \"full\" prefetch, but we're much more\n                            // conservative about which segments to include in the request.\n                            //\n                            // The server will only render up to the first loading boundary\n                            // inside new part of the tree. If there's no loading boundary\n                            // anywhere in the tree, the server will never return any data, so\n                            // we can skip the request.\n                            const subtreeHasLoadingBoundary = newTreeChild.hasLoadingBoundary !== _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary;\n                            const requestTreeChild = subtreeHasLoadingBoundary ? pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, newTreeChild, null, spawnedEntries) : (0, _cache.convertRouteTreeToFlightRouterState)(newTreeChild);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.PPRRuntime:\n                        {\n                            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n                            // not just the static PPR shell.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.Full:\n                        {\n                            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n                            // static and dynamic. We issue roughly the same request that we\n                            // would during a real navigation. The goal is that once the\n                            // navigation occurs, the router should not have to fetch any\n                            // additional data.\n                            //\n                            // Although the response will include dynamic data, opting into a\n                            // Full prefetch  via <Link prefetch={true}>  implicitly\n                            // instructs the cache to treat the response as \"static\", or non-\n                            // dynamic, since the whole point is to cache it for\n                            // future navigations.\n                            //\n                            // Construct a tree (currently a FlightRouterState) that represents\n                            // which segments need to be prefetched and which ones are already\n                            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n                            // send the request tree to the server and use the response to\n                            // populate the segment cache.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n            }\n        }\n    }\n    const requestTree = [\n        newTree.segment,\n        requestTreeChildren,\n        null,\n        null,\n        newTree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, tree, refetchMarkerContext, spawnedEntries) {\n    // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n    // server is only going to return a minimal loading state  it will stop\n    // rendering at the first loading boundary. Whereas a Full prefetch is\n    // intentionally aggressive and tries to pretfetch all the data that will be\n    // needed for a navigation, a LoadingBoundary prefetch is much more\n    // conservative. For example, it will omit from the request tree any segment\n    // that is already cached, regardles of whether it's partial or full. By\n    // contrast, a Full prefetch will refetch partial segments.\n    // \"inside-shared-layout\" tells the server where to start looking for a\n    // loading boundary.\n    let refetchMarker = refetchMarkerContext === null ? 'inside-shared-layout' : null;\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Add a refetch marker so the server knows\n                // to start rendering here.\n                // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n                // FlightRouterState from the request tree. I think this would probably\n                // already work even without any updates to the server. For consistency,\n                // though, I'll send the full tree and we'll look into this later as part\n                // of a larger redesign of the request protocol.\n                // Add the pending cache entry to the result map.\n                spawnedEntries.set(tree.requestKey, (0, _cache.upgradeToPendingSegment)(segment, // might not include it in the pending response. If another route is able\n                // to issue a per-segment request, we'll do that in the background.\n                _types.FetchStrategy.LoadingBoundary));\n                if (refetchMarkerContext !== 'refetch') {\n                    refetchMarker = refetchMarkerContext = 'refetch';\n                } else {\n                // There's already a parent with a refetch marker, so we don't need\n                // to add another one.\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                const segmentHasLoadingBoundary = tree.hasLoadingBoundary === _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary;\n                if (segmentHasLoadingBoundary) {\n                    // This segment has a loading boundary, which means the server won't\n                    // render its children. So there's nothing left to prefetch along this\n                    // path. We can bail out.\n                    return (0, _cache.convertRouteTreeToFlightRouterState)(tree);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, childTree, refetchMarkerContext, spawnedEntries);\n        }\n    }\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRouteTreeAndIncludeDynamicData(now, task, route, tree, isInsideRefetchingParent, spawnedEntries, fetchStrategy) {\n    // The tree we're constructing is the same shape as the tree we're navigating\n    // to. But even though this is a \"new\" tree, some of the individual segments\n    // may be cached as a result of other route prefetches.\n    //\n    // So we need to find the first uncached segment along each path add an\n    // explicit \"refetch\" marker so the server knows where to start rendering.\n    // Once the server starts rendering along a path, it keeps rendering the\n    // entire subtree.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy, route, tree);\n    let spawnedSegment = null;\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Include it in the request.\n                spawnedSegment = (0, _cache.upgradeToPendingSegment)(segment, fetchStrategy);\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                if (segment.isPartial && (0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n                    // This means we're in one of these cases:\n                    //   - we have a static prefetch, and we're doing a runtime prefetch\n                    //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n                    // In either case, we need to include it in the request to get a more specific (or full) version.\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n        case _cache.EntryStatus.Rejected:\n            {\n                // There's either another prefetch currently in progress, or the previous\n                // attempt failed. If the new strategy can provide more content, fetch it again.\n                if ((0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRouteTreeAndIncludeDynamicData(now, task, route, childTree, isInsideRefetchingParent || spawnedSegment !== null, spawnedEntries, fetchStrategy);\n        }\n    }\n    if (spawnedSegment !== null) {\n        // Add the pending entry to the result map.\n        spawnedEntries.set(tree.requestKey, spawnedSegment);\n    }\n    // Don't bother to add a refetch marker if one is already present in a parent.\n    const refetchMarker = !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null;\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries) {\n    // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n    // a segment is part of the runtime prefetch, the tree is constructed by\n    // diffing against what's already in the prefetch cache. Otherwise, we send\n    // a regular FlightRouterState with no special markers.\n    //\n    // See pingRouteTreeAndIncludeDynamicData for details.\n    if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n        // This segment needs a runtime prefetch.\n        return pingRouteTreeAndIncludeDynamicData(now, task, route, tree, false, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n    }\n    let requestTreeChildren = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(now, task, route, childTree, spawnedRuntimePrefetches, spawnedEntries);\n        }\n    }\n    // This segment is not part of the runtime prefetch. Clone the base tree.\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        null\n    ];\n    return requestTree;\n}\nfunction pingStaticSegmentData(now, task, route, segment, routeKey, tree) {\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            // Upgrade to Pending so we know there's already a request in progress\n            spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(segment, _types.FetchStrategy.PPR), routeKey, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            {\n                // There's already a request in progress. Depending on what kind of\n                // request it is, we may want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a pending request, but because it's using the old\n                        // prefetching strategy, we can't be sure if it will be fulfilled by\n                        // the response  it might be inside the loading boundary. Perform\n                        // a revalidation, but because it's speculative, wait to do it at\n                        // background priority.\n                        if (background(task)) {\n                            // TODO: Instead of speculatively revalidating, consider including\n                            // `hasLoading` in the route tree prefetch response.\n                            pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        }\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // The existing entry in the cache was rejected. Depending on how it\n                // was originally fetched, we may or may not want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a rejected entry, but it was fetched using the loading\n                        // boundary strategy. So the reason it wasn't returned by the server\n                        // might just be because it was inside a loading boundary. Or because\n                        // there was a dynamic rewrite. Revalidate it using the per-\n                        // segment strategy.\n                        //\n                        // Because a rejected segment will definitely prevent the segment (and\n                        // all of its children) from rendering, we perform this revalidation\n                        // immediately instead of deferring it to a background task.\n                        pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            break;\n        default:\n            segment;\n    }\n// Segments do not have dependent tasks, so once the prefetch is initiated,\n// there's nothing else for us to do (except write the server data into the\n// entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\nfunction pingPPRSegmentRevalidation(now, route, routeKey, tree) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, _types.FetchStrategy.PPR, route, tree);\n    switch(revalidatingSegment.status){\n        case _cache.EntryStatus.Empty:\n            // Spawn a prefetch request and upsert the segment into the cache\n            // upon completion.\n            upsertSegmentOnCompletion(spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(revalidatingSegment, _types.FetchStrategy.PPR), routeKey, tree)), (0, _varypath.getSegmentVaryPathForRequest)(_types.FetchStrategy.PPR, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            break;\n        case _cache.EntryStatus.Fulfilled:\n        case _cache.EntryStatus.Rejected:\n            break;\n        default:\n            revalidatingSegment;\n    }\n}\nfunction pingFullSegmentRevalidation(now, route, tree, fetchStrategy) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, fetchStrategy, route, tree);\n    if (revalidatingSegment.status === _cache.EntryStatus.Empty) {\n        // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n        // segments that we need. So we don't initiate a request here directly. By\n        // returning a pending entry from this function, it signals to the caller\n        // that this segment should be included in the request that's sent to\n        // the server.\n        const pendingSegment = (0, _cache.upgradeToPendingSegment)(revalidatingSegment, fetchStrategy);\n        upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n        return pendingSegment;\n    } else {\n        // There's already a revalidation in progress.\n        const nonEmptyRevalidatingSegment = revalidatingSegment;\n        if ((0, _cache.canNewFetchStrategyProvideMoreContent)(nonEmptyRevalidatingSegment.fetchStrategy, fetchStrategy)) {\n            // The existing revalidation was fetched using a less specific strategy.\n            // Reset it and start a new revalidation.\n            const emptySegment = (0, _cache.overwriteRevalidatingSegmentCacheEntry)(fetchStrategy, route, tree);\n            const pendingSegment = (0, _cache.upgradeToPendingSegment)(emptySegment, fetchStrategy);\n            upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n            return pendingSegment;\n        }\n        switch(nonEmptyRevalidatingSegment.status){\n            case _cache.EntryStatus.Pending:\n                // There's already an in-progress prefetch that includes this segment.\n                return null;\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                // A previous revalidation attempt finished, but we chose not to replace\n                // the existing entry in the cache. Don't try again until or unless the\n                // revalidation entry expires.\n                return null;\n            default:\n                nonEmptyRevalidatingSegment;\n                return null;\n        }\n    }\n}\nconst noop = ()=>{};\nfunction upsertSegmentOnCompletion(promise, varyPath) {\n    // Wait for a segment to finish loading, then upsert it into the cache\n    promise.then((fulfilled)=>{\n        if (fulfilled !== null) {\n            // Received new data. Attempt to replace the existing entry in the cache.\n            (0, _cache.upsertSegmentEntry)(Date.now(), varyPath, fulfilled);\n        }\n    }, noop);\n}\nfunction doesCurrentSegmentMatchCachedSegment(route, currentSegment, cachedSegment) {\n    if (cachedSegment === _segment.PAGE_SEGMENT_KEY) {\n        // In the FlightRouterState stored by the router, the page segment has the\n        // rendered search params appended to the name of the segment. In the\n        // prefetch cache, however, this is stored separately. So, when comparing\n        // the router's current FlightRouterState to the cached FlightRouterState,\n        // we need to make sure we compare both parts of the segment.\n        // TODO: This is not modeled clearly. We use the same type,\n        // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n        // _and_ the server response format, when conceptually those are three\n        // different things and treated in different ways. We should encode more of\n        // this information into the type design so mistakes are less likely.\n        return currentSegment === (0, _segment.addSearchParamsIfPageSegment)(_segment.PAGE_SEGMENT_KEY, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    }\n    // Non-page segments are compared using the same function as the server\n    return (0, _matchsegments.matchSegment)(cachedSegment, currentSegment);\n}\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\nfunction compareQueuePriority(a, b) {\n    // Since the queue is a MinHeap, this should return a positive number if b is\n    // higher priority than a, and a negative number if a is higher priority\n    // than b.\n    // `priority` is an integer, where higher numbers are higher priority.\n    const priorityDiff = b.priority - a.priority;\n    if (priorityDiff !== 0) {\n        return priorityDiff;\n    }\n    // If the priority is the same, check which phase the prefetch is in  is it\n    // prefetching the route tree, or the segments? Route trees are prioritized.\n    const phaseDiff = b.phase - a.phase;\n    if (phaseDiff !== 0) {\n        return phaseDiff;\n    }\n    // Finally, check the insertion order. `sortId` is an incrementing counter\n    // assigned to prefetches. We want to process the newest prefetches first.\n    return b.sortId - a.sortId;\n}\nfunction heapPush(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    node._heapIndex = index;\n    heapSiftUp(heap, node, index);\n}\nfunction heapPeek(heap) {\n    return heap.length === 0 ? null : heap[0];\n}\nfunction heapPop(heap) {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    first._heapIndex = -1;\n    const last = heap.pop();\n    if (last !== first) {\n        heap[0] = last;\n        last._heapIndex = 0;\n        heapSiftDown(heap, last, 0);\n    }\n    return first;\n}\nfunction heapDelete(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        node._heapIndex = -1;\n        if (heap.length !== 0) {\n            const last = heap.pop();\n            if (last !== node) {\n                heap[index] = last;\n                last._heapIndex = index;\n                heapSiftDown(heap, last, index);\n            }\n        }\n    }\n}\nfunction heapResift(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        if (index === 0) {\n            heapSiftDown(heap, node, 0);\n        } else {\n            const parentIndex = index - 1 >>> 1;\n            const parent = heap[parentIndex];\n            if (compareQueuePriority(parent, node) > 0) {\n                // The parent is larger. Sift up.\n                heapSiftUp(heap, node, index);\n            } else {\n                // The parent is smaller (or equal). Sift down.\n                heapSiftDown(heap, node, index);\n            }\n        }\n    }\n}\nfunction heapSiftUp(heap, node, i) {\n    let index = i;\n    while(index > 0){\n        const parentIndex = index - 1 >>> 1;\n        const parent = heap[parentIndex];\n        if (compareQueuePriority(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            node._heapIndex = parentIndex;\n            heap[index] = parent;\n            parent._heapIndex = index;\n            index = parentIndex;\n        } else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction heapSiftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while(index < halfLength){\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compareQueuePriority(left, node) < 0) {\n            if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n                heap[index] = right;\n                right._heapIndex = index;\n                heap[rightIndex] = node;\n                node._heapIndex = rightIndex;\n                index = rightIndex;\n            } else {\n                heap[index] = left;\n                left._heapIndex = index;\n                heap[leftIndex] = node;\n                node._heapIndex = leftIndex;\n                index = leftIndex;\n            }\n        } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n            heap[index] = right;\n            right._heapIndex = index;\n            heap[rightIndex] = node;\n            node._heapIndex = rightIndex;\n            index = rightIndex;\n        } else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=scheduler.js.map\n}),\n\"[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"normalizePathTrailingSlash\", {\n    enumerable: true,\n    get: function() {\n        return normalizePathTrailingSlash;\n    }\n});\nconst _removetrailingslash = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-client] (ecmascript)\");\nconst _parsepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-client] (ecmascript)\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith('/') || (\"TURBOPACK compile-time value\", void 0)) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=normalize-trailing-slash.js.map\n}),\n\"[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"addBasePath\", {\n    enumerable: true,\n    get: function() {\n        return addBasePath;\n    }\n});\nconst _addpathprefix = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-client] (ecmascript)\");\nconst _normalizetrailingslash = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-client] (ecmascript)\");\nconst basePath = (\"TURBOPACK compile-time value\", \"\") || '';\nfunction addBasePath(path, required) {\n    return (0, _normalizetrailingslash.normalizePathTrailingSlash)((\"TURBOPACK compile-time falsy\", 0) ? \"TURBOPACK unreachable\" : (0, _addpathprefix.addPathPrefix)(path, basePath));\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-base-path.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/app-router-utils.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createPrefetchURL: null,\n    isExternalURL: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    isExternalURL: function() {\n        return isExternalURL;\n    }\n});\nconst _isbot = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)\");\nconst _addbasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)\");\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(`Cannot prefetch '${href}' because it cannot be converted to a URL.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        return null;\n    }\n    //TURBOPACK unreachable\n    ;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-utils.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    IDLE_LINK_STATUS: null,\n    PENDING_LINK_STATUS: null,\n    mountFormInstance: null,\n    mountLinkInstance: null,\n    onLinkVisibilityChanged: null,\n    onNavigationIntent: null,\n    pingVisibleLinks: null,\n    setLinkForCurrentNavigation: null,\n    unmountLinkForCurrentNavigation: null,\n    unmountPrefetchableInstance: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    IDLE_LINK_STATUS: function() {\n        return IDLE_LINK_STATUS;\n    },\n    PENDING_LINK_STATUS: function() {\n        return PENDING_LINK_STATUS;\n    },\n    mountFormInstance: function() {\n        return mountFormInstance;\n    },\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    setLinkForCurrentNavigation: function() {\n        return setLinkForCurrentNavigation;\n    },\n    unmountLinkForCurrentNavigation: function() {\n        return unmountLinkForCurrentNavigation;\n    },\n    unmountPrefetchableInstance: function() {\n        return unmountPrefetchableInstance;\n    }\n});\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nconst _cachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-key.js [app-client] (ecmascript)\");\nconst _scheduler = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/scheduler.js [app-client] (ecmascript)\");\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\nconst PENDING_LINK_STATUS = {\n    pending: true\n};\nconst IDLE_LINK_STATUS = {\n    pending: false\n};\nfunction setLinkForCurrentNavigation(link) {\n    (0, _react.startTransition)(()=>{\n        linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link?.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\nfunction unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    if (typeof window !== 'undefined') {\n        const { createPrefetchURL } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-utils.js [app-client] (ecmascript)\");\n        try {\n            return createPrefetchURL(href);\n        } catch  {\n            // createPrefetchURL sometimes throws an error if an invalid URL is\n            // provided, though I'm not sure if it's actually necessary.\n            // TODO: Consider removing the throw from the inner function, or change it\n            // to reportError. Or maybe the error isn't even necessary for automatic\n            // prefetches, just navigations.\n            const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n            reportErrorFn(`Cannot prefetch '${href}' because it cannot be converted to a URL.`);\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nfunction mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nfunction mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nfunction unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _scheduler.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    //TURBOPACK unreachable\n    ;\n    const instance = undefined;\n}\nfunction onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    // Ensures that app-router-instance is not compiled in the server bundle\n    if (typeof window !== 'undefined') {\n        const existingPrefetchTask = instance.prefetchTask;\n        if (!instance.isVisible) {\n            // Cancel any in-progress prefetch task. (If it already finished then this\n            // is a no-op.)\n            if (existingPrefetchTask !== null) {\n                (0, _scheduler.cancelPrefetchTask)(existingPrefetchTask);\n            }\n            // We don't need to reset the prefetchTask to null upon cancellation; an\n            // old task object can be rescheduled with reschedulePrefetchTask. This is a\n            // micro-optimization but also makes the code simpler (don't need to\n            // worry about whether an old task object is stale).\n            return;\n        }\n        const { getCurrentAppRouterState } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)\");\n        const appRouterState = getCurrentAppRouterState();\n        if (appRouterState !== null) {\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            if (existingPrefetchTask === null) {\n                // Initiate a prefetch task.\n                const nextUrl = appRouterState.nextUrl;\n                const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n                instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n            } else {\n                // We already have an old task object that we can reschedule. This is\n                // effectively the same as canceling the old task and creating a new one.\n                (0, _scheduler.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n            }\n        }\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !(0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _scheduler.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _types.PrefetchPriority.Default, null);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=links.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/cache.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    EntryStatus: null,\n    canNewFetchStrategyProvideMoreContent: null,\n    convertRouteTreeToFlightRouterState: null,\n    createDetachedSegmentCacheEntry: null,\n    fetchRouteOnCacheMiss: null,\n    fetchSegmentOnCacheMiss: null,\n    fetchSegmentPrefetchesUsingDynamicRequest: null,\n    getCurrentCacheVersion: null,\n    getStaleTimeMs: null,\n    overwriteRevalidatingSegmentCacheEntry: null,\n    pingInvalidationListeners: null,\n    readOrCreateRevalidatingSegmentEntry: null,\n    readOrCreateRouteCacheEntry: null,\n    readOrCreateSegmentCacheEntry: null,\n    readRouteCacheEntry: null,\n    readSegmentCacheEntry: null,\n    requestOptimisticRouteCacheEntry: null,\n    revalidateEntireCache: null,\n    upgradeToPendingSegment: null,\n    upsertSegmentEntry: null,\n    waitForSegmentCacheEntry: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    EntryStatus: function() {\n        return EntryStatus;\n    },\n    canNewFetchStrategyProvideMoreContent: function() {\n        return canNewFetchStrategyProvideMoreContent;\n    },\n    convertRouteTreeToFlightRouterState: function() {\n        return convertRouteTreeToFlightRouterState;\n    },\n    createDetachedSegmentCacheEntry: function() {\n        return createDetachedSegmentCacheEntry;\n    },\n    fetchRouteOnCacheMiss: function() {\n        return fetchRouteOnCacheMiss;\n    },\n    fetchSegmentOnCacheMiss: function() {\n        return fetchSegmentOnCacheMiss;\n    },\n    fetchSegmentPrefetchesUsingDynamicRequest: function() {\n        return fetchSegmentPrefetchesUsingDynamicRequest;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    getStaleTimeMs: function() {\n        return getStaleTimeMs;\n    },\n    overwriteRevalidatingSegmentCacheEntry: function() {\n        return overwriteRevalidatingSegmentCacheEntry;\n    },\n    pingInvalidationListeners: function() {\n        return pingInvalidationListeners;\n    },\n    readOrCreateRevalidatingSegmentEntry: function() {\n        return readOrCreateRevalidatingSegmentEntry;\n    },\n    readOrCreateRouteCacheEntry: function() {\n        return readOrCreateRouteCacheEntry;\n    },\n    readOrCreateSegmentCacheEntry: function() {\n        return readOrCreateSegmentCacheEntry;\n    },\n    readRouteCacheEntry: function() {\n        return readRouteCacheEntry;\n    },\n    readSegmentCacheEntry: function() {\n        return readSegmentCacheEntry;\n    },\n    requestOptimisticRouteCacheEntry: function() {\n        return requestOptimisticRouteCacheEntry;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    upgradeToPendingSegment: function() {\n        return upgradeToPendingSegment;\n    },\n    upsertSegmentEntry: function() {\n        return upsertSegmentEntry;\n    },\n    waitForSegmentCacheEntry: function() {\n        return waitForSegmentCacheEntry;\n    }\n});\nconst _approutertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-types.js [app-client] (ecmascript)\");\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nconst _fetchserverresponse = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)\");\nconst _scheduler = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/scheduler.js [app-client] (ecmascript)\");\nconst _varypath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/vary-path.js [app-client] (ecmascript)\");\nconst _appbuildid = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _cachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-key.js [app-client] (ecmascript)\");\nconst _routeparams = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/route-params.js [app-client] (ecmascript)\");\nconst _cachemap = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-map.js [app-client] (ecmascript)\");\nconst _segmentvalueencoding = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js [app-client] (ecmascript)\");\nconst _flightdatahelpers = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)\");\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nconst _links = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)\");\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nconst _promisewithresolvers = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/promise-with-resolvers.js [app-client] (ecmascript)\");\nfunction getStaleTimeMs(staleTimeSeconds) {\n    return Math.max(staleTimeSeconds, 30) * 1000;\n}\nvar EntryStatus = /*#__PURE__*/ function(EntryStatus) {\n    EntryStatus[EntryStatus[\"Empty\"] = 0] = \"Empty\";\n    EntryStatus[EntryStatus[\"Pending\"] = 1] = \"Pending\";\n    EntryStatus[EntryStatus[\"Fulfilled\"] = 2] = \"Fulfilled\";\n    EntryStatus[EntryStatus[\"Rejected\"] = 3] = \"Rejected\";\n    return EntryStatus;\n}({});\nconst isOutputExportMode = (\"TURBOPACK compile-time value\", \"development\") === 'production' && (\"TURBOPACK compile-time value\", void 0) === 'export';\nconst MetadataOnlyRequestTree = [\n    '',\n    {},\n    null,\n    'metadata-only'\n];\nlet routeCacheMap = (0, _cachemap.createCacheMap)();\nlet segmentCacheMap = (0, _cachemap.createCacheMap)();\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners = null;\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0;\nfunction getCurrentCacheVersion() {\n    return currentCacheVersion;\n}\nfunction revalidateEntireCache(nextUrl, tree) {\n    // Increment the current cache version. This does not eagerly evict anything\n    // from the cache, but because all the entries are versioned, and we check\n    // the version when reading from the cache, this effectively causes all\n    // entries to be evicted lazily. We do it lazily because in the future,\n    // actions like revalidateTag or refresh will not evict the entire cache,\n    // but rather some subset of the entries.\n    currentCacheVersion++;\n    // Start a cooldown before re-prefetching to allow CDN cache propagation.\n    (0, _scheduler.startRevalidationCooldown)();\n    // Prefetch all the currently visible links again, to re-fill the cache.\n    (0, _links.pingVisibleLinks)(nextUrl, tree);\n    // Similarly, notify all invalidation listeners (i.e. those passed to\n    // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n    // if needed.\n    pingInvalidationListeners(nextUrl, tree);\n}\nfunction attachInvalidationListener(task) {\n    // This function is called whenever a prefetch task reads a cache entry. If\n    // the task has an onInvalidate function associated with it  i.e. the one\n    // optionally passed to router.prefetch(onInvalidate)  then we attach that\n    // listener to the every cache entry that the task reads. Then, if an entry\n    // is invalidated, we call the function.\n    if (task.onInvalidate !== null) {\n        if (invalidationListeners === null) {\n            invalidationListeners = new Set([\n                task\n            ]);\n        } else {\n            invalidationListeners.add(task);\n        }\n    }\n}\nfunction notifyInvalidationListener(task) {\n    const onInvalidate = task.onInvalidate;\n    if (onInvalidate !== null) {\n        // Clear the callback from the task object to guarantee it's not called more\n        // than once.\n        task.onInvalidate = null;\n        // This is a user-space function, so we must wrap in try/catch.\n        try {\n            onInvalidate();\n        } catch (error) {\n            if (typeof reportError === 'function') {\n                reportError(error);\n            } else {\n                console.error(error);\n            }\n        }\n    }\n}\nfunction pingInvalidationListeners(nextUrl, tree) {\n    // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    if (invalidationListeners !== null) {\n        const tasks = invalidationListeners;\n        invalidationListeners = null;\n        for (const task of tasks){\n            if ((0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n                notifyInvalidationListener(task);\n            }\n        }\n    }\n}\nfunction readRouteCacheEntry(now, key) {\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), routeCacheMap, varyPath, isRevalidation);\n}\nfunction readSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction readRevalidatingSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = true;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction waitForSegmentCacheEntry(pendingEntry) {\n    // Because the entry is pending, there's already a in-progress request.\n    // Attach a promise to the entry that will resolve when the server responds.\n    let promiseWithResolvers = pendingEntry.promise;\n    if (promiseWithResolvers === null) {\n        promiseWithResolvers = pendingEntry.promise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n    } else {\n    // There's already a promise we can use\n    }\n    return promiseWithResolvers.promise;\n}\nfunction readOrCreateRouteCacheEntry(now, task, key) {\n    attachInvalidationListener(task);\n    const existingEntry = readRouteCacheEntry(now, key);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const pendingEntry = {\n        canonicalUrl: null,\n        status: 0,\n        blockedTasks: null,\n        tree: null,\n        metadata: null,\n        // This is initialized to true because we don't know yet whether the route\n        // could be intercepted. It's only set to false once we receive a response\n        // from the server.\n        couldBeIntercepted: true,\n        // Similarly, we don't yet know if the route supports PPR.\n        isPPREnabled: false,\n        renderedSearch: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        // Since this is an empty entry, there's no reason to ever evict it. It will\n        // be updated when the data is populated.\n        staleAt: Infinity,\n        version: getCurrentCacheVersion()\n    };\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(routeCacheMap, varyPath, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction requestOptimisticRouteCacheEntry(now, requestedUrl, nextUrl) {\n    // This function is called during a navigation when there was no matching\n    // route tree in the prefetch cache. Before de-opting to a blocking,\n    // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n    // route tree by checking the cache for similar routes.\n    //\n    // Check if there's a route with the same pathname, but with different\n    // search params. We can then base our optimistic route tree on this entry.\n    //\n    // Conceptually, we are simulating what would happen if we did perform a\n    // prefetch the requested URL, under the assumption that the server will\n    // not redirect or rewrite the request in a different manner than the\n    // base route tree. This assumption might not hold, in which case we'll have\n    // to recover when we perform the dynamic navigation request. However, this\n    // is what would happen if a route were dynamically rewritten/redirected\n    // in between the prefetch and the navigation. So the logic needs to exist\n    // to handle this case regardless.\n    // Look for a route with the same pathname, but with an empty search string.\n    // TODO: There's nothing inherently special about the empty search string;\n    // it's chosen somewhat arbitrarily, with the rationale that it's the most\n    // likely one to exist. But we should update this to match _any_ search\n    // string. The plan is to generalize this logic alongside other improvements\n    // related to \"fallback\" cache entries.\n    const requestedSearch = requestedUrl.search;\n    if (requestedSearch === '') {\n        // The caller would have already checked if a route with an empty search\n        // string is in the cache. So we can bail out here.\n        return null;\n    }\n    const urlWithoutSearchParams = new URL(requestedUrl);\n    urlWithoutSearchParams.search = '';\n    const routeWithNoSearchParams = readRouteCacheEntry(now, (0, _cachekey.createCacheKey)(urlWithoutSearchParams.href, nextUrl));\n    if (routeWithNoSearchParams === null || routeWithNoSearchParams.status !== 2) {\n        // Bail out of constructing an optimistic route tree. This will result in\n        // a blocking, unprefetched navigation.\n        return null;\n    }\n    // Now we have a base route tree we can \"patch\" with our optimistic values.\n    // Optimistically assume that redirects for the requested pathname do\n    // not vary on the search string. Therefore, if the base route was\n    // redirected to a different search string, then the optimistic route\n    // should be redirected to the same search string. Otherwise, we use\n    // the requested search string.\n    const canonicalUrlForRouteWithNoSearchParams = new URL(routeWithNoSearchParams.canonicalUrl, requestedUrl.origin);\n    const optimisticCanonicalSearch = canonicalUrlForRouteWithNoSearchParams.search !== '' ? canonicalUrlForRouteWithNoSearchParams.search : requestedSearch;\n    // Similarly, optimistically assume that rewrites for the requested\n    // pathname do not vary on the search string. Therefore, if the base\n    // route was rewritten to a different search string, then the optimistic\n    // route should be rewritten to the same search string. Otherwise, we use\n    // the requested search string.\n    const optimisticRenderedSearch = routeWithNoSearchParams.renderedSearch !== '' ? routeWithNoSearchParams.renderedSearch : requestedSearch;\n    const optimisticUrl = new URL(routeWithNoSearchParams.canonicalUrl, location.origin);\n    optimisticUrl.search = optimisticCanonicalSearch;\n    const optimisticCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(optimisticUrl);\n    const optimisticRouteTree = createOptimisticRouteTree(routeWithNoSearchParams.tree, optimisticRenderedSearch);\n    const optimisticMetadataTree = createOptimisticRouteTree(routeWithNoSearchParams.metadata, optimisticRenderedSearch);\n    // Clone the base route tree, and override the relevant fields with our\n    // optimistic values.\n    const optimisticEntry = {\n        canonicalUrl: optimisticCanonicalUrl,\n        status: 2,\n        // This isn't cloned because it's instance-specific\n        blockedTasks: null,\n        tree: optimisticRouteTree,\n        metadata: optimisticMetadataTree,\n        couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n        isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n        // Override the rendered search with the optimistic value.\n        renderedSearch: optimisticRenderedSearch,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt: routeWithNoSearchParams.staleAt,\n        version: routeWithNoSearchParams.version\n    };\n    // Do not insert this entry into the cache. It only exists so we can\n    // perform the current navigation. Just return it to the caller.\n    return optimisticEntry;\n}\nfunction createOptimisticRouteTree(tree, newRenderedSearch) {\n    // Create a new route tree that identical to the original one except for\n    // the rendered search string, which is contained in the vary path.\n    let clonedSlots = null;\n    const originalSlots = tree.slots;\n    if (originalSlots !== null) {\n        clonedSlots = {};\n        for(const parallelRouteKey in originalSlots){\n            const childTree = originalSlots[parallelRouteKey];\n            clonedSlots[parallelRouteKey] = createOptimisticRouteTree(childTree, newRenderedSearch);\n        }\n    }\n    // We only need to clone the vary path if the route is a page.\n    if (tree.isPage) {\n        return {\n            requestKey: tree.requestKey,\n            segment: tree.segment,\n            varyPath: (0, _varypath.clonePageVaryPathWithNewSearchParams)(tree.varyPath, newRenderedSearch),\n            isPage: true,\n            slots: clonedSlots,\n            isRootLayout: tree.isRootLayout,\n            hasLoadingBoundary: tree.hasLoadingBoundary,\n            hasRuntimePrefetch: tree.hasRuntimePrefetch\n        };\n    }\n    return {\n        requestKey: tree.requestKey,\n        segment: tree.segment,\n        varyPath: tree.varyPath,\n        isPage: false,\n        slots: clonedSlots,\n        isRootLayout: tree.isRootLayout,\n        hasLoadingBoundary: tree.hasLoadingBoundary,\n        hasRuntimePrefetch: tree.hasRuntimePrefetch\n    };\n}\nfunction readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree) {\n    const existingEntry = readSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction readOrCreateRevalidatingSegmentEntry(now, fetchStrategy, route, tree) {\n    // This function is called when we've already confirmed that a particular\n    // segment is cached, but we want to perform another request anyway in case it\n    // returns more complete and/or fresher data than we already have. The logic\n    // for deciding whether to replace the existing entry is handled elsewhere;\n    // this function just handles retrieving a cache entry that we can use to\n    // track the revalidation.\n    //\n    // The reason revalidations are stored in the cache is because we need to be\n    // able to dedupe multiple revalidation requests. The reason they have to be\n    // handled specially is because we shouldn't overwrite a \"normal\" entry if\n    // one exists at the same keypath. So, for each internal cache location, there\n    // is a special \"revalidation\" slot that is used solely for this purpose.\n    //\n    // You can think of it as if all the revalidation entries were stored in a\n    // separate cache map from the canonical entries, and then transfered to the\n    // canonical cache map once the request is complete  this isn't how it's\n    // actually implemented, since it's more efficient to store them in the same\n    // data structure as the normal entries, but that's how it's modeled\n    // conceptually.\n    // TODO: Once we implement Fallback behavior for params, where an entry is\n    // re-keyed based on response information, we'll need to account for the\n    // possibility that the keypath of the previous entry is more generic than\n    // the keypath of the revalidating entry. In other words, the server could\n    // return a less generic entry upon revalidation. For now, though, this isn't\n    // a concern because the keypath is based solely on the prefetch strategy,\n    // not on data contained in the response.\n    const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction overwriteRevalidatingSegmentCacheEntry(fetchStrategy, route, tree) {\n    // This function is called when we've already decided to replace an existing\n    // revalidation entry. Create a new entry and write it into the cache,\n    // overwriting the previous value.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction upsertSegmentEntry(now, varyPath, candidateEntry) {\n    // We have a new entry that has not yet been inserted into the cache. Before\n    // we do so, we need to confirm whether it takes precedence over the existing\n    // entry (if one exists).\n    // TODO: We should not upsert an entry if its key was invalidated in the time\n    // since the request was made. We can do that by passing the \"owner\" entry to\n    // this function and confirming it's the same as `existingEntry`.\n    if ((0, _cachemap.isValueExpired)(now, getCurrentCacheVersion(), candidateEntry)) {\n        // The entry is expired. We cannot upsert it.\n        return null;\n    }\n    const existingEntry = readSegmentCacheEntry(now, varyPath);\n    if (existingEntry !== null) {\n        // Don't replace a more specific segment with a less-specific one. A case where this\n        // might happen is if the existing segment was fetched via\n        // `<Link prefetch={true}>`.\n        if (// than the segment we already have in the cache, so it can't have more content.\n        candidateEntry.fetchStrategy !== existingEntry.fetchStrategy && !canNewFetchStrategyProvideMoreContent(existingEntry.fetchStrategy, candidateEntry.fetchStrategy) || // The existing entry isn't partial, but the new one is.\n        // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n        !existingEntry.isPartial && candidateEntry.isPartial) {\n            // We're going to leave revalidating entry in the cache so that it doesn't\n            // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n            // Rejected and null out the data so it can be garbage collected. We leave\n            // `staleAt` intact to prevent subsequent revalidation attempts only until\n            // the entry expires.\n            const rejectedEntry = candidateEntry;\n            rejectedEntry.status = 3;\n            rejectedEntry.loading = null;\n            rejectedEntry.rsc = null;\n            return null;\n        }\n        // Evict the existing entry from the cache.\n        (0, _cachemap.deleteFromCacheMap)(existingEntry);\n    }\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPath, candidateEntry, isRevalidation);\n    return candidateEntry;\n}\nfunction createDetachedSegmentCacheEntry(staleAt) {\n    const emptyEntry = {\n        status: 0,\n        // Default to assuming the fetch strategy will be PPR. This will be updated\n        // when a fetch is actually initiated.\n        fetchStrategy: _types.FetchStrategy.PPR,\n        rsc: null,\n        loading: null,\n        isPartial: true,\n        promise: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt,\n        version: 0\n    };\n    return emptyEntry;\n}\nfunction upgradeToPendingSegment(emptyEntry, fetchStrategy) {\n    const pendingEntry = emptyEntry;\n    pendingEntry.status = 1;\n    pendingEntry.fetchStrategy = fetchStrategy;\n    if (fetchStrategy === _types.FetchStrategy.Full) {\n        // We can assume the response will contain the full segment data. Set this\n        // to false so we know it's OK to omit this segment from any navigation\n        // requests that may happen while the data is still pending.\n        pendingEntry.isPartial = false;\n    }\n    // Set the version here, since this is right before the request is initiated.\n    // The next time the global cache version is incremented, the entry will\n    // effectively be evicted. This happens before initiating the request, rather\n    // than when receiving the response, because it's guaranteed to happen\n    // before the data is read on the server.\n    pendingEntry.version = getCurrentCacheVersion();\n    return pendingEntry;\n}\nfunction pingBlockedTasks(entry) {\n    const blockedTasks = entry.blockedTasks;\n    if (blockedTasks !== null) {\n        for (const task of blockedTasks){\n            (0, _scheduler.pingPrefetchTask)(task);\n        }\n        entry.blockedTasks = null;\n    }\n}\nfunction fulfillRouteCacheEntry(entry, tree, metadataVaryPath, staleAt, couldBeIntercepted, canonicalUrl, renderedSearch, isPPREnabled) {\n    // The Head is not actually part of the route tree, but other than that, it's\n    // fetched and cached like a segment. Some functions expect a RouteTree\n    // object, so rather than fork the logic in all those places, we use this\n    // \"fake\" one.\n    const metadata = {\n        requestKey: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        segment: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        varyPath: metadataVaryPath,\n        // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n        // either) but for the purposes of how this field is used, it behaves like\n        // one. If this logic ever gets more complex we can change this to an enum.\n        isPage: true,\n        slots: null,\n        isRootLayout: false,\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        hasRuntimePrefetch: false\n    };\n    const fulfilledEntry = entry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.tree = tree;\n    fulfilledEntry.metadata = metadata;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.couldBeIntercepted = couldBeIntercepted;\n    fulfilledEntry.canonicalUrl = canonicalUrl;\n    fulfilledEntry.renderedSearch = renderedSearch;\n    fulfilledEntry.isPPREnabled = isPPREnabled;\n    pingBlockedTasks(entry);\n    return fulfilledEntry;\n}\nfunction fulfillSegmentCacheEntry(segmentCacheEntry, rsc, loading, staleAt, isPartial) {\n    const fulfilledEntry = segmentCacheEntry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.rsc = rsc;\n    fulfilledEntry.loading = loading;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.isPartial = isPartial;\n    // Resolve any listeners that were waiting for this data.\n    if (segmentCacheEntry.promise !== null) {\n        segmentCacheEntry.promise.resolve(fulfilledEntry);\n        // Free the promise for garbage collection.\n        fulfilledEntry.promise = null;\n    }\n    return fulfilledEntry;\n}\nfunction rejectRouteCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    pingBlockedTasks(entry);\n}\nfunction rejectSegmentCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    if (entry.promise !== null) {\n        // NOTE: We don't currently propagate the reason the prefetch was canceled\n        // but we could by accepting a `reason` argument.\n        entry.promise.resolve(null);\n        entry.promise = null;\n    }\n}\nfunction convertRootTreePrefetchToRouteTree(rootTree, renderedPathname, renderedSearch, acc) {\n    // Remove trailing and leading slashes\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    const rootSegment = _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY;\n    return convertTreePrefetchToRouteTree(rootTree.tree, rootSegment, null, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, pathnameParts, index, renderedSearch, acc);\n}\nfunction convertTreePrefetchToRouteTree(prefetch, segment, partialVaryPath, requestKey, pathnameParts, pathnamePartsIndex, renderedSearch, acc) {\n    // Converts the route tree sent by the server into the format used by the\n    // cache. The cached version of the tree includes additional fields, such as a\n    // cache key for each segment. Since this is frequently accessed, we compute\n    // it once instead of on every access. This same cache key is also used to\n    // request the segment from the server.\n    let slots = null;\n    let isPage;\n    let varyPath;\n    const prefetchSlots = prefetch.slots;\n    if (prefetchSlots !== null) {\n        isPage = false;\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        slots = {};\n        for(let parallelRouteKey in prefetchSlots){\n            const childPrefetch = prefetchSlots[parallelRouteKey];\n            const childParamName = childPrefetch.name;\n            const childParamType = childPrefetch.paramType;\n            const childServerSentParamKey = childPrefetch.paramKey;\n            let childDoesAppearInURL;\n            let childSegment;\n            let childPartialVaryPath;\n            if (childParamType !== null) {\n                // This segment is parameterized. Get the param from the pathname.\n                const childParamValue = (0, _routeparams.parseDynamicParamFromURLPart)(childParamType, pathnameParts, pathnamePartsIndex);\n                // Assign a cache key to the segment, based on the param value. In the\n                // pre-Segment Cache implementation, the server computes this and sends\n                // it in the body of the response. In the Segment Cache implementation,\n                // the server sends an empty string and we fill it in here.\n                // TODO: We're intentionally not adding the search param to page\n                // segments here; it's tracked separately and added back during a read.\n                // This would clearer if we waited to construct the segment until it's\n                // read from the cache, since that's effectively what we're\n                // doing anyway.\n                const childParamKey = // cacheComponents is enabled.\n                childServerSentParamKey !== null ? childServerSentParamKey : (0, _routeparams.getCacheKeyForDynamicParam)(childParamValue, '');\n                childPartialVaryPath = (0, _varypath.appendLayoutVaryPath)(partialVaryPath, childParamKey);\n                childSegment = [\n                    childParamName,\n                    childParamKey,\n                    childParamType\n                ];\n                childDoesAppearInURL = true;\n            } else {\n                // This segment does not have a param. Inherit the partial vary path of\n                // the parent.\n                childPartialVaryPath = partialVaryPath;\n                childSegment = childParamName;\n                childDoesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(childParamName);\n            }\n            // Only increment the index if the segment appears in the URL. If it's a\n            // \"virtual\" segment, like a route group, it remains the same.\n            const childPathnamePartsIndex = childDoesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n            const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n            const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n            slots[parallelRouteKey] = convertTreePrefetchToRouteTree(childPrefetch, childSegment, childPartialVaryPath, childRequestKey, pathnameParts, childPathnamePartsIndex, renderedSearch, acc);\n        }\n    } else {\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: prefetch.isRootLayout,\n        // This field is only relevant to dynamic routes. For a PPR/static route,\n        // there's always some partial loading state we can fetch.\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary,\n        hasRuntimePrefetch: prefetch.hasRuntimePrefetch\n    };\n}\nfunction convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc) {\n    return convertFlightRouterStateToRouteTree(flightRouterState, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, null, renderedSearch, acc);\n}\nfunction convertFlightRouterStateToRouteTree(flightRouterState, requestKey, parentPartialVaryPath, renderedSearch, acc) {\n    const originalSegment = flightRouterState[0];\n    let segment;\n    let partialVaryPath;\n    let isPage;\n    let varyPath;\n    if (Array.isArray(originalSegment)) {\n        isPage = false;\n        const paramCacheKey = originalSegment[1];\n        partialVaryPath = (0, _varypath.appendLayoutVaryPath)(parentPartialVaryPath, paramCacheKey);\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        segment = originalSegment;\n    } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        partialVaryPath = parentPartialVaryPath;\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            // The navigation implementation expects the search params to be included\n            // in the segment. However, in the case of a static response, the search\n            // params are omitted. So the client needs to add them back in when reading\n            // from the Segment Cache.\n            //\n            // For consistency, we'll do this for dynamic responses, too.\n            //\n            // TODO: We should move search params out of FlightRouterState and handle\n            // them entirely on the client, similar to our plan for dynamic params.\n            segment = _segment.PAGE_SEGMENT_KEY;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            segment = originalSegment;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    let slots = null;\n    const parallelRoutes = flightRouterState[1];\n    for(let parallelRouteKey in parallelRoutes){\n        const childRouterState = parallelRoutes[parallelRouteKey];\n        const childSegment = childRouterState[0];\n        // TODO: Eventually, the param values will not be included in the response\n        // from the server. We'll instead fill them in on the client by parsing\n        // the URL. This is where we'll do that.\n        const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n        const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n        const childTree = convertFlightRouterStateToRouteTree(childRouterState, childRequestKey, partialVaryPath, renderedSearch, acc);\n        if (slots === null) {\n            slots = {\n                [parallelRouteKey]: childTree\n            };\n        } else {\n            slots[parallelRouteKey] = childTree;\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: flightRouterState[4] === true,\n        hasLoadingBoundary: flightRouterState[5] !== undefined ? flightRouterState[5] : _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        // Non-static tree responses are only used by apps that haven't adopted\n        // Cache Components. So this is always false.\n        hasRuntimePrefetch: false\n    };\n}\nfunction convertRouteTreeToFlightRouterState(routeTree) {\n    const parallelRoutes = {};\n    if (routeTree.slots !== null) {\n        for(const parallelRouteKey in routeTree.slots){\n            parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(routeTree.slots[parallelRouteKey]);\n        }\n    }\n    const flightRouterState = [\n        routeTree.segment,\n        parallelRoutes,\n        null,\n        null,\n        routeTree.isRootLayout\n    ];\n    return flightRouterState;\n}\nasync function fetchRouteOnCacheMiss(entry, task, key) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    const pathname = key.pathname;\n    const search = key.search;\n    const nextUrl = key.nextUrl;\n    const segmentPath = '/_tree';\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        const url = new URL(pathname + search, location.origin);\n        let response;\n        let urlAfterRedirects;\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        else {\n            // \"Server\" mode. We can use request headers instead of the pathname.\n            // TODO: The eventual plan is to get rid of our custom request headers and\n            // encode everything into the URL, using a similar strategy to the\n            // \"output: export\" block above.\n            response = await fetchPrefetchResponse(url, headers);\n            urlAfterRedirects = response !== null && response.redirected ? new URL(response.url) : url;\n        }\n        if (!response || !response.ok || // 204 is a Cache miss. Though theoretically this shouldn't happen when\n        // PPR is enabled, because we always respond to route tree requests, even\n        // if it needs to be blockingly generated on demand.\n        response.status === 204 || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // TODO: The canonical URL is the href without the origin. I think\n        // historically the reason for this is because the initial canonical URL\n        // gets passed as a prop to the top-level React component, which means it\n        // needs to be computed during SSR. If it were to include the origin, it\n        // would need to always be same as location.origin on the client, to prevent\n        // a hydration mismatch. To sidestep this complexity, we omit the origin.\n        //\n        // However, since this is neither a native URL object nor a fully qualified\n        // URL string, we need to be careful about how we use it. To prevent subtle\n        // mistakes, we should create a special type for it, instead of just string.\n        // Or, we should just use a (readonly) URL object instead. The type of the\n        // prop that we pass to seed the initial state does not need to be the same\n        // type as the state itself.\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(urlAfterRedirects);\n        // Check whether the response varies based on the Next-Url header.\n        const varyHeader = response.headers.get('vary');\n        const couldBeIntercepted = varyHeader !== null && varyHeader.includes(_approuterheaders.NEXT_URL);\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route.\n        const routeIsPPREnabled = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '2' || // In output: \"export\" mode, we can't rely on response headers. But if we\n        // receive a well-formed response, we can assume it's a static response,\n        // because all data is static in this mode.\n        isOutputExportMode;\n        if (routeIsPPREnabled) {\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            // Get the params that were used to render the target page. These may\n            // be different from the params in the request URL, if the page\n            // was rewritten.\n            const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n            const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n            // Convert the server-sent data into the RouteTree format used by the\n            // client cache.\n            //\n            // During this traversal, we accumulate additional data into this\n            // \"accumulator\" object.\n            const acc = {\n                metadataVaryPath: null\n            };\n            const routeTree = convertRootTreePrefetchToRouteTree(serverData, renderedPathname, renderedSearch, acc);\n            const metadataVaryPath = acc.metadataVaryPath;\n            if (metadataVaryPath === null) {\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            const staleTimeMs = getStaleTimeMs(serverData.staleTime);\n            fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, Date.now() + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n        } else {\n            // PPR is not enabled for this route. The server responds with a\n            // different format (FlightRouterState) that we need to convert.\n            // TODO: We will unify the responses eventually. I'm keeping the types\n            // separate for now because FlightRouterState has so many\n            // overloaded concerns.\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            writeDynamicTreeResponseIntoCache(Date.now(), task, // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n            _types.FetchStrategy.LoadingBoundary, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled);\n        }\n        if (!couldBeIntercepted) {\n            // This route will never be intercepted. So we can use this entry for all\n            // requests to this route, regardless of the Next-Url header. This works\n            // because when reading the cache we always check for a valid\n            // non-intercepted entry first.\n            // Re-key the entry. The `set` implementation handles removing it from\n            // its previous position in the cache. We don't need to do anything to\n            // update the LRU, because the entry is already in it.\n            // TODO: Treat this as an upsert  should check if an entry already\n            // exists at the new keypath, and if so, whether we should keep that\n            // one instead.\n            const fulfilledVaryPath = (0, _varypath.getFulfilledRouteVaryPath)(pathname, search, nextUrl, couldBeIntercepted);\n            const isRevalidation = false;\n            (0, _cachemap.setInCacheMap)(routeCacheMap, fulfilledVaryPath, entry, isRevalidation);\n        }\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentOnCacheMiss(route, segmentCacheEntry, routeKey, tree) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    //\n    // Segment fetches are non-blocking so we don't need to ping the scheduler\n    // on completion.\n    // Use the canonical URL to request the segment, not the original URL. These\n    // are usually the same, but the canonical URL will be different if the route\n    // tree response was redirected. To avoid an extra waterfall on every segment\n    // request, we pass the redirected URL instead of the original one.\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = routeKey.nextUrl;\n    const requestKey = tree.requestKey;\n    const normalizedRequestKey = requestKey === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY ? // `_index` instead of as an empty string. This should be treated as\n    // an implementation detail and not as a stable part of the protocol.\n    // It just needs to match the equivalent logic that happens when\n    // prerendering the responses. It should not leak outside of Next.js.\n    '/_index' : requestKey;\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    const requestUrl = (\"TURBOPACK compile-time falsy\", 0) ? \"TURBOPACK unreachable\" : url;\n    try {\n        const response = await fetchPrefetchResponse(requestUrl, headers);\n        if (!response || !response.ok || response.status === 204 || // Cache miss\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route. Theoretically this should never happen\n        // because we only issue requests for segments once we've verified that\n        // the route supports PPR.\n        response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) !== '2' && // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // Wrap the original stream in a new stream that never closes. That way the\n        // Flight client doesn't error if there's a hanging promise.\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n            (0, _cachemap.setSizeInCacheMap)(segmentCacheEntry, size);\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n            // The server build does not match the client. Treat as a 404. During\n            // an actual navigation, the router will trigger an MPA navigation.\n            // TODO: Consider moving the build ID to a response header so we can check\n            // it before decoding the response, and so there's one way of checking\n            // across all response types.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        return {\n            value: fulfillSegmentCacheEntry(segmentCacheEntry, serverData.rsc, serverData.loading, // So we use the stale time of the route.\n            route.staleAt, serverData.isPartial),\n            // Return a promise that resolves when the network connection closes, so\n            // the scheduler can track the number of concurrent network connections.\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentPrefetchesUsingDynamicRequest(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries) {\n    const key = task.key;\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = key.nextUrl;\n    if (spawnedEntries.size === 1 && spawnedEntries.has(route.metadata.requestKey)) {\n        // The only thing pending is the head. Instruct the server to\n        // skip over everything else.\n        dynamicRequestTree = MetadataOnlyRequestTree;\n    }\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(dynamicRequestTree)\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    switch(fetchStrategy){\n        case _types.FetchStrategy.Full:\n            {\n                break;\n            }\n        case _types.FetchStrategy.PPRRuntime:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '2';\n                break;\n            }\n        case _types.FetchStrategy.LoadingBoundary:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n                break;\n            }\n        default:\n            {\n                fetchStrategy;\n            }\n    }\n    try {\n        const response = await fetchPrefetchResponse(url, headers);\n        if (!response || !response.ok || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n        if (renderedSearch !== route.renderedSearch) {\n            // The search params that were used to render the target page are\n            // different from the search params in the request URL. This only happens\n            // when there's a dynamic rewrite in between the tree prefetch and the\n            // data prefetch.\n            // TODO: For now, since this is an edge case, we reject the prefetch, but\n            // the proper way to handle this is to evict the stale route tree entry\n            // then fill the cache with the new response.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        let fulfilledEntries = null;\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n            // When processing a dynamic response, we don't know how large each\n            // individual segment is, so approximate by assiging each segment\n            // the average of the total response size.\n            if (fulfilledEntries === null) {\n                // Haven't received enough data yet to know which segments\n                // were included.\n                return;\n            }\n            const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length;\n            for (const entry of fulfilledEntries){\n                (0, _cachemap.setSizeInCacheMap)(entry, averageSize);\n            }\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        const isResponsePartial = fetchStrategy === _types.FetchStrategy.PPRRuntime ? serverData.rp?.[0] === true : false;\n        // Aside from writing the data into the cache, this function also returns\n        // the entries that were fulfilled, so we can streamingly update their sizes\n        // in the LRU as more data comes in.\n        fulfilledEntries = writeDynamicRenderResponseIntoCache(Date.now(), task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries);\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nfunction writeDynamicTreeResponseIntoCache(now, task, fetchStrategy, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled) {\n    // Get the URL that was used to render the target page. This may be different\n    // from the URL in the request URL, if the page was rewritten.\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const normalizedFlightDataResult = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (// MPA navigation.\n    typeof normalizedFlightDataResult === 'string' || normalizedFlightDataResult.length !== 1) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightData = normalizedFlightDataResult[0];\n    if (!flightData.isRootRender) {\n        // Unexpected response format.\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightRouterState = flightData.tree;\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    // If the response contains dynamic holes, then we must conservatively assume\n    // that any individual segment might contain dynamic holes, and also the\n    // head. If it did not contain dynamic holes, then we can assume every segment\n    // and the head is completely static.\n    const isResponsePartial = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '1';\n    // Convert the server-sent data into the RouteTree format used by the\n    // client cache.\n    //\n    // During this traversal, we accumulate additional data into this\n    // \"accumulator\" object.\n    const acc = {\n        metadataVaryPath: null\n    };\n    const routeTree = convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc);\n    const metadataVaryPath = acc.metadataVaryPath;\n    if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const fulfilledEntry = fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, now + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n    // If the server sent segment data as part of the response, we should write\n    // it into the cache to prevent a second, redundant prefetch request.\n    //\n    // TODO: When `clientSegmentCache` is enabled, the server does not include\n    // segment data when responding to a route tree prefetch request. However,\n    // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n    // the page is fully static), the normal check is bypassed and the server\n    // responds with the full page. This is a temporary situation until we can\n    // remove the \"client-only\" option. Then, we can delete this function call.\n    writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, fulfilledEntry, null);\n}\nfunction rejectSegmentEntriesIfStillPending(entries, staleAt) {\n    const fulfilledEntries = [];\n    for (const entry of entries.values()){\n        if (entry.status === 1) {\n            rejectSegmentCacheEntry(entry, staleAt);\n        } else if (entry.status === 2) {\n            fulfilledEntries.push(entry);\n        }\n    }\n    return fulfilledEntries;\n}\nfunction writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries) {\n    if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        }\n        return null;\n    }\n    const flightDatas = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (typeof flightDatas === 'string') {\n        // This means navigating to this route will result in an MPA navigation.\n        // TODO: We should cache this, too, so that the MPA navigation is immediate.\n        return null;\n    }\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    const staleAt = now + staleTimeMs;\n    for (const flightData of flightDatas){\n        const seedData = flightData.seedData;\n        if (seedData !== null) {\n            // The data sent by the server represents only a subtree of the app. We\n            // need to find the part of the task tree that matches the response.\n            //\n            // segmentPath represents the parent path of subtree. It's a repeating\n            // pattern of parallel route key and segment:\n            //\n            //   [string, Segment, string, Segment, string, Segment, ...]\n            const segmentPath = flightData.segmentPath;\n            let tree = route.tree;\n            for(let i = 0; i < segmentPath.length; i += 2){\n                const parallelRouteKey = segmentPath[i];\n                if (tree?.slots?.[parallelRouteKey] !== undefined) {\n                    tree = tree.slots[parallelRouteKey];\n                } else {\n                    if (spawnedEntries !== null) {\n                        rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n                    }\n                    return null;\n                }\n            }\n            writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, spawnedEntries);\n        }\n        const head = flightData.head;\n        if (head !== null) {\n            fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, head, null, flightData.isHeadPartial, staleAt, route.metadata, spawnedEntries);\n        }\n    }\n    // Any entry that's still pending was intentionally not rendered by the\n    // server, because it was inside the loading boundary. Mark them as rejected\n    // so we know not to fetch them again.\n    // TODO: If PPR is enabled on some routes but not others, then it's possible\n    // that a different page is able to do a per-segment prefetch of one of the\n    // segments we're marking as rejected here. We should mark on the segment\n    // somehow that the reason for the rejection is because of a non-PPR prefetch.\n    // That way a per-segment prefetch knows to disregard the rejection.\n    if (spawnedEntries !== null) {\n        const fulfilledEntries = rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        return fulfilledEntries;\n    }\n    return null;\n}\nfunction writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, entriesOwnedByCurrentTask) {\n    // This function is used to write the result of a runtime server request\n    // (CacheNodeSeedData) into the prefetch cache.\n    const rsc = seedData[0];\n    const loading = seedData[2];\n    const isPartial = rsc === null || isResponsePartial;\n    fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask);\n    // Recursively write the child data into the cache.\n    const slots = tree.slots;\n    if (slots !== null) {\n        const seedDataChildren = seedData[1];\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childSeedData = seedDataChildren[parallelRouteKey];\n            if (childSeedData !== null && childSeedData !== undefined) {\n                writeSeedDataIntoCache(now, task, fetchStrategy, route, childTree, staleAt, childSeedData, isResponsePartial, entriesOwnedByCurrentTask);\n            }\n        }\n    }\n}\nfunction fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask) {\n    // We should only write into cache entries that are owned by us. Or create\n    // a new one and write into that. We must never write over an entry that was\n    // created by a different task, because that causes data races.\n    const ownedEntry = entriesOwnedByCurrentTask !== null ? entriesOwnedByCurrentTask.get(tree.requestKey) : undefined;\n    if (ownedEntry !== undefined) {\n        fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial);\n    } else {\n        // There's no matching entry. Attempt to create a new one.\n        const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree);\n        if (possiblyNewEntry.status === 0) {\n            // Confirmed this is a new entry. We can fulfill it.\n            const newEntry = possiblyNewEntry;\n            fulfillSegmentCacheEntry(upgradeToPendingSegment(newEntry, fetchStrategy), rsc, loading, staleAt, isPartial);\n        } else {\n            // There was already an entry in the cache. But we may be able to\n            // replace it with the new one from the server.\n            const newEntry = fulfillSegmentCacheEntry(upgradeToPendingSegment(createDetachedSegmentCacheEntry(staleAt), fetchStrategy), rsc, loading, staleAt, isPartial);\n            upsertSegmentEntry(now, (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree), newEntry);\n        }\n    }\n}\nasync function fetchPrefetchResponse(url, headers) {\n    const fetchPriority = 'low';\n    // When issuing a prefetch request, don't immediately decode the response; we\n    // use the lower level `createFromResponse` API instead because we need to do\n    // some extra processing of the response stream. See\n    // `createPrefetchResponseStream` for more details.\n    const shouldImmediatelyDecode = false;\n    const response = await (0, _fetchserverresponse.createFetch)(url, headers, fetchPriority, shouldImmediatelyDecode);\n    if (!response.ok) {\n        return null;\n    }\n    // Check the content type\n    if (\"TURBOPACK compile-time falsy\", 0) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n    } else {\n        const contentType = response.headers.get('content-type');\n        const isFlightResponse = contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (!isFlightResponse) {\n            return null;\n        }\n    }\n    return response;\n}\nfunction createPrefetchResponseStream(originalFlightStream, onStreamClose, onResponseSizeUpdate) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    //\n    // While processing the original stream, we also incrementally update the size\n    // of the cache entry in the LRU.\n    let totalByteLength = 0;\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    // Incrementally update the size of the cache entry in the LRU.\n                    // NOTE: Since prefetch responses are delivered in a single chunk,\n                    // it's not really necessary to do this streamingly, but I'm doing it\n                    // anyway in case this changes in the future.\n                    totalByteLength += value.byteLength;\n                    onResponseSizeUpdate(totalByteLength);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream. We do notify the caller, though.\n                onStreamClose();\n                return;\n            }\n        }\n    });\n}\nfunction addSegmentPathToUrlInOutputExportMode(url, segmentPath) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    return url;\n}\nfunction canNewFetchStrategyProvideMoreContent(currentStrategy, newStrategy) {\n    return currentStrategy < newStrategy;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=cache.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/navigation.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    convertServerPatchToFullTree: null,\n    navigate: null,\n    navigateToSeededRoute: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    convertServerPatchToFullTree: function() {\n        return convertServerPatchToFullTree;\n    },\n    navigate: function() {\n        return navigate;\n    },\n    navigateToSeededRoute: function() {\n        return navigateToSeededRoute;\n    }\n});\nconst _fetchserverresponse = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _cache = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache.js [app-client] (ecmascript)\");\nconst _cachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-key.js [app-client] (ecmascript)\");\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nfunction navigate(url, currentUrl, currentCacheNode, currentFlightRouterState, nextUrl, freshnessPolicy, shouldScroll, accumulation) {\n    const now = Date.now();\n    const href = url.href;\n    // We special case navigations to the exact same URL as the current location.\n    // It's a common UI pattern for apps to refresh when you click a link to the\n    // current page. So when this happens, we refresh the dynamic data in the page\n    // segments.\n    //\n    // Note that this does not apply if the any part of the hash or search query\n    // has changed. This might feel a bit weird but it makes more sense when you\n    // consider that the way to trigger this behavior is to click the same link\n    // multiple times.\n    //\n    // TODO: We should probably refresh the *entire* route when this case occurs,\n    // not just the page segments. Essentially treating it the same as a refresh()\n    // triggered by an action, which is the more explicit way of modeling the UI\n    // pattern described above.\n    //\n    // Also note that this only refreshes the dynamic data, not static/ cached\n    // data. If the page segment is fully static and prefetched, the request is\n    // skipped. (This is also how refresh() works.)\n    const isSamePageNavigation = href === currentUrl.href;\n    const cacheKey = (0, _cachekey.createCacheKey)(href, nextUrl);\n    const route = (0, _cache.readRouteCacheEntry)(now, cacheKey);\n    if (route !== null && route.status === _cache.EntryStatus.Fulfilled) {\n        // We have a matching prefetch.\n        const snapshot = readRenderSnapshotFromCache(now, route, route.tree);\n        const prefetchFlightRouterState = snapshot.flightRouterState;\n        const prefetchSeedData = snapshot.seedData;\n        const headSnapshot = readHeadSnapshotFromCache(now, route);\n        const prefetchHead = headSnapshot.rsc;\n        const isPrefetchHeadPartial = headSnapshot.isPartial;\n        // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n        // because hash entries do not vary by hash fragment. However, the one\n        // we set in the router state *does* include the hash, and it's used to\n        // sync with the actual browser location. To make this less of a refactor\n        // hazard, we should always track the hash separately from the rest of\n        // the URL.\n        const newCanonicalUrl = route.canonicalUrl + url.hash;\n        const renderedSearch = route.renderedSearch;\n        return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, renderedSearch, freshnessPolicy, shouldScroll);\n    }\n    // There was no matching route tree in the cache. Let's see if we can\n    // construct an \"optimistic\" route tree.\n    //\n    // Do not construct an optimistic route tree if there was a cache hit, but\n    // the entry has a rejected status, since it may have been rejected due to a\n    // rewrite or redirect based on the search params.\n    //\n    // TODO: There are multiple reasons a prefetch might be rejected; we should\n    // track them explicitly and choose what to do here based on that.\n    if (route === null || route.status !== _cache.EntryStatus.Rejected) {\n        const optimisticRoute = (0, _cache.requestOptimisticRouteCacheEntry)(now, url, nextUrl);\n        if (optimisticRoute !== null) {\n            // We have an optimistic route tree. Proceed with the normal flow.\n            const snapshot = readRenderSnapshotFromCache(now, optimisticRoute, optimisticRoute.tree);\n            const prefetchFlightRouterState = snapshot.flightRouterState;\n            const prefetchSeedData = snapshot.seedData;\n            const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute);\n            const prefetchHead = headSnapshot.rsc;\n            const isPrefetchHeadPartial = headSnapshot.isPartial;\n            const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash;\n            const newRenderedSearch = optimisticRoute.renderedSearch;\n            return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, newRenderedSearch, freshnessPolicy, shouldScroll);\n        }\n    }\n    // There's no matching prefetch for this route in the cache.\n    let collectedDebugInfo = accumulation.collectedDebugInfo ?? [];\n    if (accumulation.collectedDebugInfo === undefined) {\n        collectedDebugInfo = accumulation.collectedDebugInfo = [];\n    }\n    return {\n        tag: _types.NavigationResultTag.Async,\n        data: navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, shouldScroll, collectedDebugInfo)\n    };\n}\nfunction navigateToSeededRoute(now, url, canonicalUrl, navigationSeed, currentUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll) {\n    // A version of navigate() that accepts the target route tree as an argument\n    // rather than reading it from the prefetch cache.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const isSamePageNavigation = url.href === currentUrl.href;\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, navigationSeed.tree, freshnessPolicy, navigationSeed.data, navigationSeed.head, null, null, false, isSamePageNavigation, accumulation);\n    if (task !== null) {\n        (0, _pprnavigations.spawnDynamicRequests)(task, url, nextUrl, freshnessPolicy, accumulation);\n        return navigationTaskToResult(task, canonicalUrl, navigationSeed.renderedSearch, accumulation.scrollableSegments, shouldScroll, url.hash);\n    }\n    // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n    return {\n        tag: _types.NavigationResultTag.MPA,\n        data: canonicalUrl\n    };\n}\nfunction navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, canonicalUrl, renderedSearch, freshnessPolicy, shouldScroll) {\n    // Recursively construct a prefetch tree by reading from the Segment Cache. To\n    // maintain compatibility, we output the same data structures as the old\n    // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n    // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n    // read from the Segment Cache directly. It's only structured this way for now\n    // so we can share code with the old prefetching implementation.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const seedData = null;\n    const seedHead = null;\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, freshnessPolicy, seedData, seedHead, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, accumulation);\n    if (task !== null) {\n        (0, _pprnavigations.spawnDynamicRequests)(task, url, nextUrl, freshnessPolicy, accumulation);\n        return navigationTaskToResult(task, canonicalUrl, renderedSearch, accumulation.scrollableSegments, shouldScroll, url.hash);\n    }\n    // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n    return {\n        tag: _types.NavigationResultTag.MPA,\n        data: canonicalUrl\n    };\n}\nfunction navigationTaskToResult(task, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash) {\n    return {\n        tag: _types.NavigationResultTag.Success,\n        data: {\n            flightRouterState: task.route,\n            cacheNode: task.node,\n            canonicalUrl,\n            renderedSearch,\n            scrollableSegments,\n            shouldScroll,\n            hash\n        }\n    };\n}\nfunction readRenderSnapshotFromCache(now, route, tree) {\n    let childRouterStates = {};\n    let childSeedDatas = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childResult = readRenderSnapshotFromCache(now, route, childTree);\n            childRouterStates[parallelRouteKey] = childResult.flightRouterState;\n            childSeedDatas[parallelRouteKey] = childResult.seedData;\n        }\n    }\n    let rsc = null;\n    let loading = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, tree.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    // Happy path: a cache hit\n                    rsc = segmentEntry.rsc;\n                    loading = segmentEntry.loading;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    // We haven't received data for this segment yet, but there's already\n                    // an in-progress request. Since it's extremely likely to arrive\n                    // before the dynamic data response, we might as well use it.\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    loading = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.loading : null);\n                    // Because the request is still pending, we typically don't know yet\n                    // whether the response will be partial. We shouldn't skip this segment\n                    // during the dynamic navigation request. Otherwise, we might need to\n                    // do yet another request to fill in the remaining data, creating\n                    // a waterfall.\n                    //\n                    // The one exception is if this segment is being fetched with via\n                    // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n                    // we can assume the response will be full. This field is set to `false`\n                    // for such segments.\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    // The navigation implementation expects the search params to be\n    // included in the segment. However, the Segment Cache tracks search\n    // params separately from the rest of the segment key. So we need to\n    // add them back here.\n    //\n    // See corresponding comment in convertFlightRouterStateToTree.\n    //\n    // TODO: What we should do instead is update the navigation diffing\n    // logic to compare search params explicitly. This is a temporary\n    // solution until more of the Segment Cache implementation has settled.\n    const segment = (0, _segment.addSearchParamsIfPageSegment)(tree.segment, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    // We don't need this information in a render snapshot, so this can just be a placeholder.\n    const hasRuntimePrefetch = false;\n    return {\n        flightRouterState: [\n            segment,\n            childRouterStates,\n            null,\n            null,\n            tree.isRootLayout\n        ],\n        seedData: [\n            rsc,\n            childSeedDatas,\n            loading,\n            isPartial,\n            hasRuntimePrefetch\n        ]\n    };\n}\nfunction readHeadSnapshotFromCache(now, route) {\n    // Same as readRenderSnapshotFromCache, but for the head\n    let rsc = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, route.metadata.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    rsc = segmentEntry.rsc;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    return {\n        rsc,\n        isPartial\n    };\n}\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute = [\n    '',\n    {},\n    null,\n    'refetch'\n];\nasync function navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, shouldScroll, collectedDebugInfo) {\n    // Runs when a navigation happens but there's no cached prefetch we can use.\n    // Don't bother to wait for a prefetch response; go straight to a full\n    // navigation that contains both static and dynamic data in a single stream.\n    // (This is unlike the old navigation implementation, which instead blocks\n    // the dynamic request until a prefetch request is received.)\n    //\n    // To avoid duplication of logic, we're going to pretend that the tree\n    // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n    // use the same server response to write the actual data into the CacheNode\n    // tree. So it's the same flow as the \"happy path\" (prefetch, then\n    // navigation), except we use a single server response for both stages.\n    let dynamicRequestTree;\n    switch(freshnessPolicy){\n        case _pprnavigations.FreshnessPolicy.Default:\n        case _pprnavigations.FreshnessPolicy.HistoryTraversal:\n            dynamicRequestTree = currentFlightRouterState;\n            break;\n        case _pprnavigations.FreshnessPolicy.Hydration:\n        case _pprnavigations.FreshnessPolicy.RefreshAll:\n        case _pprnavigations.FreshnessPolicy.HMRRefresh:\n            dynamicRequestTree = DynamicRequestTreeForEntireRoute;\n            break;\n        default:\n            freshnessPolicy;\n            dynamicRequestTree = currentFlightRouterState;\n            break;\n    }\n    const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(url, {\n        flightRouterState: dynamicRequestTree,\n        nextUrl\n    });\n    const result = await promiseForDynamicServerResponse;\n    if (typeof result === 'string') {\n        // This is an MPA navigation.\n        const newUrl = result;\n        return {\n            tag: _types.NavigationResultTag.MPA,\n            data: newUrl\n        };\n    }\n    const { flightData, canonicalUrl, renderedSearch, debugInfo: debugInfoFromResponse } = result;\n    if (debugInfoFromResponse !== null) {\n        collectedDebugInfo.push(...debugInfoFromResponse);\n    }\n    // Since the response format of dynamic requests and prefetches is slightly\n    // different, we'll need to massage the data a bit. Create FlightRouterState\n    // tree that simulates what we'd receive as the result of a prefetch.\n    const navigationSeed = convertServerPatchToFullTree(currentFlightRouterState, flightData, renderedSearch);\n    return navigateToSeededRoute(now, url, (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl), navigationSeed, currentUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll);\n}\nfunction convertServerPatchToFullTree(currentTree, flightData, renderedSearch) {\n    // During a client navigation or prefetch, the server sends back only a patch\n    // for the parts of the tree that have changed.\n    //\n    // This applies the patch to the base tree to create a full representation of\n    // the resulting tree.\n    //\n    // The return type includes a full FlightRouterState tree and a full\n    // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n    // eventually be unified, but there's still lots of existing code that\n    // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n    //\n    // TODO: This similar to what apply-router-state-patch-to-tree does. It\n    // will eventually fully replace it. We should get rid of all the remaining\n    // places where we iterate over the server patch format. This should also\n    // eventually replace normalizeFlightData.\n    let baseTree = currentTree;\n    let baseData = null;\n    let head = null;\n    for (const { segmentPath, tree: treePatch, seedData: dataPatch, head: headPatch } of flightData){\n        const result = convertServerPatchToFullTreeImpl(baseTree, baseData, treePatch, dataPatch, segmentPath, 0);\n        baseTree = result.tree;\n        baseData = result.data;\n        // This is the same for all patches per response, so just pick an\n        // arbitrary one\n        head = headPatch;\n    }\n    return {\n        tree: baseTree,\n        data: baseData,\n        renderedSearch,\n        head\n    };\n}\nfunction convertServerPatchToFullTreeImpl(baseRouterState, baseData, treePatch, dataPatch, segmentPath, index) {\n    if (index === segmentPath.length) {\n        // We reached the part of the tree that we need to patch.\n        return {\n            tree: treePatch,\n            data: dataPatch\n        };\n    }\n    // segmentPath represents the parent path of subtree. It's a repeating\n    // pattern of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // This path tells us which part of the base tree to apply the tree patch.\n    //\n    // NOTE: We receive the FlightRouterState patch in the same request as the\n    // seed data patch. Therefore we don't need to worry about diffing the segment\n    // values; we can assume the server sent us a correct result.\n    const updatedParallelRouteKey = segmentPath[index];\n    // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n    const baseTreeChildren = baseRouterState[1];\n    const baseSeedDataChildren = baseData !== null ? baseData[1] : null;\n    const newTreeChildren = {};\n    const newSeedDataChildren = {};\n    for(const parallelRouteKey in baseTreeChildren){\n        const childBaseRouterState = baseTreeChildren[parallelRouteKey];\n        const childBaseSeedData = baseSeedDataChildren !== null ? baseSeedDataChildren[parallelRouteKey] ?? null : null;\n        if (parallelRouteKey === updatedParallelRouteKey) {\n            const result = convertServerPatchToFullTreeImpl(childBaseRouterState, childBaseSeedData, treePatch, dataPatch, segmentPath, // the end of the segment path.\n            index + 2);\n            newTreeChildren[parallelRouteKey] = result.tree;\n            newSeedDataChildren[parallelRouteKey] = result.data;\n        } else {\n            // This child is not being patched. Copy it over as-is.\n            newTreeChildren[parallelRouteKey] = childBaseRouterState;\n            newSeedDataChildren[parallelRouteKey] = childBaseSeedData;\n        }\n    }\n    let clonedTree;\n    let clonedSeedData;\n    // Clone all the fields except the children.\n    // Clone the FlightRouterState tree. Based on equivalent logic in\n    // apply-router-state-patch-to-tree, but should confirm whether we need to\n    // copy all of these fields. Not sure the server ever sends, e.g. the\n    // refetch marker.\n    clonedTree = [\n        baseRouterState[0],\n        newTreeChildren\n    ];\n    if (2 in baseRouterState) {\n        clonedTree[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clonedTree[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clonedTree[4] = baseRouterState[4];\n    }\n    // Clone the CacheNodeSeedData tree.\n    const isEmptySeedDataPartial = true;\n    clonedSeedData = [\n        null,\n        newSeedDataChildren,\n        null,\n        isEmptySeedDataPartial,\n        false\n    ];\n    return {\n        tree: clonedTree,\n        data: clonedSeedData\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DYNAMIC_STALETIME_MS: null,\n    STATIC_STALETIME_MS: null,\n    generateSegmentsFromPatch: null,\n    handleExternalUrl: null,\n    handleNavigationResult: null,\n    navigateReducer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    generateSegmentsFromPatch: function() {\n        return generateSegmentsFromPatch;\n    },\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    handleNavigationResult: function() {\n        return handleNavigationResult;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _handlemutable = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)\");\nconst _navigation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/navigation.js [app-client] (ecmascript)\");\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nconst _cache = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nconst DYNAMIC_STALETIME_MS = Number((\"TURBOPACK compile-time value\", \"0\")) * 1000;\nconst STATIC_STALETIME_MS = (0, _cache.getStaleTimeMs)(Number((\"TURBOPACK compile-time value\", \"300\")));\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _types.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _types.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.renderedSearch = result.data.renderedSearch;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n                // some confusing and subtle logic in `handleMutable` that decides what\n                // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n                // not convinced it's totally coherent but the tests assert on this\n                // particular behavior so I've ported the logic as-is from the previous\n                // router implementation, for now.\n                mutable.scrollableSegments = result.data.scrollableSegments ?? undefined;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _types.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    const result = (0, _navigation.navigate)(url, currentUrl, state.cache, state.tree, state.nextUrl, _pprnavigations.FreshnessPolicy.Default, shouldScroll, mutable);\n    return handleNavigationResult(url, state, mutable, pendingPush, result);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", {\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n});\nconst _interceptionroutes = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-client] (ecmascript)\");\nfunction hasInterceptionRouteInCurrentTree([segment, parallelRoutes]) {\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === 'di(..)(..)' || segment[2] === 'ci(..)(..)' || segment[2] === 'di(.)' || segment[2] === 'ci(.)' || segment[2] === 'di(..)' || segment[2] === 'ci(..)' || segment[2] === 'di(...)' || segment[2] === 'ci(...)')) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    refreshDynamicData: null,\n    refreshReducer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    refreshDynamicData: function() {\n        return refreshDynamicData;\n    },\n    refreshReducer: function() {\n        return refreshReducer;\n    }\n});\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nconst _navigation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/navigation.js [app-client] (ecmascript)\");\nconst _cache = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache.js [app-client] (ecmascript)\");\nconst _hasinterceptionrouteincurrenttree = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nfunction refreshReducer(state) {\n    // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n    // only client-side refreshes will have this behavior; the server-side\n    // `refresh` should send new data without purging the prefetch cache.\n    const currentNextUrl = state.nextUrl;\n    const currentRouterState = state.tree;\n    (0, _cache.revalidateEntireCache)(currentNextUrl, currentRouterState);\n    return refreshDynamicData(state, _pprnavigations.FreshnessPolicy.RefreshAll);\n}\nfunction refreshDynamicData(state, freshnessPolicy) {\n    const currentNextUrl = state.nextUrl;\n    // We always send the last next-url, not the current when performing a dynamic\n    // request. This is because we update the next-url after a navigation, but we\n    // want the same interception route to be matched that used the last next-url.\n    const nextUrlForRefresh = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.previousNextUrl || currentNextUrl : null;\n    // A refresh is modeled as a navigation to the current URL, but where any\n    // existing dynamic data (including in shared layouts) is re-fetched.\n    const currentCanonicalUrl = state.canonicalUrl;\n    const currentUrl = new URL(currentCanonicalUrl, location.origin);\n    const currentFlightRouterState = state.tree;\n    const shouldScroll = true;\n    const navigationSeed = {\n        tree: state.tree,\n        renderedSearch: state.renderedSearch,\n        data: null,\n        head: null\n    };\n    const now = Date.now();\n    const result = (0, _navigation.navigateToSeededRoute)(now, currentUrl, currentCanonicalUrl, navigationSeed, currentUrl, state.cache, currentFlightRouterState, freshnessPolicy, nextUrlForRefresh, shouldScroll);\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    return (0, _navigatereducer.handleNavigationResult)(currentUrl, state, mutable, false, result);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"serverPatchReducer\", {\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n});\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nconst _navigation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/navigation.js [app-client] (ecmascript)\");\nconst _refreshreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nfunction serverPatchReducer(state, action) {\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // A \"retry\" is a navigation that happens due to a route mismatch. It's\n    // similar to a refresh, because we will omit any existing dynamic data on\n    // the page. But we seed the retry navigation with the exact tree that the\n    // server just responded with.\n    const retryMpa = action.mpa;\n    const retryUrl = new URL(action.url, location.origin);\n    const retrySeed = action.seed;\n    if (retryMpa || retrySeed === null) {\n        // If the server did not send back data during the mismatch, fall back to\n        // an MPA navigation.\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, retryUrl.href, false);\n    }\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    if (action.previousTree !== state.tree) {\n        // There was another, more recent navigation since the once that\n        // mismatched. We can abort the retry, but we still need to refresh the\n        // page to evict any stale dynamic data.\n        return (0, _refreshreducer.refreshReducer)(state);\n    }\n    // There have been no new navigations since the mismatched one. Refresh,\n    // using the tree we just received from the server.\n    const retryCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(retryUrl);\n    const retryNextUrl = action.nextUrl;\n    // A retry should not create a new history entry.\n    const pendingPush = false;\n    const shouldScroll = true;\n    const now = Date.now();\n    const result = (0, _navigation.navigateToSeededRoute)(now, retryUrl, retryCanonicalUrl, retrySeed, currentUrl, state.cache, state.tree, _pprnavigations.FreshnessPolicy.RefreshAll, retryNextUrl, shouldScroll);\n    return (0, _navigatereducer.handleNavigationResult)(retryUrl, state, mutable, pendingPush, result);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"restoreReducer\", {\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n});\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _computechangedpath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nfunction restoreReducer(state, action) {\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    let treeToRestore;\n    let renderedSearch;\n    const historyState = action.historyState;\n    if (historyState) {\n        treeToRestore = historyState.tree;\n        renderedSearch = historyState.renderedSearch;\n    } else {\n        treeToRestore = state.tree;\n        renderedSearch = state.renderedSearch;\n    }\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    const restoredUrl = action.url;\n    const restoredCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(restoredUrl);\n    const restoredNextUrl = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore) ?? restoredUrl.pathname;\n    const now = Date.now();\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, state.cache, state.tree, treeToRestore, _pprnavigations.FreshnessPolicy.HistoryTraversal, null, null, null, null, false, false, accumulation);\n    if (task === null) {\n        const mutable = {\n            preserveCustomHistoryState: true\n        };\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, restoredCanonicalUrl, false);\n    }\n    (0, _pprnavigations.spawnDynamicRequests)(task, restoredUrl, restoredNextUrl, _pprnavigations.FreshnessPolicy.HistoryTraversal, accumulation);\n    return {\n        // Set canonical url\n        canonicalUrl: restoredCanonicalUrl,\n        renderedSearch,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: task.node,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: restoredNextUrl,\n        // TODO: We need to restore previousNextUrl, too, which represents the\n        // Next-Url that was used to fetch the data. Anywhere we fetch using the\n        // canonical URL, there should be a corresponding Next-Url.\n        previousNextUrl: null,\n        debugInfo: null\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hmrRefreshReducer\", {\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n});\nconst _refreshreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nfunction hmrRefreshReducer(state) {\n    return (0, _refreshreducer.refreshDynamicData)(state, _pprnavigations.FreshnessPolicy.HMRRefresh);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    UnrecognizedActionError: null,\n    unstable_isUnrecognizedActionError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    UnrecognizedActionError: function() {\n        return UnrecognizedActionError;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return unstable_isUnrecognizedActionError;\n    }\n});\nclass UnrecognizedActionError extends Error {\n    constructor(...args){\n        super(...args);\n        this.name = 'UnrecognizedActionError';\n    }\n}\nfunction unstable_isUnrecognizedActionError(error) {\n    return !!(error && typeof error === 'object' && error instanceof UnrecognizedActionError);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unrecognized-action-error.js.map\n}),\n\"[project]/node_modules/next/dist/client/assign-location.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"assignLocation\", {\n    enumerable: true,\n    get: function() {\n        return assignLocation;\n    }\n});\nconst _addbasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)\");\nfunction assignLocation(location, url) {\n    if (location.startsWith('.')) {\n        const urlBase = url.origin + url.pathname;\n        return new URL(// new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n        // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n        (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location);\n    }\n    return new URL((0, _addbasepath.addBasePath)(location), url.href);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=assign-location.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getRedirectError: null,\n    getRedirectStatusCodeFromError: null,\n    getRedirectTypeFromError: null,\n    getURLFromRedirectError: null,\n    permanentRedirect: null,\n    redirect: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRedirectError: function() {\n        return getRedirectError;\n    },\n    getRedirectStatusCodeFromError: function() {\n        return getRedirectStatusCodeFromError;\n    },\n    getRedirectTypeFromError: function() {\n        return getRedirectTypeFromError;\n    },\n    getURLFromRedirectError: function() {\n        return getURLFromRedirectError;\n    },\n    permanentRedirect: function() {\n        return permanentRedirect;\n    },\n    redirect: function() {\n        return redirect;\n    }\n});\nconst _redirectstatuscode = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-client] (ecmascript)\");\nconst _redirecterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\");\nconst actionAsyncStorage = typeof window === 'undefined' ? __turbopack_context__.r(\"[project]/node_modules/next/dist/server/app-render/action-async-storage.external.js [app-client] (ecmascript)\").actionAsyncStorage : undefined;\nfunction getRedirectError(url, type, statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect) {\n    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = `${_redirecterror.REDIRECT_ERROR_CODE};${type};${url};${statusCode};`;\n    return error;\n}\nfunction redirect(/** The URL to redirect to */ url, type) {\n    type ??= actionAsyncStorage?.getStore()?.isAction ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;\n    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);\n}\nfunction permanentRedirect(/** The URL to redirect to */ url, type = _redirecterror.RedirectType.replace) {\n    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);\n}\nfunction getURLFromRedirectError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) return null;\n    // Slices off the beginning of the digest that contains the code and the\n    // separating ';'.\n    return error.digest.split(';').slice(2, -2).join(';');\n}\nfunction getRedirectTypeFromError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) {\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\n            value: \"E260\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return error.digest.split(';', 2)[1];\n}\nfunction getRedirectStatusCodeFromError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) {\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\n            value: \"E260\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return Number(error.digest.split(';').at(-2));\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=redirect.js.map\n}),\n\"[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasBasePath\", {\n    enumerable: true,\n    get: function() {\n        return hasBasePath;\n    }\n});\nconst _pathhasprefix = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-client] (ecmascript)\");\nconst basePath = (\"TURBOPACK compile-time value\", \"\") || '';\nfunction hasBasePath(path) {\n    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-base-path.js.map\n}),\n\"[project]/node_modules/next/dist/client/remove-base-path.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"removeBasePath\", {\n    enumerable: true,\n    get: function() {\n        return removeBasePath;\n    }\n});\nconst _hasbasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)\");\nconst basePath = (\"TURBOPACK compile-time value\", \"\") || '';\nfunction removeBasePath(path) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    // Can't trim the basePath if it has zero length!\n    if (basePath.length === 0) return path;\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = `/${path}`;\n    return path;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-base-path.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"serverActionReducer\", {\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n});\nconst _appcallserver = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)\");\nconst _appfindsourcemapurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)\");\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nconst _unrecognizedactionerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-client] (ecmascript)\");\nconst _client = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)\");\nconst _assignlocation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/assign-location.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nconst _hasinterceptionrouteincurrenttree = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)\");\nconst _flightdatahelpers = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)\");\nconst _redirect = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)\");\nconst _redirecterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\");\nconst _removebasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/remove-base-path.js [app-client] (ecmascript)\");\nconst _hasbasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)\");\nconst _serverreferenceinfo = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-client] (ecmascript)\");\nconst _cache = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache.js [app-client] (ecmascript)\");\nconst _deploymentid = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/deployment-id.js [app-client] (ecmascript)\");\nconst _navigation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/navigation.js [app-client] (ecmascript)\");\nconst _actionrevalidationkind = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/action-revalidation-kind.js [app-client] (ecmascript)\");\nconst _approuterutils = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-utils.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n;\nasync function fetchServerAction(state, nextUrl, { actionId, actionArgs }) {\n    const temporaryReferences = (0, _client.createTemporaryReferenceSet)();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await (0, _client.encodeReply)(usedArgs, {\n        temporaryReferences\n    });\n    const headers = {\n        Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n        [_approuterheaders.ACTION_HEADER]: actionId,\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree)\n    };\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    if (deploymentId) {\n        headers['x-deployment-id'] = deploymentId;\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const res = await fetch(state.canonicalUrl, {\n        method: 'POST',\n        headers,\n        body\n    });\n    // Handle server actions that the server didn't recognize.\n    const unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);\n    if (unrecognizedActionHeader === '1') {\n        throw Object.defineProperty(new _unrecognizedactionerror.UnrecognizedActionError(`Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`), \"__NEXT_ERROR_CODE\", {\n            value: \"E715\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location1, _redirectType] = redirectHeader?.split(';') || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidationKind = _actionrevalidationkind.ActionDidNotRevalidate;\n    try {\n        const revalidationHeader = res.headers.get('x-action-revalidated');\n        if (revalidationHeader) {\n            const parsedKind = JSON.parse(revalidationHeader);\n            if (parsedKind === _actionrevalidationkind.ActionDidRevalidateStaticAndDynamic || parsedKind === _actionrevalidationkind.ActionDidRevalidateDynamicOnly) {\n                revalidationKind = parsedKind;\n            }\n        }\n    } catch  {}\n    const redirectLocation = location1 ? (0, _assignlocation.assignLocation)(location1, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    const isRscResponse = !!(contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));\n    // Handle invalid server action responses.\n    // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n    // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n    if (!isRscResponse && !redirectLocation) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const message = res.status >= 400 && contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let actionResult;\n    let actionFlightData;\n    let actionFlightDataRenderedSearch;\n    let actionFlightDataCouldBeIntercepted;\n    if (isRscResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences,\n            debugChannel: createDebugChannel && createDebugChannel(headers)\n        });\n        // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n        actionResult = redirectLocation ? undefined : response.a;\n        const maybeFlightData = (0, _flightdatahelpers.normalizeFlightData)(response.f);\n        if (maybeFlightData !== '') {\n            actionFlightData = maybeFlightData;\n            actionFlightDataRenderedSearch = response.q;\n            actionFlightDataCouldBeIntercepted = response.i;\n        }\n    } else {\n        // An external redirect doesn't contain RSC data.\n        actionResult = undefined;\n        actionFlightData = undefined;\n        actionFlightDataRenderedSearch = undefined;\n        actionFlightDataCouldBeIntercepted = undefined;\n    }\n    return {\n        actionResult,\n        actionFlightData,\n        actionFlightDataRenderedSearch,\n        actionFlightDataCouldBeIntercepted,\n        redirectLocation,\n        redirectType,\n        revalidationKind,\n        isPrerender\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.previousNextUrl || state.nextUrl : null;\n    return fetchServerAction(state, nextUrl, action).then(async ({ revalidationKind, actionResult, actionFlightData: flightData, actionFlightDataRenderedSearch: flightDataRenderedSearch, actionFlightDataCouldBeIntercepted: flightDataCouldBeIntercepted, redirectLocation, redirectType })=>{\n        if (revalidationKind !== _actionrevalidationkind.ActionDidNotRevalidate) {\n            // Store whether this action triggered any revalidation\n            // The action queue will use this information to potentially\n            // trigger a refresh action if the action was discarded\n            // (ie, due to a navigation, before the action completed)\n            action.didRevalidate = true;\n            // If there was a revalidation, evict the entire prefetch cache.\n            // TODO: Evict only segments with matching tags and/or paths.\n            if (revalidationKind === _actionrevalidationkind.ActionDidRevalidateStaticAndDynamic) {\n                (0, _cache.revalidateEntireCache)(nextUrl, state.tree);\n            }\n        }\n        const pendingPush = redirectType !== _redirecterror.RedirectType.replace;\n        state.pushRef.pendingPush = pendingPush;\n        mutable.pendingPush = pendingPush;\n        if (redirectLocation !== undefined) {\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            const resolvedRedirectType = redirectType || _redirecterror.RedirectType.push;\n            if ((0, _approuterutils.isExternalURL)(redirectLocation)) {\n                // External redirect. Triggers an MPA navigation.\n                const redirectHref = redirectLocation.href;\n                const redirectError = createRedirectErrorForAction(redirectHref, resolvedRedirectType);\n                reject(redirectError);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref, pendingPush);\n            } else {\n                // Internal redirect. Triggers an SPA navigation.\n                const redirectWithBasepath = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n                const redirectHref = (0, _hasbasepath.hasBasePath)(redirectWithBasepath) ? (0, _removebasepath.removeBasePath)(redirectWithBasepath) : redirectWithBasepath;\n                const redirectError = createRedirectErrorForAction(redirectHref, resolvedRedirectType);\n                reject(redirectError);\n            }\n        } else {\n            // If there's no redirect, resolve the action with the result.\n            resolve(actionResult);\n        }\n        // Check if we can bail out without updating any state.\n        if (redirectLocation === undefined && // Did the action revalidate any data?\n        revalidationKind === _actionrevalidationkind.ActionDidNotRevalidate && // Did the server render new data?\n        flightData === undefined) {\n            // The action did not trigger any revalidations or redirects. No\n            // navigation is required.\n            return state;\n        }\n        if (flightData === undefined && redirectLocation !== undefined) {\n            // The server redirected, but did not send any Flight data. This implies\n            // an external redirect.\n            // TODO: We should refactor the action response type to be more explicit\n            // about the various response types.\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, pendingPush);\n        }\n        if (typeof flightData === 'string') {\n            // If the flight data is just a string, something earlier in the\n            // response handling triggered an external redirect.\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, pendingPush);\n        }\n        // The action triggered a navigation  either a redirect, a revalidation,\n        // or both.\n        // If there was no redirect, then the target URL is the same as the\n        // current URL.\n        const currentUrl = new URL(state.canonicalUrl, location.origin);\n        const redirectUrl = redirectLocation !== undefined ? redirectLocation : currentUrl;\n        const currentFlightRouterState = state.tree;\n        const shouldScroll = true;\n        // If the action triggered a revalidation of the cache, we should also\n        // refresh all the dynamic data.\n        const freshnessPolicy = revalidationKind === _actionrevalidationkind.ActionDidNotRevalidate ? _pprnavigations.FreshnessPolicy.Default : _pprnavigations.FreshnessPolicy.RefreshAll;\n        // The server may have sent back new data. If so, we will perform a\n        // \"seeded\" navigation that uses the data from the response.\n        if (flightData !== undefined) {\n            const normalizedFlightData = flightData[0];\n            if (normalizedFlightData !== undefined && // TODO: Currently the server always renders from the root in\n            // response to a Server Action. In the case of a normal redirect\n            // with no revalidation, it should skip over the shared layouts.\n            normalizedFlightData.isRootRender && flightDataRenderedSearch !== undefined && flightDataCouldBeIntercepted !== undefined) {\n                // The server sent back new route data as part of the response. We\n                // will use this to render the new page. If this happens to be only a\n                // subset of the data needed to render the new page, we'll initiate a\n                // new fetch, like we would for a normal navigation.\n                const redirectCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(redirectUrl);\n                const navigationSeed = {\n                    tree: normalizedFlightData.tree,\n                    renderedSearch: flightDataRenderedSearch,\n                    data: normalizedFlightData.seedData,\n                    head: normalizedFlightData.head\n                };\n                const now = Date.now();\n                const result = (0, _navigation.navigateToSeededRoute)(now, redirectUrl, redirectCanonicalUrl, navigationSeed, currentUrl, state.cache, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll);\n                return (0, _navigatereducer.handleNavigationResult)(redirectUrl, state, mutable, pendingPush, result);\n            }\n        }\n        // The server did not send back new data. We'll perform a regular, non-\n        // seeded navigation  effectively the same as <Link> or router.push().\n        const result = (0, _navigation.navigate)(redirectUrl, currentUrl, state.cache, currentFlightRouterState, nextUrl, freshnessPolicy, shouldScroll, mutable);\n        return (0, _navigatereducer.handleNavigationResult)(redirectUrl, state, mutable, pendingPush, result);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nfunction createRedirectErrorForAction(redirectHref, resolvedRedirectType) {\n    const redirectError = (0, _redirect.getRedirectError)(redirectHref, resolvedRedirectType);\n    redirectError.handled = true;\n    return redirectError;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"reducer\", {\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n});\nconst _routerreducertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)\");\nconst _navigatereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)\");\nconst _serverpatchreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-client] (ecmascript)\");\nconst _restorereducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-client] (ecmascript)\");\nconst _refreshreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-client] (ecmascript)\");\nconst _hmrrefreshreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-client] (ecmascript)\");\nconst _serveractionreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-client] (ecmascript)\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state);\n            }\n        case _routerreducertypes.ACTION_HMR_REFRESH:\n            {\n                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw Object.defineProperty(new Error('Unknown action'), \"__NEXT_ERROR_CODE\", {\n                value: \"E295\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer = typeof window === 'undefined' ? serverReducer : clientReducer;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/segment-cache/prefetch.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"prefetch\", {\n    enumerable: true,\n    get: function() {\n        return prefetch;\n    }\n});\nconst _approuterutils = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-utils.js [app-client] (ecmascript)\");\nconst _cachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/cache-key.js [app-client] (ecmascript)\");\nconst _scheduler = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/scheduler.js [app-client] (ecmascript)\");\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nfunction prefetch(href, nextUrl, treeAtTimeOfPrefetch, fetchStrategy, onInvalidate) {\n    const url = (0, _approuterutils.createPrefetchURL)(href);\n    if (url === null) {\n        // This href should not be prefetched.\n        return;\n    }\n    const cacheKey = (0, _cachekey.createCacheKey)(url.href, nextUrl);\n    (0, _scheduler.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, fetchStrategy, _types.PrefetchPriority.Default, onInvalidate);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createMutableActionQueue: null,\n    dispatchNavigateAction: null,\n    dispatchTraverseAction: null,\n    getCurrentAppRouterState: null,\n    publicAppRouterInstance: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMutableActionQueue: function() {\n        return createMutableActionQueue;\n    },\n    dispatchNavigateAction: function() {\n        return dispatchNavigateAction;\n    },\n    dispatchTraverseAction: function() {\n        return dispatchTraverseAction;\n    },\n    getCurrentAppRouterState: function() {\n        return getCurrentAppRouterState;\n    },\n    publicAppRouterInstance: function() {\n        return publicAppRouterInstance;\n    }\n});\nconst _routerreducertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)\");\nconst _routerreducer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-client] (ecmascript)\");\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _isthenable = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-client] (ecmascript)\");\nconst _types = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)\");\nconst _prefetch = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/segment-cache/prefetch.js [app-client] (ecmascript)\");\nconst _useactionqueue = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)\");\nconst _addbasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)\");\nconst _approuterutils = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-utils.js [app-client] (ecmascript)\");\nconst _links = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)\");\nfunction runRemainingActions(actionQueue, setState) {\n    if (actionQueue.pending !== null) {\n        actionQueue.pending = actionQueue.pending.next;\n        if (actionQueue.pending !== null) {\n            runAction({\n                actionQueue,\n                action: actionQueue.pending,\n                setState\n            });\n        }\n    } else {\n        // Check for refresh when pending is already null\n        // This handles the case where a discarded server action completes\n        // after the navigation has already finished and the queue is empty\n        if (actionQueue.needsRefresh) {\n            actionQueue.needsRefresh = false;\n            actionQueue.dispatch({\n                type: _routerreducertypes.ACTION_REFRESH\n            }, setState);\n        }\n    }\n}\nasync function runAction({ actionQueue, action, setState }) {\n    const prevState = actionQueue.state;\n    actionQueue.pending = action;\n    const payload = action.payload;\n    const actionResult = actionQueue.action(prevState, payload);\n    function handleResult(nextState) {\n        // if we discarded this action, the state should also be discarded\n        if (action.discarded) {\n            // Check if the discarded server action revalidated data\n            if (action.payload.type === _routerreducertypes.ACTION_SERVER_ACTION && action.payload.didRevalidate) {\n                // The server action was discarded but it revalidated data,\n                // mark that we need to refresh after all actions complete\n                actionQueue.needsRefresh = true;\n            }\n            // Still need to run remaining actions even for discarded actions\n            // to potentially trigger the refresh\n            runRemainingActions(actionQueue, setState);\n            return;\n        }\n        actionQueue.state = nextState;\n        runRemainingActions(actionQueue, setState);\n        action.resolve(nextState);\n    }\n    // if the action is a promise, set up a callback to resolve it\n    if ((0, _isthenable.isThenable)(actionResult)) {\n        actionResult.then(handleResult, (err)=>{\n            runRemainingActions(actionQueue, setState);\n            action.reject(err);\n        });\n    } else {\n        handleResult(actionResult);\n    }\n}\nfunction dispatchAction(actionQueue, payload, setState) {\n    let resolvers = {\n        resolve: setState,\n        reject: ()=>{}\n    };\n    // most of the action types are async with the exception of restore\n    // it's important that restore is handled quickly since it's fired on the popstate event\n    // and we don't want to add any delay on a back/forward nav\n    // this only creates a promise for the async actions\n    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {\n        // Create the promise and assign the resolvers to the object.\n        const deferredPromise = new Promise((resolve, reject)=>{\n            resolvers = {\n                resolve,\n                reject\n            };\n        });\n        (0, _react.startTransition)(()=>{\n            // we immediately notify React of the pending promise -- the resolver is attached to the action node\n            // and will be called when the associated action promise resolves\n            setState(deferredPromise);\n        });\n    }\n    const newAction = {\n        payload,\n        next: null,\n        resolve: resolvers.resolve,\n        reject: resolvers.reject\n    };\n    // Check if the queue is empty\n    if (actionQueue.pending === null) {\n        // The queue is empty, so add the action and start it immediately\n        // Mark this action as the last in the queue\n        actionQueue.last = newAction;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {\n        // Navigations (including back/forward) take priority over any pending actions.\n        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n        actionQueue.pending.discarded = true;\n        // The rest of the current queue should still execute after this navigation.\n        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n        newAction.next = actionQueue.pending.next;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else {\n        // The queue is not empty, so add the action to the end of the queue\n        // It will be started by runRemainingActions after the previous action finishes\n        if (actionQueue.last !== null) {\n            actionQueue.last.next = newAction;\n        }\n        actionQueue.last = newAction;\n    }\n}\nlet globalActionQueue = null;\nfunction createMutableActionQueue(initialState, instrumentationHooks) {\n    const actionQueue = {\n        state: initialState,\n        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),\n        action: async (state, action)=>{\n            const result = (0, _routerreducer.reducer)(state, action);\n            return result;\n        },\n        pending: null,\n        last: null,\n        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null\n    };\n    if (typeof window !== 'undefined') {\n        // The action queue is lazily created on hydration, but after that point\n        // it doesn't change. So we can store it in a global rather than pass\n        // it around everywhere via props/context.\n        if (globalActionQueue !== null) {\n            throw Object.defineProperty(new Error('Internal Next.js Error: createMutableActionQueue was called more ' + 'than once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E624\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        globalActionQueue = actionQueue;\n    }\n    return actionQueue;\n}\nfunction getCurrentAppRouterState() {\n    return globalActionQueue !== null ? globalActionQueue.state : null;\n}\nfunction getAppRouterActionQueue() {\n    if (globalActionQueue === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return globalActionQueue;\n}\nfunction getProfilingHookForOnNavigationStart() {\n    if (globalActionQueue !== null) {\n        return globalActionQueue.onRouterTransitionStart;\n    }\n    return null;\n}\nfunction dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {\n    // TODO: This stuff could just go into the reducer. Leaving as-is for now\n    // since we're about to rewrite all the router reducer stuff anyway.\n    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, navigateType);\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_NAVIGATE,\n        url,\n        isExternalUrl: (0, _approuterutils.isExternalURL)(url),\n        locationSearch: location.search,\n        shouldScroll,\n        navigateType\n    });\n}\nfunction dispatchTraverseAction(href, historyState) {\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, 'traverse');\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_RESTORE,\n        url: new URL(href),\n        historyState\n    });\n}\nconst publicAppRouterInstance = {\n    back: ()=>window.history.back(),\n    forward: ()=>window.history.forward(),\n    prefetch: // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href, options)=>{\n        const actionQueue = getAppRouterActionQueue();\n        const prefetchKind = options?.kind ?? _routerreducertypes.PrefetchKind.AUTO;\n        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n        // This will be possible when we update its API to not take a PrefetchKind.\n        let fetchStrategy;\n        switch(prefetchKind){\n            case _routerreducertypes.PrefetchKind.AUTO:\n                {\n                    // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                    break;\n                }\n            case _routerreducertypes.PrefetchKind.FULL:\n                {\n                    fetchStrategy = _types.FetchStrategy.Full;\n                    break;\n                }\n            default:\n                {\n                    prefetchKind;\n                    // Despite typescript thinking that this can't happen,\n                    // we might get an unexpected value from user code.\n                    // We don't know what they want, but we know they want a prefetch,\n                    // so use the default.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                }\n        }\n        (0, _prefetch.prefetch)(href, actionQueue.state.nextUrl, actionQueue.state.tree, fetchStrategy, options?.onInvalidate ?? null);\n    },\n    replace: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null);\n        });\n    },\n    push: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'push', options?.scroll ?? true, null);\n        });\n    },\n    refresh: ()=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_REFRESH\n            });\n        });\n    },\n    hmrRefresh: ()=>{\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        else {\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_HMR_REFRESH\n                });\n            });\n        }\n    }\n};\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n    window.next.router = publicAppRouterInstance;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-instance.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"AppRouterAnnouncer\", {\n    enumerable: true,\n    get: function() {\n        return AppRouterAnnouncer;\n    }\n});\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _reactdom = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)\");\nconst ANNOUNCER_TYPE = 'next-route-announcer';\nconst ANNOUNCER_ID = '__next-route-announcer__';\nfunction getAnnouncerNode() {\n    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];\n    if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n        return existingAnnouncer.shadowRoot.childNodes[0];\n    } else {\n        const container = document.createElement(ANNOUNCER_TYPE);\n        container.style.cssText = 'position:absolute';\n        const announcer = document.createElement('div');\n        announcer.ariaLive = 'assertive';\n        announcer.id = ANNOUNCER_ID;\n        announcer.role = 'alert';\n        announcer.style.cssText = 'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal';\n        // Use shadow DOM here to avoid any potential CSS bleed\n        const shadow = container.attachShadow({\n            mode: 'open'\n        });\n        shadow.appendChild(announcer);\n        document.body.appendChild(container);\n        return announcer;\n    }\n}\nfunction AppRouterAnnouncer({ tree }) {\n    const [portalNode, setPortalNode] = (0, _react.useState)(null);\n    (0, _react.useEffect)(()=>{\n        const announcer = getAnnouncerNode();\n        setPortalNode(announcer);\n        return ()=>{\n            const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0];\n            if (container?.isConnected) {\n                document.body.removeChild(container);\n            }\n        };\n    }, []);\n    const [routeAnnouncement, setRouteAnnouncement] = (0, _react.useState)('');\n    const previousTitle = (0, _react.useRef)(undefined);\n    (0, _react.useEffect)(()=>{\n        let currentTitle = '';\n        if (document.title) {\n            currentTitle = document.title;\n        } else {\n            const pageHeader = document.querySelector('h1');\n            if (pageHeader) {\n                currentTitle = pageHeader.innerText || pageHeader.textContent || '';\n            }\n        }\n        // Only announce the title change, but not for the first load because screen\n        // readers do that automatically.\n        if (previousTitle.current !== undefined && previousTitle.current !== currentTitle) {\n            setRouteAnnouncement(currentTitle);\n        }\n        previousTitle.current = currentTitle;\n    }, [\n        tree\n    ]);\n    return portalNode ? /*#__PURE__*/ (0, _reactdom.createPortal)(routeAnnouncement, portalNode) : null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-announcer.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/forbidden.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"forbidden\", {\n    enumerable: true,\n    get: function() {\n        return forbidden;\n    }\n});\nconst _httpaccessfallback = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)\");\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};403`;\nfunction forbidden() {\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        throw Object.defineProperty(new Error(`\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E488\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=forbidden.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/unauthorized.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unauthorized\", {\n    enumerable: true,\n    get: function() {\n        return unauthorized;\n    }\n});\nconst _httpaccessfallback = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)\");\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};401`;\nfunction unauthorized() {\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        throw Object.defineProperty(new Error(`\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E411\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unauthorized.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/unstable-rethrow.browser.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_rethrow\", {\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n});\nconst _bailouttocsr = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)\");\nconst _isnextroutererror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)\");\nfunction unstable_rethrow(error) {\n    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error)) {\n        throw error;\n    }\n    if (error instanceof Error && 'cause' in error) {\n        unstable_rethrow(error.cause);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unstable-rethrow.browser.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DynamicServerError: null,\n    isDynamicServerError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DynamicServerError: function() {\n        return DynamicServerError;\n    },\n    isDynamicServerError: function() {\n        return isDynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\nclass DynamicServerError extends Error {\n    constructor(description){\n        super(`Dynamic server usage: ${description}`), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nfunction isDynamicServerError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hooks-server-context.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    StaticGenBailoutError: null,\n    isStaticGenBailoutError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_rethrow\", {\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n});\nconst _dynamicrenderingutils = __turbopack_context__.r(\"[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)\");\nconst _ispostpone = __turbopack_context__.r(\"[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-client] (ecmascript)\");\nconst _bailouttocsr = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)\");\nconst _isnextroutererror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)\");\nconst _dynamicrendering = __turbopack_context__.r(\"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)\");\nconst _hooksservercontext = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-client] (ecmascript)\");\nfunction unstable_rethrow(error) {\n    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error) || (0, _dynamicrendering.isPrerenderInterruptedError)(error)) {\n        throw error;\n    }\n    if (error instanceof Error && 'cause' in error) {\n        unstable_rethrow(error.cause);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unstable-rethrow.server.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\n/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */ Object.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_rethrow\", {\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n});\nconst unstable_rethrow = typeof window === 'undefined' ? __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-client] (ecmascript)\").unstable_rethrow : __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unstable-rethrow.browser.js [app-client] (ecmascript)\").unstable_rethrow;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unstable-rethrow.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ReadonlyURLSearchParams: null,\n    RedirectType: null,\n    forbidden: null,\n    notFound: null,\n    permanentRedirect: null,\n    redirect: null,\n    unauthorized: null,\n    unstable_isUnrecognizedActionError: null,\n    unstable_rethrow: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyURLSearchParams: function() {\n        return _readonlyurlsearchparams.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _redirecterror.RedirectType;\n    },\n    forbidden: function() {\n        return _forbidden.forbidden;\n    },\n    notFound: function() {\n        return _notfound.notFound;\n    },\n    permanentRedirect: function() {\n        return _redirect.permanentRedirect;\n    },\n    redirect: function() {\n        return _redirect.redirect;\n    },\n    unauthorized: function() {\n        return _unauthorized.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _unstablerethrow.unstable_rethrow;\n    }\n});\nconst _readonlyurlsearchparams = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/readonly-url-search-params.js [app-client] (ecmascript)\");\nconst _redirect = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)\");\nconst _redirecterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\");\nconst _notfound = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/not-found.js [app-client] (ecmascript)\");\nconst _forbidden = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/forbidden.js [app-client] (ecmascript)\");\nconst _unauthorized = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unauthorized.js [app-client] (ecmascript)\");\nconst _unstablerethrow = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-client] (ecmascript)\");\nfunction unstable_isUnrecognizedActionError() {\n    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E776\",\n        enumerable: false,\n        configurable: true\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.react-server.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ReadonlyURLSearchParams: null,\n    RedirectType: null,\n    ServerInsertedHTMLContext: null,\n    forbidden: null,\n    notFound: null,\n    permanentRedirect: null,\n    redirect: null,\n    unauthorized: null,\n    unstable_isUnrecognizedActionError: null,\n    unstable_rethrow: null,\n    useParams: null,\n    usePathname: null,\n    useRouter: null,\n    useSearchParams: null,\n    useSelectedLayoutSegment: null,\n    useSelectedLayoutSegments: null,\n    useServerInsertedHTML: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    // We need the same class that was used to instantiate the context value\n    // Otherwise instanceof checks will fail in usercode\n    ReadonlyURLSearchParams: function() {\n        return _hooksclientcontextsharedruntime.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _navigationreactserver.RedirectType;\n    },\n    ServerInsertedHTMLContext: function() {\n        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;\n    },\n    forbidden: function() {\n        return _navigationreactserver.forbidden;\n    },\n    notFound: function() {\n        return _navigationreactserver.notFound;\n    },\n    permanentRedirect: function() {\n        return _navigationreactserver.permanentRedirect;\n    },\n    redirect: function() {\n        return _navigationreactserver.redirect;\n    },\n    unauthorized: function() {\n        return _navigationreactserver.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return _unrecognizedactionerror.unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _navigationreactserver.unstable_rethrow;\n    },\n    useParams: function() {\n        return useParams;\n    },\n    usePathname: function() {\n        return usePathname;\n    },\n    useRouter: function() {\n        return useRouter;\n    },\n    useSearchParams: function() {\n        return useSearchParams;\n    },\n    useSelectedLayoutSegment: function() {\n        return useSelectedLayoutSegment;\n    },\n    useSelectedLayoutSegments: function() {\n        return useSelectedLayoutSegments;\n    },\n    useServerInsertedHTML: function() {\n        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;\n    }\n});\nconst _interop_require_wildcard = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _approutercontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _hooksclientcontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _serverinsertedhtmlsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js [app-client] (ecmascript)\");\nconst _unrecognizedactionerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-client] (ecmascript)\");\nconst _navigationreactserver = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-client] (ecmascript)\");\nconst useDynamicRouteParams = typeof window === 'undefined' ? __turbopack_context__.r(\"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)\").useDynamicRouteParams : undefined;\nconst useDynamicSearchParams = typeof window === 'undefined' ? __turbopack_context__.r(\"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)\").useDynamicSearchParams : undefined;\nfunction useSearchParams() {\n    useDynamicSearchParams?.('useSearchParams()');\n    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);\n    // In the case where this is `null`, the compat types added in\n    // `next-env.d.ts` will add a new overload that changes the return type to\n    // include `null`.\n    const readonlySearchParams = (0, _react.useMemo)(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new _hooksclientcontextsharedruntime.ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    // Instrument with Suspense DevTools (dev-only)\n    if ((\"TURBOPACK compile-time value\", \"development\") !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.searchParams);\n        }\n    }\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    useDynamicRouteParams?.('usePathname()');\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\n    // will add a new overload that changes the return type to include `null`.\n    const pathname = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if ((\"TURBOPACK compile-time value\", \"development\") !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.pathname);\n        }\n    }\n    return pathname;\n}\nfunction useRouter() {\n    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);\n    if (router === null) {\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E238\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return router;\n}\nfunction useParams() {\n    useDynamicRouteParams?.('useParams()');\n    const params = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if ((\"TURBOPACK compile-time value\", \"development\") !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.params);\n        }\n    }\n    return params;\n}\nfunction useSelectedLayoutSegments(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegments()');\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n    if (!context) return null;\n    // Instrument with Suspense DevTools (dev-only)\n    if ((\"TURBOPACK compile-time value\", \"development\") !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            const promise = navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey);\n            if (promise) {\n                // We should always have a promise here, but if we don't, it's not worth erroring over.\n                // We just won't be able to instrument it, but can still provide the value.\n                return (0, _react.use)(promise);\n            }\n        }\n    }\n    return (0, _segment.getSelectedLayoutSegmentPath)(context.parentTree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegment()');\n    const navigationPromises = (0, _react.useContext)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    // Instrument with Suspense DevTools (dev-only)\n    if ((\"TURBOPACK compile-time value\", \"development\") !== 'production' && navigationPromises && 'use' in _react.default) {\n        const promise = navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey);\n        if (promise) {\n            // We should always have a promise here, but if we don't, it's not worth erroring over.\n            // We just won't be able to instrument it, but can still provide the value.\n            return (0, _react.use)(promise);\n        }\n    }\n    return (0, _segment.computeSelectedLayoutSegment)(selectedLayoutSegments, parallelRouteKey);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    RedirectBoundary: null,\n    RedirectErrorBoundary: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    RedirectBoundary: function() {\n        return RedirectBoundary;\n    },\n    RedirectErrorBoundary: function() {\n        return RedirectErrorBoundary;\n    }\n});\nconst _interop_require_wildcard = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _navigation = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)\");\nconst _redirect = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)\");\nconst _redirecterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\");\nfunction HandleRedirect({ redirect, reset, redirectType }) {\n    const router = (0, _navigation.useRouter)();\n    (0, _react.useEffect)(()=>{\n        _react.default.startTransition(()=>{\n            if (redirectType === _redirecterror.RedirectType.push) {\n                router.push(redirect, {});\n            } else {\n                router.replace(redirect, {});\n            }\n            reset();\n        });\n    }, [\n        redirect,\n        redirectType,\n        reset,\n        router\n    ]);\n    return null;\n}\nclass RedirectErrorBoundary extends _react.default.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            redirect: null,\n            redirectType: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _redirecterror.isRedirectError)(error)) {\n            const url = (0, _redirect.getURLFromRedirectError)(error);\n            const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n            if ('handled' in error) {\n                // The redirect was already handled. We'll still catch the redirect error\n                // so that we can remount the subtree, but we don't actually need to trigger the\n                // router.push.\n                return {\n                    redirect: null,\n                    redirectType: null\n                };\n            }\n            return {\n                redirect: url,\n                redirectType\n            };\n        }\n        // Re-throw if error is not for redirect\n        throw error;\n    }\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n    render() {\n        const { redirect, redirectType } = this.state;\n        if (redirect !== null && redirectType !== null) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleRedirect, {\n                redirect: redirect,\n                redirectType: redirectType,\n                reset: ()=>this.setState({\n                        redirect: null\n                    })\n            });\n        }\n        return this.props.children;\n    }\n}\nfunction RedirectBoundary({ children }) {\n    const router = (0, _navigation.useRouter)();\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(RedirectErrorBoundary, {\n        router: router,\n        children: children\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=redirect-boundary.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"findHeadInCache\", {\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n});\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst _createroutercachekey = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)\");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, '', '');\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix, keyPrefixWithoutSearchParams) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix,\n            keyPrefixWithoutSearchParams\n        ];\n    }\n    // First try the 'children' parallel route if it exists\n    // when starting from the \"root\", this corresponds with the main page component\n    const parallelRoutesKeys = Object.keys(parallelRoutes).filter((key)=>key !== 'children');\n    // if we are at the root, we need to check the children slot first\n    if ('children' in parallelRoutes) {\n        parallelRoutesKeys.unshift('children');\n    }\n    for (const key of parallelRoutesKeys){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        // If the parallel is not matched and using the default segment,\n        // skip searching the head from it.\n        if (segment === _segment.DEFAULT_SEGMENT_KEY) {\n            continue;\n        }\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheKeyWithoutSearchParams = (0, _createroutercachekey.createRouterCacheKey)(segment, true);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey, keyPrefix + '/' + cacheKeyWithoutSearchParams);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\n/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */ Object.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unresolvedThenable\", {\n    enumerable: true,\n    get: function() {\n        return unresolvedThenable;\n    }\n});\nconst unresolvedThenable = {\n    then: ()=>{}\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unresolved-thenable.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    GracefulDegradeBoundary: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    GracefulDegradeBoundary: function() {\n        return GracefulDegradeBoundary;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nfunction getDomNodeAttributes(node) {\n    const result = {};\n    for(let i = 0; i < node.attributes.length; i++){\n        const attr = node.attributes[i];\n        result[attr.name] = attr.value;\n    }\n    return result;\n}\nclass GracefulDegradeBoundary extends _react.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            hasError: false\n        };\n        this.rootHtml = '';\n        this.htmlAttributes = {};\n        this.htmlRef = /*#__PURE__*/ (0, _react.createRef)();\n    }\n    static getDerivedStateFromError(_) {\n        return {\n            hasError: true\n        };\n    }\n    componentDidMount() {\n        const htmlNode = this.htmlRef.current;\n        if (this.state.hasError && htmlNode) {\n            // Reapply the cached HTML attributes to the root element\n            Object.entries(this.htmlAttributes).forEach(([key, value])=>{\n                htmlNode.setAttribute(key, value);\n            });\n        }\n    }\n    render() {\n        const { hasError } = this.state;\n        // Cache the root HTML content on the first render\n        if (typeof window !== 'undefined' && !this.rootHtml) {\n            this.rootHtml = document.documentElement.innerHTML;\n            this.htmlAttributes = getDomNodeAttributes(document.documentElement);\n        }\n        if (hasError) {\n            // Render the current HTML content without hydration\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"html\", {\n                ref: this.htmlRef,\n                suppressHydrationWarning: true,\n                dangerouslySetInnerHTML: {\n                    __html: this.rootHtml\n                }\n            });\n        }\n        return this.props.children;\n    }\n}\nconst _default = GracefulDegradeBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=graceful-degrade-boundary.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/errors/root-error-boundary.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return RootErrorBoundary;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _gracefuldegradeboundary = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-client] (ecmascript)\"));\nconst _errorboundary = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)\");\nconst _isbot = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)\");\nconst isBotUserAgent = typeof window !== 'undefined' && (0, _isbot.isBot)(window.navigator.userAgent);\nfunction RootErrorBoundary({ children, errorComponent, errorStyles, errorScripts }) {\n    if (isBotUserAgent) {\n        // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n        // and to keep the original SSR output intact.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_gracefuldegradeboundary.default, {\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n        errorComponent: errorComponent,\n        errorStyles: errorStyles,\n        errorScripts: errorScripts,\n        children: children\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=root-error-boundary.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/navigation-devtools.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createNestedLayoutNavigationPromises: null,\n    createRootNavigationPromises: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createNestedLayoutNavigationPromises: function() {\n        return createNestedLayoutNavigationPromises;\n    },\n    createRootNavigationPromises: function() {\n        return createRootNavigationPromises;\n    }\n});\nconst _hooksclientcontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _segment = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)\");\nconst layoutSegmentPromisesCache = new WeakMap();\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */ function createLayoutSegmentPromises(tree) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    // Check if we already have cached promises for this tree\n    const cached = layoutSegmentPromisesCache.get(tree);\n    if (cached) {\n        return cached;\n    }\n    // Create new promises and cache them\n    const segmentPromises = new Map();\n    const segmentsPromises = new Map();\n    const parallelRoutes = tree[1];\n    for (const parallelRouteKey of Object.keys(parallelRoutes)){\n        const segments = (0, _segment.getSelectedLayoutSegmentPath)(tree, parallelRouteKey);\n        // Use the shared logic to compute the segment value\n        const segment = (0, _segment.computeSelectedLayoutSegment)(segments, parallelRouteKey);\n        segmentPromises.set(parallelRouteKey, (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSelectedLayoutSegment', segment));\n        segmentsPromises.set(parallelRouteKey, (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSelectedLayoutSegments', segments));\n    }\n    const result = {\n        selectedLayoutSegmentPromises: segmentPromises,\n        selectedLayoutSegmentsPromises: segmentsPromises\n    };\n    // Cache the result for future renders\n    layoutSegmentPromisesCache.set(tree, result);\n    return result;\n}\nconst rootNavigationPromisesCache = new WeakMap();\nfunction createRootNavigationPromises(tree, pathname, searchParams, pathParams) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    // Create stable cache keys from the values\n    const searchParamsString = searchParams.toString();\n    const pathParamsString = JSON.stringify(pathParams);\n    const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`;\n    // Get or create the cache for this tree\n    let treeCache = rootNavigationPromisesCache.get(tree);\n    if (!treeCache) {\n        treeCache = new Map();\n        rootNavigationPromisesCache.set(tree, treeCache);\n    }\n    // Check if we have cached promises for this combination\n    const cached = treeCache.get(cacheKey);\n    if (cached) {\n        return cached;\n    }\n    const readonlySearchParams = new _hooksclientcontextsharedruntime.ReadonlyURLSearchParams(searchParams);\n    const layoutSegmentPromises = createLayoutSegmentPromises(tree);\n    const promises = {\n        pathname: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('usePathname', pathname),\n        searchParams: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSearchParams', readonlySearchParams),\n        params: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useParams', pathParams),\n        ...layoutSegmentPromises\n    };\n    treeCache.set(cacheKey, promises);\n    return promises;\n}\nconst nestedLayoutPromisesCache = new WeakMap();\nfunction createNestedLayoutNavigationPromises(tree, parentNavPromises) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    const parallelRoutes = tree[1];\n    const parallelRouteKeys = Object.keys(parallelRoutes);\n    // Only create promises if there are parallel routes at this level\n    if (parallelRouteKeys.length === 0) {\n        return null;\n    }\n    // Get or create the cache for this tree\n    let treeCache = nestedLayoutPromisesCache.get(tree);\n    if (!treeCache) {\n        treeCache = new Map();\n        nestedLayoutPromisesCache.set(tree, treeCache);\n    }\n    // Check if we have cached promises for this parent combination\n    const cached = treeCache.get(parentNavPromises);\n    if (cached) {\n        return cached;\n    }\n    // Create merged promises\n    const layoutSegmentPromises = createLayoutSegmentPromises(tree);\n    const promises = {\n        ...parentNavPromises,\n        ...layoutSegmentPromises\n    };\n    treeCache.set(parentNavPromises, promises);\n    return promises;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation-devtools.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", {\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n});\nconst _interop_require_wildcard = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _navigationuntracked = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)\");\nconst _httpaccessfallback = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)\");\nconst _warnonce = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)\");\nconst _approutercontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n    componentDidCatch() {\n        if ((\"TURBOPACK compile-time value\", \"development\") === 'development' && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>`@${slot}`).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                    (\"TURBOPACK compile-time value\", \"development\") === 'development' && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n}\nfunction HTTPAccessFallbackBoundary({ notFound, forbidden, unauthorized, children }) {\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DevRootHTTPAccessFallbackBoundary: null,\n    bailOnRootNotFound: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DevRootHTTPAccessFallbackBoundary: function() {\n        return DevRootHTTPAccessFallbackBoundary;\n    },\n    bailOnRootNotFound: function() {\n        return bailOnRootNotFound;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _errorboundary = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)\");\nfunction bailOnRootNotFound() {\n    throw Object.defineProperty(new Error('notFound() is not allowed to use in root layout'), \"__NEXT_ERROR_CODE\", {\n        value: \"E192\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction NotAllowedRootHTTPFallbackError() {\n    bailOnRootNotFound();\n    return null;\n}\nfunction DevRootHTTPAccessFallbackBoundary({ children }) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.HTTPAccessFallbackBoundary, {\n        notFound: /*#__PURE__*/ (0, _jsxruntime.jsx)(NotAllowedRootHTTPFallbackError, {}),\n        children: children\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dev-root-http-access-fallback-boundary.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    REACT_REFRESH_FULL_RELOAD: null,\n    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: null,\n    reportInvalidHmrMessage: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    REACT_REFRESH_FULL_RELOAD: function() {\n        return REACT_REFRESH_FULL_RELOAD;\n    },\n    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: function() {\n        return REACT_REFRESH_FULL_RELOAD_FROM_ERROR;\n    },\n    reportInvalidHmrMessage: function() {\n        return reportInvalidHmrMessage;\n    }\n});\nconst REACT_REFRESH_FULL_RELOAD = '[Fast Refresh] performing full reload\\n\\n' + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' + 'Fast Refresh requires at least one parent function component in your React tree.';\nconst REACT_REFRESH_FULL_RELOAD_FROM_ERROR = '[Fast Refresh] performing full reload because your application had an unrecoverable error';\nfunction reportInvalidHmrMessage(message, err) {\n    console.warn('[HMR] Invalid message: ' + JSON.stringify(message) + '\\n' + (err instanceof Error && err?.stack || ''));\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=shared.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getSocketUrl\", {\n    enumerable: true,\n    get: function() {\n        return getSocketUrl;\n    }\n});\nconst _normalizedassetprefix = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-client] (ecmascript)\");\nfunction getSocketProtocol(assetPrefix) {\n    let protocol = window.location.protocol;\n    try {\n        // assetPrefix is a url\n        protocol = new URL(assetPrefix).protocol;\n    } catch  {}\n    return protocol === 'http:' ? 'ws:' : 'wss:';\n}\nfunction getSocketUrl(assetPrefix) {\n    const prefix = (0, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);\n    const protocol = getSocketProtocol(assetPrefix || '');\n    if (URL.canParse(prefix)) {\n        // since normalized asset prefix is ensured to be a URL format,\n        // we can safely replace the protocol\n        return prefix.replace(/^http/, 'ws');\n    }\n    const { hostname, port } = window.location;\n    return `${protocol}//${hostname}${port ? `:${port}` : ''}${prefix}`;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-socket-url.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/hot-reloader/app/web-socket.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createProcessTurbopackMessage: null,\n    createWebSocket: null,\n    useWebSocketPing: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createProcessTurbopackMessage: function() {\n        return createProcessTurbopackMessage;\n    },\n    createWebSocket: function() {\n        return createWebSocket;\n    },\n    useWebSocketPing: function() {\n        return useWebSocketPing;\n    }\n});\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _approutercontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _getsocketurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-client] (ecmascript)\");\nconst _hotreloadertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-client] (ecmascript)\");\nconst _shared = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-client] (ecmascript)\");\nconst _hotreloaderapp = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-client] (ecmascript)\");\nconst _forwardlogs = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-client] (ecmascript)\");\nconst _invarianterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)\");\nconst _constants = __turbopack_context__.r(\"[project]/node_modules/next/dist/lib/constants.js [app-client] (ecmascript)\");\nlet reconnections = 0;\nlet reloading = false;\nlet serverSessionId = null;\nlet mostRecentCompilationHash = null;\nfunction createWebSocket(assetPrefix, staticIndicatorState) {\n    if (!self.__next_r) {\n        throw Object.defineProperty(new _invarianterror.InvariantError(`Expected a request ID to be defined for the document via self.__next_r.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E806\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let webSocket;\n    let timer;\n    const sendMessage = (data)=>{\n        if (webSocket && webSocket.readyState === webSocket.OPEN) {\n            webSocket.send(data);\n        }\n    };\n    const processTurbopackMessage = createProcessTurbopackMessage(sendMessage);\n    function init() {\n        if (webSocket) {\n            webSocket.close();\n        }\n        const newWebSocket = new window.WebSocket(`${(0, _getsocketurl.getSocketUrl)(assetPrefix)}/_next/webpack-hmr?id=${self.__next_r}`);\n        newWebSocket.binaryType = 'arraybuffer';\n        function handleOnline() {\n            _forwardlogs.logQueue.onSocketReady(newWebSocket);\n            reconnections = 0;\n            window.console.log('[HMR] connected');\n        }\n        function handleMessage(event) {\n            // While the page is reloading, don't respond to any more messages.\n            if (reloading) {\n                return;\n            }\n            try {\n                const message = event.data instanceof ArrayBuffer ? parseBinaryMessage(event.data) : JSON.parse(event.data);\n                // Check for server restart in Turbopack mode\n                if (message.type === _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED) {\n                    if (serverSessionId !== null && serverSessionId !== message.data.sessionId) {\n                        // Either the server's session id has changed and it's a new server, or\n                        // it's been too long since we disconnected and we should reload the page.\n                        window.location.reload();\n                        reloading = true;\n                        return;\n                    }\n                    serverSessionId = message.data.sessionId;\n                }\n                // Track webpack compilation hash for server restart detection\n                if (message.type === _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SYNC && 'hash' in message) {\n                    // If we had previously reconnected and the hash changed, the server may have restarted\n                    if (mostRecentCompilationHash !== null && mostRecentCompilationHash !== message.hash) {\n                        window.location.reload();\n                        reloading = true;\n                        return;\n                    }\n                    mostRecentCompilationHash = message.hash;\n                }\n                (0, _hotreloaderapp.processMessage)(message, sendMessage, processTurbopackMessage, staticIndicatorState);\n            } catch (err) {\n                (0, _shared.reportInvalidHmrMessage)(event, err);\n            }\n        }\n        function handleDisconnect() {\n            newWebSocket.onerror = null;\n            newWebSocket.onclose = null;\n            newWebSocket.close();\n            reconnections++;\n            // After 25 reconnects we'll want to reload the page as it indicates the dev server is no longer running.\n            if (reconnections > _constants.WEB_SOCKET_MAX_RECONNECTIONS) {\n                reloading = true;\n                window.location.reload();\n                return;\n            }\n            clearTimeout(timer);\n            // Try again after 5 seconds\n            timer = setTimeout(init, reconnections > 5 ? 5000 : 1000);\n        }\n        newWebSocket.onopen = handleOnline;\n        newWebSocket.onerror = handleDisconnect;\n        newWebSocket.onclose = handleDisconnect;\n        newWebSocket.onmessage = handleMessage;\n        webSocket = newWebSocket;\n        return newWebSocket;\n    }\n    return init();\n}\nfunction createProcessTurbopackMessage(sendMessage) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    let queue = [];\n    let callback;\n    const processTurbopackMessage = (msg)=>{\n        if (callback) {\n            callback(msg);\n        } else {\n            queue.push(msg);\n        }\n    };\n    __turbopack_context__.A(\"[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-client] (ecmascript, async loader)\").then(({ connect })=>{\n        connect({\n            addMessageListener (cb) {\n                callback = cb;\n                // Replay all Turbopack messages before we were able to establish the HMR client.\n                for (const msg of queue){\n                    cb(msg);\n                }\n                queue.length = 0;\n            },\n            sendMessage,\n            onUpdateError: (err)=>(0, _hotreloaderapp.performFullReload)(err, sendMessage)\n        });\n    });\n    return processTurbopackMessage;\n}\nfunction useWebSocketPing(webSocket) {\n    const { tree } = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    (0, _react.useEffect)(()=>{\n        if (!webSocket) {\n            throw Object.defineProperty(new _invarianterror.InvariantError('Expected webSocket to be defined in dev mode.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E785\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // Never send pings when using Turbopack as it's not used.\n        // Pings were originally used to keep track of active routes in on-demand-entries with webpack.\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            return;\n        }\n        //TURBOPACK unreachable\n        ;\n        // Taken from on-demand-entries-client.js\n        const interval = undefined;\n    }, [\n        tree,\n        webSocket\n    ]);\n}\nconst textDecoder = new TextDecoder();\nfunction parseBinaryMessage(data) {\n    assertByteLength(data, 1);\n    const view = new DataView(data);\n    const messageType = view.getUint8(0);\n    switch(messageType){\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER:\n            {\n                const serializedErrors = new Uint8Array(data, 1);\n                return {\n                    type: _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER,\n                    serializedErrors\n                };\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK:\n            {\n                assertByteLength(data, 2);\n                const requestIdLength = view.getUint8(1);\n                assertByteLength(data, 2 + requestIdLength);\n                const requestId = textDecoder.decode(new Uint8Array(data, 2, requestIdLength));\n                const chunk = data.byteLength > 2 + requestIdLength ? new Uint8Array(data, 2 + requestIdLength) : null;\n                return {\n                    type: _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK,\n                    requestId,\n                    chunk\n                };\n            }\n        default:\n            {\n                throw Object.defineProperty(new _invarianterror.InvariantError(`Invalid binary HMR message of type ${messageType}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E809\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n    }\n}\nfunction assertByteLength(data, expectedLength) {\n    if (data.byteLength < expectedLength) {\n        throw Object.defineProperty(new _invarianterror.InvariantError(`Invalid binary HMR message: insufficient data (expected ${expectedLength} bytes, got ${data.byteLength})`), \"__NEXT_ERROR_CODE\", {\n            value: \"E808\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=web-socket.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, /**\n * Logs information about a completed HMR to the console, the server (via a\n * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging\n * hook).\n *\n * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a\n *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by\n *   turbopack when we must report a message to the browser console (because we\n *   already logged a \"rebuilding\" message), but it's not a real HMR, so we\n *   don't want to impact our telemetry.\n */ \"default\", {\n    enumerable: true,\n    get: function() {\n        return reportHmrLatency;\n    }\n});\nfunction reportHmrLatency(sendMessage, updatedModules, startMsSinceEpoch, endMsSinceEpoch, hasUpdate = true) {\n    const latencyMs = endMsSinceEpoch - startMsSinceEpoch;\n    console.log(`[Fast Refresh] done in ${latencyMs}ms`);\n    if (!hasUpdate) {\n        return;\n    }\n    sendMessage(JSON.stringify({\n        event: 'client-hmr-latency',\n        id: window.__nextDevClientId,\n        startTime: startMsSinceEpoch,\n        endTime: endMsSinceEpoch,\n        page: window.location.pathname,\n        updatedModules,\n        // Whether the page (tab) was hidden at the time the event occurred.\n        // This can impact the accuracy of the event's timing.\n        isPageHidden: document.visibilityState === 'hidden'\n    }));\n    if (self.__NEXT_HMR_LATENCY_CB) {\n        self.__NEXT_HMR_LATENCY_CB(latencyMs);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=report-hmr-latency.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"TurbopackHmr\", {\n    enumerable: true,\n    get: function() {\n        return TurbopackHmr;\n    }\n});\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100;\nclass TurbopackHmr {\n    #updatedModules;\n    #startMsSinceEpoch;\n    #lastUpdateMsSinceEpoch;\n    #deferredReportHmrStartId;\n    #reportedHmrStart;\n    constructor(){\n        this.#updatedModules = new Set();\n        this.#reportedHmrStart = false;\n    }\n    // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n    // as it reports *any* compilation, including fully no-op/cached compilations\n    // and those unrelated to HMR. Fixing this would require significant\n    // architectural changes.\n    //\n    // Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n    // a BUILT event within that threshold and nothing has changed, just suppress\n    // the message entirely.\n    #runDeferredReportHmrStart() {\n        if (this.#deferredReportHmrStartId != null) {\n            console.log('[Fast Refresh] rebuilding');\n            this.#reportedHmrStart = true;\n            this.#cancelDeferredReportHmrStart();\n        }\n    }\n    #cancelDeferredReportHmrStart() {\n        clearTimeout(this.#deferredReportHmrStartId);\n        this.#deferredReportHmrStartId = undefined;\n    }\n    onBuilding() {\n        this.#lastUpdateMsSinceEpoch = undefined;\n        this.#cancelDeferredReportHmrStart();\n        this.#startMsSinceEpoch = Date.now();\n        // report the HMR start after a short delay\n        this.#deferredReportHmrStartId = setTimeout(()=>this.#runDeferredReportHmrStart(), self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS ? 0 : TURBOPACK_HMR_START_DELAY_MS);\n    }\n    /** Helper for other `onEvent` methods. */ #onUpdate() {\n        this.#runDeferredReportHmrStart();\n        this.#lastUpdateMsSinceEpoch = Date.now();\n    }\n    onTurbopackMessage(msg) {\n        this.#onUpdate();\n        const updatedModules = extractModulesFromTurbopackMessage(msg.data);\n        for (const module1 of updatedModules){\n            this.#updatedModules.add(module1);\n        }\n    }\n    onServerComponentChanges() {\n        this.#onUpdate();\n    }\n    onReloadPage() {\n        this.#onUpdate();\n    }\n    onPageAddRemove() {\n        this.#onUpdate();\n    }\n    /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */ onBuilt() {\n        // Check that we got *any* `TurbopackMessage`, even if\n        // `updatedModules` is empty (not everything gets recorded there).\n        //\n        // There's also a case where `onBuilt` gets called before `onBuilding`,\n        // which can happen during initial page load. Ignore that too!\n        const hasUpdates = this.#lastUpdateMsSinceEpoch != null && this.#startMsSinceEpoch != null;\n        if (!hasUpdates && !this.#reportedHmrStart) {\n            // suppress the update entirely\n            this.#cancelDeferredReportHmrStart();\n            return null;\n        }\n        this.#runDeferredReportHmrStart();\n        const result = {\n            hasUpdates,\n            updatedModules: this.#updatedModules,\n            startMsSinceEpoch: this.#startMsSinceEpoch,\n            endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now()\n        };\n        this.#updatedModules = new Set();\n        this.#reportedHmrStart = false;\n        return result;\n    }\n}\nfunction extractModulesFromTurbopackMessage(data) {\n    const updatedModules = new Set();\n    const updates = Array.isArray(data) ? data : [\n        data\n    ];\n    for (const update of updates){\n        // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n        if (update.type !== 'partial' || update.instruction.type !== 'ChunkListUpdate' || update.instruction.merged === undefined) {\n            continue;\n        }\n        for (const mergedUpdate of update.instruction.merged){\n            for (const name of Object.keys(mergedUpdate.entries)){\n                const res = /(.*)\\s+[([].*/.exec(name);\n                if (res === null) {\n                    continue;\n                }\n                updatedModules.add(res[1]);\n            }\n        }\n    }\n    return updatedModules;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=turbopack-hot-reloader-common.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/debug-channel.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createDebugChannel: null,\n    getOrCreateDebugChannelReadableWriterPair: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDebugChannel: function() {\n        return createDebugChannel;\n    },\n    getOrCreateDebugChannelReadableWriterPair: function() {\n        return getOrCreateDebugChannelReadableWriterPair;\n    }\n});\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nconst _invarianterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)\");\nconst pairs = new Map();\nfunction getOrCreateDebugChannelReadableWriterPair(requestId) {\n    let pair = pairs.get(requestId);\n    if (!pair) {\n        const { readable, writable } = new TransformStream();\n        pair = {\n            readable,\n            writer: writable.getWriter()\n        };\n        pairs.set(requestId, pair);\n        pair.writer.closed.finally(()=>pairs.delete(requestId));\n    }\n    return pair;\n}\nfunction createDebugChannel(requestHeaders) {\n    let requestId;\n    if (requestHeaders) {\n        requestId = requestHeaders[_approuterheaders.NEXT_REQUEST_ID_HEADER] ?? undefined;\n        if (!requestId) {\n            throw Object.defineProperty(new _invarianterror.InvariantError(`Expected a ${JSON.stringify(_approuterheaders.NEXT_REQUEST_ID_HEADER)} request header.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E854\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    } else {\n        requestId = self.__next_r;\n        if (!requestId) {\n            throw Object.defineProperty(new _invarianterror.InvariantError(`Expected a request ID to be defined for the document via self.__next_r.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E806\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    const { readable } = getOrCreateDebugChannelReadableWriterPair(requestId);\n    return {\n        readable\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=debug-channel.js.map\n}),\n\"[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n/// <reference types=\"webpack/module.d.ts\" />\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    performFullReload: null,\n    processMessage: null,\n    waitForWebpackRuntimeHotUpdate: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return HotReload;\n    },\n    performFullReload: function() {\n        return performFullReload;\n    },\n    processMessage: function() {\n        return processMessage;\n    },\n    waitForWebpackRuntimeHotUpdate: function() {\n        return waitForWebpackRuntimeHotUpdate;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\");\nconst _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-client] (ecmascript)\"));\nconst _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-client] (ecmascript)\"));\nconst _shared = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-client] (ecmascript)\");\nconst _nextdevtools = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/next-devtools/index.js (raw)\");\nconst _replayssronlyerrors = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-client] (ecmascript)\");\nconst _appdevoverlayerrorboundary = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-client] (ecmascript)\");\nconst _useerrorhandler = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)\");\nconst _runtimeerrorhandler = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-client] (ecmascript)\");\nconst _websocket = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/app/web-socket.js [app-client] (ecmascript)\");\nconst _hotreloadertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-client] (ecmascript)\");\nconst _navigationuntracked = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)\");\nconst _reporthmrlatency = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-client] (ecmascript)\"));\nconst _turbopackhotreloadercommon = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-client] (ecmascript)\");\nconst _approuterheaders = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)\");\nconst _approuterinstance = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)\");\nconst _invarianterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)\");\nconst _debugchannel = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/debug-channel.js [app-client] (ecmascript)\");\nconst _client = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)\");\nconst _appfindsourcemapurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)\");\nconst createFromReadableStream = _client.createFromReadableStream;\nlet mostRecentCompilationHash = null;\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nlet reloading = false;\nlet webpackStartMsSinceEpoch = null;\nconst turbopackHmr = (\"TURBOPACK compile-time truthy\", 1) ? new _turbopackhotreloadercommon.TurbopackHmr() : \"TURBOPACK unreachable\";\nlet pendingHotUpdateWebpack = Promise.resolve();\nlet resolvePendingHotUpdateWebpack = ()=>{};\nfunction setPendingHotUpdateWebpack() {\n    pendingHotUpdateWebpack = new Promise((resolve)=>{\n        resolvePendingHotUpdateWebpack = ()=>{\n            resolve();\n        };\n    });\n}\nfunction waitForWebpackRuntimeHotUpdate() {\n    return pendingHotUpdateWebpack;\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */ function isUpdateAvailable() {\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        return true;\n    }\n    //TURBOPACK unreachable\n    ;\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === 'idle';\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === 'idle') {\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        module.hot.addStatusHandler(handler);\n    }\n}\nfunction performFullReload(err, sendMessage) {\n    const stackTrace = err && (err.stack && err.stack.split('\\n').slice(0, 5).join('\\n') || err.message || err + '');\n    sendMessage(JSON.stringify({\n        event: 'client-full-reload',\n        stackTrace,\n        hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,\n        dependencyChain: err ? err.dependencyChain : undefined\n    }));\n    if (reloading) return;\n    reloading = true;\n    window.location.reload();\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage) {\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        resolvePendingHotUpdateWebpack();\n        _nextdevtools.dispatcher.onBuildOk();\n        (0, _reporthmrlatency.default)(sendMessage, [], webpackStartMsSinceEpoch, Date.now());\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n            if (err) {\n                console.warn(_shared.REACT_REFRESH_FULL_RELOAD);\n            } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n            }\n            performFullReload(err, sendMessage);\n            return;\n        }\n        _nextdevtools.dispatcher.onBuildOk();\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            tryApplyUpdatesWebpack(sendMessage);\n            return;\n        }\n        _nextdevtools.dispatcher.onRefresh();\n        resolvePendingHotUpdateWebpack();\n        (0, _reporthmrlatency.default)(sendMessage, updatedModules, webpackStartMsSinceEpoch, Date.now());\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (updatedModules == null) {\n            return null;\n        }\n        // We should always handle an update, even if updatedModules is empty (but\n        // non-null) for any reason. That's what webpack would normally do:\n        // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n        _nextdevtools.dispatcher.onBeforeRefresh();\n        // https://webpack.js.org/api/hot-module-replacement/#apply\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\nfunction processMessage(message, sendMessage, processTurbopackMessage, staticIndicatorState) {\n    function handleErrors(errors) {\n        // \"Massage\" webpack messages.\n        const formatted = (0, _formatwebpackmessages.default)({\n            errors: errors,\n            warnings: []\n        });\n        // Only show the first error.\n        _nextdevtools.dispatcher.onBuildError(formatted.errors[0]);\n        // Also log them to the console.\n        for(let i = 0; i < formatted.errors.length; i++){\n            console.error((0, _stripansi.default)(formatted.errors[i]));\n        }\n        // Do not attempt to reload now.\n        // We will reload on next success instead.\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n    }\n    function handleHotUpdate() {\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            const hmrUpdate = turbopackHmr.onBuilt();\n            if (hmrUpdate != null) {\n                (0, _reporthmrlatency.default)(sendMessage, [\n                    ...hmrUpdate.updatedModules\n                ], hmrUpdate.startMsSinceEpoch, hmrUpdate.endMsSinceEpoch, hmrUpdate.hasUpdates);\n            }\n            _nextdevtools.dispatcher.onBuildOk();\n        } else //TURBOPACK unreachable\n        ;\n    }\n    switch(message.type){\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST:\n            {\n                if (\"TURBOPACK compile-time truthy\", 1) {\n                    staticIndicatorState.appIsrManifest = message.data;\n                    // Handle the initial static indicator status on receiving the ISR\n                    // manifest. Navigation is handled in an effect inside HotReload for\n                    // pathname changes as we'll receive the updated manifest before\n                    // usePathname triggers for a new value.\n                    const isStatic = staticIndicatorState.pathname ? message.data[staticIndicatorState.pathname] : undefined;\n                    _nextdevtools.dispatcher.onStaticIndicator(isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic');\n                }\n                break;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.BUILDING:\n            {\n                _nextdevtools.dispatcher.buildingIndicatorShow();\n                if (\"TURBOPACK compile-time truthy\", 1) {\n                    turbopackHmr.onBuilding();\n                } else //TURBOPACK unreachable\n                ;\n                break;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SYNC:\n            {\n                _nextdevtools.dispatcher.buildingIndicatorHide();\n                if (message.hash) {\n                    handleAvailableHash(message.hash);\n                }\n                const { errors, warnings } = message;\n                // Is undefined when it's a 'built' event\n                if ('versionInfo' in message) _nextdevtools.dispatcher.onVersionInfo(message.versionInfo);\n                if ('debug' in message && message.debug) _nextdevtools.dispatcher.onDebugInfo(message.debug);\n                if ('devIndicator' in message) _nextdevtools.dispatcher.onDevIndicator(message.devIndicator);\n                if ('devToolsConfig' in message) _nextdevtools.dispatcher.onDevToolsConfig(message.devToolsConfig);\n                const hasErrors = Boolean(errors && errors.length);\n                // Compilation with errors (e.g. syntax error or missing modules).\n                if (hasErrors) {\n                    sendMessage(JSON.stringify({\n                        event: 'client-error',\n                        errorCount: errors.length,\n                        clientId: __nextDevClientId\n                    }));\n                    handleErrors(errors);\n                    return;\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    sendMessage(JSON.stringify({\n                        event: 'client-warning',\n                        warningCount: warnings.length,\n                        clientId: __nextDevClientId\n                    }));\n                    // Print warnings to the console.\n                    const formattedMessages = (0, _formatwebpackmessages.default)({\n                        warnings: warnings,\n                        errors: []\n                    });\n                    for(let i = 0; i < formattedMessages.warnings.length; i++){\n                        if (i === 5) {\n                            console.warn('There were more warnings in other files.\\n' + 'You can find a complete log in the terminal.');\n                            break;\n                        }\n                        console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));\n                    }\n                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n                }\n                sendMessage(JSON.stringify({\n                    event: 'client-success',\n                    clientId: __nextDevClientId\n                }));\n                if (message.type === _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n                    handleHotUpdate();\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED:\n            {\n                processTurbopackMessage({\n                    type: _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n                    data: {\n                        sessionId: message.data.sessionId\n                    }\n                });\n                break;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE:\n            {\n                turbopackHmr.onTurbopackMessage(message);\n                _nextdevtools.dispatcher.onBeforeRefresh();\n                processTurbopackMessage({\n                    type: _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n                    data: message.data\n                });\n                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                    console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n                    performFullReload(null, sendMessage);\n                }\n                _nextdevtools.dispatcher.onRefresh();\n                break;\n            }\n        // TODO-APP: make server component change more granular\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:\n            {\n                turbopackHmr?.onServerComponentChanges();\n                sendMessage(JSON.stringify({\n                    event: 'server-component-reload-page',\n                    clientId: __nextDevClientId,\n                    hash: message.hash\n                }));\n                // Store the latest hash in a session cookie so that it's sent back to the\n                // server with any subsequent requests.\n                document.cookie = `${_approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`;\n                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || document.documentElement.id === '__next_error__') {\n                    if (reloading) return;\n                    reloading = true;\n                    return window.location.reload();\n                }\n                (0, _react.startTransition)(()=>{\n                    _approuterinstance.publicAppRouterInstance.hmrRefresh();\n                    _nextdevtools.dispatcher.onRefresh();\n                });\n                if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n                ;\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE:\n            {\n                turbopackHmr?.onReloadPage();\n                sendMessage(JSON.stringify({\n                    event: 'client-reload-page',\n                    clientId: __nextDevClientId\n                }));\n                if (reloading) return;\n                reloading = true;\n                return window.location.reload();\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE:\n            {\n                turbopackHmr?.onPageAddRemove();\n                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n                return _approuterinstance.publicAppRouterInstance.hmrRefresh();\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR:\n            {\n                const { errorJSON } = message;\n                if (errorJSON) {\n                    const errorObject = JSON.parse(errorJSON);\n                    const error = Object.defineProperty(new Error(errorObject.message), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    error.stack = errorObject.stack;\n                    handleErrors([\n                        error\n                    ]);\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:\n            {\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG:\n            {\n                _nextdevtools.dispatcher.onDevToolsConfig(message.data);\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK:\n            {\n                const { requestId, chunk } = message;\n                const { writer } = (0, _debugchannel.getOrCreateDebugChannelReadableWriterPair)(requestId);\n                if (chunk) {\n                    writer.ready.then(()=>writer.write(chunk)).catch(console.error);\n                } else {\n                    // A null chunk signals that no more chunks will be sent, which allows\n                    // us to close the writer.\n                    // TODO: Revisit this cleanup logic when we integrate the return channel\n                    // that keeps the connection open to be able to lazily retrieve debug\n                    // objects.\n                    writer.ready.then(()=>writer.close()).catch(console.error);\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE:\n            {\n                const errorState = (0, _nextdevtools.getSerializedOverlayState)();\n                const response = {\n                    event: _hotreloadertypes.HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n                    requestId: message.requestId,\n                    errorState,\n                    url: window.location.href\n                };\n                sendMessage(JSON.stringify(response));\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA:\n            {\n                const segmentTrieData = (0, _nextdevtools.getSegmentTrieData)();\n                const response = {\n                    event: _hotreloadertypes.HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n                    requestId: message.requestId,\n                    segmentTrieData,\n                    url: window.location.href\n                };\n                sendMessage(JSON.stringify(response));\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR:\n            {\n                _nextdevtools.dispatcher.onCacheIndicator(message.state);\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER:\n            {\n                createFromReadableStream(new ReadableStream({\n                    start (controller) {\n                        controller.enqueue(message.serializedErrors);\n                        controller.close();\n                    }\n                }), {\n                    findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n                }).then((errors)=>{\n                    for (const error of errors){\n                        console.error(error);\n                    }\n                }, (err)=>{\n                    console.error(Object.defineProperty(new Error('Failed to deserialize errors.', {\n                        cause: err\n                    }), \"__NEXT_ERROR_CODE\", {\n                        value: \"E946\",\n                        enumerable: false,\n                        configurable: true\n                    }));\n                });\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n            break;\n        default:\n            {\n                message;\n            }\n    }\n}\nfunction HotReload({ children, globalError, webSocket, staticIndicatorState }) {\n    (0, _useerrorhandler.useErrorHandler)(_nextdevtools.dispatcher.onUnhandledError, _nextdevtools.dispatcher.onUnhandledRejection);\n    (0, _websocket.useWebSocketPing)(webSocket);\n    // We don't want access of the pathname for the dev tools to trigger a dynamic\n    // access (as the dev overlay will never be present in production).\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        // this conditional is only for dead-code elimination which\n        // isn't a runtime conditional only build-time so ignore hooks rule\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            if (!staticIndicatorState) {\n                throw Object.defineProperty(new _invarianterror.InvariantError('Expected staticIndicatorState to be defined in dev mode.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E786\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            staticIndicatorState.pathname = pathname;\n            if (staticIndicatorState.appIsrManifest) {\n                const isStatic = pathname ? staticIndicatorState.appIsrManifest[pathname] : undefined;\n                _nextdevtools.dispatcher.onStaticIndicator(isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic');\n            }\n        }, [\n            pathname,\n            staticIndicatorState\n        ]);\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {\n        globalError: globalError,\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_replayssronlyerrors.ReplaySsrOnlyErrors, {\n                onBlockingError: _nextdevtools.dispatcher.openErrorOverlay\n            }),\n            children\n        ]\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hot-reloader-app.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return AppRouter;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _interop_require_wildcard = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _approutercontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _routerreducertypes = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)\");\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _hooksclientcontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _useactionqueue = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)\");\nconst _approuterannouncer = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-client] (ecmascript)\");\nconst _redirectboundary = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)\");\nconst _findheadincache = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-client] (ecmascript)\");\nconst _unresolvedthenable = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)\");\nconst _removebasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/remove-base-path.js [app-client] (ecmascript)\");\nconst _hasbasepath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)\");\nconst _computechangedpath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)\");\nconst _navfailurehandler = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-client] (ecmascript)\");\nconst _approuterinstance = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)\");\nconst _redirect = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)\");\nconst _redirecterror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)\");\nconst _links = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)\");\nconst _rooterrorboundary = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/errors/root-error-boundary.js [app-client] (ecmascript)\"));\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)\"));\nconst _boundarycomponents = __turbopack_context__.r(\"[project]/node_modules/next/dist/lib/framework/boundary-components.js [app-client] (ecmascript)\");\nconst _deploymentid = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/deployment-id.js [app-client] (ecmascript)\");\nconst globalMutable = {};\nfunction HistoryUpdater({ appRouterState }) {\n    (0, _react.useInsertionEffect)(()=>{\n        if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n        ;\n        const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState;\n        const appHistoryState = {\n            tree,\n            renderedSearch\n        };\n        // TODO: Use Navigation API if available\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        (0, _links.pingVisibleLinks)(appRouterState.nextUrl, appRouterState.tree);\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState?.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head({ headCacheNode }) {\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n/**\n * The global router that wraps the application components.\n */ function Router({ actionQueue, globalError, webSocket, staticIndicatorState }) {\n    const state = (0, _useactionqueue.useActionQueue)(actionQueue);\n    const { canonicalUrl } = state;\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl, typeof window === 'undefined' ? 'http://n' : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { cache, tree } = state;\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: _approuterinstance.publicAppRouterInstance,\n                cache,\n                tree\n            };\n        }, [\n            cache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            if (!event.persisted || !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, []);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                // TODO: This should access the router methods directly, rather than\n                // go through the public interface.\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    _approuterinstance.publicAppRouterInstance.push(url, {});\n                } else {\n                    _approuterinstance.publicAppRouterInstance.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, []);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = state;\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location = window.location;\n            if (pushRef.pendingPush) {\n                location.assign(canonicalUrl);\n            } else {\n                location.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        // NOTE: This is intentionally using `throw` instead of `use` because we're\n        // inside an externally mutable condition (pushRef.mpaNavigation), which\n        // violates the rules of hooks.\n        throw _unresolvedthenable.unresolvedThenable;\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            const href = window.location.href;\n            const appHistoryState = window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url ?? href, href),\n                    historyState: appHistoryState\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, []);\n    const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state;\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    // Create instrumented promises for navigation hooks (dev-only)\n    // These are specially instrumented promises to show in the Suspense DevTools\n    // Promises are cached outside of render to survive suspense retries.\n    let instrumentedNavigationPromises = null;\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { createRootNavigationPromises } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/navigation-devtools.js [app-client] (ecmascript)\");\n        instrumentedNavigationPromises = createRootNavigationPromises(tree, pathname, searchParams, pathParams);\n    }\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            parentParams: {},\n            // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n            // It represents the root of the app.\n            debugNameContext: '/',\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            // Root segment is always active\n            isActive: true\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            tree,\n            focusAndScrollRef,\n            nextUrl,\n            previousNextUrl\n        };\n    }, [\n        tree,\n        focusAndScrollRef,\n        nextUrl,\n        previousNextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        }, typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {\n                children: cache.rsc\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (typeof window !== 'undefined') {\n            const { DevRootHTTPAccessFallbackBoundary } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js [app-client] (ecmascript)\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-client] (ecmascript)\").default;\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            globalError: globalError,\n            webSocket: webSocket,\n            staticIndicatorState: staticIndicatorState,\n            children: content\n        });\n    } else //TURBOPACK unreachable\n    ;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: state\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.NavigationPromisesContext.Provider, {\n                value: instrumentedNavigationPromises,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                    value: pathParams,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                        value: pathname,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                            value: searchParams,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                                value: globalLayoutRouterContext,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                    value: _approuterinstance.publicAppRouterInstance,\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                        value: layoutRouterContext,\n                                        children: content\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\nfunction AppRouter({ actionQueue, globalErrorState, webSocket, staticIndicatorState }) {\n    (0, _navfailurehandler.useNavFailureHandler)();\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n        actionQueue: actionQueue,\n        globalError: globalErrorState,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    // At the very top level, use the default GlobalError component as the final fallback.\n    // When the app router itself fails, which means the framework itself fails, we show the default error.\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n        errorComponent: _globalerror.default,\n        children: router\n    });\n}\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId = (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: `${href}${dplId}`,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\n}),\n\"[project]/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createInitialRouterState\", {\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n});\nconst _createhreffromurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)\");\nconst _computechangedpath = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)\");\nconst _flightdatahelpers = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)\");\nconst _pprnavigations = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)\");\nfunction createInitialRouterState({ navigatedAt, initialFlightData, initialCanonicalUrlParts, initialRenderedSearch, location }) {\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    const initialState = {\n        tree: initialTree,\n        cache: (0, _pprnavigations.createInitialCacheNodeForHydration)(navigatedAt, initialTree, initialSeedData, initialHead),\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        renderedSearch: initialRenderedSearch,\n        nextUrl: ((0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || location?.pathname) ?? null,\n        previousNextUrl: null,\n        debugInfo: null\n    };\n    return initialState;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-link-gc.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"linkGc\", {\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n});\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            const link = node;\n                            if (link.dataset.precedence?.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            if (otherLink.dataset.precedence?.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector(`link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`);\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-index.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hydrate\", {\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n});\nconst _interop_require_default = __turbopack_context__.r(\"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)\");\nconst _jsxruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)\");\n__turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-globals.js [app-client] (ecmascript)\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react-dom/client.js [app-client] (ecmascript)\"));\nconst _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)\"));\nconst _client1 = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)\");\nconst _headmanagercontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _onrecoverableerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [app-client] (ecmascript)\");\nconst _errorboundarycallbacks = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js [app-client] (ecmascript)\");\nconst _appcallserver = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)\");\nconst _appfindsourcemapurl = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)\");\nconst _approuterinstance = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)\"));\nconst _createinitialrouterstate = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js [app-client] (ecmascript)\");\nconst _approutercontextsharedruntime = __turbopack_context__.r(\"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)\");\nconst _appbuildid = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)\");\nconst _flightdatahelpers = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)\");\n/// <reference types=\"react-dom/experimental\" />\nconst createFromReadableStream = _client1.createFromReadableStream;\nconst createFromFetch = _client1.createFromFetch;\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.length = 0;\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nif (\"TURBOPACK compile-time truthy\", 1) {\n    // @ts-expect-error\n    readable.name = 'hydration';\n}\nlet debugChannel;\nif (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n;\nconst clientResumeFetch = window.__NEXT_CLIENT_RESUME;\nlet initialServerResponse;\nif (clientResumeFetch) {\n    initialServerResponse = Promise.resolve(createFromFetch(clientResumeFetch, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel\n    })).then(async (fallbackInitialRSCPayload)=>(0, _flightdatahelpers.createInitialRSCPayloadFromFallbackPrerender)(await clientResumeFetch, fallbackInitialRSCPayload));\n} else {\n    initialServerResponse = createFromReadableStream(readable, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel,\n        startTime: 0\n    });\n}\nfunction ServerRoot({ initialRSCPayload, actionQueue, webSocket, staticIndicatorState }) {\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorState: initialRSCPayload.G,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    if ((\"TURBOPACK compile-time value\", \"development\") === 'development' && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\nconst StrictModeIfEnabled = (\"TURBOPACK compile-time truthy\", 1) ? _react.default.StrictMode : \"TURBOPACK unreachable\";\nfunction Root({ children }) {\n    if (\"TURBOPACK compile-time falsy\", 0) //TURBOPACK unreachable\n    ;\n    return children;\n}\nconst enableTransitionIndicator = (\"TURBOPACK compile-time value\", false);\nfunction noDefaultTransitionIndicator() {\n    return ()=>{};\n}\nconst reactRootOptions = {\n    onDefaultTransitionIndicator: (\"TURBOPACK compile-time falsy\", 0) ? \"TURBOPACK unreachable\" : noDefaultTransitionIndicator,\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nasync function hydrate(instrumentationHooks, assetPrefix) {\n    let staticIndicatorState;\n    let webSocket;\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { createWebSocket } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/dev/hot-reloader/app/web-socket.js [app-client] (ecmascript)\");\n        staticIndicatorState = {\n            pathname: null,\n            appIsrManifest: null\n        };\n        webSocket = createWebSocket(assetPrefix, staticIndicatorState);\n    }\n    const initialRSCPayload = await initialServerResponse;\n    // setAppBuildId should be called only once, during JS initialization\n    // and before any components have hydrated.\n    (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n    const initialTimestamp = Date.now();\n    const actionQueue = (0, _approuterinstance.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n        navigatedAt: initialTimestamp,\n        initialFlightData: initialRSCPayload.f,\n        initialCanonicalUrlParts: initialRSCPayload.c,\n        initialRenderedSearch: initialRSCPayload.q,\n        location: window.location\n    }), instrumentationHooks);\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {\n                    initialRSCPayload: initialRSCPayload,\n                    actionQueue: actionQueue,\n                    webSocket: webSocket,\n                    staticIndicatorState: staticIndicatorState\n                })\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__') {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            const { RootLevelDevOverlayElement } = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/client-entry.js [app-client] (ecmascript)\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = /*#__PURE__*/ (0, _jsxruntime.jsx)(RootLevelDevOverlayElement, {\n                children: element\n            });\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        const { linkGc } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-link-gc.js [app-client] (ecmascript)\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\n}),\n\"[project]/node_modules/next/dist/client/app-next-turbopack.js [app-client] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n\"use strict\";\n\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i(\"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)\");\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nconst _appbootstrap = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-bootstrap.js [app-client] (ecmascript)\");\nconst _onrecoverableerror = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [app-client] (ecmascript)\");\nwindow.next.turbopack = true;\nself.__webpack_hash__ = '';\n// eslint-disable-next-line @next/internal/typechecked-require\nconst instrumentationHooks = __turbopack_context__.r(\"[project]/node_modules/next/dist/lib/require-instrumentation-client.js [app-client] (ecmascript)\");\n(0, _appbootstrap.appBootstrap)((assetPrefix)=>{\n    const { hydrate } = __turbopack_context__.r(\"[project]/node_modules/next/dist/client/app-index.js [app-client] (ecmascript)\");\n    try {\n        hydrate(instrumentationHooks, assetPrefix);\n    } finally{\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            const enableCacheIndicator = (\"TURBOPACK compile-time value\", false);\n            const { getOwnerStack } = __turbopack_context__.r(\"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)\");\n            const { renderAppDevOverlay } = __turbopack_context__.r(\"[project]/node_modules/next/dist/compiled/next-devtools/index.js (raw)\");\n            renderAppDevOverlay(getOwnerStack, _onrecoverableerror.isRecoverableError, enableCacheIndicator);\n        }\n    }\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-next-turbopack.js.map\n}),\n]);\n\n//# sourceMappingURL=node_modules_next_dist_client_17643121._.js.map","sourceMap":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/asset-prefix.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/set-attributes-from-props.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-bootstrap.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/react-client-callbacks/report-global-error.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/react-client-callbacks/on-recoverable-error.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect-status-code.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect-error.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/is-next-router-error.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/lib/console.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-globals.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/readonly-url-search-params.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-headers.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation-untracked.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/nav-failure-handler.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/handle-isr-error.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/error-boundary.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/builtin/global-error.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/runtime-error-handler.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/not-found.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/react-client-callbacks/error-boundary-callbacks.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/use-action-queue.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-call-server.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-find-source-map-url.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/match-segments.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/handle-mutable.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/route-params.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/flight-data-helpers.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-build-id.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/types.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/lru.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/cache-map.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/vary-path.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/cache-key.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/scheduler.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/normalize-trailing-slash.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/add-base-path.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-utils.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/links.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/cache.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/navigation.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unrecognized-action-error.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/assign-location.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/has-base-path.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/remove-base-path.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/router-reducer.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/prefetch.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-instance.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-announcer.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/forbidden.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unauthorized.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unstable-rethrow.browser.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/hooks-server-context.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/static-generation-bailout.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unstable-rethrow.server.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unstable-rethrow.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation.react-server.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect-boundary.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unresolved-thenable.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/errors/graceful-degrade-boundary.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/errors/root-error-boundary.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation-devtools.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/dev-root-http-access-fallback-boundary.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/shared.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/get-socket-url.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/app/web-socket.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/report-hmr-latency.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/turbopack-hot-reloader-common.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/debug-channel.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/app/hot-reloader-app.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/create-initial-router-state.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-link-gc.ts","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-index.tsx","file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-next-turbopack.ts"],"sections":[{"offset":{"line":4,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/asset-prefix.ts"],"sourcesContent":["import { InvariantError } from '../shared/lib/invariant-error'\n\nexport function getAssetPrefix() {\n  const currentScript = document.currentScript\n\n  if (!(currentScript instanceof HTMLScriptElement)) {\n    throw new InvariantError(\n      `Expected document.currentScript to be a <script> element. Received ${currentScript} instead.`\n    )\n  }\n\n  const { pathname } = new URL(currentScript.src)\n  const nextIndex = pathname.indexOf('/_next/')\n\n  if (nextIndex === -1) {\n    throw new InvariantError(\n      `Expected document.currentScript src to contain '/_next/'. Received ${currentScript.src} instead.`\n    )\n  }\n\n  return pathname.slice(0, nextIndex)\n}\n"],"names":["getAssetPrefix","currentScript","document","HTMLScriptElement","InvariantError","pathname","URL","src","nextIndex","indexOf","slice"],"mappings":";;;+BAEgBA,kBAAAA;;;eAAAA;;;gCAFe;AAExB,SAASA;IACd,MAAMC,gBAAgBC,SAASD,aAAa;IAE5C,IAAI,CAAEA,CAAAA,yBAAyBE,iBAAgB,GAAI;QACjD,MAAM,OAAA,cAEL,CAFK,IAAIC,gBAAAA,cAAc,CACtB,CAAC,mEAAmE,EAAEH,cAAc,SAAS,CAAC,GAD1F,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAM,EAAEI,QAAQ,EAAE,GAAG,IAAIC,IAAIL,cAAcM,GAAG;IAC9C,MAAMC,YAAYH,SAASI,OAAO,CAAC;IAEnC,IAAID,cAAc,CAAC,GAAG;QACpB,MAAM,OAAA,cAEL,CAFK,IAAIJ,gBAAAA,cAAc,CACtB,CAAC,mEAAmE,EAAEH,cAAcM,GAAG,CAAC,SAAS,CAAC,GAD9F,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAOF,SAASK,KAAK,CAAC,GAAGF;AAC3B","ignoreList":[0]}},{"offset":{"line":45,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/set-attributes-from-props.ts"],"sourcesContent":["const DOMAttributeNames: Record<string, string> = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv',\n  noModule: 'noModule',\n}\n\nconst ignoreProps = [\n  'onLoad',\n  'onReady',\n  'dangerouslySetInnerHTML',\n  'children',\n  'onError',\n  'strategy',\n  'stylesheets',\n]\n\nfunction isBooleanScriptAttribute(\n  attr: string\n): attr is 'async' | 'defer' | 'noModule' {\n  return ['async', 'defer', 'noModule'].includes(attr)\n}\n\nexport function setAttributesFromProps(el: HTMLElement, props: object) {\n  for (const [p, value] of Object.entries(props)) {\n    if (!props.hasOwnProperty(p)) continue\n    if (ignoreProps.includes(p)) continue\n\n    // we don't render undefined props to the DOM\n    if (value === undefined) {\n      continue\n    }\n\n    const attr = DOMAttributeNames[p] || p.toLowerCase()\n\n    if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n      // Correctly assign boolean script attributes\n      // https://github.com/vercel/next.js/pull/20748\n      ;(el as HTMLScriptElement)[attr] = !!value\n    } else {\n      el.setAttribute(attr, String(value))\n    }\n\n    // Remove falsy non-zero boolean attributes so they are correctly interpreted\n    // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n    if (\n      value === false ||\n      (el.tagName === 'SCRIPT' &&\n        isBooleanScriptAttribute(attr) &&\n        (!value || value === 'false'))\n    ) {\n      // Call setAttribute before, as we need to set and unset the attribute to override force async:\n      // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n      el.setAttribute(attr, '')\n      el.removeAttribute(attr)\n    }\n  }\n}\n"],"names":["setAttributesFromProps","DOMAttributeNames","acceptCharset","className","htmlFor","httpEquiv","noModule","ignoreProps","isBooleanScriptAttribute","attr","includes","el","props","p","value","Object","entries","hasOwnProperty","undefined","toLowerCase","tagName","setAttribute","String","removeAttribute"],"mappings":";;;+BAwBgBA,0BAAAA;;;eAAAA;;;AAxBhB,MAAMC,oBAA4C;IAChDC,eAAe;IACfC,WAAW;IACXC,SAAS;IACTC,WAAW;IACXC,UAAU;AACZ;AAEA,MAAMC,cAAc;IAClB;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,yBACPC,IAAY;IAEZ,OAAO;QAAC;QAAS;QAAS;KAAW,CAACC,QAAQ,CAACD;AACjD;AAEO,SAAST,uBAAuBW,EAAe,EAAEC,KAAa;IACnE,KAAK,MAAM,CAACC,GAAGC,MAAM,IAAIC,OAAOC,OAAO,CAACJ,OAAQ;QAC9C,IAAI,CAACA,MAAMK,cAAc,CAACJ,IAAI;QAC9B,IAAIN,YAAYG,QAAQ,CAACG,IAAI;QAE7B,6CAA6C;QAC7C,IAAIC,UAAUI,WAAW;YACvB;QACF;QAEA,MAAMT,OAAOR,iBAAiB,CAACY,EAAE,IAAIA,EAAEM,WAAW;QAElD,IAAIR,GAAGS,OAAO,KAAK,YAAYZ,yBAAyBC,OAAO;YAC7D,6CAA6C;YAC7C,+CAA+C;;YAC7CE,EAAwB,CAACF,KAAK,GAAG,CAAC,CAACK;QACvC,OAAO;YACLH,GAAGU,YAAY,CAACZ,MAAMa,OAAOR;QAC/B;QAEA,6EAA6E;QAC7E,2GAA2G;QAC3G,IACEA,UAAU,SACTH,GAAGS,OAAO,KAAK,YACdZ,yBAAyBC,SACxB,CAAA,CAACK,SAASA,UAAU,OAAM,GAC7B;YACA,+FAA+F;YAC/F,2EAA2E;YAC3EH,GAAGU,YAAY,CAACZ,MAAM;YACtBE,GAAGY,eAAe,CAACd;QACrB;IACF;AACF","ignoreList":[0]}},{"offset":{"line":115,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-bootstrap.ts"],"sourcesContent":["/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */\n\nimport { getAssetPrefix } from './asset-prefix'\nimport { setAttributesFromProps } from './set-attributes-from-props'\n\nconst version = process.env.__NEXT_VERSION\n\nwindow.next = {\n  version,\n  appDir: true,\n}\n\nfunction loadScriptsInSequence(\n  scripts: [src: string, props: { [prop: string]: any }][],\n  hydrate: () => void\n) {\n  if (!scripts || !scripts.length) {\n    return hydrate()\n  }\n\n  return scripts\n    .reduce((promise, [src, props]) => {\n      return promise.then(() => {\n        return new Promise<void>((resolve, reject) => {\n          const el = document.createElement('script')\n\n          if (props) {\n            setAttributesFromProps(el, props)\n          }\n\n          if (src) {\n            el.src = src\n            el.onload = () => resolve()\n            el.onerror = reject\n          } else if (props) {\n            el.innerHTML = props.children\n            setTimeout(resolve)\n          }\n\n          document.head.appendChild(el)\n        })\n      })\n    }, Promise.resolve())\n    .catch((err: Error) => {\n      console.error(err)\n      // Still try to hydrate even if there's an error.\n    })\n    .then(() => {\n      hydrate()\n    })\n}\n\nexport function appBootstrap(hydrate: (assetPrefix: string) => void) {\n  const assetPrefix = getAssetPrefix()\n\n  loadScriptsInSequence((self as any).__next_s, () => {\n    // If the static shell is being debugged, skip hydration if the\n    // `__nextppronly` query is present. This is only enabled when the\n    // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n    // set to `1`. Otherwise the following is optimized out.\n    if (process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1') {\n      const search = new URLSearchParams(window.location.search)\n      if (\n        search.get('__nextppronly') === 'fallback' ||\n        search.get('__nextppronly') === '1'\n      ) {\n        console.warn(\n          `Skipping hydration due to __nextppronly=${search.get('__nextppronly')}`\n        )\n        return\n      }\n    }\n\n    hydrate(assetPrefix)\n  })\n}\n"],"names":["appBootstrap","version","process","env","__NEXT_VERSION","window","next","appDir","loadScriptsInSequence","scripts","hydrate","length","reduce","promise","src","props","then","Promise","resolve","reject","el","document","createElement","setAttributesFromProps","onload","onerror","innerHTML","children","setTimeout","head","appendChild","catch","err","console","error","assetPrefix","getAssetPrefix","self","__next_s","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","search","URLSearchParams","location","get","warn"],"mappings":"AAiEQE,QAAQC,GAAG,CAACoC,0CAA0C,KAAK,KAAK;AAjExE;;;;;CAKC,GAAA;;;;+BAoDevC,gBAAAA;;;eAAAA;;;6BAlDe;wCACQ;AAEvC,MAAMC,UAAUC,QAAQC,GAAG,CAACC,cAAc;AAE1CC,OAAOC,IAAI,GAAG;IACZL;IACAM,QAAQ;AACV;AAEA,SAASC,sBACPC,OAAwD,EACxDC,OAAmB;IAEnB,IAAI,CAACD,WAAW,CAACA,QAAQE,MAAM,EAAE;QAC/B,OAAOD;IACT;IAEA,OAAOD,QACJG,MAAM,CAAC,CAACC,SAAS,CAACC,KAAKC,MAAM;QAC5B,OAAOF,QAAQG,IAAI,CAAC;YAClB,OAAO,IAAIC,QAAc,CAACC,SAASC;gBACjC,MAAMC,KAAKC,SAASC,aAAa,CAAC;gBAElC,IAAIP,OAAO;oBACTQ,CAAAA,GAAAA,wBAAAA,sBAAsB,EAACH,IAAIL;gBAC7B;gBAEA,IAAID,KAAK;oBACPM,GAAGN,GAAG,GAAGA;oBACTM,GAAGI,MAAM,GAAG,IAAMN;oBAClBE,GAAGK,OAAO,GAAGN;gBACf,OAAO,IAAIJ,OAAO;oBAChBK,GAAGM,SAAS,GAAGX,MAAMY,QAAQ;oBAC7BC,WAAWV;gBACb;gBAEAG,SAASQ,IAAI,CAACC,WAAW,CAACV;YAC5B;QACF;IACF,GAAGH,QAAQC,OAAO,IACjBa,KAAK,CAAC,CAACC;QACNC,QAAQC,KAAK,CAACF;IACd,iDAAiD;IACnD,GACChB,IAAI,CAAC;QACJN;IACF;AACJ;AAEO,SAASV,aAAaU,OAAsC;IACjE,MAAMyB,cAAcC,CAAAA,GAAAA,aAAAA,cAAc;IAElC5B,sBAAuB6B,KAAaC,QAAQ,EAAE;QAC5C,+DAA+D;QAC/D,kEAAkE;QAClE,uEAAuE;QACvE,wDAAwD;QACxD;;QAaA5B,QAAQyB;IACV;AACF","ignoreList":[0]}},{"offset":{"line":190,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/react-client-callbacks/report-global-error.ts"],"sourcesContent":["export const reportGlobalError =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : (error: unknown) => {\n        // TODO: Dispatch error event\n        globalThis.console.error(error)\n      }\n"],"names":["reportGlobalError","reportError","error","globalThis","console"],"mappings":";;;+BAAaA,qBAAAA;;;eAAAA;;;AAAN,MAAMA,oBACX,OAAOC,gBAAgB,aAEnB,AACAA,cACA,CAACC,2BAFyC;IAGxC,6BAA6B;IAC7BC,WAAWC,OAAO,CAACF,KAAK,CAACA;AAC3B","ignoreList":[0]}},{"offset":{"line":214,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/react-client-callbacks/on-recoverable-error.ts"],"sourcesContent":["// This module can be shared between both pages router and app router\n\nimport type { HydrationOptions } from 'react-dom/client'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport isError from '../../lib/is-error'\nimport { reportGlobalError } from './report-global-error'\n\nconst recoverableErrors = new WeakSet<Error>()\n\nexport function isRecoverableError(error: Error): boolean {\n  return recoverableErrors.has(error)\n}\n\nexport const onRecoverableError: HydrationOptions['onRecoverableError'] = (\n  error\n) => {\n  // x-ref: https://github.com/facebook/react/pull/28736\n  let cause = isError(error) && 'cause' in error ? error.cause : error\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(cause)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { decorateDevError } =\n      require('../../next-devtools/userspace/app/errors/stitched-error') as typeof import('../../next-devtools/userspace/app/errors/stitched-error')\n    const causeError = decorateDevError(cause)\n    recoverableErrors.add(causeError)\n    cause = causeError\n  }\n\n  reportGlobalError(cause)\n}\n"],"names":["isRecoverableError","onRecoverableError","recoverableErrors","WeakSet","error","has","cause","isError","isBailoutToCSRError","process","env","NODE_ENV","decorateDevError","require","causeError","add","reportGlobalError"],"mappings":"AAqBMS,QAAQC,GAAG,CAACC,QAAQ,KAAK;AArB/B,qEAAqE;;;;;;;;;;;;;;;;IASrDX,kBAAkB,EAAA;eAAlBA;;IAIHC,kBAAkB,EAAA;eAAlBA;;;;8BAVuB;kEAChB;mCACc;AAElC,MAAMC,oBAAoB,IAAIC;AAEvB,SAASH,mBAAmBI,KAAY;IAC7C,OAAOF,kBAAkBG,GAAG,CAACD;AAC/B;AAEO,MAAMH,qBAA6D,CACxEG;IAEA,sDAAsD;IACtD,IAAIE,QAAQC,CAAAA,GAAAA,SAAAA,OAAO,EAACH,UAAU,WAAWA,QAAQA,MAAME,KAAK,GAAGF;IAC/D,6EAA6E;IAC7E,IAAII,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;IAEhC,wCAA2C;QACzC,MAAM,EAAEM,gBAAgB,EAAE,GACxBC,QAAQ;QACV,MAAMC,aAAaF,iBAAiBN;QACpCJ,kBAAkBa,GAAG,CAACD;QACtBR,QAAQQ;IACV;IAEAE,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACV;AACpB","ignoreList":[0]}},{"offset":{"line":270,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","error","digest","prefix","httpStatus","split","has","Number","status"],"mappings":";;;;;;;;;;;;;;;;;IAAaA,qBAAqB,EAAA;eAArBA;;IAQAC,8BAA8B,EAAA;eAA9BA;;IAuCGC,kCAAkC,EAAA;eAAlCA;;IAPAC,2BAA2B,EAAA;eAA3BA;;IAnBAC,yBAAyB,EAAA;eAAzBA;;;AArBT,MAAMJ,wBAAwB;IACnCK,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB;AAEA,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACX;AAErC,MAAMC,iCAAiC;AAavC,SAASG,0BACdQ,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWb,kCACXO,cAAcS,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASZ,4BACdS,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASb,mCACdiB,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0]}},{"offset":{"line":344,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;+BAAYA,sBAAAA;;;eAAAA;;;AAAL,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA","ignoreList":[0]}},{"offset":{"line":370,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","RedirectStatusCode"],"mappings":";;;;;;;;;;;;;;;IAEaA,mBAAmB,EAAA;eAAnBA;;IAEDC,YAAY,EAAA;eAAZA;;IAgBIC,eAAe,EAAA;eAAfA;;;oCApBmB;AAE5B,MAAMF,sBAAsB;AAE5B,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;;AAgBL,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcG,oBAAAA,kBAAkB;AAEpC","ignoreList":[0]}},{"offset":{"line":424,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError"],"mappings":";;;+BAWgBA,qBAAAA;;;eAAAA;;;oCART;+BAC6C;AAO7C,SAASA,kBACdC,KAAc;IAEd,OAAOC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,UAAUE,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACF;AAC7D","ignoreList":[0]}},{"offset":{"line":449,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/lib/console.ts"],"sourcesContent":["import isError from '../../lib/is-error'\n\nfunction formatObject(arg: unknown, depth: number) {\n  switch (typeof arg) {\n    case 'object':\n      if (arg === null) {\n        return 'null'\n      } else if (Array.isArray(arg)) {\n        let result = '['\n        if (depth < 1) {\n          for (let i = 0; i < arg.length; i++) {\n            if (result !== '[') {\n              result += ','\n            }\n            if (Object.prototype.hasOwnProperty.call(arg, i)) {\n              result += formatObject(arg[i], depth + 1)\n            }\n          }\n        } else {\n          result += arg.length > 0 ? '...' : ''\n        }\n        result += ']'\n        return result\n      } else if (arg instanceof Error) {\n        return arg + ''\n      } else {\n        const keys = Object.keys(arg)\n        let result = '{'\n        if (depth < 1) {\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            const desc = Object.getOwnPropertyDescriptor(arg, 'key')\n            if (desc && !desc.get && !desc.set) {\n              const jsonKey = JSON.stringify(key)\n              if (jsonKey !== '\"' + key + '\"') {\n                result += jsonKey + ': '\n              } else {\n                result += key + ': '\n              }\n              result += formatObject(desc.value, depth + 1)\n            }\n          }\n        } else {\n          result += keys.length > 0 ? '...' : ''\n        }\n        result += '}'\n        return result\n      }\n    case 'string':\n      return JSON.stringify(arg)\n    case 'number':\n    case 'bigint':\n    case 'boolean':\n    case 'symbol':\n    case 'undefined':\n    case 'function':\n    default:\n      return String(arg)\n  }\n}\n\nexport function formatConsoleArgs(args: unknown[]): string {\n  let message: string\n  let idx: number\n  if (typeof args[0] === 'string') {\n    message = args[0]\n    idx = 1\n  } else {\n    message = ''\n    idx = 0\n  }\n  let result = ''\n  let startQuote = false\n  for (let i = 0; i < message.length; ++i) {\n    const char = message[i]\n    if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n      result += char\n      continue\n    }\n\n    const code = message[++i]\n    switch (code) {\n      case 'c': {\n        // TODO: We should colorize with HTML instead of turning into a string.\n        // Ignore for now.\n        result = startQuote ? `${result}]` : `[${result}`\n        startQuote = !startQuote\n        idx++\n        break\n      }\n      case 'O':\n      case 'o': {\n        result += formatObject(args[idx++], 0)\n        break\n      }\n      case 'd':\n      case 'i': {\n        result += parseInt(args[idx++] as any, 10)\n        break\n      }\n      case 'f': {\n        result += parseFloat(args[idx++] as any)\n        break\n      }\n      case 's': {\n        result += String(args[idx++])\n        break\n      }\n      default:\n        result += '%' + code\n    }\n  }\n\n  for (; idx < args.length; idx++) {\n    result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0)\n  }\n\n  return result\n}\n\nexport function parseConsoleArgs(args: unknown[]): {\n  environmentName: string | null\n  error: Error | null\n} {\n  // See\n  // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n  //\n  // Logs replayed from the server look like this:\n  // [\n  //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n  //   \"background: #e6e6e6; ...\",\n  //   \" Server \", // can also be e.g. \" Prerender \"\n  //   \"\",\n  //   Error,\n  //   \"The above error occurred in the <Page> component.\",\n  //   ...\n  // ]\n  if (\n    args.length > 3 &&\n    typeof args[0] === 'string' &&\n    args[0].startsWith('%c%s%c') &&\n    typeof args[1] === 'string' &&\n    typeof args[2] === 'string' &&\n    typeof args[3] === 'string'\n  ) {\n    const environmentName = args[2]\n    const maybeError = args[4]\n\n    return {\n      environmentName: environmentName.trim(),\n      error: isError(maybeError) ? maybeError : null,\n    }\n  }\n\n  return {\n    environmentName: null,\n    error: null,\n  }\n}\n"],"names":["formatConsoleArgs","parseConsoleArgs","formatObject","arg","depth","Array","isArray","result","i","length","Object","prototype","hasOwnProperty","call","Error","keys","key","desc","getOwnPropertyDescriptor","get","set","jsonKey","JSON","stringify","value","String","args","message","idx","startQuote","char","code","parseInt","parseFloat","startsWith","environmentName","maybeError","trim","error","isError"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":628,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-globals.ts"],"sourcesContent":["// imports polyfill from `@next/polyfill-module` after build.\nimport '../build/polyfills/polyfill-module'\n\n// Only setup devtools in development\nif (process.env.NODE_ENV !== 'production') {\n  require('../next-devtools/userspace/app/app-dev-overlay-setup') as typeof import('../next-devtools/userspace/app/app-dev-overlay-setup')\n}\n"],"names":["process","env","NODE_ENV","require"],"mappings":"AAIIA,QAAQC,GAAG,CAACC,QAAQ,KAAK;AAJ7B,6DAA6D;;;;;;AAG7D,qCAAqC;AACrC,wCAA2C;;AAE3C","ignoreList":[0]}},{"offset":{"line":650,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/readonly-url-search-params.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n"],"names":["ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA;;;;CAIC,GAED,cAAc;;;+BAaDA,2BAAAA;;;eAAAA;;;AAZb,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAMO,MAAMH,gCAAgCI;IAC3C,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF","ignoreList":[0]}},{"offset":{"line":693,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-headers.ts"],"sourcesContent":["export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n\n// TODO: Should this include nextjs in the name, like the others?\nexport const NEXT_ACTION_REVALIDATED_HEADER = 'x-action-revalidated' as const\n"],"names":["ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ACTION_REVALIDATED_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACaA,aAAa,EAAA;eAAbA;;IAiBAC,cAAc,EAAA;eAAdA;;IAeAC,4BAA4B,EAAA;eAA5BA;;IAKAC,8BAA8B,EAAA;eAA9BA;;IATAC,wBAAwB,EAAA;eAAxBA;;IAfAC,4BAA4B,EAAA;eAA5BA;;IADAC,uBAAuB,EAAA;eAAvBA;;IAsBAC,2BAA2B,EAAA;eAA3BA;;IAHAC,wBAAwB,EAAA;eAAxBA;;IAEAC,sBAAsB,EAAA;eAAtBA;;IAJAC,0BAA0B,EAAA;eAA1BA;;IACAC,2BAA2B,EAAA;eAA3BA;;IAzBAC,2BAA2B,EAAA;eAA3BA;;IAKAC,mCAAmC,EAAA;eAAnCA;;IAiBAC,6BAA6B,EAAA;eAA7BA;;IAvBAC,6BAA6B,EAAA;eAA7BA;;IAqBAC,oBAAoB,EAAA;eAApBA;;IAXAC,QAAQ,EAAA;eAARA;;IACAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,UAAU,EAAA;eAAVA;;;AAAN,MAAMA,aAAa;AACnB,MAAMnB,gBAAgB;AAItB,MAAMe,gCAAgC;AACtC,MAAMH,8BAA8B;AAKpC,MAAMC,sCACX;AACK,MAAMP,0BAA0B;AAChC,MAAMD,+BAA+B;AACrC,MAAMY,WAAW;AACjB,MAAMC,0BAA0B;AAEhC,MAAMjB,iBAAiB;IAC5BkB;IACAJ;IACAH;IACAN;IACAO;CACD;AAEM,MAAMG,uBAAuB;AAE7B,MAAMF,gCAAgC;AACtC,MAAMV,2BAA2B;AACjC,MAAMM,6BAA6B;AACnC,MAAMC,8BAA8B;AACpC,MAAMH,2BAA2B;AACjC,MAAMN,+BAA+B;AACrC,MAAMO,yBAAyB;AAC/B,MAAMF,8BAA8B;AAGpC,MAAMJ,iCAAiC","ignoreList":[0]}},{"offset":{"line":823,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation-untracked.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n"],"names":["useUntrackedPathname","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useContext","PathnameContext"],"mappings":";;;+BAqDgBA,wBAAAA;;;eAAAA;;;uBArDW;iDACK;AAEhC;;;;;;CAMC,GACD,SAASC;IACP,IAAI,OAAOC,WAAW,aAAa;QACjC,iEAAiE;QACjE,MAAM,EAAEC,oBAAoB,EAAE,GAC5BC,QAAQ;QAEV,MAAMC,gBAAgBF,qBAAqBG,QAAQ;QACnD,IAAI,CAACD,eAAe,OAAO;QAE3B,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAMC,iBAAiBH,cAAcI,mBAAmB;gBACxD,OAAOD,iBAAiBA,eAAeE,IAAI,GAAG,IAAI;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEL;QACJ;QAEA,OAAO;IACT;IAEA,OAAO;AACT;AAaO,SAASL;IACd,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAIC,0BAA0B;QAC5B,OAAO;IACT;IAEA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,OAAOU,CAAAA,GAAAA,OAAAA,UAAU,EAACC,iCAAAA,eAAe;AACnC","ignoreList":[0]}},{"offset":{"line":890,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;+BAAgBA,qBAAAA;;;eAAAA;;;AAAT,SAASA,kBACdC,GAA8C,EAC9CC,cAAuB,IAAI;IAE3B,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0]}},{"offset":{"line":913,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/nav-failure-handler.ts"],"sourcesContent":["import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n"],"names":["handleHardNavError","useNavFailureHandler","error","window","next","__pendingUrl","createHrefFromUrl","URL","location","href","console","toString","process","env","__NEXT_APP_NAV_FAIL_HANDLING","useEffect","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener"],"mappings":"AAsBMY,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;;;;;;;;;;;;;;;IAnBhCd,kBAAkB,EAAA;eAAlBA;;IAkBAC,oBAAoB,EAAA;eAApBA;;;uBArBU;mCACQ;AAE3B,SAASD,mBAAmBE,KAAc;IAC/C,IACEA,SACA,OAAOC,WAAW,eAClBA,OAAOC,IAAI,CAACC,YAAY,IACxBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAAC,IAAIC,IAAIJ,OAAOK,QAAQ,CAACC,IAAI,OAC5CH,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH,OAAOC,IAAI,CAACC,YAAY,GAC5C;QACAK,QAAQR,KAAK,CACX,CAAC,iEAAiE,CAAC,EACnEA;QAEFC,OAAOK,QAAQ,CAACC,IAAI,GAAGN,OAAOC,IAAI,CAACC,YAAY,CAACM,QAAQ;QACxD,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAASV;IACd;;AAwBF","ignoreList":[0]}},{"offset":{"line":961,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/handle-isr-error.tsx"],"sourcesContent":["const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isStaticGeneration) {\n      if (error) {\n        console.error(error)\n      }\n      throw error\n    }\n  }\n\n  return null\n}\n"],"names":["HandleISRError","workAsyncStorage","window","require","undefined","error","store","getStore","isStaticGeneration","console"],"mappings":";;;+BAUgBA,kBAAAA;;;eAAAA;;;AAVhB,MAAMC,mBACJ,OAAOC,WAAW,cAEZC,QAAQ,+HACRF,gBAAgB,GAClBG;AAKC,SAASJ,eAAe,EAAEK,KAAK,EAAkB;IACtD,IAAIJ,kBAAkB;QACpB,MAAMK,QAAQL,iBAAiBM,QAAQ;QACvC,IAAID,OAAOE,oBAAoB;YAC7B,IAAIH,OAAO;gBACTI,QAAQJ,KAAK,CAACA;YAChB;YACA,MAAMA;QACR;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},{"offset":{"line":994,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","window","isBot","navigator","userAgent","React","Component","constructor","props","reset","setState","error","state","previousPathname","pathname","getDerivedStateFromError","isNextRouterError","getDerivedStateFromProps","process","env","__NEXT_APP_NAV_FAIL_HANDLING","handleHardNavError","render","HandleISRError","errorStyles","errorScripts","this","errorComponent","children","useUntrackedPathname"],"mappings":"AAiEQoB,QAAQC,GAAG,CAACC,4BAA4B,EAAE;AAjElD;;;;;;;;;;;;;;;;IAgIgBtB,aAAa,EAAA;eAAbA;;IA5FHC,oBAAoB,EAAA;eAApBA;;;;;gEAlCmB;qCACK;mCACH;mCACC;gCACJ;uBACT;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AA0B5D,MAAML,6BAA6BM,OAAAA,OAAK,CAACC,SAAS;IAIvDC,YAAYC,KAAgC,CAAE;QAC5C,KAAK,CAACA,QAAAA,IAAAA,CAoDRC,KAAAA,GAAQ;YACN,IAAI,CAACC,QAAQ,CAAC;gBAAEC,OAAO;YAAK;QAC9B;QArDE,IAAI,CAACC,KAAK,GAAG;YAAED,OAAO;YAAME,kBAAkB,IAAI,CAACL,KAAK,CAACM,QAAQ;QAAC;IACpE;IAEA,OAAOC,yBAAyBJ,KAAY,EAAE;QAC5C,IAAIK,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACL,QAAQ;YAC5B,+DAA+D;YAC/D,4GAA4G;YAC5G,MAAMA;QACR;QAEA,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAOM,yBACLT,KAAgC,EAChCI,KAAgC,EACE;QAClC,MAAM,EAAED,KAAK,EAAE,GAAGC;QAElB,iCAAiC;QACjC,8CAA8C;QAC9C,iDAAiD;QACjD,6CAA6C;QAC7C;;QAUA;;;;;KAKC,GACD,IAAIJ,MAAMM,QAAQ,KAAKF,MAAMC,gBAAgB,IAAID,MAAMD,KAAK,EAAE;YAC5D,OAAO;gBACLA,OAAO;gBACPE,kBAAkBL,MAAMM,QAAQ;YAClC;QACF;QACA,OAAO;YACLH,OAAOC,MAAMD,KAAK;YAClBE,kBAAkBL,MAAMM,QAAQ;QAClC;IACF;IAMA,yIAAyI;IACzIQ,SAA0B;QACxB,uFAAuF;QACvF,iHAAiH;QACjH,IAAI,IAAI,CAACV,KAAK,CAACD,KAAK,IAAI,CAACX,gBAAgB;YACvC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;kCACE,CAAA,GAAA,YAAA,GAAA,EAACuB,gBAAAA,cAAc,EAAA;wBAACZ,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;;oBACtC,IAAI,CAACH,KAAK,CAACgB,WAAW;oBACtB,IAAI,CAAChB,KAAK,CAACiB,YAAY;kCACxB,CAAA,GAAA,YAAA,GAAA,EAACC,IAAI,CAAClB,KAAK,CAACmB,cAAc,EAAA;wBACxBhB,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;wBACvBF,OAAO,IAAI,CAACA,KAAK;;;;QAIzB;QAEA,OAAO,IAAI,CAACD,KAAK,CAACoB,QAAQ;IAC5B;AACF;AAWO,SAAS9B,cAAc,EAC5B6B,cAAc,EACdH,WAAW,EACXC,YAAY,EACZG,QAAQ,EAGT;IACC,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,oEAAoE;IACpE,MAAMd,WAAWe,CAAAA,GAAAA,qBAAAA,oBAAoB;IACrC,IAAIF,gBAAgB;QAClB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAAC5B,sBAAAA;YACCe,UAAUA;YACVa,gBAAgBA;YAChBH,aAAaA;YACbC,cAAcA;sBAEbG;;IAGP;IAEA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGA;;AACZ","ignoreList":[0]}},{"offset":{"line":1125,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/builtin/global-error.tsx"],"sourcesContent":["'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n"],"names":["styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","DefaultGlobalError","digest","html","id","head","body","HandleISRError","div","style","h2","window","location","hostname","p"],"mappings":";;;+BAmDA,AADA,2CAC2C,qCADqC;AAEhF,WAAA;;;eAAA;;;;gCAlD+B;AAE/B,MAAMA,SAAS;IACbC,OAAO;QACL,0FAA0F;QAC1FC,YACE;QACFC,QAAQ;QACRC,WAAW;QACXC,SAAS;QACTC,eAAe;QACfC,YAAY;QACZC,gBAAgB;IAClB;IACAC,MAAM;QACJC,UAAU;QACVC,YAAY;QACZC,YAAY;QACZC,QAAQ;IACV;AACF;AAKA,SAASC,mBAAmB,EAAEb,KAAK,EAAkB;IACnD,MAAMc,SAA6Bd,OAAOc;IAC1C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;QAAKC,IAAG;;0BACP,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA,CAAAA;0BACD,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;;kCACC,CAAA,GAAA,YAAA,GAAA,EAACC,gBAAAA,cAAc,EAAA;wBAACnB,OAAOA;;kCACvB,CAAA,GAAA,YAAA,GAAA,EAACoB,OAAAA;wBAAIC,OAAOtB,OAAOC,KAAK;kCACtB,WAAA,GAAA,CAAA,GAAA,YAAA,IAAA,EAACoB,OAAAA;;8CACC,CAAA,GAAA,YAAA,IAAA,EAACE,MAAAA;oCAAGD,OAAOtB,OAAOS,IAAI;;wCAAE;wCACAM,SAAS,WAAW;wCAAS;wCACvBS,OAAOC,QAAQ,CAACC,QAAQ;wCAAC;wCAAU;wCAC9DX,SAAS,gBAAgB;wCAAkB;;;gCAG7CA,SAAAA,WAAAA,GAAS,CAAA,GAAA,YAAA,GAAA,EAACY,KAAAA;oCAAEL,OAAOtB,OAAOS,IAAI;8CAAG,CAAC,QAAQ,EAAEM,QAAQ;qCAAQ;;;;;;;;AAMzE;MAIA,WAAeD","ignoreList":[0]}},{"offset":{"line":1207,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/runtime-error-handler.ts"],"sourcesContent":["export const RuntimeErrorHandler = {\n  hadRuntimeError: false,\n}\n"],"names":["RuntimeErrorHandler","hadRuntimeError"],"mappings":";;;+BAAaA,uBAAAA;;;eAAAA;;;AAAN,MAAMA,sBAAsB;IACjCC,iBAAiB;AACnB","ignoreList":[0]}},{"offset":{"line":1230,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest"],"mappings":";;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0]}},{"offset":{"line":1274,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/react-client-callbacks/error-boundary-callbacks.ts"],"sourcesContent":["// This file is only used in app router due to the specific error state handling.\n\nimport type { ErrorInfo } from 'react'\nimport { isNextRouterError } from '../components/is-next-router-error'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { reportGlobalError } from './report-global-error'\nimport { ErrorBoundaryHandler } from '../components/error-boundary'\nimport DefaultErrorBoundary from '../components/builtin/global-error'\n\nconst devToolErrorMod: typeof import('../../next-devtools/userspace/app/errors') =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../../next-devtools/userspace/app/errors') as typeof import('../../next-devtools/userspace/app/errors'))\n    : {\n        decorateDevError: (error: unknown) => error as Error,\n        handleClientError: () => {},\n        originConsoleError: console.error.bind(console),\n      }\n\nexport function onCaughtError(\n  thrownValue: unknown,\n  errorInfo: ErrorInfo & { errorBoundary?: React.Component }\n) {\n  const errorBoundaryComponent = errorInfo.errorBoundary?.constructor\n\n  let isImplicitErrorBoundary\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { AppDevOverlayErrorBoundary } =\n      require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary') as typeof import('../../next-devtools/userspace/app/app-dev-overlay-error-boundary')\n\n    isImplicitErrorBoundary =\n      errorBoundaryComponent === AppDevOverlayErrorBoundary\n  }\n\n  isImplicitErrorBoundary =\n    isImplicitErrorBoundary ||\n    (errorBoundaryComponent === ErrorBoundaryHandler &&\n      (errorInfo.errorBoundary! as InstanceType<typeof ErrorBoundaryHandler>)\n        .props.errorComponent === DefaultErrorBoundary)\n\n  // Skip the segment explorer triggered error\n  if (process.env.NODE_ENV !== 'production') {\n    const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } =\n      require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n    if (\n      thrownValue instanceof Error &&\n      thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE\n    ) {\n      return\n    }\n  }\n\n  if (isImplicitErrorBoundary) {\n    // We don't consider errors caught unless they're caught by an explicit error\n    // boundary. The built-in ones are considered implicit.\n    // This mimics how the same app would behave without Next.js.\n    return onUncaughtError(thrownValue)\n  }\n\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const errorBoundaryName =\n      // read react component displayName\n      (errorBoundaryComponent as any)?.displayName ||\n      errorBoundaryComponent?.name ||\n      'Unknown'\n\n    const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1]\n\n    // Match chrome or safari stack trace\n    const matches =\n      // regex to match the function name in the stack trace\n      // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n      // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n      componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? []\n    const componentThatErroredName = matches[1] || matches[2] || 'Unknown'\n\n    // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n    const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`\n    const componentErrorMessage = componentThatErroredName\n      ? `The above error occurred in the <${componentThatErroredName}> component.`\n      : `The above error occurred in one of your components.`\n\n    const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // Log and report the error with location but without modifying the error stack\n    devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation)\n\n    devToolErrorMod.handleClientError(error)\n  } else {\n    devToolErrorMod.originConsoleError(thrownValue)\n  }\n}\n\nexport function onUncaughtError(thrownValue: unknown) {\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n    reportGlobalError(error)\n  } else {\n    reportGlobalError(thrownValue)\n  }\n}\n"],"names":["onCaughtError","onUncaughtError","devToolErrorMod","process","env","NODE_ENV","require","decorateDevError","error","handleClientError","originConsoleError","console","bind","thrownValue","errorInfo","errorBoundaryComponent","errorBoundary","constructor","isImplicitErrorBoundary","AppDevOverlayErrorBoundary","ErrorBoundaryHandler","props","errorComponent","DefaultErrorBoundary","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","Error","message","isBailoutToCSRError","isNextRouterError","errorBoundaryName","displayName","name","componentThatErroredFrame","componentStack","split","matches","match","componentThatErroredName","errorBoundaryMessage","componentErrorMessage","errorLocation","reportGlobalError"],"mappings":"AAUEG,QAAQC,GAAG,CAACC,QAAQ,KAAK,eACpBC,QAAQ;AAXf,iFAAiF;;;;;;;;;;;;;;;;IAkBjEN,aAAa,EAAA;eAAbA;;IA+EAC,eAAe,EAAA;eAAfA;;;;mCA9FkB;8BACE;mCACF;+BACG;sEACJ;AAEjC,MAAMC,6LAGA;AAMC,SAASF,cACda,WAAoB,EACpBC,SAA0D;IAE1D,MAAMC,yBAAyBD,UAAUE,aAAa,EAAEC;IAExD,IAAIC;IAEJ,IAAIf,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEc,0BAA0B,EAAE,GAClCb,QAAQ;QAEVY,0BACEH,2BAA2BI;IAC/B;IAEAD,0BACEA,2BACCH,2BAA2BK,eAAAA,oBAAoB,IAC7CN,UAAUE,aAAa,CACrBK,KAAK,CAACC,cAAc,KAAKC,aAAAA,OAAoB;IAEpD,4CAA4C;IAC5C,IAAIpB,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEmB,wCAAwC,EAAE,GAChDlB,QAAQ;QACV,IACEO,uBAAuBY,SACvBZ,YAAYa,OAAO,KAAKF,0CACxB;YACA;QACF;IACF;IAEA,IAAIN,yBAAyB;QAC3B,6EAA6E;QAC7E,uDAAuD;QACvD,6DAA6D;QAC7D,OAAOjB,gBAAgBY;IACzB;IAEA,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMwB,oBAEJ,AADA,AACCd,wBAAgCe,WADE,IAEnCf,wBAAwBgB,QACxB;QAEF,MAAMC,4BAA4BlB,WAAWmB,gBAAgBC,MAAM,KAAK,CAAC,EAAE;QAE3E,qCAAqC;QACrC,MAAMC,UACJ,AACA,sDADsD,+CAC+C;QACrG,gGAAgG;QAChGH,2BAA2BI,MAAM,4BAA4B,EAAE;QACjE,MAAMC,2BAA2BF,OAAO,CAAC,EAAE,IAAIA,OAAO,CAAC,EAAE,IAAI;QAE7D,iIAAiI;QACjI,MAAMG,uBAAuB,CAAC,uBAAuB,EAAET,kBAAkB,iBAAiB,CAAC;QAC3F,MAAMU,wBAAwBF,uCAC1B,CAAC,iCAAiC,EAAEA,yBAAyB,YAAY,CAAC,GAC1E,CAAC,mDAAmD,CAAC;QAEzD,MAAMG,gBAAgB,GAAGD,sBAAsB,CAAC,EAAED,sBAAsB;QACxE,MAAM9B,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,+EAA+E;QAC/EX,gBAAgBQ,kBAAkB,CAAC,YAAYG,aAAa2B;QAE5DtC,gBAAgBO,iBAAiB,CAACD;IACpC,OAAO;;AAGT;AAEO,SAASP,gBAAgBY,WAAoB;IAClD,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMG,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,oFAAoF;QACpF4B,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACjC;IACpB,OAAO;;AAGT","ignoreList":[0]}},{"offset":{"line":1368,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { NavigationSeed } from '../segment-cache/navigation'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  previousTree: FlightRouterState\n  url: URL\n  nextUrl: string | null\n  seed: NavigationSeed | null\n  mpa: boolean\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind"],"mappings":";;;;;;;;;;;;;;;;;;;IAYaA,kBAAkB,EAAA;eAAlBA;;IAHAC,eAAe,EAAA;eAAfA;;IADAC,cAAc,EAAA;eAAdA;;IAEAC,cAAc,EAAA;eAAdA;;IAGAC,oBAAoB,EAAA;eAApBA;;IAFAC,mBAAmB,EAAA;eAAnBA;;IA2IDC,YAAY,EAAA;eAAZA;;;AA9IL,MAAMJ,iBAAiB;AACvB,MAAMD,kBAAkB;AACxB,MAAME,iBAAiB;AACvB,MAAME,sBAAsB;AAC5B,MAAML,qBAAqB;AAC3B,MAAMI,uBAAuB;AAyI7B,IAAKE,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA","ignoreList":[0]}},{"offset":{"line":1431,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/use-action-queue.ts"],"sourcesContent":["import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n"],"names":["dispatchAppRouterAction","useActionQueue","dispatch","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","state","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","isThenable","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","then","asyncState","push","_debugInfo","set","use"],"mappings":"AAwBgBM,QAAQC,GAAG,CAACC,QAAQ;;;;;;;;;;;;;;;;IATpBR,uBAAuB,EAAA;eAAvBA;;IAeAC,cAAc,EAAA;eAAdA;;;;iEA7BoB;4BACT;AAQ3B,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEzC,SAASF,wBAAwBG,MAAsB;IAC5D,IAAID,aAAa,MAAM;QACrB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAF,SAASC;AACX;AAEA,MAAME,8DAAmC;AACzC,MAAMI,wBAGFJ,uCAAU,IAAIK,YAAa;AAExB,SAAST,eACdU,WAAiC;IAEjC,MAAM,CAACC,OAAOC,SAAS,GAAGC,OAAAA,OAAK,CAACC,QAAQ,CAAeJ,YAAYC,KAAK;IAExE,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,IAAIN,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEQ,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjCd,WAAW,CAACC;YACVe,yBAAyB;gBACvBP,YAAYT,QAAQ,CAACC,QAAQU;YAC/B;QACF;IACF,OAAO;;IAKP,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,4EAA4E;IAC5E,yBAAyB;IACzB,MAAMM,qBAAqBC,CAAAA,GAAAA,OAAAA,OAAO,EAAC;QACjC,IAAI,CAACf,SAAS;;QAId,IAAIgB,CAAAA,GAAAA,YAAAA,UAAU,EAACT,QAAQ;YACrB,8EAA8E;YAC9E,kFAAkF;YAClF,IAAIU,uBAAuBb,sBAAsBc,GAAG,CAACX;YACrD,IAAIU,yBAAyBE,WAAW;gBACtC,MAAMC,YAA4B,EAAE;gBACpCH,uBAAuBI,QAAQC,OAAO,CAACf,OAAOgB,IAAI,CAAC,CAACC;oBAClD,IAAIA,WAAWJ,SAAS,KAAK,MAAM;wBACjCA,UAAUK,IAAI,IAAID,WAAWJ,SAAS;oBACxC;oBACA,OAAOI;gBACT;gBACAP,qBAAqBS,UAAU,GAAGN;gBAElChB,sBAAsBuB,GAAG,CAACpB,OAAOU;YACnC;YAEA,OAAOA;QACT;QACA,OAAOV;IACT,GAAG;QAACA;KAAM;IAEV,OAAOS,CAAAA,GAAAA,YAAAA,UAAU,EAACF,sBACdc,CAAAA,GAAAA,OAAAA,GAAG,EAACd,sBACJA;AACN","ignoreList":[0]}},{"offset":{"line":1535,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-call-server.ts"],"sourcesContent":["import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n"],"names":["callServer","actionId","actionArgs","Promise","resolve","reject","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_ACTION"],"mappings":";;;+BAIsBA,cAAAA;;;eAAAA;;;uBAJU;oCACK;gCACG;AAEjC,eAAeA,WAAWC,QAAgB,EAAEC,UAAiB;IAClE,OAAO,IAAIC,QAAQ,CAACC,SAASC;QAC3BC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACdC,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;gBACtBC,MAAMC,oBAAAA,oBAAoB;gBAC1BR;gBACAC;gBACAE;gBACAC;YACF;QACF;IACF;AACF","ignoreList":[0]}},{"offset":{"line":1571,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-find-source-map-url.ts"],"sourcesContent":["const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n"],"names":["findSourceMapURL","basePath","process","env","__NEXT_ROUTER_BASEPATH","pathname","NODE_ENV","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined"],"mappings":"AAAiBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAGtCJ,oBAAAA;;;eAAAA;;;AAHb,MAAMC,mDAAiD;AACvD,MAAMI,WAAW,GAAGJ,SAAS,oBAAoB,CAAC;AAE3C,MAAMD,mBACXE,QAAQC,GAAG,CAACG,QAAQ,KAAK,cACrB,SAASN,iBAAiBO,QAAgB;IACxC,IAAIA,aAAa,IAAI;QACnB,OAAO;IACT;IAEA,IACEA,SAASC,UAAU,CAACC,SAASC,QAAQ,CAACC,MAAM,KAC5CJ,SAASK,QAAQ,CAAC,kBAClB;QACA,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAO,GAAGL,SAAS,IAAI,CAAC;IAC1B;IAEA,MAAMM,MAAM,IAAIC,IAAIT,UAAUI,SAASC,QAAQ,CAACC,MAAM;IACtDE,IAAIE,YAAY,CAACC,GAAG,CAAC,YAAYT;IAEjC,OAAOM,IAAII,IAAI;AACjB,IACAC","ignoreList":[0]}},{"offset":{"line":1613,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/match-segments.ts"],"sourcesContent":["import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n"],"names":["matchSegment","existingSegment","segment"],"mappings":";;;+BAEaA,gBAAAA;;;eAAAA;;;AAAN,MAAMA,eAAe,CAC1BC,iBACAC;IAEA,oCAAoC;IACpC,IAAI,OAAOD,oBAAoB,UAAU;QACvC,IAAI,OAAOC,YAAY,UAAU;YAC/B,wCAAwC;YACxC,OAAOD,oBAAoBC;QAC7B;QACA,OAAO;IACT;IAEA,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAO;IACT;IACA,OAAOD,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE,IAAID,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE;AAC/E","ignoreList":[0]}},{"offset":{"line":1647,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n"],"names":["computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","startsWith","undefined","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","split","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":1777,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/handle-mutable.ts"],"sourcesContent":["import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n"],"names":["handleMutable","isNotUndefined","value","state","mutable","shouldScroll","previousNextUrl","nextUrl","patchedTree","changedPath","computeChangedPath","tree","canonicalUrl","renderedSearch","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","debugInfo","collectedDebugInfo"],"mappings":";;;+BAWgBA,iBAAAA;;;eAAAA;;;oCAXmB;AAOnC,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASF,cACdG,KAA2B,EAC3BC,OAAgB;IAEhB,0DAA0D;IAC1D,MAAMC,eAAeD,QAAQC,YAAY,IAAI;IAE7C,IAAIC,kBAAkBH,MAAMG,eAAe;IAC3C,IAAIC,UAAUJ,MAAMI,OAAO;IAE3B,IAAIN,eAAeG,QAAQI,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,cAAcC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACP,MAAMQ,IAAI,EAAEP,QAAQI,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDH,kBAAkBC;YAClBA,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUJ,MAAMS,YAAY;QAC9B;IACA,0EAA0E;IAC5E;IAEA,OAAO;QACL,YAAY;QACZA,cAAcR,QAAQQ,YAAY,IAAIT,MAAMS,YAAY;QACxDC,gBAAgBT,QAAQS,cAAc,IAAIV,MAAMU,cAAc;QAC9DC,SAAS;YACPC,aAAad,eAAeG,QAAQW,WAAW,IAC3CX,QAAQW,WAAW,GACnBZ,MAAMW,OAAO,CAACC,WAAW;YAC7BC,eAAef,eAAeG,QAAQY,aAAa,IAC/CZ,QAAQY,aAAa,GACrBb,MAAMW,OAAO,CAACE,aAAa;YAC/BC,4BAA4BhB,eAC1BG,QAAQa,0BAA0B,IAEhCb,QAAQa,0BAA0B,GAClCd,MAAMW,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOd,eACHJ,eAAeG,SAASgB,sBACtB,OACAjB,MAAMe,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBjB,QAAQiB,cAAc,IAAI;YAC1CC,cAAcjB,eAEV,AACAD,QAAQkB,YAAY,IAAIlB,QAAQkB,IADI,QACQ,KAAK,KAE/CC,mBAAmBnB,QAAQkB,YAAY,CAACE,KAAK,CAAC,MAC9CrB,MAAMe,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAcpB,eACTD,SAASgB,sBAAsBjB,MAAMe,iBAAiB,CAACO,YAAY,GAEpE,EAAE;QACR;QACA,eAAe;QACfC,OAAOtB,QAAQsB,KAAK,GAAGtB,QAAQsB,KAAK,GAAGvB,MAAMuB,KAAK;QAClD,8BAA8B;QAC9Bf,MAAMV,eAAeG,QAAQI,WAAW,IACpCJ,QAAQI,WAAW,GACnBL,MAAMQ,IAAI;QACdJ;QACAD,iBAAiBA;QACjBqB,WAAWvB,QAAQwB,kBAAkB,IAAI;IAC3C;AACF","ignoreList":[0]}},{"offset":{"line":1844,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/route-params.ts"],"sourcesContent":["import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n"],"names":["doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","get","NEXT_REWRITTEN_QUERY_HEADER","URL","url","search","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathname","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","prefix","i","segment","ROOT_SEGMENT_REQUEST_KEY","startsWith","PAGE_SEGMENT_KEY","endsWith","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","split","result","key","value","entries","undefined","Array","isArray","push"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":2072,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/flight-data-helpers.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n"],"names":["createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","response","fallbackInitialRSCPayload","renderedPathname","getRenderedPathname","renderedSearch","getRenderedSearch","canonicalUrl","createHrefFromUrl","URL","location","href","originalFlightDataPath","f","originalFlightRouterState","b","c","split","q","i","fillInFallbackFlightRouterState","m","G","S","flightRouterState","pathnameParts","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","doesStaticSegmentAppearInURL","paramName","paramType","paramValue","parseDynamicParamFromURLPart","cacheKey","getCacheKeyForDynamicParam","childPathnamePartsIndex","children","newChildren","key","childFlightRouterState","newState","flightSegmentPath","flightData","map","isHmrRefresh","encodeURIComponent","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","Object","entries","result","shouldPreserveRefreshMarker","undefined","startsWith","PAGE_SEGMENT_KEY","Boolean"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":2293,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-build-id.ts"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n"],"names":["getAppBuildId","setAppBuildId","globalBuildId","buildId"],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AAEtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;;;;;;;;;;;;;;;IAO7DA,aAAa,EAAA;eAAbA;;IAJAC,aAAa,EAAA;eAAbA;;;AAFhB,IAAIC,gBAAwB;AAErB,SAASD,cAAcE,OAAe;IAC3CD,gBAAgBC;AAClB;AAEO,SAASH;IACd,OAAOE;AACT","ignoreList":[0]}},{"offset":{"line":2344,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","uniqueCacheKey","computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","rawQuery","startsWith","slice","pairs","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join"],"mappings":";;;;;;;;;;;;;;IA4BaA,0BAA0B,EAAA;eAA1BA;;IA6BAC,kCAAkC,EAAA;eAAlCA;;;yCAvDkC;kCAOxC;AAmBA,MAAMD,6BAA6B,CACxCE,KACAC;IAEA,MAAMC,iBAAiBC,CAAAA,GAAAA,yBAAAA,8BAA8B,EACnDF,OAAO,CAACG,kBAAAA,2BAA2B,CAAC,EACpCH,OAAO,CAACI,kBAAAA,mCAAmC,CAAC,EAC5CJ,OAAO,CAACK,kBAAAA,6BAA6B,CAAC,EACtCL,OAAO,CAACM,kBAAAA,QAAQ,CAAC;IAEnBR,mCAAmCC,KAAKE;AAC1C;AAkBO,MAAMH,qCAAqC,CAChDC,KACAQ;IAEA;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBT,IAAIU,MAAM;IACjC,MAAMC,WAAWF,eAAeG,UAAU,CAAC,OACvCH,eAAeI,KAAK,CAAC,KACrBJ;IAEJ,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAMK,QAAQH,SACXI,KAAK,CAAC,KACNC,MAAM,CAAC,CAACC,OAASA,QAAQ,CAACA,KAAKL,UAAU,CAAC,GAAGM,kBAAAA,oBAAoB,CAAC,CAAC,CAAC;IAEvE,IAAIV,KAAKW,MAAM,GAAG,GAAG;QACnBL,MAAMM,IAAI,CAAC,GAAGF,kBAAAA,oBAAoB,CAAC,CAAC,EAAEV,MAAM;IAC9C,OAAO;QACLM,MAAMM,IAAI,CAAC,GAAGF,kBAAAA,oBAAoB,EAAE;IACtC;IACAlB,IAAIU,MAAM,GAAGI,MAAMK,MAAM,GAAG,CAAC,CAAC,EAAEL,MAAMO,IAAI,CAAC,MAAM,GAAG;AACtD","ignoreList":[0]}},{"offset":{"line":2405,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport {\n  type NEXT_ROUTER_PREFETCH_HEADER,\n  type NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport { getDeploymentId } from '../../../shared/lib/deployment-id'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      'auto',\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","doMpaNavigation","url","urlToUrlWithoutFlightMarker","URL","location","origin","toString","isPageUnloading","window","addEventListener","options","flightRouterState","nextUrl","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","NEXT_URL","originalUrl","__NEXT_CONFIG_OUTPUT","pathname","endsWith","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","responseUrl","canonicalUrl","redirected","contentType","get","interception","includes","postponed","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","staleTime","parseInt","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","getAppBuildId","b","normalizedFlightData","normalizeFlightData","f","flightData","renderedSearch","getRenderedSearch","couldBeIntercepted","prerendered","S","debugInfo","_debugInfo","err","console","error","fetchPriority","signal","__NEXT_TEST_MODE","deploymentId","getDeploymentId","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","undefined","fetchUrl","setCacheBustingSearchParam","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","searchParams","NEXT_RSC_UNION_QUERY","delete","rscResponse","href","status","requestHeaders","callServer","findSourceMapURL","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":2704,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith","PAGE_SEGMENT_KEY"],"mappings":";;;+BAGgBA,wBAAAA;;;eAAAA;;;yBAFiB;AAE1B,SAASA,qBACdC,OAAgB,EAChBC,0BAAmC,KAAK;IAExC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAO,GAAGA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,EAAE;IACpD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACC,SAAAA,gBAAgB,GAAG;QACnE,OAAOA,SAAAA,gBAAgB;IACzB;IAEA,OAAOL;AACT","ignoreList":[0]}},{"offset":{"line":2738,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild"],"mappings":";;;+BAEgBA,+BAAAA;;;eAAAA;;;AAAT,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,oEAAoE;IACpE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD","ignoreList":[0]}},{"offset":{"line":2791,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  ChildSegmentMap,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { dispatchAppRouterAction } from '../use-action-queue'\nimport {\n  ACTION_SERVER_PATCH,\n  type ServerPatchAction,\n} from './router-reducer-types'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\nimport {\n  convertServerPatchToFullTree,\n  type NavigationSeed,\n} from '../segment-cache/navigation'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  status: NavigationTaskStatus\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshUrl: string | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport const enum FreshnessPolicy {\n  Default,\n  Hydration,\n  HistoryTraversal,\n  RefreshAll,\n  HMRRefresh,\n}\n\nconst enum NavigationTaskStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\n/**\n * When a NavigationTask finishes, there may or may not be data still missing,\n * necessitating a retry.\n */\nconst enum NavigationTaskExitStatus {\n  /**\n   * No additional navigation is required.\n   */\n  Done = 0,\n  /**\n   * Some data failed to load, presumably due to a route tree mismatch. Perform\n   * a soft retry to reload the entire tree.\n   */\n  SoftRetry = 1,\n  /**\n   * Some data failed to load in an unrecoverable way, e.g. in an inactive\n   * parallel route. Fall back to a hard (MPA-style) retry.\n   */\n  HardRetry = 2,\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\nconst noop = () => {}\n\nexport function createInitialCacheNodeForHydration(\n  navigatedAt: number,\n  initialTree: FlightRouterState,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData\n): CacheNode {\n  // Create the initial cache node tree, using the data embedded into the\n  // HTML document.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = createCacheNodeOnNavigation(\n    navigatedAt,\n    initialTree,\n    undefined,\n    FreshnessPolicy.Hydration,\n    seedData,\n    seedHead,\n    null,\n    null,\n    false,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  // NOTE: We intentionally don't check if any data needs to be fetched from the\n  // server. We assume the initial hydration payload is sufficient to render\n  // the page.\n  //\n  // The completeness of the initial data is an important property that we rely\n  // on as a last-ditch mechanism for recovering the app; we must always be able\n  // to reload a fresh HTML document to get to a consistent state.\n  //\n  // In the future, there may be cases where the server intentionally sends\n  // partial data and expects the client to fill in the rest, in which case this\n  // logic may change. (There already is a similar case where the server sends\n  // _no_ hydration data in the HTML document at all, and the client fetches it\n  // separately, but that's different because we still end up hydrating with a\n  // complete tree.)\n\n  return task.node\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshUrl = null\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouterState,\n    freshness,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    parentRefreshUrl,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  parentRefreshUrl: string | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = newRouterState[0]\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouterState)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterState,\n      oldCacheNode,\n      freshness,\n      seedData,\n      seedHead,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const isRootLayout = newRouterState[4] === true\n  const childDidFindRootLayout = didFindRootLayout || isRootLayout\n\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n      // We should never drop dynamic data in shared layouts, except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n      shouldRefreshDynamicData = false\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      shouldDropSiblingCaches = true\n      shouldRefreshDynamicData = true\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    const dropPrefetchRsc = false\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = seedHead === null\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const href = newRouterState[2]\n  const refreshUrl =\n    typeof href === 'string' && newRouterState[3] === 'refresh'\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        href\n      : // Inherit the refresh URL from the parent.\n        parentRefreshUrl\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshUrl !== null) {\n    accumulateRefreshUrl(accumulation, refreshUrl)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    let newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    if (oldRouterStateChild === undefined) {\n      // This should never happen, but if it does, it suggests a malformed\n      // server response. Trigger a full-page navigation.\n      return null\n    }\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n\n    let seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    let prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    let newSegmentChild = newRouterStateChild[0]\n    let seedHeadChild = seedHead\n    let prefetchHeadChild = prefetchHead\n    let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n    if (\n      // Skip this branch during a history traversal. We restore the tree that\n      // was stashed in the history entry as-is.\n      freshness !== FreshnessPolicy.HistoryTraversal &&\n      newSegmentChild === DEFAULT_SEGMENT_KEY\n    ) {\n      // This is a \"default\" segment. These are never sent by the server during\n      // a soft navigation; instead, the client reuses whatever segment was\n      // already active in that slot on the previous route.\n      newRouterStateChild = reuseActiveSegmentInDefaultSlot(\n        oldUrl,\n        oldRouterStateChild\n      )\n      newSegmentChild = newRouterStateChild[0]\n\n      // Since we're switching to a different route tree, these are no\n      // longer valid, because they correspond to the outer tree.\n      seedDataChild = null\n      seedHeadChild = null\n      prefetchDataChild = null\n      prefetchHeadChild = null\n      isPrefetchHeadPartialChild = false\n    }\n\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = updateCacheNodeOnNavigation(\n      navigatedAt,\n      oldUrl,\n      oldCacheNodeChild,\n      oldRouterStateChild,\n      newRouterStateChild,\n      freshness,\n      childDidFindRootLayout,\n      seedDataChild ?? null,\n      seedHeadChild,\n      prefetchDataChild ?? null,\n      prefetchHeadChild,\n      isPrefetchHeadPartialChild,\n      isSamePageNavigation,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      refreshUrl,\n      accumulation\n    )\n\n    if (taskChild === null) {\n      // One of the child tasks discovered a change to the root layout.\n      // Immediately unwind from this recursive traversal. This will trigger a\n      // full-page navigation.\n      return null\n    }\n\n    // Recursively propagate up the child tasks.\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    // The child tree's route state may be different from the prefetched\n    // route sent by the server. We need to clone it as we traverse back up\n    // the tree.\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      // Something in the child tree is dynamic.\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshUrl,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouterState: FlightRouterState,\n  oldCacheNode: CacheNode | void,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = newRouterState[0]\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  let dropPrefetchRsc: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n      // We should never drop dynamic data in sibling caches except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n\n      // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n      // is set, and the data is not stale. (This is not a recommended API with\n      // Cache Components, but it's supported for backwards compatibility. Use\n      // cacheLife instead.)\n      //\n      // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n      shouldRefreshDynamicData =\n        oldCacheNode === undefined ||\n        navigatedAt - oldCacheNode.navigatedAt >= DYNAMIC_STALETIME_MS\n\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.Hydration:\n      // During hydration, we assume the data sent by the server is both\n      // consistent and complete.\n      shouldRefreshDynamicData = false\n      shouldDropSiblingCaches = false\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.HistoryTraversal:\n      // During back/forward navigations, we reuse the dynamic data regardless\n      // of how stale it may be.\n      shouldRefreshDynamicData = false\n      shouldRefreshDynamicData = false\n\n      // Only show prefetched data if the dynamic data is still pending. This\n      // avoids a flash back to the prefetch state in a case where it's highly\n      // likely to have already streamed in.\n      //\n      // Tehnically, what we're actually checking is whether the dynamic network\n      // response was received. But since it's a streaming response, this does\n      // not mean that all the dynamic data has fully streamed in. It just means\n      // that _some_ of the dynamic data was received. But as a heuristic, we\n      // assume that the rest dynamic data will stream in quickly, so it's still\n      // better to skip the prefetch state.\n      if (oldCacheNode !== undefined) {\n        const oldRsc = oldCacheNode.rsc\n        const oldRscDidResolve =\n          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n        dropPrefetchRsc = oldRscDidResolve\n      } else {\n        dropPrefetchRsc = false\n      }\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      // Drop all dynamic data.\n      shouldRefreshDynamicData = true\n      shouldDropSiblingCaches = true\n      dropPrefetchRsc = false\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n    // Reuse the existing CacheNode\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial =\n      seedHead === null && freshness !== FreshnessPolicy.Hydration\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (\n    freshness === FreshnessPolicy.Hydration &&\n    isLeafSegment &&\n    seedHead !== null\n  ) {\n    // This is another weird case related to \"not found\" pages and hydration.\n    // There will be a head sent by the server, but no page seed data.\n    // TODO: We really should get rid of all these \"not found\" specific quirks\n    // and make sure the tree is always consistent.\n    const seedRsc = null\n    const seedLoading = null\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = false\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = false\n  } else if (freshness !== FreshnessPolicy.Hydration && prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n    const seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterStateChild,\n      oldCacheNodeChild,\n      freshness,\n      seedDataChild ?? null,\n      seedHead,\n      prefetchDataChild ?? null,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      accumulation\n    )\n\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshUrl: null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshUrl: string\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): FlightRouterState {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return reusedRouterState\n}\n\nfunction reuseDynamicCacheNode(\n  dropPrefetchRsc: boolean,\n  existingCacheNode: CacheNode,\n  parallelRoutes: Map<string, ChildSegmentMap>\n): CacheNode {\n  // Clone an existing CacheNode's data, with (possibly) new children.\n  const cacheNode: CacheNode = {\n    rsc: existingCacheNode.rsc,\n    prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n    head: existingCacheNode.head,\n    prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n    loading: existingCacheNode.loading,\n\n    parallelRoutes,\n\n    // Don't update the navigatedAt timestamp, since we're reusing\n    // existing data.\n    navigatedAt: existingCacheNode.navigatedAt,\n  }\n  return cacheNode\n}\n\nfunction readCacheNodeFromSeedData(\n  seedRsc: React.ReactNode,\n  seedLoading: LoadingModuleData | Promise<LoadingModuleData>,\n  isSeedRscPartial: boolean,\n  seedHead: HeadData | null,\n  isSeedHeadPartial: boolean,\n  isPageSegment: boolean,\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  navigatedAt: number\n): CacheNode {\n  // TODO: Currently this is threaded through the navigation logic using the\n  // CacheNodeSeedData type, but in the future this will read directly from\n  // the Segment Cache. See readRenderSnapshotFromCache.\n\n  let rsc: React.ReactNode\n  let prefetchRsc: React.ReactNode\n  if (isSeedRscPartial) {\n    // The prefetched data contains dynamic holes. Create a pending promise that\n    // will be fulfilled when the dynamic data is received from the server.\n    prefetchRsc = seedRsc\n    rsc = createDeferredRsc()\n  } else {\n    // The prefetched data is complete. Use it directly.\n    prefetchRsc = null\n    rsc = seedRsc\n  }\n\n  // If this is a page segment, also read the head.\n  let prefetchHead: HeadData | null\n  let head: HeadData | null\n  if (isPageSegment) {\n    if (isSeedHeadPartial) {\n      prefetchHead = seedHead\n      head = createDeferredRsc()\n    } else {\n      prefetchHead = null\n      head = seedHead\n    }\n  } else {\n    prefetchHead = null\n    head = null\n  }\n\n  const cacheNode: CacheNode = {\n    rsc,\n    prefetchRsc,\n    head,\n    prefetchHead,\n    // TODO: Technically, a loading boundary could contain dynamic data. We\n    // should have separate `loading` and `prefetchLoading` fields to handle\n    // this, like we do for the segment data and head.\n    loading: seedLoading,\n    parallelRoutes,\n    navigatedAt,\n  }\n\n  return cacheNode\n}\n\nfunction spawnNewCacheNode(\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  isLeafSegment: boolean,\n  navigatedAt: number,\n  freshness: FreshnessPolicy\n): CacheNode {\n  // We should never spawn network requests during hydration. We must treat the\n  // initial payload as authoritative, because the initial page load is used\n  // as a last-ditch mechanism for recovering the app.\n  //\n  // This is also an important safety check because if this leaks into the\n  // server rendering path (which theoretically it never should because\n  // the server payload should be consistent), the server would hang because\n  // these promises would never resolve.\n  //\n  // TODO: There is an existing case where the global \"not found\" boundary\n  // triggers this path. But it does render correctly despite that. That's an\n  // unusual render path so it's not surprising, but we should look into\n  // modeling it in a more consistent way. See also the /_notFound special\n  // case in updateCacheNodeOnNavigation.\n  const isHydration = freshness === FreshnessPolicy.Hydration\n\n  const cacheNode: CacheNode = {\n    rsc: !isHydration ? createDeferredRsc() : null,\n    prefetchRsc: null,\n    head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n    prefetchHead: null,\n    loading: !isHydration ? createDeferredRsc<LoadingModuleData>() : null,\n    parallelRoutes,\n    navigatedAt,\n  }\n  return cacheNode\n}\n\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function spawnDynamicRequests(\n  task: NavigationTask,\n  primaryUrl: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  accumulation: NavigationRequestAccumulation\n): void {\n  const dynamicRequestTree = task.dynamicRequestTree\n  if (dynamicRequestTree === null) {\n    // This navigation was fully cached. There are no dynamic requests to spawn.\n    previousNavigationDidMismatch = false\n    return\n  }\n\n  // This is intentionally not an async function to discourage the caller from\n  // awaiting the result. Any subsequent async operations spawned by this\n  // function should result in a separate navigation task, rather than\n  // block the original one.\n  //\n  // In this function we spawn (but do not await) all the network requests that\n  // block the navigation, and collect the promises. The next function,\n  // `finishNavigationTask`, can await the promises in any order without\n  // accidentally introducing a network waterfall.\n  const primaryRequestPromise = fetchMissingDynamicData(\n    task,\n    dynamicRequestTree,\n    primaryUrl,\n    nextUrl,\n    freshnessPolicy\n  )\n\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  let refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null = null\n  if (separateRefreshUrls !== null) {\n    // There are multiple URLs that we need to request the data from. This\n    // happens when a \"default\" parallel route slot is present in the tree, and\n    // its data cannot be fetched from the current route. We need to split the\n    // combined dynamic request tree into separate requests per URL.\n\n    // TODO: Create a scoped dynamic request tree that omits anything that\n    // is not relevant to the given URL. Without doing this, the server may\n    // sometimes render more data than necessary; this is not a regression\n    // compared to the pre-Segment Cache implementation, though, just an\n    // optimization we can make in the future.\n\n    // Construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    refreshRequestPromises = []\n    const canonicalUrl = createHrefFromUrl(primaryUrl)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        refreshRequestPromises.push(\n          fetchMissingDynamicData(\n            task,\n            scopedDynamicRequestTree,\n            new URL(refreshUrl, location.origin),\n            // TODO: Just noticed that this should actually the Next-Url at the\n            // time the refresh URL was set, not the current Next-Url. Need to\n            // start tracking this alongside the refresh URL. In the meantime,\n            // if a refresh fails due to a mismatch, it will trigger a\n            // hard refresh.\n            nextUrl,\n            freshnessPolicy\n          )\n        )\n      }\n    }\n  }\n\n  // Further async operations are moved into this separate function to\n  // discourage sequential network requests.\n  const voidPromise = finishNavigationTask(\n    task,\n    nextUrl,\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n  // `finishNavigationTask` is responsible for error handling, so we can attach\n  // noop callbacks to this promise.\n  voidPromise.then(noop, noop)\n}\n\nasync function finishNavigationTask(\n  task: NavigationTask,\n  nextUrl: string | null,\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n): Promise<void> {\n  // Wait for all the requests to finish, or for the first one to fail.\n  let exitStatus = await waitForRequestsToFinish(\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n\n  // Once the all the requests have finished, check the tree for any remaining\n  // pending tasks. If anything is still pending, it means the server response\n  // does not match the client, and we must refresh to get back to a consistent\n  // state. We can skip this step if we already detected a mismatch during the\n  // first phase; it doesn't matter in that case because we're going to refresh\n  // the whole tree regardless.\n  if (exitStatus === NavigationTaskExitStatus.Done) {\n    exitStatus = abortRemainingPendingTasks(task, null, null)\n  }\n\n  switch (exitStatus) {\n    case NavigationTaskExitStatus.Done: {\n      // The task has completely finished. There's no missing data. Exit.\n      previousNavigationDidMismatch = false\n      return\n    }\n    case NavigationTaskExitStatus.SoftRetry: {\n      // Some data failed to finish loading. Trigger a soft retry.\n      // TODO: As an extra precaution against soft retry loops, consider\n      // tracking whether a navigation was itself triggered by a retry. If two\n      // happen in a row, fall back to a hard retry.\n      const isHardRetry = false\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    case NavigationTaskExitStatus.HardRetry: {\n      // Some data failed to finish loading in a non-recoverable way, such as a\n      // network error. Trigger an MPA navigation.\n      //\n      // Hard navigating/refreshing is how we prevent an infinite retry loop\n      // caused by a network error  when the network fails, we fall back to the\n      // browser behavior for offline navigations. In the future, Next.js may\n      // introduce its own custom handling of offline navigations, but that\n      // doesn't exist yet.\n      const isHardRetry = true\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    default: {\n      return exitStatus satisfies never\n    }\n  }\n}\n\nfunction waitForRequestsToFinish(\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n) {\n  // Custom async combinator logic. This could be replaced by Promise.any but\n  // we don't assume that's available.\n  //\n  // Each promise resolves once the server responsds and the data is written\n  // into the CacheNode tree. Resolve the combined promise once all the\n  // requests finish.\n  //\n  // Or, resolve as soon as one of the requests fails, without waiting for the\n  // others to finish.\n  return new Promise<NavigationTaskExitStatus>((resolve) => {\n    const onFulfill = (result: { exitStatus: NavigationTaskExitStatus }) => {\n      if (result.exitStatus === NavigationTaskExitStatus.Done) {\n        remainingCount--\n        if (remainingCount === 0) {\n          // All the requests finished successfully.\n          resolve(NavigationTaskExitStatus.Done)\n        }\n      } else {\n        // One of the requests failed. Exit with a failing status.\n        // NOTE: It's possible for one of the requests to fail with SoftRetry\n        // and a later one to fail with HardRetry. In this case, we choose to\n        // retry immediately, rather than delay the retry until all the requests\n        // finish. If it fails again, we will hard retry on the next\n        // attempt, anyway.\n        resolve(result.exitStatus)\n      }\n    }\n    // onReject shouldn't ever be called because fetchMissingDynamicData's\n    // entire body is wrapped in a try/catch. This is just defensive.\n    const onReject = () => resolve(NavigationTaskExitStatus.HardRetry)\n\n    // Attach the listeners to the promises.\n    let remainingCount = 1\n    primaryRequestPromise.then(onFulfill, onReject)\n    if (refreshRequestPromises !== null) {\n      remainingCount += refreshRequestPromises.length\n      refreshRequestPromises.forEach((refreshRequestPromise) =>\n        refreshRequestPromise.then(onFulfill, onReject)\n      )\n    }\n  })\n}\n\nfunction dispatchRetryDueToTreeMismatch(\n  isHardRetry: boolean,\n  retryUrl: URL,\n  retryNextUrl: string | null,\n  seed: NavigationSeed | null,\n  baseTree: FlightRouterState\n) {\n  // If this is the second time in a row that a navigation resulted in a\n  // mismatch, fall back to a hard (MPA) refresh.\n  isHardRetry = isHardRetry || previousNavigationDidMismatch\n  previousNavigationDidMismatch = true\n  const retryAction: ServerPatchAction = {\n    type: ACTION_SERVER_PATCH,\n    previousTree: baseTree,\n    url: retryUrl,\n    nextUrl: retryNextUrl,\n    seed,\n    mpa: isHardRetry,\n  }\n  dispatchAppRouterAction(retryAction)\n}\n\nasync function fetchMissingDynamicData(\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  url: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy\n): Promise<{\n  exitStatus: NavigationTaskExitStatus\n  url: URL\n  seed: NavigationSeed | null\n}> {\n  try {\n    const result = await fetchServerResponse(url, {\n      flightRouterState: dynamicRequestTree,\n      nextUrl,\n      isHmrRefresh: freshnessPolicy === FreshnessPolicy.HMRRefresh,\n    })\n    if (typeof result === 'string') {\n      // fetchServerResponse will return an href to indicate that the SPA\n      // navigation failed. For example, if the server triggered a hard\n      // redirect, or the fetch request errored. Initiate an MPA navigation\n      // to the given href.\n      return {\n        exitStatus: NavigationTaskExitStatus.HardRetry,\n        url: new URL(result, location.origin),\n        seed: null,\n      }\n    }\n    const seed = convertServerPatchToFullTree(\n      task.route,\n      result.flightData,\n      result.renderedSearch\n    )\n    const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(\n      task,\n      seed.tree,\n      seed.data,\n      seed.head,\n      result.debugInfo\n    )\n    return {\n      exitStatus: didReceiveUnknownParallelRoute\n        ? NavigationTaskExitStatus.SoftRetry\n        : NavigationTaskExitStatus.Done,\n      url: new URL(result.canonicalUrl, location.origin),\n      seed,\n    }\n  } catch {\n    // This shouldn't happen because fetchServerResponse's entire body is\n    // wrapped in a try/catch. If it does, though, it implies the server failed\n    // to respond with any tree at all. So we must fall back to a hard retry.\n    return {\n      exitStatus: NavigationTaskExitStatus.HardRetry,\n      url: url,\n      seed: null,\n    }\n  }\n}\n\nfunction writeDynamicDataIntoNavigationTask(\n  task: NavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData | null,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): boolean {\n  if (task.status === NavigationTaskStatus.Pending && dynamicData !== null) {\n    task.status = NavigationTaskStatus.Fulfilled\n    finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo)\n  }\n\n  const taskChildren = task.children\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null\n\n  // Detect whether the server sends a parallel route slot that the client\n  // doesn't know about.\n  let didReceiveUnknownParallelRoute = false\n\n  if (taskChildren !== null) {\n    for (const parallelRouteKey in serverChildren) {\n      const serverRouterStateChild: FlightRouterState =\n        serverChildren[parallelRouteKey]\n      const dynamicDataChild: CacheNodeSeedData | null | void =\n        dynamicDataChildren !== null\n          ? dynamicDataChildren[parallelRouteKey]\n          : null\n\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild === undefined) {\n        // The server sent a child segment that the client doesn't know about.\n        //\n        // When we receive an unknown parallel route, we must consider it a\n        // mismatch. This is unlike the case where the segment itself\n        // mismatches, because multiple routes can be active simultaneously.\n        // But a given layout should never have a mismatching set of\n        // child slots.\n        //\n        // Theoretically, this should only happen in development during an HMR\n        // refresh, because the set of parallel routes for a layout does not\n        // change over the lifetime of a build/deployment. In production, we\n        // should have already mismatched on either the build id or the segment\n        // path. But as an extra precaution, we validate in prod, too.\n        didReceiveUnknownParallelRoute = true\n      } else {\n        const taskSegment = taskChild.route[0]\n        if (\n          matchSegment(serverRouterStateChild[0], taskSegment) &&\n          dynamicDataChild !== null &&\n          dynamicDataChild !== undefined\n        ) {\n          // Found a match for this task. Keep traversing down the task tree.\n          const childDidReceiveUnknownParallelRoute =\n            writeDynamicDataIntoNavigationTask(\n              taskChild,\n              serverRouterStateChild,\n              dynamicDataChild,\n              dynamicHead,\n              debugInfo\n            )\n          if (childDidReceiveUnknownParallelRoute) {\n            didReceiveUnknownParallelRoute = true\n          }\n        }\n      }\n    }\n  }\n\n  return didReceiveUnknownParallelRoute\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n\n  if (dynamicSegmentData === null) {\n    // This is an empty CacheNode; this particular server request did not\n    // render this segment. There may be a separate pending request that will,\n    // though, so we won't abort the task until all pending requests finish.\n    return\n  }\n\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nfunction abortRemainingPendingTasks(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): NavigationTaskExitStatus {\n  let exitStatus\n  if (task.status === NavigationTaskStatus.Pending) {\n    // The data for this segment is still missing.\n    task.status = NavigationTaskStatus.Rejected\n    abortPendingCacheNode(task.node, error, debugInfo)\n\n    // If the server failed to fulfill the data for this segment, it implies\n    // that the route tree received from the server mismatched the tree that\n    // was previously prefetched.\n    //\n    // In an app with fully static routes and no proxy-driven redirects or\n    // rewrites, this should never happen, because the route for a URL would\n    // always be the same across multiple requests. So, this implies that some\n    // runtime routing condition changed, likely in a proxy, without being\n    // pushed to the client.\n    //\n    // When this happens, we treat this the same as a refresh(). The entire\n    // tree will be re-rendered from the root.\n    if (task.refreshUrl === null) {\n      // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n      // in a Server Action.\n      exitStatus = NavigationTaskExitStatus.SoftRetry\n    } else {\n      // The mismatch was discovered inside an inactive parallel route. This\n      // implies the inactive parallel route is no longer reachable at the URL\n      // that originally rendered it. Fall back to an MPA refresh.\n      // TODO: An alternative could be to trigger a soft refresh but to _not_\n      // re-use the inactive parallel routes this time. Similar to what would\n      // happen if were to do a hard refrehs, but without the HTML page.\n      exitStatus = NavigationTaskExitStatus.HardRetry\n    }\n  } else {\n    // This segment finished. (An error here is treated as Done because they are\n    // surfaced to the application during render.)\n    exitStatus = NavigationTaskExitStatus.Done\n  }\n\n  const taskChildren = task.children\n  if (taskChildren !== null) {\n    for (const [, taskChild] of taskChildren) {\n      const childExitStatus = abortRemainingPendingTasks(\n        taskChild,\n        error,\n        debugInfo\n      )\n      // Propagate the exit status up the tree. The statuses are ordered by\n      // their precedence.\n      if (childExitStatus > exitStatus) {\n        exitStatus = childExitStatus\n      }\n    }\n  }\n\n  return exitStatus\n}\n\nfunction abortPendingCacheNode(\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nexport function isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n"],"names":["FreshnessPolicy","createInitialCacheNodeForHydration","isDeferredRsc","spawnDynamicRequests","startPPRNavigation","noop","navigatedAt","initialTree","seedData","seedHead","accumulation","scrollableSegments","separateRefreshUrls","task","createCacheNodeOnNavigation","undefined","node","oldUrl","oldCacheNode","oldRouterState","newRouterState","freshness","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshUrl","updateCacheNodeOnNavigation","parentSegmentPath","parentParallelRouteKey","oldSegment","newSegment","matchSegment","isNavigatingToNewRootLayout","NOT_FOUND_SEGMENT_KEY","segmentPath","concat","newRouterStateChildren","oldRouterStateChildren","seedDataChildren","prefetchDataChildren","isRootLayout","childDidFindRootLayout","oldParallelRoutes","parallelRoutes","shouldDropSiblingCaches","shouldRefreshDynamicData","newParallelRoutes","Map","isLeafSegment","Object","keys","length","newCacheNode","needsDynamicRequest","dropPrefetchRsc","reuseDynamicCacheNode","seedRsc","seedLoading","isSeedRscPartial","isSeedHeadPartial","readCacheNodeFromSeedData","prefetchRsc","prefetchLoading","isPrefetchRSCPartial","spawnNewCacheNode","href","refreshUrl","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","seedDataChild","prefetchDataChild","newSegmentChild","seedHeadChild","prefetchHeadChild","isPrefetchHeadPartialChild","DEFAULT_SEGMENT_KEY","reuseActiveSegmentInDefaultSlot","newSegmentKeyChild","createRouterCacheKey","oldCacheNodeChild","taskChild","set","newCacheNodeChild","newSegmentMapChild","taskChildRoute","route","dynamicRequestTreeChild","dynamicRequestTree","status","patchRouterStateWithNewChildren","createDynamicRequestTree","children","DYNAMIC_STALETIME_MS","oldRsc","rsc","oldRscDidResolve","push","baseRouterState","newChildren","clone","Set","add","reusedRouterState","oldRefreshMarker","createHrefFromUrl","existingCacheNode","cacheNode","head","loading","isPageSegment","createDeferredRsc","isHydration","previousNavigationDidMismatch","primaryUrl","nextUrl","freshnessPolicy","primaryRequestPromise","fetchMissingDynamicData","refreshRequestPromises","canonicalUrl","scopedDynamicRequestTree","URL","location","origin","voidPromise","finishNavigationTask","then","exitStatus","waitForRequestsToFinish","abortRemainingPendingTasks","isHardRetry","primaryRequestResult","dispatchRetryDueToTreeMismatch","url","seed","Promise","resolve","onFulfill","result","remainingCount","onReject","forEach","refreshRequestPromise","retryUrl","retryNextUrl","baseTree","retryAction","type","ACTION_SERVER_PATCH","previousTree","mpa","dispatchAppRouterAction","fetchServerResponse","flightRouterState","isHmrRefresh","convertServerPatchToFullTree","flightData","renderedSearch","didReceiveUnknownParallelRoute","writeDynamicDataIntoNavigationTask","tree","data","debugInfo","serverRouterState","dynamicData","dynamicHead","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","taskSegment","childDidReceiveUnknownParallelRoute","dynamicSegmentData","dynamicLoading","error","abortPendingCacheNode","childExitStatus","reject","DEFERRED","Symbol","value","tag","pendingRsc","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","_debugInfo"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":3918,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/types.ts"],"sourcesContent":["/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n"],"names":["FetchStrategy","NavigationResultTag","PrefetchPriority"],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;;IA+BiBA,aAAa,EAAA;eAAbA;;IA7BAC,mBAAmB,EAAA;eAAnBA;;IAUAC,gBAAgB,EAAA;eAAhBA;;;AAVX,IAAWD,sBAAAA,WAAAA,GAAAA,SAAAA,mBAAAA;;;;;WAAAA;;AAUX,IAAWC,mBAAAA,WAAAA,GAAAA,SAAAA,gBAAAA;IAChB;;;;;GAKC,GAAA,gBAAA,CAAA,gBAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IAED;;GAEC,GAAA,gBAAA,CAAA,gBAAA,CAAA,UAAA,GAAA,EAAA,GAAA;IAED;;;GAGC,GAAA,gBAAA,CAAA,gBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;WAfeA;;AAmBX,IAAWF,gBAAAA,WAAAA,GAAAA,SAAAA,aAAAA;IAChB,6DAA6D;IAC7D,+DAA+D;IAC/D,mDAAmD;;;;;WAHnCA","ignoreList":[0]}},{"offset":{"line":3989,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/lru.ts"],"sourcesContent":["import { deleteMapEntry } from './cache-map'\nimport type { UnknownMapEntry } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\nlet head: UnknownMapEntry | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: UnknownMapEntry) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: UnknownMapEntry) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n        prev.next = next\n        next.prev = prev\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteMapEntry(tail)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n"],"names":["deleteFromLru","lruPut","updateLruSize","head","didScheduleCleanup","lruSize","maxLruSize","node","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteMapEntry","requestIdleCallback","cb","setTimeout"],"mappings":";;;;;;;;;;;;;;;IAoEgBA,aAAa,EAAA;eAAbA;;IArDAC,MAAM,EAAA;eAANA;;IAuCAC,aAAa,EAAA;eAAbA;;;0BAtDe;AAG/B,8EAA8E;AAC9E,2DAA2D;AAE3D,IAAIC,OAA+B;AACnC,IAAIC,qBAA8B;AAClC,IAAIC,UAAkB;AAEtB,+EAA+E;AAC/E,0EAA0E;AAC1E,4CAA4C;AAC5C,MAAMC,aAAa,KAAK,OAAO,KAAK,QAAQ;;AAErC,SAASL,OAAOM,IAAqB;IAC1C,IAAIJ,SAASI,MAAM;QACjB,sBAAsB;QACtB;IACF;IACA,MAAMC,OAAOD,KAAKC,IAAI;IACtB,MAAMC,OAAOF,KAAKE,IAAI;IACtB,IAAIA,SAAS,QAAQD,SAAS,MAAM;QAClC,uBAAuB;QACvBH,WAAWE,KAAKG,IAAI;QACpB,mEAAmE;QACnE,yEAAyE;QACzE,wBAAwB;QACxBC;IACF,OAAO;QACL,oDAAoD;QACpDH,KAAKC,IAAI,GAAGA;QACZA,KAAKD,IAAI,GAAGA;IACd;IAEA,gCAAgC;IAChC,IAAIL,SAAS,MAAM;QACjB,0BAA0B;QAC1BI,KAAKC,IAAI,GAAGD;QACZA,KAAKE,IAAI,GAAGF;IACd,OAAO;QACL,+BAA+B;QAC/B,MAAMK,OAAOT,KAAKK,IAAI;QACtBD,KAAKC,IAAI,GAAGI;QACZ,sEAAsE;QACtE,IAAIA,SAAS,MAAM;YACjBA,KAAKH,IAAI,GAAGF;QACd;QACAA,KAAKE,IAAI,GAAGN;QACZA,KAAKK,IAAI,GAAGD;IACd;IACAJ,OAAOI;AACT;AAEO,SAASL,cAAcK,IAAqB,EAAEM,WAAmB;IACtE,yEAAyE;IACzE,iEAAiE;IACjE,MAAMC,eAAeP,KAAKG,IAAI;IAC9BH,KAAKG,IAAI,GAAGG;IACZ,IAAIN,KAAKE,IAAI,KAAK,MAAM;QACtB,wDAAwD;QACxD;IACF;IACA,4BAA4B;IAC5BJ,UAAUA,UAAUS,eAAeD;IACnCF;AACF;AAEO,SAASX,cAAce,OAAwB;IACpD,MAAMN,OAAOM,QAAQN,IAAI;IACzB,MAAMD,OAAOO,QAAQP,IAAI;IACzB,IAAIC,SAAS,QAAQD,SAAS,MAAM;QAClCH,WAAWU,QAAQL,IAAI;QAEvBK,QAAQN,IAAI,GAAG;QACfM,QAAQP,IAAI,GAAG;QAEf,uBAAuB;QACvB,IAAIL,SAASY,SAAS;YACpB,kBAAkB;YAClB,IAAIN,SAASN,MAAM;gBACjB,0BAA0B;gBAC1BA,OAAO;YACT,OAAO;gBACLA,OAAOM;gBACPD,KAAKC,IAAI,GAAGA;gBACZA,KAAKD,IAAI,GAAGA;YACd;QACF,OAAO;YACLA,KAAKC,IAAI,GAAGA;YACZA,KAAKD,IAAI,GAAGA;QACd;IACF,OAAO;IACL,kBAAkB;IACpB;AACF;AAEA,SAASG;IACP,IAAIP,sBAAsBC,WAAWC,YAAY;QAC/C;IACF;IACAF,qBAAqB;IACrBY,uBAAuBC;AACzB;AAEA,SAASA;IACPb,qBAAqB;IAErB,sEAAsE;IACtE,gEAAgE;IAChE,iEAAiE;IACjE,MAAMc,mBAAmBZ,aAAa;IACtC,MAAOD,UAAUa,oBAAoBf,SAAS,KAAM;QAClD,MAAMS,OAAOT,KAAKK,IAAI;QACtB,sEAAsE;QACtE,IAAII,SAAS,MAAM;YACjB,mEAAmE;YACnE,WAAW;YACXO,CAAAA,GAAAA,UAAAA,cAAc,EAACP;QACjB;IACF;AACF;AAEA,MAAMI,yBACJ,OAAOI,wBAAwB,aAC3BA,sBACA,CAACC,KAAmBC,WAAWD,IAAI","ignoreList":[0]}},{"offset":{"line":4136,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/cache-map.ts"],"sourcesContent":["import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Represents a node in the cache map and LRU.\n * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n *\n * The LRU can contain entries of different value types\n * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n * the common structure needed for cache map and LRU operations without\n * requiring knowledge of the specific value type.\n */\nexport interface MapEntry<V extends MapValue> {\n  // Cache map structure fields\n  parent: MapEntry<V> | null\n  key: unknown\n  map: Map<unknown, MapEntry<V>> | null\n  value: V | null\n\n  // LRU linked list fields\n  prev: MapEntry<V> | null\n  next: MapEntry<V> | null\n  size: number\n}\n\n/**\n * A looser type for MapEntry\n * This allows the LRU to work with entries of different\n * value types while still providing type safety.\n *\n * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n * type since we're only reading from the map, not inserting into it.\n */\nexport type UnknownMapEntry = {\n  parent: UnknownMapEntry | null\n  key: unknown\n  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n  value: MapValue | null\n\n  prev: UnknownMapEntry | null\n  next: UnknownMapEntry | null\n  size: number\n}\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: MapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired(\n  now: number,\n  currentCacheVersion: number,\n  value: MapValue\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n    entry.value = null\n  }\n\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  entry.value = value\n  value.ref = entry\n\n  updateLruSize(entry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap(value: MapValue): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef(value: MapValue): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nexport function deleteMapEntry(entry: UnknownMapEntry): void {\n  // Delete the entry from the cache.\n  entry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = entry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = entry.parent\n    let key = entry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(entry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n"],"names":["Fallback","createCacheMap","deleteFromCacheMap","deleteMapEntry","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","key","value","map","prev","next","size","getOrInitialize","keys","isRevalidation","entry","remainingKeys","previousKey","existingEntry","get","undefined","Map","newEntry","set","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","lruPut","staleAt","version","lazilyEvictIfNeeded","result","fallbackEntry","setMapEntryValue","updateLruSize","dropRef","oldEntry","ref","deleteFromLru","parentMap","delete","revalidatingEntry"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":4443,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/vary-path.ts"],"sourcesContent":["import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    value: NormalizedPathname\n    parent: {\n      value: NormalizedSearch\n      parent: {\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    value: string\n    parent: {\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    value: requestKey,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it  for example, if the server tells us that the response\n  // doesn't vary on a particular param  but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    value: originalVaryPath.value,\n    parent: {\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n"],"names":["appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","pathname","search","nextUrl","varyPath","value","parent","couldBeIntercepted","Fallback","parentPath","cacheKey","varyPathPart","requestKey","layoutVaryPath","renderedSearch","pageVaryPath","pageRequestKey","HEAD_REQUEST_KEY","fetchStrategy","tree","originalVaryPath","isPage","doesVaryOnSearchParams","FetchStrategy","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath"],"mappings":";;;;;;;;;;;;;;;;;;;;IAuHgBA,oBAAoB,EAAA;eAApBA;;IAgJAC,oCAAoC,EAAA;eAApCA;;IArIAC,sBAAsB,EAAA;eAAtBA;;IA4BAC,wBAAwB,EAAA;eAAxBA;;IAjBAC,oBAAoB,EAAA;eAApBA;;IA5CAC,yBAAyB,EAAA;eAAzBA;;IAnBAC,gBAAgB,EAAA;eAAhBA;;IA2HAC,4BAA4B,EAAA;eAA5BA;;;uBAzMc;0BAOc;sCACX;AAsE1B,SAASD,iBACdE,QAA4B,EAC5BC,MAAwB,EACxBC,OAAiC;IAEjC,wCAAwC;IACxC,MAAMC,WAAqB;QACzBC,OAAOJ;QACPK,QAAQ;YACND,OAAOH;YACPI,QAAQ;gBACND,OAAOF;gBACPG,QAAQ;YACV;QACF;IACF;IACA,OAAOF;AACT;AAEO,SAASN,0BACdG,QAA4B,EAC5BC,MAAwB,EACxBC,OAAiC,EACjCI,kBAA2B;IAE3B,2EAA2E;IAC3E,yDAAyD;IACzD,wCAAwC;IACxC,MAAMH,WAAqB;QACzBC,OAAOJ;QACPK,QAAQ;YACND,OAAOH;YACPI,QAAQ;gBACND,OAAOE,qBAAqBJ,UAAUK,UAAAA,QAAQ;gBAC9CF,QAAQ;YACV;QACF;IACF;IACA,OAAOF;AACT;AAEO,SAASX,qBACdgB,UAAyC,EACzCC,QAAgB;IAEhB,MAAMC,eAAyB;QAC7BN,OAAOK;QACPJ,QAAQG;IACV;IACA,OAAOE;AACT;AAEO,SAAShB,uBACdiB,UAAkB,EAClBR,QAAuC;IAEvC,MAAMS,iBAA2B;QAC/BR,OAAOO;QACPN,QAAQF;IACV;IACA,OAAOS;AACT;AAEO,SAAShB,qBACde,UAAkB,EAClBE,cAAgC,EAChCV,QAAuC;IAEvC,8EAA8E;IAC9E,2CAA2C;IAC3C,MAAMW,eAAyB;QAC7BV,OAAOO;QACPN,QAAQ;YACND,OAAOS;YACPR,QAAQF;QACV;IACF;IACA,OAAOW;AACT;AAEO,SAASnB,yBACdoB,cAAsB,EACtBF,cAAgC,EAChCV,QAAuC;IAEvC,2EAA2E;IAC3E,sEAAsE;IACtE,0EAA0E;IAC1E,UAAU;IACV,EAAE;IACF,2EAA2E;IAC3E,4EAA4E;IAC5E,2EAA2E;IAC3E,0EAA0E;IAC1E,kBAAkB;IAClB,EAAE;IACF,mEAAmE;IACnE,yEAAyE;IACzE,uEAAuE;IACvE,2BAA2B;IAC3B,EAAE;IACF,0EAA0E;IAC1E,2EAA2E;IAC3E,uEAAuE;IACvE,mBAAmB;IAEnB,2EAA2E;IAC3E,oEAAoE;IACpE,qEAAqE;IACrE,uEAAuE;IACvE,MAAMW,eAAyB;QAC7B,uEAAuE;QACvE,2EAA2E;QAC3E,8CAA8C;QAC9CV,OAAOW,iBAAiBC,sBAAAA,gBAAgB;QACxCX,QAAQ;YACND,OAAOS;YACPR,QAAQF;QACV;IACF;IACA,OAAOW;AACT;AAEO,SAASf,6BACdkB,aAA4B,EAC5BC,IAAe;IAEf,4EAA4E;IAC5E,0EAA0E;IAC1E,0EAA0E;IAC1E,eAAe;IACf,EAAE;IACF,4EAA4E;IAC5E,wEAAwE;IACxE,4EAA4E;IAC5E,0EAA0E;IAC1E,+DAA+D;IAC/D,EAAE;IACF,wEAAwE;IACxE,sEAAsE;IACtE,mDAAmD;IACnD,EAAE;IACF,yEAAyE;IACzE,kCAAkC;IAClC,EAAE;IACF,2EAA2E;IAC3E,2EAA2E;IAC3E,oEAAoE;IACpE,MAAMC,mBAAmBD,KAAKf,QAAQ;IAEtC,2EAA2E;IAC3E,sEAAsE;IACtE,wEAAwE;IACxE,IAAIe,KAAKE,MAAM,EAAE;QACf,uEAAuE;QACvE,uEAAuE;QACvE,2CAA2C;QAC3C,MAAMC,yBACJJ,kBAAkBK,OAAAA,aAAa,CAACC,IAAI,IACpCN,kBAAkBK,OAAAA,aAAa,CAACE,UAAU;QAE5C,IAAI,CAACH,wBAAwB;YAC3B,yEAAyE;YACzE,iEAAiE;YACjE,iBAAiB;YACjB,EAAE;YACF,2CAA2C;YAC3C,wDAAwD;YACxD,MAAMI,uBAAwBN,iBAAkCd,MAAM;YACtE,MAAMqB,qBAAqBD,qBAAqBpB,MAAM;YACtD,MAAMsB,kBAA4B;gBAChCvB,OAAOe,iBAAiBf,KAAK;gBAC7BC,QAAQ;oBACND,OAAOG,UAAAA,QAAQ;oBACfF,QAAQqB;gBACV;YACF;YACA,OAAOC;QACT;IACF;IAEA,4EAA4E;IAC5E,OAAOR;AACT;AAEO,SAAS1B,qCACd0B,gBAA8B,EAC9BS,SAA2B;IAE3B,2CAA2C;IAC3C,yDAAyD;IACzD,MAAMH,uBAAuBN,iBAAiBd,MAAM;IACpD,MAAMwB,iBAA2B;QAC/BzB,OAAOe,iBAAiBf,KAAK;QAC7BC,QAAQ;YACND,OAAOwB;YACPvB,QAAQoB,qBAAqBpB,MAAM;QACrC;IACF;IACA,OAAOwB;AACT","ignoreList":[0]}},{"offset":{"line":4661,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/cache-key.ts"],"sourcesContent":["// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n"],"names":["createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","pathname","search"],"mappings":"AAAA,2DAA2D;;;;+BAmB3CA,kBAAAA;;;eAAAA;;;AAAT,SAASA,eACdC,YAAoB,EACpBC,OAAsB;IAEtB,MAAMC,cAAc,IAAIC,IAAIH;IAC5B,MAAMI,WAAW;QACfC,UAAUH,YAAYG,QAAQ;QAC9BC,QAAQJ,YAAYI,MAAM;QAC1BL,SAASA;IACX;IACA,OAAOG;AACT","ignoreList":[0]}},{"offset":{"line":4691,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/scheduler.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport { getCurrentCacheVersion } from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization  theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(\n      now,\n      FetchStrategy.PPR,\n      route,\n      route.metadata\n    ),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree  the part that doesn't exist on the current page  we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static  once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch  via <Link prefetch={true}>  implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state  it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response  it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    route,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    route,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        fetchStrategy,\n        route,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in  is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n"],"names":["cancelPrefetchTask","isPrefetchTaskDirty","pingPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","startRevalidationCooldown","scheduleMicrotask","queueMicrotask","fn","Promise","resolve","then","catch","error","setTimeout","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","key","treeAtTimeOfPrefetch","fetchStrategy","priority","onInvalidate","task","cacheVersion","getCurrentCacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","PrefetchPriority","Intent","heapResift","nextUrl","tree","currentCacheVersion","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","result","onPrefetchConnectionClosed","closed","value","now","Date","heapPeek","exitStatus","pingRoute","heapPop","background","route","readOrCreateRouteCacheEntry","pingRootRouteTree","search","url","URL","pathname","location","origin","keyWithoutSearch","createCacheKey","href","routeWithoutSearch","status","EntryStatus","Empty","Pending","fetchRouteOnCacheMiss","Fulfilled","Rejected","staleAt","blockedTasks","Set","add","FetchStrategy","PPR","isPPREnabled","LoadingBoundary","pingStaticHead","pingSharedPartOfCacheComponentsTree","spawnedEntries","Map","pingRuntimeHead","PPRRuntime","requestTree","pingRuntimePrefetches","needsDynamicRequest","size","fetchSegmentPrefetchesUsingDynamicRequest","Full","dynamicRequestTree","diffRouteTreeAgainstCurrent","pingStaticSegmentData","readOrCreateSegmentCacheEntry","metadata","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","segment","oldTreeChildren","newTreeChildren","slots","parallelRouteKey","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","undefined","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","hasRuntimePrefetch","requestKey","childTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","hasLoadingBoundary","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","convertRouteTreeToFlightRouterState","isRootLayout","refetchMarkerContext","refetchMarker","set","upgradeToPendingSegment","segmentHasLoadingBoundary","SegmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","isPartial","canNewFetchStrategyProvideMoreContent","pingFullSegmentRevalidation","has","routeKey","fetchSegmentOnCacheMiss","pingPPRSegmentRevalidation","revalidatingSegment","readOrCreateRevalidatingSegmentEntry","upsertSegmentOnCompletion","getSegmentVaryPathForRequest","pendingSegment","waitForSegmentCacheEntry","nonEmptyRevalidatingSegment","emptySegment","overwriteRevalidatingSegmentCacheEntry","noop","promise","varyPath","fulfilled","upsertSegmentEntry","currentSegment","cachedSegment","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","renderedSearch","matchSegment","compareQueuePriority","a","b","priorityDiff","phaseDiff","heap","node","index","length","push","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","parent","i","halfLength","leftIndex","left","rightIndex","right"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":5838,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/normalize-trailing-slash.ts"],"sourcesContent":["import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n"],"names":["normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","parsePath","__NEXT_TRAILING_SLASH","test","removeTrailingSlash","endsWith"],"mappings":"AAQ+BG,QAAQC,GAAG,CAACC,4BAA4B;;;;;+BAD1DL,8BAAAA;;;eAAAA;;;qCAPuB;2BACV;AAMnB,MAAMA,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,kDAAkD;QACrE,OAAOD;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,GAAGC,CAAAA,GAAAA,WAAAA,SAAS,EAACR;IAC5C,IAAIE,QAAQC,GAAG,CAACM,qBAAqB,EAAE;;IAUvC,OAAO,GAAGE,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACN,YAAYC,QAAQC,MAAM;AAC1D","ignoreList":[0]}},{"offset":{"line":5871,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/add-base-path.ts"],"sourcesContent":["import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n"],"names":["addBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","required","normalizePathTrailingSlash","__NEXT_MANUAL_CLIENT_BASE_PATH","addPathPrefix"],"mappings":"AAGkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BALc;wCACa;AAE3C,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY,EAAEC,QAAkB;IAC1D,OAAOC,CAAAA,GAAAA,wBAAAA,0BAA0B,EAC/BL,QAAQC,GAAG,CAACK,0BACRH,IADsC,IAAI,CAACC,iBAE3CG,CAAAA,GAAAA,eAAAA,aAAa,EAACJ,MAAMJ;AAE5B","ignoreList":[0]}},{"offset":{"line":5899,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-utils.ts"],"sourcesContent":["import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n"],"names":["createPrefetchURL","isExternalURL","url","origin","window","location","href","isBot","navigator","userAgent","URL","addBasePath","_","Error","process","env","NODE_ENV"],"mappings":"AAgCMc,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IAlBfhB,iBAAiB,EAAA;eAAjBA;;IAXAC,aAAa,EAAA;eAAbA;;;uBAHM;6BACM;AAErB,SAASA,cAAcC,GAAQ;IACpC,OAAOA,IAAIC,MAAM,KAAKC,OAAOC,QAAQ,CAACF,MAAM;AAC9C;AASO,SAASH,kBAAkBM,IAAY;IAC5C,kDAAkD;IAClD,IAAIC,CAAAA,GAAAA,OAAAA,KAAK,EAACH,OAAOI,SAAS,CAACC,SAAS,GAAG;QACrC,OAAO;IACT;IAEA,IAAIP;IACJ,IAAI;QACFA,MAAM,IAAIQ,IAAIC,CAAAA,GAAAA,aAAAA,WAAW,EAACL,OAAOF,OAAOC,QAAQ,CAACC,IAAI;IACvD,EAAE,OAAOM,GAAG;QACV,2EAA2E;QAC3E,kDAAkD;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,iBAAiB,EAAEP,KAAK,0CAA0C,CAAC,GADhE,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,uEAAuE;IACvE,wCAA4C;QAC1C,OAAO;IACT;;;AAQF","ignoreList":[0]}},{"offset":{"line":5962,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/links.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n"],"names":["IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","startTransition","setOptimisticLinkStatus","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","get","undefined","set","observe","coercePrefetchableUrl","href","window","createPrefetchURL","require","reportErrorFn","reportError","console","error","router","fetchStrategy","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","delete","cancelPrefetchTask","unobserve","entries","entry","intersectionRatio","target","process","env","NODE_ENV","add","rescheduleLinkPrefetch","PrefetchPriority","Default","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","FetchStrategy","Full","Intent","priority","existingPrefetchTask","getCurrentAppRouterState","appRouterState","treeAtTimeOfPrefetch","tree","nextUrl","cacheKey","createCacheKey","scheduleSegmentPrefetchTask","reschedulePrefetchTask","task","isPrefetchTaskDirty"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":6248,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/cache.ts"],"sourcesContent":["import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it  i.e. the one\n  // optionally passed to router.prefetch(onInvalidate)  then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete  this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert  should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time  it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n"],"names":["EntryStatus","canNewFetchStrategyProvideMoreContent","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentCacheVersion","getStaleTimeMs","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","requestOptimisticRouteCacheEntry","revalidateEntireCache","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","staleTimeSeconds","Math","max","isOutputExportMode","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","createCacheMap","segmentCacheMap","invalidationListeners","currentCacheVersion","nextUrl","tree","startRevalidationCooldown","pingVisibleLinks","attachInvalidationListener","task","onInvalidate","Set","add","notifyInvalidationListener","error","reportError","console","tasks","isPrefetchTaskDirty","now","key","varyPath","getRouteVaryPath","pathname","search","isRevalidation","getFromCacheMap","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","promise","createPromiseWithResolvers","existingEntry","canonicalUrl","status","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","renderedSearch","ref","size","staleAt","Infinity","version","setInCacheMap","requestedUrl","requestedSearch","urlWithoutSearchParams","URL","routeWithNoSearchParams","createPrefetchRequestKey","href","canonicalUrlForRouteWithNoSearchParams","origin","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","location","optimisticCanonicalUrl","createHrefFromUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","slots","parallelRouteKey","childTree","isPage","requestKey","segment","clonePageVaryPathWithNewSearchParams","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","fetchStrategy","route","varyPathForRequest","getSegmentVaryPathForRequest","candidateEntry","isValueExpired","isPartial","rejectedEntry","loading","rsc","deleteFromCacheMap","emptyEntry","FetchStrategy","PPR","Full","pingBlockedTasks","entry","pingPrefetchTask","fulfillRouteCacheEntry","metadataVaryPath","HEAD_REQUEST_KEY","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","resolve","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","acc","pathnameParts","split","filter","p","index","rootSegment","ROOT_SEGMENT_REQUEST_KEY","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","finalizeLayoutVaryPath","childPrefetch","childParamName","name","childParamType","paramType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","parseDynamicParamFromURLPart","childParamKey","getCacheKeyForDynamicParam","appendLayoutVaryPath","doesStaticSegmentAppearInURL","childPathnamePartsIndex","childRequestKeyPart","createSegmentRequestKeyPart","childRequestKey","appendSegmentRequestKeyPart","endsWith","PAGE_SEGMENT_KEY","finalizePageVaryPath","finalizeMetadataVaryPath","SegmentHasLoadingBoundary","convertRootFlightRouterStateToRouteTree","flightRouterState","convertFlightRouterStateToRouteTree","parentPartialVaryPath","originalSegment","Array","isArray","paramCacheKey","parallelRoutes","childRouterState","undefined","routeTree","segmentPath","headers","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","url","response","urlAfterRedirects","headResponse","fetch","method","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","get","includes","closed","routeIsPPREnabled","NEXT_DID_POSTPONE_HEADER","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","setSizeInCacheMap","serverData","createFromNextReadableStream","buildId","getAppBuildId","getRenderedPathname","getRenderedSearch","staleTimeMs","staleTime","b","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","getFulfilledRouteVaryPath","value","routeKey","normalizedRequestKey","requestUrl","dynamicRequestTree","spawnedEntries","has","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","length","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","normalizeFlightData","f","flightData","isRootRender","parseInt","NEXT_ROUTER_STALE_TIME_HEADER","isNaN","STATIC_STALETIME_MS","entries","values","push","flightDatas","seedData","i","writeSeedDataIntoCache","head","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","seedDataChildren","childSeedData","ownedEntry","possiblyNewEntry","newEntry","fetchPriority","shouldImmediatelyDecode","createFetch","contentType","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","slice","staticExportFilename","convertSegmentPathToStaticExportFilename","currentStrategy","newStrategy"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":7622,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/navigation.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationTask,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath> | null\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<MPANavigationResult | SuccessfulNavigationResult>\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = href === currentUrl.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      freshnessPolicy,\n      shouldScroll\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        freshnessPolicy,\n        shouldScroll\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      collectedDebugInfo\n    ),\n  }\n}\n\nexport function navigateToSeededRoute(\n  now: number,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.tree,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    null,\n    null,\n    false,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      navigationSeed.renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const seedData = null\n  const seedHead = null\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    freshnessPolicy,\n    seedData,\n    seedHead,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigationTaskToResult(\n  task: NavigationTask,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState: task.route,\n      cacheNode: task.node,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Because the request is still pending, we typically don't know yet\n        // whether the response will be partial. We shouldn't skip this segment\n        // during the dynamic navigation request. Otherwise, we might need to\n        // do yet another request to fill in the remaining data, creating\n        // a waterfall.\n        //\n        // The one exception is if this segment is being fetched with via\n        // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n        // we can assume the response will be full. This field is set to `false`\n        // for such segments.\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  collectedDebugInfo: Array<unknown>\n): Promise<MPANavigationResult | SuccessfulNavigationResult> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  return navigateToSeededRoute(\n    now,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll\n  )\n}\n\nexport type NavigationSeed = {\n  tree: FlightRouterState\n  renderedSearch: string\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  for (const {\n    segmentPath,\n    tree: treePatch,\n    seedData: dataPatch,\n    head: headPatch,\n  } of flightData) {\n    const result = convertServerPatchToFullTreeImpl(\n      baseTree,\n      baseData,\n      treePatch,\n      dataPatch,\n      segmentPath,\n      0\n    )\n    baseTree = result.tree\n    baseData = result.data\n    // This is the same for all patches per response, so just pick an\n    // arbitrary one\n    head = headPatch\n  }\n\n  return {\n    tree: baseTree,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    clonedTree[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n"],"names":["convertServerPatchToFullTree","navigate","navigateToSeededRoute","url","currentUrl","currentCacheNode","currentFlightRouterState","nextUrl","freshnessPolicy","shouldScroll","accumulation","now","Date","href","isSamePageNavigation","cacheKey","createCacheKey","route","readRouteCacheEntry","status","EntryStatus","Fulfilled","snapshot","readRenderSnapshotFromCache","tree","prefetchFlightRouterState","flightRouterState","prefetchSeedData","seedData","headSnapshot","readHeadSnapshotFromCache","prefetchHead","rsc","isPrefetchHeadPartial","isPartial","newCanonicalUrl","canonicalUrl","hash","renderedSearch","navigateUsingPrefetchedRouteTree","Rejected","optimisticRoute","requestOptimisticRouteCacheEntry","newRenderedSearch","collectedDebugInfo","undefined","tag","NavigationResultTag","Async","data","navigateDynamicallyWithNoPrefetch","navigationSeed","scrollableSegments","separateRefreshUrls","task","startPPRNavigation","head","spawnDynamicRequests","navigationTaskToResult","MPA","seedHead","Success","cacheNode","node","childRouterStates","childSeedDatas","slots","parallelRouteKey","childTree","childResult","loading","segmentEntry","readSegmentCacheEntry","varyPath","Pending","promiseForFulfilledEntry","waitForSegmentCacheEntry","then","entry","Empty","segment","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","hasRuntimePrefetch","isRootLayout","metadata","DynamicRequestTreeForEntireRoute","dynamicRequestTree","FreshnessPolicy","Default","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","fetchServerResponse","result","newUrl","flightData","debugInfo","debugInfoFromResponse","push","createHrefFromUrl","currentTree","baseTree","baseData","segmentPath","treePatch","dataPatch","headPatch","convertServerPatchToFullTreeImpl","baseRouterState","index","length","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newTreeChildren","newSeedDataChildren","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","isEmptySeedDataPartial"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":8082,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nexport function handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n      // some confusing and subtle logic in `handleMutable` that decides what\n      // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n      // not convinced it's totally coherent but the tests assert on this\n      // particular behavior so I've ported the logic as-is from the previous\n      // router implementation, for now.\n      mutable.scrollableSegments = result.data.scrollableSegments ?? undefined\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    FreshnessPolicy.Default,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n"],"names":["DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","generateSegmentsFromPatch","handleExternalUrl","handleNavigationResult","navigateReducer","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","getStaleTimeMs","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","handleMutable","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","result","tag","NavigationResultTag","MPA","newUrl","data","Success","cache","cacheNode","patchedTree","flightRouterState","renderedSearch","shouldScroll","hashFragment","hash","oldUrl","URL","onlyHashChange","pathname","search","Async","then","asyncResult","action","isExternalUrl","navigateType","href","createHrefFromUrl","preserveCustomHistoryState","toString","document","getElementById","currentUrl","location","origin","navigateUsingSegmentCache","tree","nextUrl","FreshnessPolicy","Default"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":8252,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","isInterceptionRouteAppPath","key"],"mappings":";;;+BAGgBA,qCAAAA;;;eAAAA;;;oCAF2B;AAEpC,SAASA,kCAAkC,CAChDC,SACAC,eACkB;IAClB,wGAAwG;IACxG,IACEC,MAAMC,OAAO,CAACH,YACbA,CAAAA,OAAO,CAAC,EAAE,KAAK,gBACdA,OAAO,CAAC,EAAE,KAAK,gBACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,aACfA,OAAO,CAAC,EAAE,KAAK,SAAQ,GACzB;QACA,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYI,CAAAA,GAAAA,oBAAAA,0BAA0B,EAACJ,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMI,OAAOJ,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACI,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},{"offset":{"line":8292,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function refreshReducer(state: ReadonlyReducerState): ReducerState {\n  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n  // only client-side refreshes will have this behavior; the server-side\n  // `refresh` should send new data without purging the prefetch cache.\n  const currentNextUrl = state.nextUrl\n  const currentRouterState = state.tree\n  revalidateEntireCache(currentNextUrl, currentRouterState)\n  return refreshDynamicData(state, FreshnessPolicy.RefreshAll)\n}\n\nexport function refreshDynamicData(\n  state: ReadonlyReducerState,\n  freshnessPolicy: FreshnessPolicy.RefreshAll | FreshnessPolicy.HMRRefresh\n): ReducerState {\n  const currentNextUrl = state.nextUrl\n\n  // We always send the last next-url, not the current when performing a dynamic\n  // request. This is because we update the next-url after a navigation, but we\n  // want the same interception route to be matched that used the last next-url.\n  const nextUrlForRefresh = hasInterceptionRouteInCurrentTree(state.tree)\n    ? state.previousNextUrl || currentNextUrl\n    : null\n\n  // A refresh is modeled as a navigation to the current URL, but where any\n  // existing dynamic data (including in shared layouts) is re-fetched.\n  const currentCanonicalUrl = state.canonicalUrl\n  const currentUrl = new URL(currentCanonicalUrl, location.origin)\n  const currentFlightRouterState = state.tree\n  const shouldScroll = true\n\n  const navigationSeed = {\n    tree: state.tree,\n    renderedSearch: state.renderedSearch,\n    data: null,\n    head: null,\n  }\n\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    currentUrl,\n    currentCanonicalUrl,\n    navigationSeed,\n    currentUrl,\n    state.cache,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrlForRefresh,\n    shouldScroll\n  )\n\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  return handleNavigationResult(currentUrl, state, mutable, false, result)\n}\n"],"names":["refreshDynamicData","refreshReducer","state","currentNextUrl","nextUrl","currentRouterState","tree","revalidateEntireCache","FreshnessPolicy","RefreshAll","freshnessPolicy","nextUrlForRefresh","hasInterceptionRouteInCurrentTree","previousNextUrl","currentCanonicalUrl","canonicalUrl","currentUrl","URL","location","origin","currentFlightRouterState","shouldScroll","navigationSeed","renderedSearch","data","head","now","Date","result","navigateToSeededRoute","cache","mutable","preserveCustomHistoryState","handleNavigationResult"],"mappings":";;;;;;;;;;;;;;IAqBgBA,kBAAkB,EAAA;eAAlBA;;IAVAC,cAAc,EAAA;eAAdA;;;iCANuB;4BACD;uBACA;mDACY;gCAClB;AAEzB,SAASA,eAAeC,KAA2B;IACxD,0EAA0E;IAC1E,sEAAsE;IACtE,qEAAqE;IACrE,MAAMC,iBAAiBD,MAAME,OAAO;IACpC,MAAMC,qBAAqBH,MAAMI,IAAI;IACrCC,CAAAA,GAAAA,OAAAA,qBAAqB,EAACJ,gBAAgBE;IACtC,OAAOL,mBAAmBE,OAAOM,gBAAAA,eAAe,CAACC,UAAU;AAC7D;AAEO,SAAST,mBACdE,KAA2B,EAC3BQ,eAAwE;IAExE,MAAMP,iBAAiBD,MAAME,OAAO;IAEpC,8EAA8E;IAC9E,6EAA6E;IAC7E,8EAA8E;IAC9E,MAAMO,oBAAoBC,CAAAA,GAAAA,mCAAAA,iCAAiC,EAACV,MAAMI,IAAI,IAClEJ,MAAMW,eAAe,IAAIV,iBACzB;IAEJ,yEAAyE;IACzE,qEAAqE;IACrE,MAAMW,sBAAsBZ,MAAMa,YAAY;IAC9C,MAAMC,aAAa,IAAIC,IAAIH,qBAAqBI,SAASC,MAAM;IAC/D,MAAMC,2BAA2BlB,MAAMI,IAAI;IAC3C,MAAMe,eAAe;IAErB,MAAMC,iBAAiB;QACrBhB,MAAMJ,MAAMI,IAAI;QAChBiB,gBAAgBrB,MAAMqB,cAAc;QACpCC,MAAM;QACNC,MAAM;IACR;IAEA,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,SAASC,CAAAA,GAAAA,YAAAA,qBAAqB,EAClCH,KACAV,YACAF,qBACAQ,gBACAN,YACAd,MAAM4B,KAAK,EACXV,0BACAV,iBACAC,mBACAU;IAGF,MAAMU,UAAmB,CAAC;IAC1BA,QAAQC,0BAA0B,GAAG;IAErC,OAAOC,CAAAA,GAAAA,iBAAAA,sBAAsB,EAACjB,YAAYd,OAAO6B,SAAS,OAAOH;AACnE","ignoreList":[0]}},{"offset":{"line":8362,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return handleExternalUrl(state, mutable, retryUrl.href, false)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  // A retry should not create a new history entry.\n  const pendingPush = false\n  const shouldScroll = true\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll\n  )\n  return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n}\n"],"names":["serverPatchReducer","state","action","mutable","preserveCustomHistoryState","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","handleExternalUrl","href","currentUrl","canonicalUrl","previousTree","tree","refreshReducer","retryCanonicalUrl","createHrefFromUrl","retryNextUrl","nextUrl","pendingPush","shouldScroll","now","Date","result","navigateToSeededRoute","cache","FreshnessPolicy","RefreshAll","handleNavigationResult"],"mappings":";;;+BAYgBA,sBAAAA;;;eAAAA;;;mCAZkB;iCAOwB;4BACpB;gCACP;gCACC;AAEzB,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAMC,UAAmB,CAAC;IAC1BA,QAAQC,0BAA0B,GAAG;IAErC,uEAAuE;IACvE,0EAA0E;IAC1E,0EAA0E;IAC1E,8BAA8B;IAC9B,MAAMC,WAAWH,OAAOI,GAAG;IAC3B,MAAMC,WAAW,IAAIC,IAAIN,OAAOO,GAAG,EAAEC,SAASC,MAAM;IACpD,MAAMC,YAAYV,OAAOW,IAAI;IAC7B,IAAIR,YAAYO,cAAc,MAAM;QAClC,yEAAyE;QACzE,qBAAqB;QACrB,OAAOE,CAAAA,GAAAA,iBAAAA,iBAAiB,EAACb,OAAOE,SAASI,SAASQ,IAAI,EAAE;IAC1D;IACA,MAAMC,aAAa,IAAIR,IAAIP,MAAMgB,YAAY,EAAEP,SAASC,MAAM;IAC9D,IAAIT,OAAOgB,YAAY,KAAKjB,MAAMkB,IAAI,EAAE;QACtC,gEAAgE;QAChE,uEAAuE;QACvE,wCAAwC;QACxC,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACnB;IACxB;IACA,wEAAwE;IACxE,mDAAmD;IACnD,MAAMoB,oBAAoBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf;IAC5C,MAAMgB,eAAerB,OAAOsB,OAAO;IACnC,iDAAiD;IACjD,MAAMC,cAAc;IACpB,MAAMC,eAAe;IACrB,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,SAASC,CAAAA,GAAAA,YAAAA,qBAAqB,EAClCH,KACApB,UACAc,mBACAT,WACAI,YACAf,MAAM8B,KAAK,EACX9B,MAAMkB,IAAI,EACVa,gBAAAA,eAAe,CAACC,UAAU,EAC1BV,cACAG;IAEF,OAAOQ,CAAAA,GAAAA,iBAAAA,sBAAsB,EAAC3B,UAAUN,OAAOE,SAASsB,aAAaI;AACvE","ignoreList":[0]}},{"offset":{"line":8420,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport type { Mutable } from '../router-reducer-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredCanonicalUrl = createHrefFromUrl(restoredUrl)\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.cache,\n    state.tree,\n    treeToRestore,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    null,\n    null,\n    false,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    const mutable: Mutable = {\n      preserveCustomHistoryState: true,\n    }\n    return handleExternalUrl(state, mutable, restoredCanonicalUrl, false)\n  }\n\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation\n  )\n\n  return {\n    // Set canonical url\n    canonicalUrl: restoredCanonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: task.node,\n    // Restore provided tree\n    tree: treeToRestore,\n\n    nextUrl: restoredNextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n"],"names":["restoreReducer","state","action","treeToRestore","renderedSearch","historyState","tree","currentUrl","URL","canonicalUrl","location","origin","restoredUrl","url","restoredCanonicalUrl","createHrefFromUrl","restoredNextUrl","extractPathFromFlightRouterState","pathname","now","Date","accumulation","scrollableSegments","separateRefreshUrls","task","startPPRNavigation","cache","FreshnessPolicy","HistoryTraversal","mutable","preserveCustomHistoryState","handleExternalUrl","spawnDynamicRequests","pushRef","pendingPush","mpaNavigation","focusAndScrollRef","node","nextUrl","previousNextUrl","debugInfo"],"mappings":";;;+BAiBgBA,kBAAAA;;;eAAAA;;;mCAjBkB;oCAMe;gCAM1C;iCAE2B;AAG3B,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAIC;IACJ,IAAIC;IACJ,MAAMC,eAAeH,OAAOG,YAAY;IACxC,IAAIA,cAAc;QAChBF,gBAAgBE,aAAaC,IAAI;QACjCF,iBAAiBC,aAAaD,cAAc;IAC9C,OAAO;QACLD,gBAAgBF,MAAMK,IAAI;QAC1BF,iBAAiBH,MAAMG,cAAc;IACvC;IAEA,MAAMG,aAAa,IAAIC,IAAIP,MAAMQ,YAAY,EAAEC,SAASC,MAAM;IAC9D,MAAMC,cAAcV,OAAOW,GAAG;IAC9B,MAAMC,uBAAuBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH;IAC/C,MAAMI,kBACJC,CAAAA,GAAAA,oBAAAA,gCAAgC,EAACd,kBAAkBS,YAAYM,QAAQ;IAEzE,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,eAA8C;QAClDC,oBAAoB;QACpBC,qBAAqB;IACvB;IACA,MAAMC,OAAOC,CAAAA,GAAAA,gBAAAA,kBAAkB,EAC7BN,KACAZ,YACAN,MAAMyB,KAAK,EACXzB,MAAMK,IAAI,EACVH,eACAwB,gBAAAA,eAAe,CAACC,gBAAgB,EAChC,MACA,MACA,MACA,MACA,OACA,OACAP;IAGF,IAAIG,SAAS,MAAM;QACjB,MAAMK,UAAmB;YACvBC,4BAA4B;QAC9B;QACA,OAAOC,CAAAA,GAAAA,iBAAAA,iBAAiB,EAAC9B,OAAO4B,SAASf,sBAAsB;IACjE;IAEAkB,CAAAA,GAAAA,gBAAAA,oBAAoB,EAClBR,MACAZ,aACAI,iBACAW,gBAAAA,eAAe,CAACC,gBAAgB,EAChCP;IAGF,OAAO;QACL,oBAAoB;QACpBZ,cAAcK;QACdV;QACA6B,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FL,4BAA4B;QAC9B;QACAM,mBAAmBnC,MAAMmC,iBAAiB;QAC1CV,OAAOF,KAAKa,IAAI;QAChB,wBAAwB;QACxB/B,MAAMH;QAENmC,SAAStB;QACT,sEAAsE;QACtE,wEAAwE;QACxE,2DAA2D;QAC3DuB,iBAAiB;QACjBC,WAAW;IACb;AACF","ignoreList":[0]}},{"offset":{"line":8500,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts"],"sourcesContent":["import type {\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { refreshDynamicData } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function hmrRefreshReducer(state: ReadonlyReducerState): ReducerState {\n  return refreshDynamicData(state, FreshnessPolicy.HMRRefresh)\n}\n"],"names":["hmrRefreshReducer","state","refreshDynamicData","FreshnessPolicy","HMRRefresh"],"mappings":";;;+BAOgBA,qBAAAA;;;eAAAA;;;gCAHmB;gCACH;AAEzB,SAASA,kBAAkBC,KAA2B;IAC3D,OAAOC,CAAAA,GAAAA,gBAAAA,kBAAkB,EAACD,OAAOE,gBAAAA,eAAe,CAACC,UAAU;AAC7D","ignoreList":[0]}},{"offset":{"line":8525,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unrecognized-action-error.ts"],"sourcesContent":["export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n"],"names":["UnrecognizedActionError","unstable_isUnrecognizedActionError","Error","constructor","args","name","error"],"mappings":";;;;;;;;;;;;;;IAAaA,uBAAuB,EAAA;eAAvBA;;IAyBGC,kCAAkC,EAAA;eAAlCA;;;AAzBT,MAAMD,gCAAgCE;IAC3CC,YAAY,GAAGC,IAAyC,CAAE;QACxD,KAAK,IAAIA;QACT,IAAI,CAACC,IAAI,GAAG;IACd;AACF;AAoBO,SAASJ,mCACdK,KAAc;IAEd,OAAO,CAAC,CACNA,CAAAA,SACA,OAAOA,UAAU,YACjBA,iBAAiBN,uBAAsB;AAE3C","ignoreList":[0]}},{"offset":{"line":8566,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/assign-location.ts"],"sourcesContent":["import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n"],"names":["assignLocation","location","url","startsWith","urlBase","origin","pathname","URL","endsWith","addBasePath","href"],"mappings":";;;+BASgBA,kBAAAA;;;eAAAA;;;6BATY;AASrB,SAASA,eAAeC,QAAgB,EAAEC,GAAQ;IACvD,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,UAAUF,IAAIG,MAAM,GAAGH,IAAII,QAAQ;QACzC,OAAO,IAAIC,IACT,AAGA,AAFA,6FAA6F,kBADkB;QAE/G,qGAAqG;QACpGH,CAAAA,QAAQI,QAAQ,CAAC,OAAOJ,UAAUA,UAAU,GAAE,IAAKH;IAExD;IAEA,OAAO,IAAIM,IAAIE,CAAAA,GAAAA,aAAAA,WAAW,EAACR,WAAWC,IAAIQ,IAAI;AAChD","ignoreList":[0]}},{"offset":{"line":8596,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","getStore","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","split","slice","join","Number","at"],"mappings":";;;;;;;;;;;;;;;;;;IAegBA,gBAAgB,EAAA;eAAhBA;;IA6EAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IAvBAC,QAAQ,EAAA;eAARA;;;oCArCmB;+BAM5B;AAEP,MAAMC,qBACJ,OAAOC,WAAW,cAEZC,QAAQ,iIACRF,kBAAkB,GACpBG;AAEC,SAAST,iBACdU,GAAW,EACXC,IAAkB,EAClBC,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAG,GAAGD,eAAAA,mBAAmB,CAAC,CAAC,EAAEN,KAAK,CAAC,EAAED,IAAI,CAAC,EAAEE,WAAW,CAAC,CAAC;IACrE,OAAOG;AACT;AAcO,SAASV,SACd,2BAA2B,GAC3BK,GAAW,EACXC,IAAmB;IAEnBA,SAASL,oBAAoBa,YAAYC,WACrCC,eAAAA,YAAY,CAACC,IAAI,GACjBD,eAAAA,YAAY,CAACE,OAAO;IAExB,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACC,iBAAiB;AACxE;AAaO,SAASV,kBACd,2BAA2B,GAC3BM,GAAW,EACXC,OAAqBU,eAAAA,YAAY,CAACE,OAAO;IAEzC,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACW,iBAAiB;AACxE;AAUO,SAASrB,wBAAwBY,KAAc;IACpD,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAAS1B,yBAAyBa,KAAoB;IAC3D,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASzB,+BAA+Bc,KAAoB;IACjE,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOa,OAAOd,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0]}},{"offset":{"line":8689,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/has-base-path.ts"],"sourcesContent":["import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n"],"names":["hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","pathHasPrefix"],"mappings":"AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BAJc;AAE9B,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY;IACtC,OAAOC,CAAAA,GAAAA,eAAAA,aAAa,EAACD,MAAMJ;AAC7B","ignoreList":[0]}},{"offset":{"line":8716,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/remove-base-path.ts"],"sourcesContent":["import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n"],"names":["removeBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","__NEXT_MANUAL_CLIENT_BASE_PATH","hasBasePath","length","slice","startsWith"],"mappings":"AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,kBAAAA;;;eAAAA;;;6BAJY;AAE5B,MAAMC,mDAA6D;AAE5D,SAASD,eAAeK,IAAY;IACzC,IAAIH,QAAQC,GAAG,CAACG,8BAA8B,EAAE;;IAMhD,iDAAiD;IACjD,IAAIL,SAASO,MAAM,KAAK,GAAG,OAAOH;IAElCA,OAAOA,KAAKI,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACH,KAAKK,UAAU,CAAC,MAAML,OAAO,CAAC,CAAC,EAAEA,MAAM;IAC5C,OAAOA;AACT","ignoreList":[0]}},{"offset":{"line":8749,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { getDeploymentId } from '../../../../shared/lib/deployment-id'\nimport {\n  navigateToSeededRoute,\n  navigate as navigateUsingSegmentCache,\n} from '../../segment-cache/navigation'\nimport type { NormalizedSearch } from '../../segment-cache/cache-key'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateDynamicOnly,\n  ActionDidRevalidateStaticAndDynamic,\n  type ActionRevalidationKind,\n} from '../../../../shared/lib/action-revalidation-kind'\nimport { isExternalURL } from '../../app-router-utils'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\n// TODO: Refactor to be a discriminated union. Or just get rid of it;\n// fetchServerAction only has one caller, no reason this intermediate type has\n// to exist.\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  revalidationKind: ActionRevalidationKind\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  actionFlightDataRenderedSearch: NormalizedSearch | undefined\n  actionFlightDataCouldBeIntercepted: boolean | undefined\n  isPrerender: boolean\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n\n  let revalidationKind: ActionRevalidationKind = ActionDidNotRevalidate\n  try {\n    const revalidationHeader = res.headers.get('x-action-revalidated')\n    if (revalidationHeader) {\n      const parsedKind = JSON.parse(revalidationHeader)\n      if (\n        parsedKind === ActionDidRevalidateStaticAndDynamic ||\n        parsedKind === ActionDidRevalidateDynamicOnly\n      ) {\n        revalidationKind = parsedKind\n      }\n    }\n  } catch {}\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  let actionFlightDataRenderedSearch: FetchServerActionResult['actionFlightDataRenderedSearch']\n  let actionFlightDataCouldBeIntercepted: FetchServerActionResult['actionFlightDataCouldBeIntercepted']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    const maybeFlightData = normalizeFlightData(response.f)\n    if (maybeFlightData !== '') {\n      actionFlightData = maybeFlightData\n      actionFlightDataRenderedSearch = response.q as NormalizedSearch\n      actionFlightDataCouldBeIntercepted = response.i\n    }\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n    actionFlightDataRenderedSearch = undefined\n    actionFlightDataCouldBeIntercepted = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    actionFlightDataRenderedSearch,\n    actionFlightDataCouldBeIntercepted,\n    redirectLocation,\n    redirectType,\n    revalidationKind,\n    isPrerender,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      revalidationKind,\n      actionResult,\n      actionFlightData: flightData,\n      actionFlightDataRenderedSearch: flightDataRenderedSearch,\n      actionFlightDataCouldBeIntercepted: flightDataCouldBeIntercepted,\n      redirectLocation,\n      redirectType,\n    }) => {\n      if (revalidationKind !== ActionDidNotRevalidate) {\n        // Store whether this action triggered any revalidation\n        // The action queue will use this information to potentially\n        // trigger a refresh action if the action was discarded\n        // (ie, due to a navigation, before the action completed)\n        action.didRevalidate = true\n\n        // If there was a revalidation, evict the entire prefetch cache.\n        // TODO: Evict only segments with matching tags and/or paths.\n        if (revalidationKind === ActionDidRevalidateStaticAndDynamic) {\n          revalidateEntireCache(nextUrl, state.tree)\n        }\n      }\n\n      const pendingPush = redirectType !== RedirectType.replace\n      state.pushRef.pendingPush = pendingPush\n      mutable.pendingPush = pendingPush\n\n      if (redirectLocation !== undefined) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const resolvedRedirectType = redirectType || RedirectType.push\n\n        if (isExternalURL(redirectLocation)) {\n          // External redirect. Triggers an MPA navigation.\n          const redirectHref = redirectLocation.href\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            resolvedRedirectType\n          )\n          reject(redirectError)\n          return handleExternalUrl(state, mutable, redirectHref, pendingPush)\n        } else {\n          // Internal redirect. Triggers an SPA navigation.\n          const redirectWithBasepath = createHrefFromUrl(\n            redirectLocation,\n            false\n          )\n          const redirectHref = hasBasePath(redirectWithBasepath)\n            ? removeBasePath(redirectWithBasepath)\n            : redirectWithBasepath\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            resolvedRedirectType\n          )\n          reject(redirectError)\n        }\n      } else {\n        // If there's no redirect, resolve the action with the result.\n        resolve(actionResult)\n      }\n\n      // Check if we can bail out without updating any state.\n      if (\n        // Did the action trigger a redirect?\n        redirectLocation === undefined &&\n        // Did the action revalidate any data?\n        revalidationKind === ActionDidNotRevalidate &&\n        // Did the server render new data?\n        flightData === undefined\n      ) {\n        // The action did not trigger any revalidations or redirects. No\n        // navigation is required.\n        return state\n      }\n\n      if (flightData === undefined && redirectLocation !== undefined) {\n        // The server redirected, but did not send any Flight data. This implies\n        // an external redirect.\n        // TODO: We should refactor the action response type to be more explicit\n        // about the various response types.\n        return handleExternalUrl(\n          state,\n          mutable,\n          redirectLocation.href,\n          pendingPush\n        )\n      }\n\n      if (typeof flightData === 'string') {\n        // If the flight data is just a string, something earlier in the\n        // response handling triggered an external redirect.\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // The action triggered a navigation  either a redirect, a revalidation,\n      // or both.\n\n      // If there was no redirect, then the target URL is the same as the\n      // current URL.\n      const currentUrl = new URL(state.canonicalUrl, location.origin)\n      const redirectUrl =\n        redirectLocation !== undefined ? redirectLocation : currentUrl\n      const currentFlightRouterState = state.tree\n      const shouldScroll = true\n\n      // If the action triggered a revalidation of the cache, we should also\n      // refresh all the dynamic data.\n      const freshnessPolicy =\n        revalidationKind === ActionDidNotRevalidate\n          ? FreshnessPolicy.Default\n          : FreshnessPolicy.RefreshAll\n\n      // The server may have sent back new data. If so, we will perform a\n      // \"seeded\" navigation that uses the data from the response.\n      if (flightData !== undefined) {\n        const normalizedFlightData = flightData[0]\n        if (\n          normalizedFlightData !== undefined &&\n          // TODO: Currently the server always renders from the root in\n          // response to a Server Action. In the case of a normal redirect\n          // with no revalidation, it should skip over the shared layouts.\n          normalizedFlightData.isRootRender &&\n          flightDataRenderedSearch !== undefined &&\n          flightDataCouldBeIntercepted !== undefined\n        ) {\n          // The server sent back new route data as part of the response. We\n          // will use this to render the new page. If this happens to be only a\n          // subset of the data needed to render the new page, we'll initiate a\n          // new fetch, like we would for a normal navigation.\n          const redirectCanonicalUrl = createHrefFromUrl(redirectUrl)\n          const navigationSeed = {\n            tree: normalizedFlightData.tree,\n            renderedSearch: flightDataRenderedSearch,\n            data: normalizedFlightData.seedData,\n            head: normalizedFlightData.head,\n          }\n          const now = Date.now()\n          const result = navigateToSeededRoute(\n            now,\n            redirectUrl,\n            redirectCanonicalUrl,\n            navigationSeed,\n            currentUrl,\n            state.cache,\n            currentFlightRouterState,\n            freshnessPolicy,\n            nextUrl,\n            shouldScroll\n          )\n          return handleNavigationResult(\n            redirectUrl,\n            state,\n            mutable,\n            pendingPush,\n            result\n          )\n        }\n      }\n\n      // The server did not send back new data. We'll perform a regular, non-\n      // seeded navigation  effectively the same as <Link> or router.push().\n      const result = navigateUsingSegmentCache(\n        redirectUrl,\n        currentUrl,\n        state.cache,\n        currentFlightRouterState,\n        nextUrl,\n        freshnessPolicy,\n        shouldScroll,\n        mutable\n      )\n      return handleNavigationResult(\n        redirectUrl,\n        state,\n        mutable,\n        pendingPush,\n        result\n      )\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n\nfunction createRedirectErrorForAction(\n  redirectHref: string,\n  resolvedRedirectType: RedirectType\n) {\n  const redirectError = getRedirectError(redirectHref, resolvedRedirectType)\n  // We mark the error as handled because we don't want the redirect to be tried later by\n  // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n  // again, as it's run within an effect.\n  // We don't actually need the RedirectBoundary to do a router.push because we already\n  // have all the necessary RSC data to render the new page within a single roundtrip.\n  ;(redirectError as any).handled = true\n  return redirectError\n}\n"],"names":["serverActionReducer","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","info","extractInfoFromServerReferenceId","usedArgs","type","omitUnusedArgs","body","encodeReply","headers","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","tree","deploymentId","getDeploymentId","NEXT_URL","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","location","_redirectType","split","redirectType","RedirectType","push","replace","undefined","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidationKind","ActionDidNotRevalidate","revalidationHeader","parsedKind","JSON","parse","ActionDidRevalidateStaticAndDynamic","ActionDidRevalidateDynamicOnly","redirectLocation","assignLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","actionFlightDataRenderedSearch","actionFlightDataCouldBeIntercepted","response","Promise","resolve","callServer","findSourceMapURL","debugChannel","a","maybeFlightData","normalizeFlightData","f","q","i","action","reject","mutable","preserveCustomHistoryState","previousNextUrl","hasInterceptionRouteInCurrentTree","then","flightData","flightDataRenderedSearch","flightDataCouldBeIntercepted","didRevalidate","revalidateEntireCache","pendingPush","pushRef","resolvedRedirectType","isExternalURL","redirectHref","redirectError","createRedirectErrorForAction","handleExternalUrl","redirectWithBasepath","createHrefFromUrl","hasBasePath","removeBasePath","currentUrl","origin","redirectUrl","currentFlightRouterState","shouldScroll","freshnessPolicy","FreshnessPolicy","Default","RefreshAll","normalizedFlightData","isRootRender","redirectCanonicalUrl","navigationSeed","renderedSearch","data","seedData","head","now","Date","result","navigateToSeededRoute","cache","handleNavigationResult","navigateUsingSegmentCache","e","getRedirectError","handled"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":9042,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["reducer","clientReducer","state","action","type","ACTION_NAVIGATE","navigateReducer","ACTION_SERVER_PATCH","serverPatchReducer","ACTION_RESTORE","restoreReducer","ACTION_REFRESH","refreshReducer","ACTION_HMR_REFRESH","hmrRefreshReducer","ACTION_SERVER_ACTION","serverActionReducer","Error","serverReducer","_action","window"],"mappings":";;;+BA4DaA,WAAAA;;;eAAAA;;;oCArDN;iCAMyB;oCACG;gCACJ;gCACA;mCACG;qCACE;AAEpC;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKC,oBAAAA,eAAe;YAAE;gBACpB,OAAOC,CAAAA,GAAAA,iBAAAA,eAAe,EAACJ,OAAOC;YAChC;QACA,KAAKI,oBAAAA,mBAAmB;YAAE;gBACxB,OAAOC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACN,OAAOC;YACnC;QACA,KAAKM,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACR,OAAOC;YAC/B;QACA,KAAKQ,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACV;YACxB;QACA,KAAKW,oBAAAA,kBAAkB;YAAE;gBACvB,OAAOC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACZ;YAC3B;QACA,KAAKa,oBAAAA,oBAAoB;YAAE;gBACzB,OAAOC,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACd,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,OAAA,cAA2B,CAA3B,IAAIc,MAAM,mBAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0B;IACpC;AACF;AAEA,SAASC,cACPhB,KAA2B,EAC3BiB,OAAuB;IAEvB,OAAOjB;AACT;AAGO,MAAMF,UACX,OAAOoB,WAAW,cAAcF,gBAAgBjB","ignoreList":[0]}},{"offset":{"line":9110,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/segment-cache/prefetch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport { PrefetchPriority, type PrefetchTaskFetchStrategy } from './types'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription  it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n"],"names":["prefetch","href","nextUrl","treeAtTimeOfPrefetch","fetchStrategy","onInvalidate","url","createPrefetchURL","cacheKey","createCacheKey","schedulePrefetchTask","PrefetchPriority","Default"],"mappings":";;;+BA0BgBA,YAAAA;;;eAAAA;;;gCAzBkB;0BACH;2BACM;uBAC4B;AAsB1D,SAASA,SACdC,IAAY,EACZC,OAAsB,EACtBC,oBAAuC,EACvCC,aAAwC,EACxCC,YAAiC;IAEjC,MAAMC,MAAMC,CAAAA,GAAAA,gBAAAA,iBAAiB,EAACN;IAC9B,IAAIK,QAAQ,MAAM;QAChB,sCAAsC;QACtC;IACF;IACA,MAAME,WAAWC,CAAAA,GAAAA,UAAAA,cAAc,EAACH,IAAIL,IAAI,EAAEC;IAC1CQ,CAAAA,GAAAA,WAAAA,oBAAoB,EAClBF,UACAL,sBACAC,eACAO,OAAAA,gBAAgB,CAACC,OAAO,EACxBP;AAEJ","ignoreList":[0]}},{"offset":{"line":9143,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-instance.ts"],"sourcesContent":["import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch({ type: ACTION_REFRESH }, setState)\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","prevState","state","payload","actionResult","handleResult","nextState","discarded","ACTION_SERVER_ACTION","didRevalidate","resolve","isThenable","then","err","reject","dispatchAction","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","globalActionQueue","initialState","instrumentationHooks","result","reducer","onRouterTransitionStart","window","Error","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","location","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","historyState","back","history","forward","prefetch","options","prefetchKind","kind","PrefetchKind","AUTO","fetchStrategy","FetchStrategy","PPR","FULL","Full","prefetchWithSegmentCache","nextUrl","tree","onInvalidate","replace","scroll","push","refresh","hmrRefresh","NODE_ENV","ACTION_HMR_REFRESH","router"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":9460,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router-announcer.tsx"],"sourcesContent":["import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../shared/lib/app-router-types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n"],"names":["AppRouterAnnouncer","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","tree","portalNode","setPortalNode","useState","useEffect","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","undefined","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal"],"mappings":";;;+BA6BgBA,sBAAAA;;;eAAAA;;;uBA7B4B;0BACf;AAG7B,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;IACP,MAAMC,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,mBAAmBG,YAAYC,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEO,SAASb,mBAAmB,EAAEsB,IAAI,EAA+B;IACtE,MAAM,CAACC,YAAYC,cAAc,GAAGC,CAAAA,GAAAA,OAAAA,QAAQ,EAAqB;IAEjEC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,MAAMb,YAAYV;QAClBqB,cAAcX;QACd,OAAO;YACL,MAAMJ,YAAYJ,SAASsB,oBAAoB,CAAC1B,eAAe,CAAC,EAAE;YAClE,IAAIQ,WAAWmB,aAAa;gBAC1BvB,SAASgB,IAAI,CAACQ,WAAW,CAACpB;YAC5B;QACF;IACF,GAAG,EAAE;IAEL,MAAM,CAACqB,mBAAmBC,qBAAqB,GAAGN,CAAAA,GAAAA,OAAAA,QAAQ,EAAC;IAC3D,MAAMO,gBAAgBC,CAAAA,GAAAA,OAAAA,MAAM,EAAqBC;IAEjDR,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,IAAIS,eAAe;QACnB,IAAI9B,SAAS+B,KAAK,EAAE;YAClBD,eAAe9B,SAAS+B,KAAK;QAC/B,OAAO;YACL,MAAMC,aAAahC,SAASiC,aAAa,CAAC;YAC1C,IAAID,YAAY;gBACdF,eAAeE,WAAWE,SAAS,IAAIF,WAAWG,WAAW,IAAI;YACnE;QACF;QAEA,4EAA4E;QAC5E,iCAAiC;QACjC,IACER,cAAcS,OAAO,KAAKP,aAC1BF,cAAcS,OAAO,KAAKN,cAC1B;YACAJ,qBAAqBI;QACvB;QACAH,cAAcS,OAAO,GAAGN;IAC1B,GAAG;QAACb;KAAK;IAET,OAAOC,aAAAA,WAAAA,GAAamB,CAAAA,GAAAA,UAAAA,YAAY,EAACZ,mBAAmBP,cAAc;AACpE","ignoreList":[0]}},{"offset":{"line":9540,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAsBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},{"offset":{"line":9592,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAuBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},{"offset":{"line":9645,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unstable-rethrow.browser.ts"],"sourcesContent":["import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","Error","cause"],"mappings":";;;+BAGgBA,oBAAAA;;;eAAAA;;;8BAHoB;mCACF;AAE3B,SAASA,iBAAiBC,KAAc;IAC7C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAAUE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;QAC1D,MAAMA;IACR;IAEA,IAAIA,iBAAiBG,SAAS,WAAWH,OAAO;QAC9CD,iBAAiBC,MAAMI,KAAK;IAC9B;AACF","ignoreList":[0]}},{"offset":{"line":9675,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err"],"mappings":";;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAC,CAAC,sBAAsB,EAAEA,aAAa,GAAA,IAAA,CADlBA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0]}},{"offset":{"line":9719,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error"],"mappings":";;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB","ignoreList":[0]}},{"offset":{"line":9763,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","isPrerenderInterruptedError","Error","cause"],"mappings":";;;+BAUgBA,oBAAAA;;;eAAAA;;;uCAV+B;4BACpB;8BACS;mCACF;kCAI3B;oCAC8B;AAE9B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACH,UACrBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ,UAClBK,CAAAA,GAAAA,YAAAA,UAAU,EAACL,UACXM,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACN,UAC/BO,CAAAA,GAAAA,kBAAAA,2BAA2B,EAACP,QAC5B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBQ,SAAS,WAAWR,OAAO;QAC9CD,iBAAiBC,MAAMS,KAAK;IAC9B;AACF","ignoreList":[0]}},{"offset":{"line":9797,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC;;;+BACYA,oBAAAA;;;eAAAA;;;AAAN,MAAMA,mBACX,OAAOC,WAAW,cAEZC,QAAQ,2HACRF,gBAAgB,GAEhBE,QAAQ,4HACRF,gBAAgB","ignoreList":[0]}},{"offset":{"line":9824,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","Error"],"mappings":";;;;;;;;;;;;;;;;;;;;;IAcSA,uBAAuB,EAAA;eAAvBA,yBAAAA,uBAAuB;;IALvBC,YAAY,EAAA;eAAZA,eAAAA,YAAY;;IAEZC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAFEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAIRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IAVLC,kCAAkC,EAAA;eAAlCA;;IAWPC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;yCAbe;0BAQI;+BACf;0BACJ;2BACC;8BACG;iCACI;AAX1B,SAASD;IACd,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0]}},{"offset":{"line":9898,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  ReadonlyURLSearchParams,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo((): ReadonlyURLSearchParams => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null!\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams])\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  // We need the same class that was used to instantiate the context value\n  // Otherwise instanceof checks will fail in usercode\n  ReadonlyURLSearchParams,\n}\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  unstable_rethrow,\n} from './navigation.react-server'\n"],"names":["ReadonlyURLSearchParams","RedirectType","ServerInsertedHTMLContext","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","useDynamicRouteParams","window","require","undefined","useDynamicSearchParams","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","process","env","NODE_ENV","React","navigationPromises","use","NavigationPromisesContext","pathname","PathnameContext","router","AppRouterContext","Error","params","PathParamsContext","parallelRouteKey","context","LayoutRouterContext","promise","selectedLayoutSegmentsPromises","get","getSelectedLayoutSegmentPath","parentTree","selectedLayoutSegments","selectedLayoutSegmentPromises","computeSelectedLayoutSegment"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":10100,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/redirect-boundary.tsx"],"sourcesContent":["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],"names":["RedirectBoundary","RedirectErrorBoundary","HandleRedirect","redirect","reset","redirectType","router","useRouter","useEffect","React","startTransition","RedirectType","push","replace","Component","constructor","props","state","getDerivedStateFromError","error","isRedirectError","url","getURLFromRedirectError","getRedirectTypeFromError","render","setState","children"],"mappings":";;;;;;;;;;;;;;IAgFgBA,gBAAgB,EAAA;eAAhBA;;IA3CHC,qBAAqB,EAAA;eAArBA;;;;;iEApCoB;4BAEP;0BACwC;+BACpB;AAO9C,SAASC,eAAe,EACtBC,QAAQ,EACRC,KAAK,EACLC,YAAY,EAKb;IACC,MAAMC,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IAExBC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACRC,OAAAA,OAAK,CAACC,eAAe,CAAC;YACpB,IAAIL,iBAAiBM,eAAAA,YAAY,CAACC,IAAI,EAAE;gBACtCN,OAAOM,IAAI,CAACT,UAAU,CAAC;YACzB,OAAO;gBACLG,OAAOO,OAAO,CAACV,UAAU,CAAC;YAC5B;YACAC;QACF;IACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;KAAO;IAE1C,OAAO;AACT;AAEO,MAAML,8BAA8BQ,OAAAA,OAAK,CAACK,SAAS;IAIxDC,YAAYC,KAA4B,CAAE;QACxC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEd,UAAU;YAAME,cAAc;QAAK;IACpD;IAEA,OAAOa,yBAAyBC,KAAU,EAAE;QAC1C,IAAIC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,QAAQ;YAC1B,MAAME,MAAMC,CAAAA,GAAAA,UAAAA,uBAAuB,EAACH;YACpC,MAAMd,eAAekB,CAAAA,GAAAA,UAAAA,wBAAwB,EAACJ;YAC9C,IAAI,aAAaA,OAAO;gBACtB,yEAAyE;gBACzE,gFAAgF;gBAChF,eAAe;gBACf,OAAO;oBAAEhB,UAAU;oBAAME,cAAc;gBAAK;YAC9C;YAEA,OAAO;gBAAEF,UAAUkB;gBAAKhB;YAAa;QACvC;QACA,wCAAwC;QACxC,MAAMc;IACR;IAEA,yIAAyI;IACzIK,SAA0B;QACxB,MAAM,EAAErB,QAAQ,EAAEE,YAAY,EAAE,GAAG,IAAI,CAACY,KAAK;QAC7C,IAAId,aAAa,QAAQE,iBAAiB,MAAM;YAC9C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACH,gBAAAA;gBACCC,UAAUA;gBACVE,cAAcA;gBACdD,OAAO,IAAM,IAAI,CAACqB,QAAQ,CAAC;wBAAEtB,UAAU;oBAAK;;QAGlD;QAEA,OAAO,IAAI,CAACa,KAAK,CAACU,QAAQ;IAC5B;AACF;AAEO,SAAS1B,iBAAiB,EAAE0B,QAAQ,EAAiC;IAC1E,MAAMpB,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IACxB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACN,uBAAAA;QAAsBK,QAAQA;kBAASoB;;AAE5C","ignoreList":[0]}},{"offset":{"line":10208,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n"],"names":["findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","cacheNode","item"],"mappings":";;;+BAOgBA,mBAAAA;;;eAAAA;;;yBAHoB;sCACC;AAE9B,SAASA,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,KAAK,MAAMD,OAAOF,mBAAoB;QACpC,MAAM,CAACI,SAASC,oBAAoB,GAAGb,cAAc,CAACU,IAAI;QAC1D,gEAAgE;QAChE,mCAAmC;QACnC,IAAIE,YAAYE,SAAAA,mBAAmB,EAAE;YACnC;QACF;QACA,MAAMC,kBAAkBhB,MAAMC,cAAc,CAACgB,GAAG,CAACN;QACjD,IAAI,CAACK,iBAAiB;YACpB;QACF;QAEA,MAAME,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACN;QACtC,MAAMO,8BAA8BD,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACN,SAAS;QAElE,MAAMQ,YAAYL,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACG,WAAW;YACd;QACF;QAEA,MAAMC,OAAOpB,oBACXmB,WACAP,qBACAX,YAAY,MAAMe,UAClBf,YAAY,MAAMiB;QAGpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},{"offset":{"line":10274,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/unresolved-thenable.ts"],"sourcesContent":["/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n"],"names":["unresolvedThenable","then"],"mappings":"AAAA;;CAEC;;;+BACYA,sBAAAA;;;eAAAA;;;AAAN,MAAMA,qBAAqB;IAChCC,MAAM,KAAO;AACf","ignoreList":[0]}},{"offset":{"line":10299,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/errors/graceful-degrade-boundary.tsx"],"sourcesContent":["'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n"],"names":["GracefulDegradeBoundary","getDomNodeAttributes","node","result","i","attributes","length","attr","name","value","Component","constructor","props","state","hasError","rootHtml","htmlAttributes","htmlRef","createRef","getDerivedStateFromError","_","componentDidMount","htmlNode","current","Object","entries","forEach","key","setAttribute","render","window","document","documentElement","innerHTML","html","ref","suppressHydrationWarning","dangerouslySetInnerHTML","__html","children"],"mappings":";;;;;;;;;;;;;;IAqBaA,uBAAuB,EAAA;eAAvBA;;IAuDb,OAAsC,EAAA;eAAtC;;;;uBA1EqD;AAUrD,SAASC,qBAAqBC,IAAiB;IAC7C,MAAMC,SAAiC,CAAC;IACxC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,KAAKG,UAAU,CAACC,MAAM,EAAEF,IAAK;QAC/C,MAAMG,OAAOL,KAAKG,UAAU,CAACD,EAAE;QAC/BD,MAAM,CAACI,KAAKC,IAAI,CAAC,GAAGD,KAAKE,KAAK;IAChC;IACA,OAAON;AACT;AAEO,MAAMH,gCAAgCU,OAAAA,SAAS;IAQpDC,YAAYC,KAAyB,CAAE;QACrC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEC,UAAU;QAAM;QAC/B,IAAI,CAACC,QAAQ,GAAG;QAChB,IAAI,CAACC,cAAc,GAAG,CAAC;QACvB,IAAI,CAACC,OAAO,GAAA,WAAA,GAAGC,CAAAA,GAAAA,OAAAA,SAAS;IAC1B;IAEA,OAAOC,yBAAyBC,CAAU,EAAsB;QAC9D,OAAO;YAAEN,UAAU;QAAK;IAC1B;IAEAO,oBAAoB;QAClB,MAAMC,WAAW,IAAI,CAACL,OAAO,CAACM,OAAO;QACrC,IAAI,IAAI,CAACV,KAAK,CAACC,QAAQ,IAAIQ,UAAU;YACnC,yDAAyD;YACzDE,OAAOC,OAAO,CAAC,IAAI,CAACT,cAAc,EAAEU,OAAO,CAAC,CAAC,CAACC,KAAKlB,MAAM;gBACvDa,SAASM,YAAY,CAACD,KAAKlB;YAC7B;QACF;IACF;IAEAoB,SAAS;QACP,MAAM,EAAEf,QAAQ,EAAE,GAAG,IAAI,CAACD,KAAK;QAC/B,kDAAkD;QAClD,IAAI,OAAOiB,WAAW,eAAe,CAAC,IAAI,CAACf,QAAQ,EAAE;YACnD,IAAI,CAACA,QAAQ,GAAGgB,SAASC,eAAe,CAACC,SAAS;YAClD,IAAI,CAACjB,cAAc,GAAGf,qBAAqB8B,SAASC,eAAe;QACrE;QAEA,IAAIlB,UAAU;YACZ,oDAAoD;YACpD,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACoB,QAAAA;gBACCC,KAAK,IAAI,CAAClB,OAAO;gBACjBmB,wBAAwB,EAAA;gBACxBC,yBAAyB;oBACvBC,QAAQ,IAAI,CAACvB,QAAQ;gBACvB;;QAGN;QAEA,OAAO,IAAI,CAACH,KAAK,CAAC2B,QAAQ;IAC5B;AACF;MAEA,WAAevC","ignoreList":[0]}},{"offset":{"line":10386,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/errors/root-error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n"],"names":["RootErrorBoundary","isBotUserAgent","window","isBot","navigator","userAgent","children","errorComponent","errorStyles","errorScripts","GracefulDegradeBoundary","ErrorBoundary"],"mappings":";;;+BAUA,WAAA;;;eAAwBA;;;;;gEARQ;kFACI;+BACmB;uBACjC;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AAEpD,SAASL,kBAAkB,EACxCM,QAAQ,EACRC,cAAc,EACdC,WAAW,EACXC,YAAY,EACuC;IACnD,IAAIR,gBAAgB;QAClB,kFAAkF;QAClF,8CAA8C;QAC9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACS,yBAAAA,OAAuB,EAAA;sBAAEJ;;IACnC;IAEA,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACK,eAAAA,aAAa,EAAA;QACZJ,gBAAgBA;QAChBC,aAAaA;QACbC,cAAcA;kBAEbH;;AAGP","ignoreList":[0]}},{"offset":{"line":10428,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/navigation-devtools.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { Params } from '../../server/request/params'\nimport {\n  createDevToolsInstrumentedPromise,\n  ReadonlyURLSearchParams,\n  type InstrumentedPromise,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\n\n/**\n * Promises are cached by tree to ensure stability across suspense retries.\n */\ntype LayoutSegmentPromisesCache = {\n  selectedLayoutSegmentPromises: Map<string, InstrumentedPromise<string | null>>\n  selectedLayoutSegmentsPromises: Map<string, InstrumentedPromise<string[]>>\n}\n\nconst layoutSegmentPromisesCache = new WeakMap<\n  FlightRouterState,\n  LayoutSegmentPromisesCache\n>()\n\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */\nfunction createLayoutSegmentPromises(\n  tree: FlightRouterState\n): LayoutSegmentPromisesCache | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Check if we already have cached promises for this tree\n  const cached = layoutSegmentPromisesCache.get(tree)\n  if (cached) {\n    return cached\n  }\n\n  // Create new promises and cache them\n  const segmentPromises = new Map<string, InstrumentedPromise<string | null>>()\n  const segmentsPromises = new Map<string, InstrumentedPromise<string[]>>()\n\n  const parallelRoutes = tree[1]\n  for (const parallelRouteKey of Object.keys(parallelRoutes)) {\n    const segments = getSelectedLayoutSegmentPath(tree, parallelRouteKey)\n\n    // Use the shared logic to compute the segment value\n    const segment = computeSelectedLayoutSegment(segments, parallelRouteKey)\n\n    segmentPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegment', segment)\n    )\n    segmentsPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegments', segments)\n    )\n  }\n\n  const result: LayoutSegmentPromisesCache = {\n    selectedLayoutSegmentPromises: segmentPromises,\n    selectedLayoutSegmentsPromises: segmentsPromises,\n  }\n\n  // Cache the result for future renders\n  layoutSegmentPromisesCache.set(tree, result)\n\n  return result\n}\n\nconst rootNavigationPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<string, NavigationPromises>\n>()\n\n/**\n * Creates instrumented navigation promises for the root app-router.\n */\nexport function createRootNavigationPromises(\n  tree: FlightRouterState,\n  pathname: string,\n  searchParams: URLSearchParams,\n  pathParams: Params\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Create stable cache keys from the values\n  const searchParamsString = searchParams.toString()\n  const pathParamsString = JSON.stringify(pathParams)\n  const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`\n\n  // Get or create the cache for this tree\n  let treeCache = rootNavigationPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<string, NavigationPromises>()\n    rootNavigationPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this combination\n  const cached = treeCache.get(cacheKey)\n  if (cached) {\n    return cached\n  }\n\n  const readonlySearchParams = new ReadonlyURLSearchParams(searchParams)\n\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n\n  const promises: NavigationPromises = {\n    pathname: createDevToolsInstrumentedPromise('usePathname', pathname),\n    searchParams: createDevToolsInstrumentedPromise(\n      'useSearchParams',\n      readonlySearchParams\n    ),\n    params: createDevToolsInstrumentedPromise('useParams', pathParams),\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(cacheKey, promises)\n\n  return promises\n}\n\nconst nestedLayoutPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<NavigationPromises | null, NavigationPromises>\n>()\n\n/**\n * Creates merged navigation promises for nested layouts.\n * Merges parent promises with layout-specific segment promises.\n */\nexport function createNestedLayoutNavigationPromises(\n  tree: FlightRouterState,\n  parentNavPromises: NavigationPromises | null\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  const parallelRoutes = tree[1]\n  const parallelRouteKeys = Object.keys(parallelRoutes)\n\n  // Only create promises if there are parallel routes at this level\n  if (parallelRouteKeys.length === 0) {\n    return null\n  }\n\n  // Get or create the cache for this tree\n  let treeCache = nestedLayoutPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<NavigationPromises | null, NavigationPromises>()\n    nestedLayoutPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this parent combination\n  const cached = treeCache.get(parentNavPromises)\n  if (cached) {\n    return cached\n  }\n\n  // Create merged promises\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n  const promises: NavigationPromises = {\n    ...parentNavPromises!,\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(parentNavPromises, promises)\n\n  return promises\n}\n"],"names":["createNestedLayoutNavigationPromises","createRootNavigationPromises","layoutSegmentPromisesCache","WeakMap","createLayoutSegmentPromises","tree","process","env","NODE_ENV","cached","get","segmentPromises","Map","segmentsPromises","parallelRoutes","parallelRouteKey","Object","keys","segments","getSelectedLayoutSegmentPath","segment","computeSelectedLayoutSegment","set","createDevToolsInstrumentedPromise","result","selectedLayoutSegmentPromises","selectedLayoutSegmentsPromises","rootNavigationPromisesCache","pathname","searchParams","pathParams","searchParamsString","toString","pathParamsString","JSON","stringify","cacheKey","treeCache","readonlySearchParams","ReadonlyURLSearchParams","layoutSegmentPromises","promises","params","nestedLayoutPromisesCache","parentNavPromises","parallelRouteKeys","length"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":10555,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["HTTPAccessFallbackBoundary","HTTPAccessFallbackErrorBoundary","React","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","process","env","NODE_ENV","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","warnOnce","getDerivedStateFromError","error","isHTTPAccessFallbackError","httpStatus","getAccessFallbackHTTPStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getAccessFallbackErrorTypeByStatus","useUntrackedPathname","useContext","MissingSlotContext","hasErrorFallback"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":10684,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/dev-root-http-access-fallback-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React from 'react'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\n\n// TODO: error on using forbidden and unauthorized in root layout\nexport function bailOnRootNotFound() {\n  throw new Error('notFound() is not allowed to use in root layout')\n}\n\nfunction NotAllowedRootHTTPFallbackError() {\n  bailOnRootNotFound()\n  return null\n}\n\nexport function DevRootHTTPAccessFallbackBoundary({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <HTTPAccessFallbackBoundary notFound={<NotAllowedRootHTTPFallbackError />}>\n      {children}\n    </HTTPAccessFallbackBoundary>\n  )\n}\n"],"names":["DevRootHTTPAccessFallbackBoundary","bailOnRootNotFound","Error","NotAllowedRootHTTPFallbackError","children","HTTPAccessFallbackBoundary","notFound"],"mappings":";;;;;;;;;;;;;;IAegBA,iCAAiC,EAAA;eAAjCA;;IATAC,kBAAkB,EAAA;eAAlBA;;;;;gEAJE;+BACyB;AAGpC,SAASA;IACd,MAAM,OAAA,cAA4D,CAA5D,IAAIC,MAAM,oDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA2D;AACnE;AAEA,SAASC;IACPF;IACA,OAAO;AACT;AAEO,SAASD,kCAAkC,EAChDI,QAAQ,EAGT;IACC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,eAAAA,0BAA0B,EAAA;QAACC,UAAAA,WAAAA,GAAU,CAAA,GAAA,YAAA,GAAA,EAACH,iCAAAA,CAAAA;kBACpCC;;AAGP","ignoreList":[0]}},{"offset":{"line":10737,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/shared.ts"],"sourcesContent":["import type { HmrMessageSentToBrowser } from '../../../server/dev/hot-reloader-types'\n\nexport const REACT_REFRESH_FULL_RELOAD =\n  '[Fast Refresh] performing full reload\\n\\n' +\n  \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n  'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n  'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n  'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n  'Fast Refresh requires at least one parent function component in your React tree.'\n\nexport const REACT_REFRESH_FULL_RELOAD_FROM_ERROR =\n  '[Fast Refresh] performing full reload because your application had an unrecoverable error'\n\nexport function reportInvalidHmrMessage(\n  message: HmrMessageSentToBrowser | MessageEvent<unknown>,\n  err: unknown\n) {\n  console.warn(\n    '[HMR] Invalid message: ' +\n      JSON.stringify(message) +\n      '\\n' +\n      ((err instanceof Error && err?.stack) || '')\n  )\n}\n"],"names":["REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","reportInvalidHmrMessage","message","err","console","warn","JSON","stringify","Error","stack"],"mappings":";;;;;;;;;;;;;;;IAEaA,yBAAyB,EAAA;eAAzBA;;IAQAC,oCAAoC,EAAA;eAApCA;;IAGGC,uBAAuB,EAAA;eAAvBA;;;AAXT,MAAMF,4BACX,8CACA,mIACA,qIACA,+GACA,8HACA;AAEK,MAAMC,uCACX;AAEK,SAASC,wBACdC,OAAwD,EACxDC,GAAY;IAEZC,QAAQC,IAAI,CACV,4BACEC,KAAKC,SAAS,CAACL,WACf,OACC,CAACC,eAAeK,SAASL,KAAKM,SAAU,EAAC;AAEhD","ignoreList":[0]}},{"offset":{"line":10778,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/get-socket-url.ts"],"sourcesContent":["import { normalizedAssetPrefix } from '../../../shared/lib/normalized-asset-prefix'\n\nfunction getSocketProtocol(assetPrefix: string): string {\n  let protocol = window.location.protocol\n\n  try {\n    // assetPrefix is a url\n    protocol = new URL(assetPrefix).protocol\n  } catch {}\n\n  return protocol === 'http:' ? 'ws:' : 'wss:'\n}\n\nexport function getSocketUrl(assetPrefix: string | undefined): string {\n  const prefix = normalizedAssetPrefix(assetPrefix)\n  const protocol = getSocketProtocol(assetPrefix || '')\n\n  if (URL.canParse(prefix)) {\n    // since normalized asset prefix is ensured to be a URL format,\n    // we can safely replace the protocol\n    return prefix.replace(/^http/, 'ws')\n  }\n\n  const { hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? `:${port}` : ''}${prefix}`\n}\n"],"names":["getSocketUrl","getSocketProtocol","assetPrefix","protocol","window","location","URL","prefix","normalizedAssetPrefix","canParse","replace","hostname","port"],"mappings":";;;+BAagBA,gBAAAA;;;eAAAA;;;uCAbsB;AAEtC,SAASC,kBAAkBC,WAAmB;IAC5C,IAAIC,WAAWC,OAAOC,QAAQ,CAACF,QAAQ;IAEvC,IAAI;QACF,uBAAuB;QACvBA,WAAW,IAAIG,IAAIJ,aAAaC,QAAQ;IAC1C,EAAE,OAAM,CAAC;IAET,OAAOA,aAAa,UAAU,QAAQ;AACxC;AAEO,SAASH,aAAaE,WAA+B;IAC1D,MAAMK,SAASC,CAAAA,GAAAA,uBAAAA,qBAAqB,EAACN;IACrC,MAAMC,WAAWF,kBAAkBC,eAAe;IAElD,IAAII,IAAIG,QAAQ,CAACF,SAAS;QACxB,+DAA+D;QAC/D,qCAAqC;QACrC,OAAOA,OAAOG,OAAO,CAAC,SAAS;IACjC;IAEA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAE,GAAGR,OAAOC,QAAQ;IAC1C,OAAO,GAAGF,SAAS,EAAE,EAAEQ,WAAWC,OAAO,CAAC,CAAC,EAAEA,MAAM,GAAG,KAAKL,QAAQ;AACrE","ignoreList":[0]}},{"offset":{"line":10818,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/app/web-socket.ts"],"sourcesContent":["import { useContext, useEffect } from 'react'\nimport { GlobalLayoutRouterContext } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { getSocketUrl } from '../get-socket-url'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n  type TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport { reportInvalidHmrMessage } from '../shared'\nimport {\n  performFullReload,\n  processMessage,\n  type StaticIndicatorState,\n} from './hot-reloader-app'\nimport { logQueue } from '../../../../next-devtools/userspace/app/forward-logs'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { WEB_SOCKET_MAX_RECONNECTIONS } from '../../../../lib/constants'\n\nlet reconnections = 0\nlet reloading = false\nlet serverSessionId: number | null = null\nlet mostRecentCompilationHash: string | null = null\n\nexport function createWebSocket(\n  assetPrefix: string,\n  staticIndicatorState: StaticIndicatorState\n) {\n  if (!self.__next_r) {\n    throw new InvariantError(\n      `Expected a request ID to be defined for the document via self.__next_r.`\n    )\n  }\n\n  let webSocket: WebSocket\n  let timer: ReturnType<typeof setTimeout>\n\n  const sendMessage = (data: string) => {\n    if (webSocket && webSocket.readyState === webSocket.OPEN) {\n      webSocket.send(data)\n    }\n  }\n\n  const processTurbopackMessage = createProcessTurbopackMessage(sendMessage)\n\n  function init() {\n    if (webSocket) {\n      webSocket.close()\n    }\n\n    const newWebSocket = new window.WebSocket(\n      `${getSocketUrl(assetPrefix)}/_next/webpack-hmr?id=${self.__next_r}`\n    )\n\n    newWebSocket.binaryType = 'arraybuffer'\n\n    function handleOnline() {\n      logQueue.onSocketReady(newWebSocket)\n\n      reconnections = 0\n      window.console.log('[HMR] connected')\n    }\n\n    function handleMessage(event: MessageEvent) {\n      // While the page is reloading, don't respond to any more messages.\n      if (reloading) {\n        return\n      }\n\n      try {\n        const message: HmrMessageSentToBrowser =\n          event.data instanceof ArrayBuffer\n            ? parseBinaryMessage(event.data)\n            : JSON.parse(event.data)\n\n        // Check for server restart in Turbopack mode\n        if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED) {\n          if (\n            serverSessionId !== null &&\n            serverSessionId !== message.data.sessionId\n          ) {\n            // Either the server's session id has changed and it's a new server, or\n            // it's been too long since we disconnected and we should reload the page.\n            window.location.reload()\n            reloading = true\n            return\n          }\n          serverSessionId = message.data.sessionId\n        }\n\n        // Track webpack compilation hash for server restart detection\n        if (\n          message.type === HMR_MESSAGE_SENT_TO_BROWSER.SYNC &&\n          'hash' in message\n        ) {\n          // If we had previously reconnected and the hash changed, the server may have restarted\n          if (\n            mostRecentCompilationHash !== null &&\n            mostRecentCompilationHash !== message.hash\n          ) {\n            window.location.reload()\n            reloading = true\n            return\n          }\n          mostRecentCompilationHash = message.hash\n        }\n\n        processMessage(\n          message,\n          sendMessage,\n          processTurbopackMessage,\n          staticIndicatorState\n        )\n      } catch (err: unknown) {\n        reportInvalidHmrMessage(event, err)\n      }\n    }\n\n    function handleDisconnect() {\n      newWebSocket.onerror = null\n      newWebSocket.onclose = null\n      newWebSocket.close()\n      reconnections++\n\n      // After 25 reconnects we'll want to reload the page as it indicates the dev server is no longer running.\n      if (reconnections > WEB_SOCKET_MAX_RECONNECTIONS) {\n        reloading = true\n        window.location.reload()\n        return\n      }\n\n      clearTimeout(timer)\n      // Try again after 5 seconds\n      timer = setTimeout(init, reconnections > 5 ? 5000 : 1000)\n    }\n\n    newWebSocket.onopen = handleOnline\n    newWebSocket.onerror = handleDisconnect\n    newWebSocket.onclose = handleDisconnect\n    newWebSocket.onmessage = handleMessage\n\n    webSocket = newWebSocket\n    return newWebSocket\n  }\n\n  return init()\n}\n\nexport function createProcessTurbopackMessage(\n  sendMessage: (data: string) => void\n): (msg: TurbopackMessageSentToBrowser) => void {\n  if (!process.env.TURBOPACK) {\n    return () => {}\n  }\n\n  let queue: TurbopackMessageSentToBrowser[] = []\n  let callback: ((msg: TurbopackMessageSentToBrowser) => void) | undefined\n\n  const processTurbopackMessage = (msg: TurbopackMessageSentToBrowser) => {\n    if (callback) {\n      callback(msg)\n    } else {\n      queue.push(msg)\n    }\n  }\n\n  import(\n    // @ts-expect-error requires \"moduleResolution\": \"node16\" in tsconfig.json and not .ts extension\n    '@vercel/turbopack-ecmascript-runtime/browser/dev/hmr-client/hmr-client.ts'\n  ).then(({ connect }) => {\n    connect({\n      addMessageListener(cb: (msg: TurbopackMessageSentToBrowser) => void) {\n        callback = cb\n\n        // Replay all Turbopack messages before we were able to establish the HMR client.\n        for (const msg of queue) {\n          cb(msg)\n        }\n        queue.length = 0\n      },\n      sendMessage,\n      onUpdateError: (err: unknown) => performFullReload(err, sendMessage),\n    })\n  })\n\n  return processTurbopackMessage\n}\n\nexport function useWebSocketPing(webSocket: WebSocket | undefined) {\n  const { tree } = useContext(GlobalLayoutRouterContext)\n\n  useEffect(() => {\n    if (!webSocket) {\n      throw new InvariantError('Expected webSocket to be defined in dev mode.')\n    }\n\n    // Never send pings when using Turbopack as it's not used.\n    // Pings were originally used to keep track of active routes in on-demand-entries with webpack.\n    if (process.env.TURBOPACK) {\n      return\n    }\n\n    // Taken from on-demand-entries-client.js\n    const interval = setInterval(() => {\n      if (webSocket.readyState === webSocket.OPEN) {\n        webSocket.send(\n          JSON.stringify({\n            event: 'ping',\n            tree,\n            appDirRoute: true,\n          })\n        )\n      }\n    }, 2500)\n    return () => clearInterval(interval)\n  }, [tree, webSocket])\n}\n\nconst textDecoder = new TextDecoder()\n\nfunction parseBinaryMessage(data: ArrayBuffer): HmrMessageSentToBrowser {\n  assertByteLength(data, 1)\n  const view = new DataView(data)\n  const messageType = view.getUint8(0)\n\n  switch (messageType) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER: {\n      const serializedErrors = new Uint8Array(data, 1)\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER,\n        serializedErrors,\n      }\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      assertByteLength(data, 2)\n      const requestIdLength = view.getUint8(1)\n      assertByteLength(data, 2 + requestIdLength)\n\n      const requestId = textDecoder.decode(\n        new Uint8Array(data, 2, requestIdLength)\n      )\n\n      const chunk =\n        data.byteLength > 2 + requestIdLength\n          ? new Uint8Array(data, 2 + requestIdLength)\n          : null\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK,\n        requestId,\n        chunk,\n      }\n    }\n    default: {\n      throw new InvariantError(\n        `Invalid binary HMR message of type ${messageType}`\n      )\n    }\n  }\n}\n\nfunction assertByteLength(data: ArrayBuffer, expectedLength: number) {\n  if (data.byteLength < expectedLength) {\n    throw new InvariantError(\n      `Invalid binary HMR message: insufficient data (expected ${expectedLength} bytes, got ${data.byteLength})`\n    )\n  }\n}\n"],"names":["createProcessTurbopackMessage","createWebSocket","useWebSocketPing","reconnections","reloading","serverSessionId","mostRecentCompilationHash","assetPrefix","staticIndicatorState","self","__next_r","InvariantError","webSocket","timer","sendMessage","data","readyState","OPEN","send","processTurbopackMessage","init","close","newWebSocket","window","WebSocket","getSocketUrl","binaryType","handleOnline","logQueue","onSocketReady","console","log","handleMessage","event","message","ArrayBuffer","parseBinaryMessage","JSON","parse","type","HMR_MESSAGE_SENT_TO_BROWSER","TURBOPACK_CONNECTED","sessionId","location","reload","SYNC","hash","processMessage","err","reportInvalidHmrMessage","handleDisconnect","onerror","onclose","WEB_SOCKET_MAX_RECONNECTIONS","clearTimeout","setTimeout","onopen","onmessage","process","env","TURBOPACK","queue","callback","msg","push","then","connect","addMessageListener","cb","length","onUpdateError","performFullReload","tree","useContext","GlobalLayoutRouterContext","useEffect","interval","setInterval","stringify","appDirRoute","clearInterval","textDecoder","TextDecoder","assertByteLength","view","DataView","messageType","getUint8","ERRORS_TO_SHOW_IN_BROWSER","serializedErrors","Uint8Array","REACT_DEBUG_CHUNK","requestIdLength","requestId","decode","chunk","byteLength","expectedLength"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":11051,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/report-hmr-latency.ts"],"sourcesContent":["declare global {\n  interface Window {\n    __NEXT_HMR_LATENCY_CB: ((latencyMs: number) => void) | undefined\n  }\n}\n\n/**\n * Logs information about a completed HMR to the console, the server (via a\n * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging\n * hook).\n *\n * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a\n *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by\n *   turbopack when we must report a message to the browser console (because we\n *   already logged a \"rebuilding\" message), but it's not a real HMR, so we\n *   don't want to impact our telemetry.\n */\nexport default function reportHmrLatency(\n  sendMessage: (message: string) => void,\n  updatedModules: ReadonlyArray<string | number>,\n  startMsSinceEpoch: number,\n  endMsSinceEpoch: number,\n  hasUpdate: boolean = true\n) {\n  const latencyMs = endMsSinceEpoch - startMsSinceEpoch\n  console.log(`[Fast Refresh] done in ${latencyMs}ms`)\n  if (!hasUpdate) {\n    return\n  }\n  sendMessage(\n    JSON.stringify({\n      event: 'client-hmr-latency',\n      id: window.__nextDevClientId,\n      startTime: startMsSinceEpoch,\n      endTime: endMsSinceEpoch,\n      page: window.location.pathname,\n      updatedModules,\n      // Whether the page (tab) was hidden at the time the event occurred.\n      // This can impact the accuracy of the event's timing.\n      isPageHidden: document.visibilityState === 'hidden',\n    })\n  )\n  if (self.__NEXT_HMR_LATENCY_CB) {\n    self.__NEXT_HMR_LATENCY_CB(latencyMs)\n  }\n}\n"],"names":["reportHmrLatency","sendMessage","updatedModules","startMsSinceEpoch","endMsSinceEpoch","hasUpdate","latencyMs","console","log","JSON","stringify","event","id","window","__nextDevClientId","startTime","endTime","page","location","pathname","isPageHidden","document","visibilityState","self","__NEXT_HMR_LATENCY_CB"],"mappings":";;;+BAMA;;;;;;;;;;CAUC,GACD,WAAA;;;eAAwBA;;;AAAT,SAASA,iBACtBC,WAAsC,EACtCC,cAA8C,EAC9CC,iBAAyB,EACzBC,eAAuB,EACvBC,YAAqB,IAAI;IAEzB,MAAMC,YAAYF,kBAAkBD;IACpCI,QAAQC,GAAG,CAAC,CAAC,uBAAuB,EAAEF,UAAU,EAAE,CAAC;IACnD,IAAI,CAACD,WAAW;QACd;IACF;IACAJ,YACEQ,KAAKC,SAAS,CAAC;QACbC,OAAO;QACPC,IAAIC,OAAOC,iBAAiB;QAC5BC,WAAWZ;QACXa,SAASZ;QACTa,MAAMJ,OAAOK,QAAQ,CAACC,QAAQ;QAC9BjB;QACA,oEAAoE;QACpE,sDAAsD;QACtDkB,cAAcC,SAASC,eAAe,KAAK;IAC7C;IAEF,IAAIC,KAAKC,qBAAqB,EAAE;QAC9BD,KAAKC,qBAAqB,CAAClB;IAC7B;AACF","ignoreList":[0]}},{"offset":{"line":11102,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/turbopack-hot-reloader-common.ts"],"sourcesContent":["import type { TurbopackMessage } from '../../../server/dev/hot-reloader-types'\nimport type { Update as TurbopackUpdate } from '../../../build/swc/types'\n\ndeclare global {\n  interface Window {\n    __NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS: boolean | undefined\n  }\n}\n\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100\n\ninterface HmrUpdate {\n  hasUpdates: boolean\n  updatedModules: Set<string>\n  startMsSinceEpoch: number\n  endMsSinceEpoch: number\n}\n\nexport class TurbopackHmr {\n  #updatedModules: Set<string>\n  #startMsSinceEpoch: number | undefined\n  #lastUpdateMsSinceEpoch: number | undefined\n  #deferredReportHmrStartId: ReturnType<typeof setTimeout> | undefined\n  #reportedHmrStart: boolean\n\n  constructor() {\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n  }\n\n  // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n  // as it reports *any* compilation, including fully no-op/cached compilations\n  // and those unrelated to HMR. Fixing this would require significant\n  // architectural changes.\n  //\n  // Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n  // a BUILT event within that threshold and nothing has changed, just suppress\n  // the message entirely.\n  #runDeferredReportHmrStart() {\n    if (this.#deferredReportHmrStartId != null) {\n      console.log('[Fast Refresh] rebuilding')\n      this.#reportedHmrStart = true\n      this.#cancelDeferredReportHmrStart()\n    }\n  }\n\n  #cancelDeferredReportHmrStart() {\n    clearTimeout(this.#deferredReportHmrStartId)\n    this.#deferredReportHmrStartId = undefined\n  }\n\n  onBuilding() {\n    this.#lastUpdateMsSinceEpoch = undefined\n    this.#cancelDeferredReportHmrStart()\n    this.#startMsSinceEpoch = Date.now()\n\n    // report the HMR start after a short delay\n    this.#deferredReportHmrStartId = setTimeout(\n      () => this.#runDeferredReportHmrStart(),\n      // debugging feature: don't defer/suppress noisy no-op HMR update messages\n      self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS\n        ? 0\n        : TURBOPACK_HMR_START_DELAY_MS\n    )\n  }\n\n  /** Helper for other `onEvent` methods. */\n  #onUpdate() {\n    this.#runDeferredReportHmrStart()\n    this.#lastUpdateMsSinceEpoch = Date.now()\n  }\n\n  onTurbopackMessage(msg: TurbopackMessage) {\n    this.#onUpdate()\n    const updatedModules = extractModulesFromTurbopackMessage(msg.data)\n    for (const module of updatedModules) {\n      this.#updatedModules.add(module)\n    }\n  }\n\n  onServerComponentChanges() {\n    this.#onUpdate()\n  }\n\n  onReloadPage() {\n    this.#onUpdate()\n  }\n\n  onPageAddRemove() {\n    this.#onUpdate()\n  }\n\n  /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */\n  onBuilt(): HmrUpdate | null {\n    // Check that we got *any* `TurbopackMessage`, even if\n    // `updatedModules` is empty (not everything gets recorded there).\n    //\n    // There's also a case where `onBuilt` gets called before `onBuilding`,\n    // which can happen during initial page load. Ignore that too!\n    const hasUpdates =\n      this.#lastUpdateMsSinceEpoch != null && this.#startMsSinceEpoch != null\n    if (!hasUpdates && !this.#reportedHmrStart) {\n      // suppress the update entirely\n      this.#cancelDeferredReportHmrStart()\n      return null\n    }\n    this.#runDeferredReportHmrStart()\n\n    const result = {\n      hasUpdates,\n      updatedModules: this.#updatedModules,\n      startMsSinceEpoch: this.#startMsSinceEpoch!,\n      endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now(),\n    }\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n    return result\n  }\n}\n\nfunction extractModulesFromTurbopackMessage(\n  data: TurbopackUpdate | TurbopackUpdate[]\n): Set<string> {\n  const updatedModules: Set<string> = new Set()\n\n  const updates = Array.isArray(data) ? data : [data]\n  for (const update of updates) {\n    // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n    if (\n      update.type !== 'partial' ||\n      update.instruction.type !== 'ChunkListUpdate' ||\n      update.instruction.merged === undefined\n    ) {\n      continue\n    }\n\n    for (const mergedUpdate of update.instruction.merged) {\n      for (const name of Object.keys(mergedUpdate.entries)) {\n        const res = /(.*)\\s+[([].*/.exec(name)\n        if (res === null) {\n          continue\n        }\n\n        updatedModules.add(res[1])\n      }\n    }\n  }\n\n  return updatedModules\n}\n"],"names":["TurbopackHmr","TURBOPACK_HMR_START_DELAY_MS","constructor","Set","console","log","clearTimeout","undefined","onBuilding","Date","now","setTimeout","self","__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS","onTurbopackMessage","msg","updatedModules","extractModulesFromTurbopackMessage","data","module","add","onServerComponentChanges","onReloadPage","onPageAddRemove","onBuilt","hasUpdates","result","startMsSinceEpoch","endMsSinceEpoch","updates","Array","isArray","update","type","instruction","merged","mergedUpdate","name","Object","keys","entries","res","exec"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":11231,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/debug-channel.ts"],"sourcesContent":["import { NEXT_REQUEST_ID_HEADER } from '../components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport interface DebugChannelReadableWriterPair {\n  readonly readable: ReadableStream<Uint8Array>\n  readonly writer: WritableStreamDefaultWriter<Uint8Array>\n}\n\nconst pairs = new Map<string, DebugChannelReadableWriterPair>()\n\nexport function getOrCreateDebugChannelReadableWriterPair(\n  requestId: string\n): DebugChannelReadableWriterPair {\n  let pair = pairs.get(requestId)\n\n  if (!pair) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>()\n    pair = { readable, writer: writable.getWriter() }\n    pairs.set(requestId, pair)\n    pair.writer.closed.finally(() => pairs.delete(requestId))\n  }\n\n  return pair\n}\n\nexport function createDebugChannel(\n  requestHeaders: Record<string, string> | undefined\n): {\n  writable?: WritableStream\n  readable?: ReadableStream\n} {\n  let requestId: string | undefined\n\n  if (requestHeaders) {\n    requestId = requestHeaders[NEXT_REQUEST_ID_HEADER] ?? undefined\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a ${JSON.stringify(NEXT_REQUEST_ID_HEADER)} request header.`\n      )\n    }\n  } else {\n    requestId = self.__next_r\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a request ID to be defined for the document via self.__next_r.`\n      )\n    }\n  }\n\n  const { readable } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n  return { readable }\n}\n"],"names":["createDebugChannel","getOrCreateDebugChannelReadableWriterPair","pairs","Map","requestId","pair","get","readable","writable","TransformStream","writer","getWriter","set","closed","finally","delete","requestHeaders","NEXT_REQUEST_ID_HEADER","undefined","InvariantError","JSON","stringify","self","__next_r"],"mappings":";;;;;;;;;;;;;;IAyBgBA,kBAAkB,EAAA;eAAlBA;;IAfAC,yCAAyC,EAAA;eAAzCA;;;kCAVuB;gCACR;AAO/B,MAAMC,QAAQ,IAAIC;AAEX,SAASF,0CACdG,SAAiB;IAEjB,IAAIC,OAAOH,MAAMI,GAAG,CAACF;IAErB,IAAI,CAACC,MAAM;QACT,MAAM,EAAEE,QAAQ,EAAEC,QAAQ,EAAE,GAAG,IAAIC;QACnCJ,OAAO;YAAEE;YAAUG,QAAQF,SAASG,SAAS;QAAG;QAChDT,MAAMU,GAAG,CAACR,WAAWC;QACrBA,KAAKK,MAAM,CAACG,MAAM,CAACC,OAAO,CAAC,IAAMZ,MAAMa,MAAM,CAACX;IAChD;IAEA,OAAOC;AACT;AAEO,SAASL,mBACdgB,cAAkD;IAKlD,IAAIZ;IAEJ,IAAIY,gBAAgB;QAClBZ,YAAYY,cAAc,CAACC,kBAAAA,sBAAsB,CAAC,IAAIC;QAEtD,IAAI,CAACd,WAAW;YACd,MAAM,OAAA,cAEL,CAFK,IAAIe,gBAAAA,cAAc,CACtB,CAAC,WAAW,EAAEC,KAAKC,SAAS,CAACJ,kBAAAA,sBAAsB,EAAE,gBAAgB,CAAC,GADlE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF,OAAO;QACLb,YAAYkB,KAAKC,QAAQ;QAEzB,IAAI,CAACnB,WAAW;YACd,MAAM,OAAA,cAEL,CAFK,IAAIe,gBAAAA,cAAc,CACtB,CAAC,uEAAuE,CAAC,GADrE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IAEA,MAAM,EAAEZ,QAAQ,EAAE,GAAGN,0CAA0CG;IAE/D,OAAO;QAAEG;IAAS;AACpB","ignoreList":[0]}},{"offset":{"line":11305,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/dev/hot-reloader/app/hot-reloader-app.tsx"],"sourcesContent":["/// <reference types=\"webpack/module.d.ts\" />\n\nimport type { ReactNode } from 'react'\nimport { useEffect, startTransition } from 'react'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\nimport formatWebpackMessages from '../../../../shared/lib/format-webpack-messages'\nimport {\n  REACT_REFRESH_FULL_RELOAD,\n  REACT_REFRESH_FULL_RELOAD_FROM_ERROR,\n} from '../shared'\nimport {\n  dispatcher,\n  getSerializedOverlayState,\n  getSegmentTrieData,\n} from 'next/dist/compiled/next-devtools'\nimport { ReplaySsrOnlyErrors } from '../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors'\nimport { AppDevOverlayErrorBoundary } from '../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary'\nimport { useErrorHandler } from '../../../../next-devtools/userspace/app/errors/use-error-handler'\nimport { RuntimeErrorHandler } from '../../runtime-error-handler'\nimport { useWebSocketPing } from './web-socket'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  HMR_MESSAGE_SENT_TO_SERVER,\n} from '../../../../server/dev/hot-reloader-types'\nimport type {\n  HmrMessageSentToBrowser,\n  TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport type { McpErrorStateResponse } from '../../../../shared/lib/mcp-error-types'\nimport type { McpPageMetadataResponse } from '../../../../shared/lib/mcp-page-metadata-types'\nimport { useUntrackedPathname } from '../../../components/navigation-untracked'\nimport reportHmrLatency from '../../report-hmr-latency'\nimport { TurbopackHmr } from '../turbopack-hot-reloader-common'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../../components/app-router-headers'\nimport {\n  publicAppRouterInstance,\n  type GlobalErrorState,\n} from '../../../components/app-router-instance'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { getOrCreateDebugChannelReadableWriterPair } from '../../debug-channel'\n// TODO: Explicitly import from client.browser (doesn't work with Webpack).\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\n\nexport interface StaticIndicatorState {\n  pathname: string | null\n  appIsrManifest: Record<string, boolean> | null\n}\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n\nlet mostRecentCompilationHash: any = null\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now())\nlet reloading = false\nlet webpackStartMsSinceEpoch: number | null = null\nconst turbopackHmr: TurbopackHmr | null = process.env.TURBOPACK\n  ? new TurbopackHmr()\n  : null\n\nlet pendingHotUpdateWebpack = Promise.resolve()\nlet resolvePendingHotUpdateWebpack: () => void = () => {}\nfunction setPendingHotUpdateWebpack() {\n  pendingHotUpdateWebpack = new Promise((resolve) => {\n    resolvePendingHotUpdateWebpack = () => {\n      resolve()\n    }\n  })\n}\n\nexport function waitForWebpackRuntimeHotUpdate() {\n  return pendingHotUpdateWebpack\n}\n\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash: string) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash\n}\n\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */\nfunction isUpdateAvailable() {\n  if (process.env.TURBOPACK) {\n    return true\n  }\n\n  /* globals __webpack_hash__ */\n  // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_hash__\n}\n\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n  return module.hot.status() === 'idle'\n}\nfunction afterApplyUpdates(fn: any) {\n  if (canApplyUpdates()) {\n    fn()\n  } else {\n    function handler(status: any) {\n      if (status === 'idle') {\n        module.hot.removeStatusHandler(handler)\n        fn()\n      }\n    }\n    module.hot.addStatusHandler(handler)\n  }\n}\n\nexport function performFullReload(\n  err: any,\n  sendMessage: (data: string) => void\n) {\n  const stackTrace =\n    err &&\n    ((err.stack && err.stack.split('\\n').slice(0, 5).join('\\n')) ||\n      err.message ||\n      err + '')\n\n  sendMessage(\n    JSON.stringify({\n      event: 'client-full-reload',\n      stackTrace,\n      hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,\n      dependencyChain: err ? err.dependencyChain : undefined,\n    })\n  )\n\n  if (reloading) return\n  reloading = true\n  window.location.reload()\n}\n\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage: (message: string) => void) {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    resolvePendingHotUpdateWebpack()\n    dispatcher.onBuildOk()\n    reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch!, Date.now())\n    return\n  }\n\n  function handleApplyUpdates(\n    err: any,\n    updatedModules: (string | number)[] | null\n  ) {\n    if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n      if (err) {\n        console.warn(REACT_REFRESH_FULL_RELOAD)\n      } else if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n      }\n      performFullReload(err, sendMessage)\n      return\n    }\n\n    dispatcher.onBuildOk()\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdatesWebpack(sendMessage)\n      return\n    }\n\n    dispatcher.onRefresh()\n    resolvePendingHotUpdateWebpack()\n    reportHmrLatency(\n      sendMessage,\n      updatedModules,\n      webpackStartMsSinceEpoch!,\n      Date.now()\n    )\n\n    if (process.env.__NEXT_TEST_MODE) {\n      afterApplyUpdates(() => {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      })\n    }\n  }\n\n  // https://webpack.js.org/api/hot-module-replacement/#check\n  module.hot\n    .check(/* autoApply */ false)\n    .then((updatedModules: (string | number)[] | null) => {\n      if (updatedModules == null) {\n        return null\n      }\n\n      // We should always handle an update, even if updatedModules is empty (but\n      // non-null) for any reason. That's what webpack would normally do:\n      // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n      dispatcher.onBeforeRefresh()\n      // https://webpack.js.org/api/hot-module-replacement/#apply\n      return module.hot.apply()\n    })\n    .then(\n      (updatedModules: (string | number)[] | null) => {\n        handleApplyUpdates(null, updatedModules)\n      },\n      (err: any) => {\n        handleApplyUpdates(err, null)\n      }\n    )\n}\n\n/** Handles messages from the server for the App Router. */\nexport function processMessage(\n  message: HmrMessageSentToBrowser,\n  sendMessage: (message: string) => void,\n  processTurbopackMessage: (msg: TurbopackMessageSentToBrowser) => void,\n  staticIndicatorState: StaticIndicatorState\n) {\n  function handleErrors(errors: ReadonlyArray<unknown>) {\n    // \"Massage\" webpack messages.\n    const formatted = formatWebpackMessages({\n      errors: errors,\n      warnings: [],\n    })\n\n    // Only show the first error.\n    dispatcher.onBuildError(formatted.errors[0])\n\n    // Also log them to the console.\n    for (let i = 0; i < formatted.errors.length; i++) {\n      console.error(stripAnsi(formatted.errors[i]))\n    }\n\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (process.env.__NEXT_TEST_MODE) {\n      if (self.__NEXT_HMR_CB) {\n        self.__NEXT_HMR_CB(formatted.errors[0])\n        self.__NEXT_HMR_CB = null\n      }\n    }\n  }\n\n  function handleHotUpdate() {\n    if (process.env.TURBOPACK) {\n      const hmrUpdate = turbopackHmr!.onBuilt()\n      if (hmrUpdate != null) {\n        reportHmrLatency(\n          sendMessage,\n          [...hmrUpdate.updatedModules],\n          hmrUpdate.startMsSinceEpoch,\n          hmrUpdate.endMsSinceEpoch,\n          // suppress the `client-hmr-latency` event if the update was a no-op:\n          hmrUpdate.hasUpdates\n        )\n      }\n      dispatcher.onBuildOk()\n    } else {\n      tryApplyUpdatesWebpack(sendMessage)\n    }\n  }\n\n  switch (message.type) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST: {\n      if (process.env.__NEXT_DEV_INDICATOR) {\n        staticIndicatorState.appIsrManifest = message.data\n\n        // Handle the initial static indicator status on receiving the ISR\n        // manifest. Navigation is handled in an effect inside HotReload for\n        // pathname changes as we'll receive the updated manifest before\n        // usePathname triggers for a new value.\n\n        const isStatic = staticIndicatorState.pathname\n          ? message.data[staticIndicatorState.pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILDING: {\n      dispatcher.buildingIndicatorShow()\n\n      if (process.env.TURBOPACK) {\n        turbopackHmr!.onBuilding()\n      } else {\n        webpackStartMsSinceEpoch = Date.now()\n        setPendingHotUpdateWebpack()\n        console.log('[Fast Refresh] rebuilding')\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SYNC: {\n      dispatcher.buildingIndicatorHide()\n\n      if (message.hash) {\n        handleAvailableHash(message.hash)\n      }\n\n      const { errors, warnings } = message\n\n      // Is undefined when it's a 'built' event\n      if ('versionInfo' in message)\n        dispatcher.onVersionInfo(message.versionInfo)\n      if ('debug' in message && message.debug)\n        dispatcher.onDebugInfo(message.debug)\n      if ('devIndicator' in message)\n        dispatcher.onDevIndicator(message.devIndicator)\n      if ('devToolsConfig' in message)\n        dispatcher.onDevToolsConfig(message.devToolsConfig)\n\n      const hasErrors = Boolean(errors && errors.length)\n      // Compilation with errors (e.g. syntax error or missing modules).\n      if (hasErrors) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-error',\n            errorCount: errors.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        handleErrors(errors)\n        return\n      }\n\n      const hasWarnings = Boolean(warnings && warnings.length)\n      if (hasWarnings) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-warning',\n            warningCount: warnings.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        // Print warnings to the console.\n        const formattedMessages = formatWebpackMessages({\n          warnings: warnings,\n          errors: [],\n        })\n\n        for (let i = 0; i < formattedMessages.warnings.length; i++) {\n          if (i === 5) {\n            console.warn(\n              'There were more warnings in other files.\\n' +\n                'You can find a complete log in the terminal.'\n            )\n            break\n          }\n          console.warn(stripAnsi(formattedMessages.warnings[i]))\n        }\n\n        // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n      }\n\n      sendMessage(\n        JSON.stringify({\n          event: 'client-success',\n          clientId: __nextDevClientId,\n        })\n      )\n\n      if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n        handleHotUpdate()\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n        data: {\n          sessionId: message.data.sessionId,\n        },\n      })\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {\n      turbopackHmr!.onTurbopackMessage(message)\n      dispatcher.onBeforeRefresh()\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n        data: message.data,\n      })\n      if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n        performFullReload(null, sendMessage)\n      }\n      dispatcher.onRefresh()\n      break\n    }\n    // TODO-APP: make server component change more granular\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {\n      turbopackHmr?.onServerComponentChanges()\n      sendMessage(\n        JSON.stringify({\n          event: 'server-component-reload-page',\n          clientId: __nextDevClientId,\n          hash: message.hash,\n        })\n      )\n\n      // Store the latest hash in a session cookie so that it's sent back to the\n      // server with any subsequent requests.\n      document.cookie = `${NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`\n\n      if (\n        RuntimeErrorHandler.hadRuntimeError ||\n        document.documentElement.id === '__next_error__'\n      ) {\n        if (reloading) return\n        reloading = true\n        return window.location.reload()\n      }\n\n      startTransition(() => {\n        publicAppRouterInstance.hmrRefresh()\n        dispatcher.onRefresh()\n      })\n\n      if (process.env.__NEXT_TEST_MODE) {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE: {\n      turbopackHmr?.onReloadPage()\n      sendMessage(\n        JSON.stringify({\n          event: 'client-reload-page',\n          clientId: __nextDevClientId,\n        })\n      )\n      if (reloading) return\n      reloading = true\n      return window.location.reload()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n    case HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE: {\n      turbopackHmr?.onPageAddRemove()\n      // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n      return publicAppRouterInstance.hmrRefresh()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR: {\n      const { errorJSON } = message\n      if (errorJSON) {\n        const errorObject = JSON.parse(errorJSON)\n        const error = new Error(errorObject.message)\n        error.stack = errorObject.stack\n        handleErrors([error])\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG: {\n      dispatcher.onDevToolsConfig(message.data)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      const { requestId, chunk } = message\n      const { writer } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n      if (chunk) {\n        writer.ready.then(() => writer.write(chunk)).catch(console.error)\n      } else {\n        // A null chunk signals that no more chunks will be sent, which allows\n        // us to close the writer.\n        // TODO: Revisit this cleanup logic when we integrate the return channel\n        // that keeps the connection open to be able to lazily retrieve debug\n        // objects.\n        writer.ready.then(() => writer.close()).catch(console.error)\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE: {\n      const errorState = getSerializedOverlayState()\n      const response: McpErrorStateResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n        requestId: message.requestId,\n        errorState,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA: {\n      const segmentTrieData = getSegmentTrieData()\n      const response: McpPageMetadataResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n        requestId: message.requestId,\n        segmentTrieData,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR: {\n      dispatcher.onCacheIndicator(message.state)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER: {\n      createFromReadableStream<Error[]>(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue(message.serializedErrors)\n            controller.close()\n          },\n        }),\n        { findSourceMapURL }\n      ).then(\n        (errors) => {\n          for (const error of errors) {\n            console.error(error)\n          }\n        },\n        (err) => {\n          console.error(\n            new Error('Failed to deserialize errors.', { cause: err })\n          )\n        }\n      )\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n      // These action types are handled in src/client/page-bootstrap.ts\n      break\n    default: {\n      message satisfies never\n    }\n  }\n}\n\nexport default function HotReload({\n  children,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  children: ReactNode\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  useErrorHandler(dispatcher.onUnhandledError, dispatcher.onUnhandledRejection)\n  useWebSocketPing(webSocket)\n\n  // We don't want access of the pathname for the dev tools to trigger a dynamic\n  // access (as the dev overlay will never be present in production).\n  const pathname = useUntrackedPathname()\n\n  if (process.env.__NEXT_DEV_INDICATOR) {\n    // this conditional is only for dead-code elimination which\n    // isn't a runtime conditional only build-time so ignore hooks rule\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!staticIndicatorState) {\n        throw new InvariantError(\n          'Expected staticIndicatorState to be defined in dev mode.'\n        )\n      }\n\n      staticIndicatorState.pathname = pathname\n\n      if (staticIndicatorState.appIsrManifest) {\n        const isStatic = pathname\n          ? staticIndicatorState.appIsrManifest[pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n    }, [pathname, staticIndicatorState])\n  }\n\n  return (\n    <AppDevOverlayErrorBoundary globalError={globalError}>\n      <ReplaySsrOnlyErrors onBlockingError={dispatcher.openErrorOverlay} />\n      {children}\n    </AppDevOverlayErrorBoundary>\n  )\n}\n"],"names":["HotReload","performFullReload","processMessage","waitForWebpackRuntimeHotUpdate","createFromReadableStream","createFromReadableStreamBrowser","mostRecentCompilationHash","__nextDevClientId","Math","round","random","Date","now","reloading","webpackStartMsSinceEpoch","turbopackHmr","process","env","TURBOPACK","TurbopackHmr","pendingHotUpdateWebpack","Promise","resolve","resolvePendingHotUpdateWebpack","setPendingHotUpdateWebpack","handleAvailableHash","hash","isUpdateAvailable","__webpack_hash__","canApplyUpdates","module","hot","status","afterApplyUpdates","fn","handler","removeStatusHandler","addStatusHandler","err","sendMessage","stackTrace","stack","split","slice","join","message","JSON","stringify","event","hadRuntimeError","RuntimeErrorHandler","dependencyChain","undefined","window","location","reload","tryApplyUpdatesWebpack","dispatcher","onBuildOk","reportHmrLatency","handleApplyUpdates","updatedModules","console","warn","REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","onRefresh","__NEXT_TEST_MODE","self","__NEXT_HMR_CB","check","then","onBeforeRefresh","apply","processTurbopackMessage","staticIndicatorState","handleErrors","errors","formatted","formatWebpackMessages","warnings","onBuildError","i","length","error","stripAnsi","handleHotUpdate","hmrUpdate","onBuilt","startMsSinceEpoch","endMsSinceEpoch","hasUpdates","type","HMR_MESSAGE_SENT_TO_BROWSER","ISR_MANIFEST","__NEXT_DEV_INDICATOR","appIsrManifest","data","isStatic","pathname","onStaticIndicator","BUILDING","buildingIndicatorShow","onBuilding","log","BUILT","SYNC","buildingIndicatorHide","onVersionInfo","versionInfo","debug","onDebugInfo","onDevIndicator","devIndicator","onDevToolsConfig","devToolsConfig","hasErrors","Boolean","errorCount","clientId","hasWarnings","warningCount","formattedMessages","TURBOPACK_CONNECTED","sessionId","TURBOPACK_MESSAGE","onTurbopackMessage","SERVER_COMPONENT_CHANGES","onServerComponentChanges","document","cookie","NEXT_HMR_REFRESH_HASH_COOKIE","documentElement","id","startTransition","publicAppRouterInstance","hmrRefresh","RELOAD_PAGE","onReloadPage","ADDED_PAGE","REMOVED_PAGE","onPageAddRemove","SERVER_ERROR","errorJSON","errorObject","parse","Error","DEV_PAGES_MANIFEST_UPDATE","DEVTOOLS_CONFIG","REACT_DEBUG_CHUNK","requestId","chunk","writer","getOrCreateDebugChannelReadableWriterPair","ready","write","catch","close","REQUEST_CURRENT_ERROR_STATE","errorState","getSerializedOverlayState","response","HMR_MESSAGE_SENT_TO_SERVER","MCP_ERROR_STATE_RESPONSE","url","href","REQUEST_PAGE_METADATA","segmentTrieData","getSegmentTrieData","MCP_PAGE_METADATA_RESPONSE","CACHE_INDICATOR","onCacheIndicator","state","ERRORS_TO_SHOW_IN_BROWSER","ReadableStream","start","controller","enqueue","serializedErrors","findSourceMapURL","cause","MIDDLEWARE_CHANGES","CLIENT_CHANGES","SERVER_ONLY_CHANGES","children","globalError","webSocket","useErrorHandler","onUnhandledError","onUnhandledRejection","useWebSocketPing","useUntrackedPathname","useEffect","InvariantError","AppDevOverlayErrorBoundary","ReplaySsrOnlyErrors","onBlockingError","openErrorOverlay"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":11798,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/app-router.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\nimport { getDeploymentIdQueryOrEmptyString } from '../../shared/lib/deployment-id'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    // TODO: Use Navigation API if available\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = getDeploymentIdQueryOrEmptyString()\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n"],"names":["AppRouter","globalMutable","HistoryUpdater","appRouterState","useInsertionEffect","process","env","__NEXT_APP_NAV_FAIL_HANDLING","window","next","__pendingUrl","undefined","tree","pushRef","canonicalUrl","renderedSearch","appHistoryState","historyState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","createHrefFromUrl","URL","location","href","pushState","replaceState","useEffect","pingVisibleLinks","nextUrl","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","head","prefetchHead","resolvedPrefetchRsc","useDeferredValue","Router","actionQueue","globalError","webSocket","staticIndicatorState","useActionQueue","searchParams","pathname","useMemo","url","hasBasePath","removeBasePath","NODE_ENV","cache","nd","router","publicAppRouterInstance","handlePageShow","event","persisted","pendingMpaPath","dispatchAppRouterAction","type","ACTION_RESTORE","addEventListener","removeEventListener","handleUnhandledRedirect","error","reason","isRedirectError","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","RedirectType","push","replace","mpaNavigation","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","startTransition","_unused","_N","onPopState","reload","dispatchTraverseAction","focusAndScrollRef","previousNextUrl","matchingHead","findHeadInCache","pathParams","getSelectedParams","instrumentedNavigationPromises","createRootNavigationPromises","require","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","RedirectBoundary","RootLayoutBoundary","rsc","AppRouterAnnouncer","DevRootHTTPAccessFallbackBoundary","HotReloader","default","RootErrorBoundary","errorComponent","errorStyles","RuntimeStyles","NavigationPromisesContext","Provider","value","PathParamsContext","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","Set","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","size","add","forEach","cb","Promise","resolve","forceUpdate","React","useState","renderedStylesSize","changed","c","delete","dplId","getDeploymentIdQueryOrEmptyString","map","i","link","rel","precedence"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":12288,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type { FlightDataPath } from '../../../shared/lib/app-router-types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\n\nimport type { AppRouterState } from './router-reducer-types'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\nimport { createInitialCacheNodeForHydration } from './ppr-navigations'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialRenderedSearch: string\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialRenderedSearch,\n  location,\n}: InitialRouterStateParameters): AppRouterState {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  const initialState = {\n    tree: initialTree,\n    cache: createInitialCacheNodeForHydration(\n      navigatedAt,\n      initialTree,\n      initialSeedData,\n      initialHead\n    ),\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    renderedSearch: initialRenderedSearch,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n\n  return initialState\n}\n"],"names":["createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","location","initialCanonicalUrl","join","normalizedFlightData","getFlightDataPartsFromPath","tree","initialTree","seedData","initialSeedData","head","initialHead","canonicalUrl","createHrefFromUrl","initialState","cache","createInitialCacheNodeForHydration","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","renderedSearch","nextUrl","extractPathFromFlightRouterState","pathname","previousNextUrl","debugInfo"],"mappings":";;;+BAiBgBA,4BAAAA;;;eAAAA;;;mCAfkB;oCACe;mCAGN;gCACQ;AAU5C,SAASA,yBAAyB,EACvCC,WAAW,EACXC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,QAAQ,EACqB;IAC7B,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBH,yBAAyBI,IAAI,CAAC;IAE1D,MAAMC,uBAAuBC,CAAAA,GAAAA,mBAAAA,0BAA0B,EAACP,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJQ,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGP;IACJ,gGAAgG;IAChG,gDAAgD;IAEhD,MAAMQ,eACJ,AACA,6EAD6E,qEACqE;IAClJX,WAEIY,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACZ,YAClBC;IAEN,MAAMY,eAAe;QACnBR,MAAMC;QACNQ,OAAOC,CAAAA,GAAAA,gBAAAA,kCAAkC,EACvCnB,aACAU,aACAE,iBACAE;QAEFM,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAb;QACAc,gBAAgB1B;QAChB2B,SAEE,AADA,AACCC,CAAAA,CAAAA,GAAAA,oBAAAA,gCAAgC,EAACrB,WADoC,KACpBN,UAAU4B,QAAO,KACnE;QACFC,iBAAiB;QACjBC,WAAW;IACb;IAEA,OAAOjB;AACT","ignoreList":[0]}},{"offset":{"line":12347,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-link-gc.ts"],"sourcesContent":["export function linkGc() {\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const callback = (mutationList: MutationRecord[]) => {\n      for (const mutation of mutationList) {\n        if (mutation.type === 'childList') {\n          for (const node of mutation.addedNodes) {\n            if (\n              'tagName' in node &&\n              (node as HTMLLinkElement).tagName === 'LINK'\n            ) {\n              const link = node as HTMLLinkElement\n              if (link.dataset.precedence?.startsWith('next')) {\n                const href = link.getAttribute('href')\n                if (href) {\n                  const [resource, version] = href.split('?v=', 2)\n                  if (version) {\n                    const currentOrigin = window.location.origin\n                    const allLinks = [\n                      ...document.querySelectorAll(\n                        'link[href^=\"' + resource + '\"]'\n                      ),\n                      // It's possible that the resource is a full URL or only pathname,\n                      // so we need to remove the alternative href as well.\n                      ...document.querySelectorAll(\n                        'link[href^=\"' +\n                          (resource.startsWith(currentOrigin)\n                            ? resource.slice(currentOrigin.length)\n                            : currentOrigin + resource) +\n                          '\"]'\n                      ),\n                    ] as HTMLLinkElement[]\n\n                    for (const otherLink of allLinks) {\n                      if (otherLink.dataset.precedence?.startsWith('next')) {\n                        const otherHref = otherLink.getAttribute('href')\n                        if (otherHref) {\n                          const [, otherVersion] = otherHref.split('?v=', 2)\n                          if (!otherVersion || +otherVersion < +version) {\n                            // Delay the removal of the stylesheet to avoid FOUC\n                            // caused by `@font-face` rules, as they seem to be\n                            // a couple of ticks delayed between the old and new\n                            // styles being swapped even if the font is cached.\n                            setTimeout(() => {\n                              otherLink.remove()\n                            }, 5)\n                            const preloadLink = document.querySelector(\n                              `link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`\n                            )\n                            if (preloadLink) {\n                              preloadLink.remove()\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Create an observer instance linked to the callback function\n    const observer = new MutationObserver(callback)\n    observer.observe(document.head, {\n      childList: true,\n    })\n  }\n}\n"],"names":["linkGc","process","env","NODE_ENV","callback","mutationList","mutation","type","node","addedNodes","tagName","link","dataset","precedence","startsWith","href","getAttribute","resource","version","split","currentOrigin","window","location","origin","allLinks","document","querySelectorAll","slice","length","otherLink","otherHref","otherVersion","setTimeout","remove","preloadLink","querySelector","observer","MutationObserver","observe","head","childList"],"mappings":"AAEMC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BAFfH,UAAAA;;;eAAAA;;;AAAT,SAASA;IACd,yEAAyE;IACzE,wCAA2C;QACzC,MAAMI,WAAW,CAACC;YAChB,KAAK,MAAMC,YAAYD,aAAc;gBACnC,IAAIC,SAASC,IAAI,KAAK,aAAa;oBACjC,KAAK,MAAMC,QAAQF,SAASG,UAAU,CAAE;wBACtC,IACE,aAAaD,QACZA,KAAyBE,OAAO,KAAK,QACtC;4BACA,MAAMC,OAAOH;4BACb,IAAIG,KAAKC,OAAO,CAACC,UAAU,EAAEC,WAAW,SAAS;gCAC/C,MAAMC,OAAOJ,KAAKK,YAAY,CAAC;gCAC/B,IAAID,MAAM;oCACR,MAAM,CAACE,UAAUC,QAAQ,GAAGH,KAAKI,KAAK,CAAC,OAAO;oCAC9C,IAAID,SAAS;wCACX,MAAME,gBAAgBC,OAAOC,QAAQ,CAACC,MAAM;wCAC5C,MAAMC,WAAW;+CACZC,SAASC,gBAAgB,CAC1B,iBAAiBT,WAAW;4CAE9B,kEAAkE;4CAClE,qDAAqD;+CAClDQ,SAASC,gBAAgB,CAC1B,iBACGT,CAAAA,SAASH,UAAU,CAACM,iBACjBH,SAASU,KAAK,CAACP,cAAcQ,MAAM,IACnCR,gBAAgBH,QAAO,IAC3B;yCAEL;wCAED,KAAK,MAAMY,aAAaL,SAAU;4CAChC,IAAIK,UAAUjB,OAAO,CAACC,UAAU,EAAEC,WAAW,SAAS;gDACpD,MAAMgB,YAAYD,UAAUb,YAAY,CAAC;gDACzC,IAAIc,WAAW;oDACb,MAAM,GAAGC,aAAa,GAAGD,UAAUX,KAAK,CAAC,OAAO;oDAChD,IAAI,CAACY,gBAAgB,CAACA,eAAe,CAACb,SAAS;wDAC7C,oDAAoD;wDACpD,mDAAmD;wDACnD,oDAAoD;wDACpD,mDAAmD;wDACnDc,WAAW;4DACTH,UAAUI,MAAM;wDAClB,GAAG;wDACH,MAAMC,cAAcT,SAASU,aAAa,CACxC,CAAC,sCAAsC,EAAEL,UAAU,EAAE,CAAC;wDAExD,IAAII,aAAa;4DACfA,YAAYD,MAAM;wDACpB;oDACF;gDACF;4CACF;wCACF;oCACF;gCACF;4BACF;wBACF;oBACF;gBACF;YACF;QACF;QAEA,8DAA8D;QAC9D,MAAMG,WAAW,IAAIC,iBAAiBjC;QACtCgC,SAASE,OAAO,CAACb,SAASc,IAAI,EAAE;YAC9BC,WAAW;QACb;IACF;AACF","ignoreList":[0]}},{"offset":{"line":12426,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-index.tsx"],"sourcesContent":["import './app-globals'\nimport ReactDOMClient from 'react-dom/client'\nimport React from 'react'\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\nimport { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'\nimport { onRecoverableError } from './react-client-callbacks/on-recoverable-error'\nimport {\n  onCaughtError,\n  onUncaughtError,\n} from './react-client-callbacks/error-boundary-callbacks'\nimport { callServer } from './app-call-server'\nimport { findSourceMapURL } from './app-find-source-map-url'\nimport {\n  type AppRouterActionQueue,\n  createMutableActionQueue,\n} from './components/app-router-instance'\nimport AppRouter from './components/app-router'\nimport type { InitialRSCPayload } from '../shared/lib/app-router-types'\nimport { createInitialRouterState } from './components/router-reducer/create-initial-router-state'\nimport { MissingSlotContext } from '../shared/lib/app-router-context.shared-runtime'\nimport { setAppBuildId } from './app-build-id'\nimport type { StaticIndicatorState } from './dev/hot-reloader/app/hot-reloader-app'\nimport { createInitialRSCPayloadFromFallbackPrerender } from './flight-data-helpers'\n\n/// <reference types=\"react-dom/experimental\" />\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nconst appElement: HTMLElement | Document = document\n\nconst encoder = new TextEncoder()\n\nlet initialServerDataBuffer: (string | Uint8Array)[] | undefined = undefined\nlet initialServerDataWriter: ReadableStreamDefaultController | undefined =\n  undefined\nlet initialServerDataLoaded = false\nlet initialServerDataFlushed = false\n\nlet initialFormStateData: null | any = null\n\ntype FlightSegment =\n  | [isBootStrap: 0]\n  | [isNotBootstrap: 1, responsePartial: string]\n  | [isFormState: 2, formState: any]\n  | [isBinary: 3, responseBase64Partial: string]\n\ntype NextFlight = Omit<Array<FlightSegment>, 'push'> & {\n  push: (seg: FlightSegment) => void\n}\n\ndeclare global {\n  // If you're working in a browser environment\n  interface Window {\n    /**\n     * request ID, dev-only\n     */\n    __next_r?: string\n    __next_f: NextFlight\n  }\n}\n\nfunction nextServerDataCallback(seg: FlightSegment): void {\n  if (seg[0] === 0) {\n    initialServerDataBuffer = []\n  } else if (seg[0] === 1) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(encoder.encode(seg[1]))\n    } else {\n      initialServerDataBuffer.push(seg[1])\n    }\n  } else if (seg[0] === 2) {\n    initialFormStateData = seg[1]\n  } else if (seg[0] === 3) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    // Decode the base64 string back to binary data.\n    const binaryString = atob(seg[1])\n    const decodedChunk = new Uint8Array(binaryString.length)\n    for (var i = 0; i < binaryString.length; i++) {\n      decodedChunk[i] = binaryString.charCodeAt(i)\n    }\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(decodedChunk)\n    } else {\n      initialServerDataBuffer.push(decodedChunk)\n    }\n  }\n}\n\nfunction isStreamErrorOrUnfinished(ctr: ReadableStreamDefaultController) {\n  // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n  return ctr.desiredSize === null || ctr.desiredSize < 0\n}\n\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr: ReadableStreamDefaultController) {\n  if (initialServerDataBuffer) {\n    initialServerDataBuffer.forEach((val) => {\n      ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val)\n    })\n    if (initialServerDataLoaded && !initialServerDataFlushed) {\n      if (isStreamErrorOrUnfinished(ctr)) {\n        ctr.error(\n          new Error(\n            'The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'\n          )\n        )\n      } else {\n        ctr.close()\n      }\n      initialServerDataFlushed = true\n      initialServerDataBuffer = undefined\n    }\n  }\n\n  initialServerDataWriter = ctr\n}\n\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function () {\n  if (initialServerDataWriter && !initialServerDataFlushed) {\n    initialServerDataWriter.close()\n    initialServerDataFlushed = true\n    initialServerDataBuffer = undefined\n  }\n  initialServerDataLoaded = true\n}\n\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', DOMContentLoaded, false)\n} else {\n  // Delayed in marco task to ensure it's executed later than hydration\n  setTimeout(DOMContentLoaded)\n}\n\nconst nextServerDataLoadingGlobal = (self.__next_f = self.__next_f || [])\n\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback)\nnextServerDataLoadingGlobal.length = 0\n\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback\n\nconst readable = new ReadableStream({\n  start(controller) {\n    nextServerDataRegisterWriter(controller)\n  },\n})\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-expect-error\n  readable.name = 'hydration'\n}\n\nlet debugChannel:\n  | { readable?: ReadableStream; writable?: WritableStream }\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL &&\n  typeof window !== 'undefined'\n) {\n  const { createDebugChannel } =\n    require('./dev/debug-channel') as typeof import('./dev/debug-channel')\n\n  debugChannel = createDebugChannel(undefined)\n}\n\nconst clientResumeFetch: Promise<Response> | undefined =\n  // @ts-expect-error\n  window.__NEXT_CLIENT_RESUME\n\nlet initialServerResponse: Promise<InitialRSCPayload>\nif (clientResumeFetch) {\n  initialServerResponse = Promise.resolve(\n    createFromFetch<InitialRSCPayload>(clientResumeFetch, {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n    })\n  ).then(async (fallbackInitialRSCPayload) =>\n    createInitialRSCPayloadFromFallbackPrerender(\n      await clientResumeFetch,\n      fallbackInitialRSCPayload\n    )\n  )\n} else {\n  initialServerResponse = createFromReadableStream<InitialRSCPayload>(\n    readable,\n    {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n      startTime: 0,\n    }\n  )\n}\n\nfunction ServerRoot({\n  initialRSCPayload,\n  actionQueue,\n  webSocket,\n  staticIndicatorState,\n}: {\n  initialRSCPayload: InitialRSCPayload\n  actionQueue: AppRouterActionQueue\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}): React.ReactNode {\n  const router = (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorState={initialRSCPayload.G}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  if (process.env.NODE_ENV === 'development' && initialRSCPayload.m) {\n    // We provide missing slot information in a context provider only during development\n    // as we log some additional information about the missing slots in the console.\n    return (\n      <MissingSlotContext value={initialRSCPayload.m}>\n        {router}\n      </MissingSlotContext>\n    )\n  }\n\n  return router\n}\n\nconst StrictModeIfEnabled = process.env.__NEXT_STRICT_MODE_APP\n  ? React.StrictMode\n  : React.Fragment\n\nfunction Root({ children }: React.PropsWithChildren<{}>) {\n  if (process.env.__NEXT_TEST_MODE) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      window.__NEXT_HYDRATED = true\n      window.__NEXT_HYDRATED_AT = performance.now()\n      window.__NEXT_HYDRATED_CB?.()\n    }, [])\n  }\n\n  return children\n}\n\nconst enableTransitionIndicator = process.env.__NEXT_TRANSITION_INDICATOR\n\nfunction noDefaultTransitionIndicator() {\n  return () => {}\n}\n\nconst reactRootOptions: ReactDOMClient.RootOptions = {\n  onDefaultTransitionIndicator: enableTransitionIndicator\n    ? // TODO: Compose default with user-configureable (e.g. nprogress)\n      undefined\n    : noDefaultTransitionIndicator,\n  onRecoverableError,\n  onCaughtError,\n  onUncaughtError,\n}\n\nexport type ClientInstrumentationHooks = {\n  onRouterTransitionStart?: (\n    url: string,\n    navigationType: 'push' | 'replace' | 'traverse'\n  ) => void\n}\n\nexport async function hydrate(\n  instrumentationHooks: ClientInstrumentationHooks | null,\n  assetPrefix: string\n) {\n  let staticIndicatorState: StaticIndicatorState | undefined\n  let webSocket: WebSocket | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { createWebSocket } =\n      require('./dev/hot-reloader/app/web-socket') as typeof import('./dev/hot-reloader/app/web-socket')\n\n    staticIndicatorState = { pathname: null, appIsrManifest: null }\n    webSocket = createWebSocket(assetPrefix, staticIndicatorState)\n  }\n  const initialRSCPayload = await initialServerResponse\n  // setAppBuildId should be called only once, during JS initialization\n  // and before any components have hydrated.\n  setAppBuildId(initialRSCPayload.b)\n\n  const initialTimestamp = Date.now()\n  const actionQueue: AppRouterActionQueue = createMutableActionQueue(\n    createInitialRouterState({\n      navigatedAt: initialTimestamp,\n      initialFlightData: initialRSCPayload.f,\n      initialCanonicalUrlParts: initialRSCPayload.c,\n      initialRenderedSearch: initialRSCPayload.q,\n      location: window.location,\n    }),\n    instrumentationHooks\n  )\n\n  const reactEl = (\n    <StrictModeIfEnabled>\n      <HeadManagerContext.Provider value={{ appDir: true }}>\n        <Root>\n          <ServerRoot\n            initialRSCPayload={initialRSCPayload}\n            actionQueue={actionQueue}\n            webSocket={webSocket}\n            staticIndicatorState={staticIndicatorState}\n          />\n        </Root>\n      </HeadManagerContext.Provider>\n    </StrictModeIfEnabled>\n  )\n\n  if (document.documentElement.id === '__next_error__') {\n    let element = reactEl\n    // Server rendering failed, fall back to client-side rendering\n    if (process.env.NODE_ENV !== 'production') {\n      const { RootLevelDevOverlayElement } =\n        require('../next-devtools/userspace/app/client-entry') as typeof import('../next-devtools/userspace/app/client-entry')\n\n      // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n      element = (\n        <RootLevelDevOverlayElement>{element}</RootLevelDevOverlayElement>\n      )\n    }\n\n    ReactDOMClient.createRoot(appElement, reactRootOptions).render(element)\n  } else {\n    React.startTransition(() => {\n      ReactDOMClient.hydrateRoot(appElement, reactEl, {\n        ...reactRootOptions,\n        formState: initialFormStateData,\n      })\n    })\n  }\n\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const { linkGc } =\n      require('./app-link-gc') as typeof import('./app-link-gc')\n    linkGc()\n  }\n}\n"],"names":["hydrate","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","appElement","document","encoder","TextEncoder","initialServerDataBuffer","undefined","initialServerDataWriter","initialServerDataLoaded","initialServerDataFlushed","initialFormStateData","nextServerDataCallback","seg","Error","enqueue","encode","push","binaryString","atob","decodedChunk","Uint8Array","length","i","charCodeAt","isStreamErrorOrUnfinished","ctr","desiredSize","nextServerDataRegisterWriter","forEach","val","error","close","DOMContentLoaded","readyState","addEventListener","setTimeout","nextServerDataLoadingGlobal","self","__next_f","readable","ReadableStream","start","controller","process","env","NODE_ENV","name","debugChannel","__NEXT_REACT_DEBUG_CHANNEL","window","createDebugChannel","require","clientResumeFetch","__NEXT_CLIENT_RESUME","initialServerResponse","Promise","resolve","callServer","findSourceMapURL","then","fallbackInitialRSCPayload","createInitialRSCPayloadFromFallbackPrerender","startTime","ServerRoot","initialRSCPayload","actionQueue","webSocket","staticIndicatorState","router","AppRouter","globalErrorState","G","m","MissingSlotContext","value","StrictModeIfEnabled","__NEXT_STRICT_MODE_APP","React","StrictMode","Fragment","Root","children","__NEXT_TEST_MODE","useEffect","__NEXT_HYDRATED","__NEXT_HYDRATED_AT","performance","now","__NEXT_HYDRATED_CB","enableTransitionIndicator","__NEXT_TRANSITION_INDICATOR","noDefaultTransitionIndicator","reactRootOptions","onDefaultTransitionIndicator","onRecoverableError","onCaughtError","onUncaughtError","instrumentationHooks","assetPrefix","createWebSocket","pathname","appIsrManifest","setAppBuildId","b","initialTimestamp","Date","createMutableActionQueue","createInitialRouterState","navigatedAt","initialFlightData","f","initialCanonicalUrlParts","c","initialRenderedSearch","q","location","reactEl","HeadManagerContext","Provider","appDir","documentElement","id","element","RootLevelDevOverlayElement","ReactDOMClient","createRoot","render","startTransition","hydrateRoot","formState","linkGc"],"mappings":"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","ignoreList":[0]}},{"offset":{"line":12690,"column":0},"map":{"version":3,"sources":["file:///home/dev-env/repos/kore_project/frontend/node_modules/next/src/client/app-next-turbopack.ts"],"sourcesContent":["import { appBootstrap } from './app-bootstrap'\nimport { isRecoverableError } from './react-client-callbacks/on-recoverable-error'\n\nwindow.next.turbopack = true\n;(self as any).__webpack_hash__ = ''\n\n// eslint-disable-next-line @next/internal/typechecked-require\nconst instrumentationHooks = require('../lib/require-instrumentation-client')\n\nappBootstrap((assetPrefix) => {\n  const { hydrate } = require('./app-index') as typeof import('./app-index')\n  try {\n    hydrate(instrumentationHooks, assetPrefix)\n  } finally {\n    if (process.env.NODE_ENV !== 'production') {\n      const enableCacheIndicator = process.env.__NEXT_CACHE_COMPONENTS\n      const { getOwnerStack } =\n        require('../next-devtools/userspace/app/errors/stitched-error') as typeof import('../next-devtools/userspace/app/errors/stitched-error')\n      const { renderAppDevOverlay } =\n        require('next/dist/compiled/next-devtools') as typeof import('next/dist/compiled/next-devtools')\n      renderAppDevOverlay(\n        getOwnerStack,\n        isRecoverableError,\n        enableCacheIndicator\n      )\n    }\n  }\n})\n"],"names":["window","next","turbopack","self","__webpack_hash__","instrumentationHooks","require","appBootstrap","assetPrefix","hydrate","process","env","NODE_ENV","enableCacheIndicator","__NEXT_CACHE_COMPONENTS","getOwnerStack","renderAppDevOverlay","isRecoverableError"],"mappings":"AAcQU,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;8BAdJ;oCACM;AAEnCZ,OAAOC,IAAI,CAACC,SAAS,GAAG;AACtBC,KAAaC,gBAAgB,GAAG;AAElC,8DAA8D;AAC9D,MAAMC,uBAAuBC,QAAQ;AAErCC,CAAAA,GAAAA,cAAAA,YAAY,EAAC,CAACC;IACZ,MAAM,EAAEC,OAAO,EAAE,GAAGH,QAAQ;IAC5B,IAAI;QACFG,QAAQJ,sBAAsBG;IAChC,SAAU;QACR,wCAA2C;YACzC,MAAMK,uBAAuBH,QAAQC,GAAG,CAACG,uBAAuB;YAChE,MAAM,EAAEC,aAAa,EAAE,GACrBT,QAAQ;YACV,MAAM,EAAEU,mBAAmB,EAAE,GAC3BV,QAAQ;YACVU,oBACED,eACAE,oBAAAA,kBAAkB,EAClBJ;QAEJ;IACF;AACF","ignoreList":[0]}}],"sourcesContent":["import { InvariantError } from '../shared/lib/invariant-error'\n\nexport function getAssetPrefix() {\n  const currentScript = document.currentScript\n\n  if (!(currentScript instanceof HTMLScriptElement)) {\n    throw new InvariantError(\n      `Expected document.currentScript to be a <script> element. Received ${currentScript} instead.`\n    )\n  }\n\n  const { pathname } = new URL(currentScript.src)\n  const nextIndex = pathname.indexOf('/_next/')\n\n  if (nextIndex === -1) {\n    throw new InvariantError(\n      `Expected document.currentScript src to contain '/_next/'. Received ${currentScript.src} instead.`\n    )\n  }\n\n  return pathname.slice(0, nextIndex)\n}\n","const DOMAttributeNames: Record<string, string> = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv',\n  noModule: 'noModule',\n}\n\nconst ignoreProps = [\n  'onLoad',\n  'onReady',\n  'dangerouslySetInnerHTML',\n  'children',\n  'onError',\n  'strategy',\n  'stylesheets',\n]\n\nfunction isBooleanScriptAttribute(\n  attr: string\n): attr is 'async' | 'defer' | 'noModule' {\n  return ['async', 'defer', 'noModule'].includes(attr)\n}\n\nexport function setAttributesFromProps(el: HTMLElement, props: object) {\n  for (const [p, value] of Object.entries(props)) {\n    if (!props.hasOwnProperty(p)) continue\n    if (ignoreProps.includes(p)) continue\n\n    // we don't render undefined props to the DOM\n    if (value === undefined) {\n      continue\n    }\n\n    const attr = DOMAttributeNames[p] || p.toLowerCase()\n\n    if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n      // Correctly assign boolean script attributes\n      // https://github.com/vercel/next.js/pull/20748\n      ;(el as HTMLScriptElement)[attr] = !!value\n    } else {\n      el.setAttribute(attr, String(value))\n    }\n\n    // Remove falsy non-zero boolean attributes so they are correctly interpreted\n    // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n    if (\n      value === false ||\n      (el.tagName === 'SCRIPT' &&\n        isBooleanScriptAttribute(attr) &&\n        (!value || value === 'false'))\n    ) {\n      // Call setAttribute before, as we need to set and unset the attribute to override force async:\n      // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n      el.setAttribute(attr, '')\n      el.removeAttribute(attr)\n    }\n  }\n}\n","/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */\n\nimport { getAssetPrefix } from './asset-prefix'\nimport { setAttributesFromProps } from './set-attributes-from-props'\n\nconst version = process.env.__NEXT_VERSION\n\nwindow.next = {\n  version,\n  appDir: true,\n}\n\nfunction loadScriptsInSequence(\n  scripts: [src: string, props: { [prop: string]: any }][],\n  hydrate: () => void\n) {\n  if (!scripts || !scripts.length) {\n    return hydrate()\n  }\n\n  return scripts\n    .reduce((promise, [src, props]) => {\n      return promise.then(() => {\n        return new Promise<void>((resolve, reject) => {\n          const el = document.createElement('script')\n\n          if (props) {\n            setAttributesFromProps(el, props)\n          }\n\n          if (src) {\n            el.src = src\n            el.onload = () => resolve()\n            el.onerror = reject\n          } else if (props) {\n            el.innerHTML = props.children\n            setTimeout(resolve)\n          }\n\n          document.head.appendChild(el)\n        })\n      })\n    }, Promise.resolve())\n    .catch((err: Error) => {\n      console.error(err)\n      // Still try to hydrate even if there's an error.\n    })\n    .then(() => {\n      hydrate()\n    })\n}\n\nexport function appBootstrap(hydrate: (assetPrefix: string) => void) {\n  const assetPrefix = getAssetPrefix()\n\n  loadScriptsInSequence((self as any).__next_s, () => {\n    // If the static shell is being debugged, skip hydration if the\n    // `__nextppronly` query is present. This is only enabled when the\n    // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n    // set to `1`. Otherwise the following is optimized out.\n    if (process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1') {\n      const search = new URLSearchParams(window.location.search)\n      if (\n        search.get('__nextppronly') === 'fallback' ||\n        search.get('__nextppronly') === '1'\n      ) {\n        console.warn(\n          `Skipping hydration due to __nextppronly=${search.get('__nextppronly')}`\n        )\n        return\n      }\n    }\n\n    hydrate(assetPrefix)\n  })\n}\n","export const reportGlobalError =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : (error: unknown) => {\n        // TODO: Dispatch error event\n        globalThis.console.error(error)\n      }\n","// This module can be shared between both pages router and app router\n\nimport type { HydrationOptions } from 'react-dom/client'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport isError from '../../lib/is-error'\nimport { reportGlobalError } from './report-global-error'\n\nconst recoverableErrors = new WeakSet<Error>()\n\nexport function isRecoverableError(error: Error): boolean {\n  return recoverableErrors.has(error)\n}\n\nexport const onRecoverableError: HydrationOptions['onRecoverableError'] = (\n  error\n) => {\n  // x-ref: https://github.com/facebook/react/pull/28736\n  let cause = isError(error) && 'cause' in error ? error.cause : error\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(cause)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { decorateDevError } =\n      require('../../next-devtools/userspace/app/errors/stitched-error') as typeof import('../../next-devtools/userspace/app/errors/stitched-error')\n    const causeError = decorateDevError(cause)\n    recoverableErrors.add(causeError)\n    cause = causeError\n  }\n\n  reportGlobalError(cause)\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n","import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","import isError from '../../lib/is-error'\n\nfunction formatObject(arg: unknown, depth: number) {\n  switch (typeof arg) {\n    case 'object':\n      if (arg === null) {\n        return 'null'\n      } else if (Array.isArray(arg)) {\n        let result = '['\n        if (depth < 1) {\n          for (let i = 0; i < arg.length; i++) {\n            if (result !== '[') {\n              result += ','\n            }\n            if (Object.prototype.hasOwnProperty.call(arg, i)) {\n              result += formatObject(arg[i], depth + 1)\n            }\n          }\n        } else {\n          result += arg.length > 0 ? '...' : ''\n        }\n        result += ']'\n        return result\n      } else if (arg instanceof Error) {\n        return arg + ''\n      } else {\n        const keys = Object.keys(arg)\n        let result = '{'\n        if (depth < 1) {\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            const desc = Object.getOwnPropertyDescriptor(arg, 'key')\n            if (desc && !desc.get && !desc.set) {\n              const jsonKey = JSON.stringify(key)\n              if (jsonKey !== '\"' + key + '\"') {\n                result += jsonKey + ': '\n              } else {\n                result += key + ': '\n              }\n              result += formatObject(desc.value, depth + 1)\n            }\n          }\n        } else {\n          result += keys.length > 0 ? '...' : ''\n        }\n        result += '}'\n        return result\n      }\n    case 'string':\n      return JSON.stringify(arg)\n    case 'number':\n    case 'bigint':\n    case 'boolean':\n    case 'symbol':\n    case 'undefined':\n    case 'function':\n    default:\n      return String(arg)\n  }\n}\n\nexport function formatConsoleArgs(args: unknown[]): string {\n  let message: string\n  let idx: number\n  if (typeof args[0] === 'string') {\n    message = args[0]\n    idx = 1\n  } else {\n    message = ''\n    idx = 0\n  }\n  let result = ''\n  let startQuote = false\n  for (let i = 0; i < message.length; ++i) {\n    const char = message[i]\n    if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n      result += char\n      continue\n    }\n\n    const code = message[++i]\n    switch (code) {\n      case 'c': {\n        // TODO: We should colorize with HTML instead of turning into a string.\n        // Ignore for now.\n        result = startQuote ? `${result}]` : `[${result}`\n        startQuote = !startQuote\n        idx++\n        break\n      }\n      case 'O':\n      case 'o': {\n        result += formatObject(args[idx++], 0)\n        break\n      }\n      case 'd':\n      case 'i': {\n        result += parseInt(args[idx++] as any, 10)\n        break\n      }\n      case 'f': {\n        result += parseFloat(args[idx++] as any)\n        break\n      }\n      case 's': {\n        result += String(args[idx++])\n        break\n      }\n      default:\n        result += '%' + code\n    }\n  }\n\n  for (; idx < args.length; idx++) {\n    result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0)\n  }\n\n  return result\n}\n\nexport function parseConsoleArgs(args: unknown[]): {\n  environmentName: string | null\n  error: Error | null\n} {\n  // See\n  // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n  //\n  // Logs replayed from the server look like this:\n  // [\n  //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n  //   \"background: #e6e6e6; ...\",\n  //   \" Server \", // can also be e.g. \" Prerender \"\n  //   \"\",\n  //   Error,\n  //   \"The above error occurred in the <Page> component.\",\n  //   ...\n  // ]\n  if (\n    args.length > 3 &&\n    typeof args[0] === 'string' &&\n    args[0].startsWith('%c%s%c') &&\n    typeof args[1] === 'string' &&\n    typeof args[2] === 'string' &&\n    typeof args[3] === 'string'\n  ) {\n    const environmentName = args[2]\n    const maybeError = args[4]\n\n    return {\n      environmentName: environmentName.trim(),\n      error: isError(maybeError) ? maybeError : null,\n    }\n  }\n\n  return {\n    environmentName: null,\n    error: null,\n  }\n}\n","// imports polyfill from `@next/polyfill-module` after build.\nimport '../build/polyfills/polyfill-module'\n\n// Only setup devtools in development\nif (process.env.NODE_ENV !== 'production') {\n  require('../next-devtools/userspace/app/app-dev-overlay-setup') as typeof import('../next-devtools/userspace/app/app-dev-overlay-setup')\n}\n","/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n\n// TODO: Should this include nextjs in the name, like the others?\nexport const NEXT_ACTION_REVALIDATED_HEADER = 'x-action-revalidated' as const\n","import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n","const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isStaticGeneration) {\n      if (error) {\n        console.error(error)\n      }\n      throw error\n    }\n  }\n\n  return null\n}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n","'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n","export const RuntimeErrorHandler = {\n  hadRuntimeError: false,\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n","// This file is only used in app router due to the specific error state handling.\n\nimport type { ErrorInfo } from 'react'\nimport { isNextRouterError } from '../components/is-next-router-error'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { reportGlobalError } from './report-global-error'\nimport { ErrorBoundaryHandler } from '../components/error-boundary'\nimport DefaultErrorBoundary from '../components/builtin/global-error'\n\nconst devToolErrorMod: typeof import('../../next-devtools/userspace/app/errors') =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../../next-devtools/userspace/app/errors') as typeof import('../../next-devtools/userspace/app/errors'))\n    : {\n        decorateDevError: (error: unknown) => error as Error,\n        handleClientError: () => {},\n        originConsoleError: console.error.bind(console),\n      }\n\nexport function onCaughtError(\n  thrownValue: unknown,\n  errorInfo: ErrorInfo & { errorBoundary?: React.Component }\n) {\n  const errorBoundaryComponent = errorInfo.errorBoundary?.constructor\n\n  let isImplicitErrorBoundary\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { AppDevOverlayErrorBoundary } =\n      require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary') as typeof import('../../next-devtools/userspace/app/app-dev-overlay-error-boundary')\n\n    isImplicitErrorBoundary =\n      errorBoundaryComponent === AppDevOverlayErrorBoundary\n  }\n\n  isImplicitErrorBoundary =\n    isImplicitErrorBoundary ||\n    (errorBoundaryComponent === ErrorBoundaryHandler &&\n      (errorInfo.errorBoundary! as InstanceType<typeof ErrorBoundaryHandler>)\n        .props.errorComponent === DefaultErrorBoundary)\n\n  // Skip the segment explorer triggered error\n  if (process.env.NODE_ENV !== 'production') {\n    const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } =\n      require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n    if (\n      thrownValue instanceof Error &&\n      thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE\n    ) {\n      return\n    }\n  }\n\n  if (isImplicitErrorBoundary) {\n    // We don't consider errors caught unless they're caught by an explicit error\n    // boundary. The built-in ones are considered implicit.\n    // This mimics how the same app would behave without Next.js.\n    return onUncaughtError(thrownValue)\n  }\n\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const errorBoundaryName =\n      // read react component displayName\n      (errorBoundaryComponent as any)?.displayName ||\n      errorBoundaryComponent?.name ||\n      'Unknown'\n\n    const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1]\n\n    // Match chrome or safari stack trace\n    const matches =\n      // regex to match the function name in the stack trace\n      // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n      // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n      componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? []\n    const componentThatErroredName = matches[1] || matches[2] || 'Unknown'\n\n    // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n    const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`\n    const componentErrorMessage = componentThatErroredName\n      ? `The above error occurred in the <${componentThatErroredName}> component.`\n      : `The above error occurred in one of your components.`\n\n    const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // Log and report the error with location but without modifying the error stack\n    devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation)\n\n    devToolErrorMod.handleClientError(error)\n  } else {\n    devToolErrorMod.originConsoleError(thrownValue)\n  }\n}\n\nexport function onUncaughtError(thrownValue: unknown) {\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n    reportGlobalError(error)\n  } else {\n    reportGlobalError(thrownValue)\n  }\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { NavigationSeed } from '../segment-cache/navigation'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  previousTree: FlightRouterState\n  url: URL\n  nextUrl: string | null\n  seed: NavigationSeed | null\n  mpa: boolean\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n","import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport {\n  type NEXT_ROUTER_PREFETCH_HEADER,\n  type NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport { getDeploymentId } from '../../../shared/lib/deployment-id'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      'auto',\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  ChildSegmentMap,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { dispatchAppRouterAction } from '../use-action-queue'\nimport {\n  ACTION_SERVER_PATCH,\n  type ServerPatchAction,\n} from './router-reducer-types'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\nimport {\n  convertServerPatchToFullTree,\n  type NavigationSeed,\n} from '../segment-cache/navigation'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  status: NavigationTaskStatus\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshUrl: string | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport const enum FreshnessPolicy {\n  Default,\n  Hydration,\n  HistoryTraversal,\n  RefreshAll,\n  HMRRefresh,\n}\n\nconst enum NavigationTaskStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\n/**\n * When a NavigationTask finishes, there may or may not be data still missing,\n * necessitating a retry.\n */\nconst enum NavigationTaskExitStatus {\n  /**\n   * No additional navigation is required.\n   */\n  Done = 0,\n  /**\n   * Some data failed to load, presumably due to a route tree mismatch. Perform\n   * a soft retry to reload the entire tree.\n   */\n  SoftRetry = 1,\n  /**\n   * Some data failed to load in an unrecoverable way, e.g. in an inactive\n   * parallel route. Fall back to a hard (MPA-style) retry.\n   */\n  HardRetry = 2,\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\nconst noop = () => {}\n\nexport function createInitialCacheNodeForHydration(\n  navigatedAt: number,\n  initialTree: FlightRouterState,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData\n): CacheNode {\n  // Create the initial cache node tree, using the data embedded into the\n  // HTML document.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = createCacheNodeOnNavigation(\n    navigatedAt,\n    initialTree,\n    undefined,\n    FreshnessPolicy.Hydration,\n    seedData,\n    seedHead,\n    null,\n    null,\n    false,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  // NOTE: We intentionally don't check if any data needs to be fetched from the\n  // server. We assume the initial hydration payload is sufficient to render\n  // the page.\n  //\n  // The completeness of the initial data is an important property that we rely\n  // on as a last-ditch mechanism for recovering the app; we must always be able\n  // to reload a fresh HTML document to get to a consistent state.\n  //\n  // In the future, there may be cases where the server intentionally sends\n  // partial data and expects the client to fill in the rest, in which case this\n  // logic may change. (There already is a similar case where the server sends\n  // _no_ hydration data in the HTML document at all, and the client fetches it\n  // separately, but that's different because we still end up hydrating with a\n  // complete tree.)\n\n  return task.node\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshUrl = null\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouterState,\n    freshness,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    parentRefreshUrl,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  parentRefreshUrl: string | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = newRouterState[0]\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouterState)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterState,\n      oldCacheNode,\n      freshness,\n      seedData,\n      seedHead,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const isRootLayout = newRouterState[4] === true\n  const childDidFindRootLayout = didFindRootLayout || isRootLayout\n\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n      // We should never drop dynamic data in shared layouts, except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n      shouldRefreshDynamicData = false\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      shouldDropSiblingCaches = true\n      shouldRefreshDynamicData = true\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    const dropPrefetchRsc = false\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = seedHead === null\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const href = newRouterState[2]\n  const refreshUrl =\n    typeof href === 'string' && newRouterState[3] === 'refresh'\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        href\n      : // Inherit the refresh URL from the parent.\n        parentRefreshUrl\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshUrl !== null) {\n    accumulateRefreshUrl(accumulation, refreshUrl)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    let newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    if (oldRouterStateChild === undefined) {\n      // This should never happen, but if it does, it suggests a malformed\n      // server response. Trigger a full-page navigation.\n      return null\n    }\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n\n    let seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    let prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    let newSegmentChild = newRouterStateChild[0]\n    let seedHeadChild = seedHead\n    let prefetchHeadChild = prefetchHead\n    let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n    if (\n      // Skip this branch during a history traversal. We restore the tree that\n      // was stashed in the history entry as-is.\n      freshness !== FreshnessPolicy.HistoryTraversal &&\n      newSegmentChild === DEFAULT_SEGMENT_KEY\n    ) {\n      // This is a \"default\" segment. These are never sent by the server during\n      // a soft navigation; instead, the client reuses whatever segment was\n      // already active in that slot on the previous route.\n      newRouterStateChild = reuseActiveSegmentInDefaultSlot(\n        oldUrl,\n        oldRouterStateChild\n      )\n      newSegmentChild = newRouterStateChild[0]\n\n      // Since we're switching to a different route tree, these are no\n      // longer valid, because they correspond to the outer tree.\n      seedDataChild = null\n      seedHeadChild = null\n      prefetchDataChild = null\n      prefetchHeadChild = null\n      isPrefetchHeadPartialChild = false\n    }\n\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = updateCacheNodeOnNavigation(\n      navigatedAt,\n      oldUrl,\n      oldCacheNodeChild,\n      oldRouterStateChild,\n      newRouterStateChild,\n      freshness,\n      childDidFindRootLayout,\n      seedDataChild ?? null,\n      seedHeadChild,\n      prefetchDataChild ?? null,\n      prefetchHeadChild,\n      isPrefetchHeadPartialChild,\n      isSamePageNavigation,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      refreshUrl,\n      accumulation\n    )\n\n    if (taskChild === null) {\n      // One of the child tasks discovered a change to the root layout.\n      // Immediately unwind from this recursive traversal. This will trigger a\n      // full-page navigation.\n      return null\n    }\n\n    // Recursively propagate up the child tasks.\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    // The child tree's route state may be different from the prefetched\n    // route sent by the server. We need to clone it as we traverse back up\n    // the tree.\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      // Something in the child tree is dynamic.\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshUrl,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouterState: FlightRouterState,\n  oldCacheNode: CacheNode | void,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = newRouterState[0]\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  let dropPrefetchRsc: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n      // We should never drop dynamic data in sibling caches except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n\n      // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n      // is set, and the data is not stale. (This is not a recommended API with\n      // Cache Components, but it's supported for backwards compatibility. Use\n      // cacheLife instead.)\n      //\n      // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n      shouldRefreshDynamicData =\n        oldCacheNode === undefined ||\n        navigatedAt - oldCacheNode.navigatedAt >= DYNAMIC_STALETIME_MS\n\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.Hydration:\n      // During hydration, we assume the data sent by the server is both\n      // consistent and complete.\n      shouldRefreshDynamicData = false\n      shouldDropSiblingCaches = false\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.HistoryTraversal:\n      // During back/forward navigations, we reuse the dynamic data regardless\n      // of how stale it may be.\n      shouldRefreshDynamicData = false\n      shouldRefreshDynamicData = false\n\n      // Only show prefetched data if the dynamic data is still pending. This\n      // avoids a flash back to the prefetch state in a case where it's highly\n      // likely to have already streamed in.\n      //\n      // Tehnically, what we're actually checking is whether the dynamic network\n      // response was received. But since it's a streaming response, this does\n      // not mean that all the dynamic data has fully streamed in. It just means\n      // that _some_ of the dynamic data was received. But as a heuristic, we\n      // assume that the rest dynamic data will stream in quickly, so it's still\n      // better to skip the prefetch state.\n      if (oldCacheNode !== undefined) {\n        const oldRsc = oldCacheNode.rsc\n        const oldRscDidResolve =\n          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n        dropPrefetchRsc = oldRscDidResolve\n      } else {\n        dropPrefetchRsc = false\n      }\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      // Drop all dynamic data.\n      shouldRefreshDynamicData = true\n      shouldDropSiblingCaches = true\n      dropPrefetchRsc = false\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n    // Reuse the existing CacheNode\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial =\n      seedHead === null && freshness !== FreshnessPolicy.Hydration\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (\n    freshness === FreshnessPolicy.Hydration &&\n    isLeafSegment &&\n    seedHead !== null\n  ) {\n    // This is another weird case related to \"not found\" pages and hydration.\n    // There will be a head sent by the server, but no page seed data.\n    // TODO: We really should get rid of all these \"not found\" specific quirks\n    // and make sure the tree is always consistent.\n    const seedRsc = null\n    const seedLoading = null\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = false\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = false\n  } else if (freshness !== FreshnessPolicy.Hydration && prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n    const seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterStateChild,\n      oldCacheNodeChild,\n      freshness,\n      seedDataChild ?? null,\n      seedHead,\n      prefetchDataChild ?? null,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      accumulation\n    )\n\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshUrl: null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshUrl: string\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): FlightRouterState {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return reusedRouterState\n}\n\nfunction reuseDynamicCacheNode(\n  dropPrefetchRsc: boolean,\n  existingCacheNode: CacheNode,\n  parallelRoutes: Map<string, ChildSegmentMap>\n): CacheNode {\n  // Clone an existing CacheNode's data, with (possibly) new children.\n  const cacheNode: CacheNode = {\n    rsc: existingCacheNode.rsc,\n    prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n    head: existingCacheNode.head,\n    prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n    loading: existingCacheNode.loading,\n\n    parallelRoutes,\n\n    // Don't update the navigatedAt timestamp, since we're reusing\n    // existing data.\n    navigatedAt: existingCacheNode.navigatedAt,\n  }\n  return cacheNode\n}\n\nfunction readCacheNodeFromSeedData(\n  seedRsc: React.ReactNode,\n  seedLoading: LoadingModuleData | Promise<LoadingModuleData>,\n  isSeedRscPartial: boolean,\n  seedHead: HeadData | null,\n  isSeedHeadPartial: boolean,\n  isPageSegment: boolean,\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  navigatedAt: number\n): CacheNode {\n  // TODO: Currently this is threaded through the navigation logic using the\n  // CacheNodeSeedData type, but in the future this will read directly from\n  // the Segment Cache. See readRenderSnapshotFromCache.\n\n  let rsc: React.ReactNode\n  let prefetchRsc: React.ReactNode\n  if (isSeedRscPartial) {\n    // The prefetched data contains dynamic holes. Create a pending promise that\n    // will be fulfilled when the dynamic data is received from the server.\n    prefetchRsc = seedRsc\n    rsc = createDeferredRsc()\n  } else {\n    // The prefetched data is complete. Use it directly.\n    prefetchRsc = null\n    rsc = seedRsc\n  }\n\n  // If this is a page segment, also read the head.\n  let prefetchHead: HeadData | null\n  let head: HeadData | null\n  if (isPageSegment) {\n    if (isSeedHeadPartial) {\n      prefetchHead = seedHead\n      head = createDeferredRsc()\n    } else {\n      prefetchHead = null\n      head = seedHead\n    }\n  } else {\n    prefetchHead = null\n    head = null\n  }\n\n  const cacheNode: CacheNode = {\n    rsc,\n    prefetchRsc,\n    head,\n    prefetchHead,\n    // TODO: Technically, a loading boundary could contain dynamic data. We\n    // should have separate `loading` and `prefetchLoading` fields to handle\n    // this, like we do for the segment data and head.\n    loading: seedLoading,\n    parallelRoutes,\n    navigatedAt,\n  }\n\n  return cacheNode\n}\n\nfunction spawnNewCacheNode(\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  isLeafSegment: boolean,\n  navigatedAt: number,\n  freshness: FreshnessPolicy\n): CacheNode {\n  // We should never spawn network requests during hydration. We must treat the\n  // initial payload as authoritative, because the initial page load is used\n  // as a last-ditch mechanism for recovering the app.\n  //\n  // This is also an important safety check because if this leaks into the\n  // server rendering path (which theoretically it never should because\n  // the server payload should be consistent), the server would hang because\n  // these promises would never resolve.\n  //\n  // TODO: There is an existing case where the global \"not found\" boundary\n  // triggers this path. But it does render correctly despite that. That's an\n  // unusual render path so it's not surprising, but we should look into\n  // modeling it in a more consistent way. See also the /_notFound special\n  // case in updateCacheNodeOnNavigation.\n  const isHydration = freshness === FreshnessPolicy.Hydration\n\n  const cacheNode: CacheNode = {\n    rsc: !isHydration ? createDeferredRsc() : null,\n    prefetchRsc: null,\n    head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n    prefetchHead: null,\n    loading: !isHydration ? createDeferredRsc<LoadingModuleData>() : null,\n    parallelRoutes,\n    navigatedAt,\n  }\n  return cacheNode\n}\n\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function spawnDynamicRequests(\n  task: NavigationTask,\n  primaryUrl: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  accumulation: NavigationRequestAccumulation\n): void {\n  const dynamicRequestTree = task.dynamicRequestTree\n  if (dynamicRequestTree === null) {\n    // This navigation was fully cached. There are no dynamic requests to spawn.\n    previousNavigationDidMismatch = false\n    return\n  }\n\n  // This is intentionally not an async function to discourage the caller from\n  // awaiting the result. Any subsequent async operations spawned by this\n  // function should result in a separate navigation task, rather than\n  // block the original one.\n  //\n  // In this function we spawn (but do not await) all the network requests that\n  // block the navigation, and collect the promises. The next function,\n  // `finishNavigationTask`, can await the promises in any order without\n  // accidentally introducing a network waterfall.\n  const primaryRequestPromise = fetchMissingDynamicData(\n    task,\n    dynamicRequestTree,\n    primaryUrl,\n    nextUrl,\n    freshnessPolicy\n  )\n\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  let refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null = null\n  if (separateRefreshUrls !== null) {\n    // There are multiple URLs that we need to request the data from. This\n    // happens when a \"default\" parallel route slot is present in the tree, and\n    // its data cannot be fetched from the current route. We need to split the\n    // combined dynamic request tree into separate requests per URL.\n\n    // TODO: Create a scoped dynamic request tree that omits anything that\n    // is not relevant to the given URL. Without doing this, the server may\n    // sometimes render more data than necessary; this is not a regression\n    // compared to the pre-Segment Cache implementation, though, just an\n    // optimization we can make in the future.\n\n    // Construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    refreshRequestPromises = []\n    const canonicalUrl = createHrefFromUrl(primaryUrl)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        refreshRequestPromises.push(\n          fetchMissingDynamicData(\n            task,\n            scopedDynamicRequestTree,\n            new URL(refreshUrl, location.origin),\n            // TODO: Just noticed that this should actually the Next-Url at the\n            // time the refresh URL was set, not the current Next-Url. Need to\n            // start tracking this alongside the refresh URL. In the meantime,\n            // if a refresh fails due to a mismatch, it will trigger a\n            // hard refresh.\n            nextUrl,\n            freshnessPolicy\n          )\n        )\n      }\n    }\n  }\n\n  // Further async operations are moved into this separate function to\n  // discourage sequential network requests.\n  const voidPromise = finishNavigationTask(\n    task,\n    nextUrl,\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n  // `finishNavigationTask` is responsible for error handling, so we can attach\n  // noop callbacks to this promise.\n  voidPromise.then(noop, noop)\n}\n\nasync function finishNavigationTask(\n  task: NavigationTask,\n  nextUrl: string | null,\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n): Promise<void> {\n  // Wait for all the requests to finish, or for the first one to fail.\n  let exitStatus = await waitForRequestsToFinish(\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n\n  // Once the all the requests have finished, check the tree for any remaining\n  // pending tasks. If anything is still pending, it means the server response\n  // does not match the client, and we must refresh to get back to a consistent\n  // state. We can skip this step if we already detected a mismatch during the\n  // first phase; it doesn't matter in that case because we're going to refresh\n  // the whole tree regardless.\n  if (exitStatus === NavigationTaskExitStatus.Done) {\n    exitStatus = abortRemainingPendingTasks(task, null, null)\n  }\n\n  switch (exitStatus) {\n    case NavigationTaskExitStatus.Done: {\n      // The task has completely finished. There's no missing data. Exit.\n      previousNavigationDidMismatch = false\n      return\n    }\n    case NavigationTaskExitStatus.SoftRetry: {\n      // Some data failed to finish loading. Trigger a soft retry.\n      // TODO: As an extra precaution against soft retry loops, consider\n      // tracking whether a navigation was itself triggered by a retry. If two\n      // happen in a row, fall back to a hard retry.\n      const isHardRetry = false\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    case NavigationTaskExitStatus.HardRetry: {\n      // Some data failed to finish loading in a non-recoverable way, such as a\n      // network error. Trigger an MPA navigation.\n      //\n      // Hard navigating/refreshing is how we prevent an infinite retry loop\n      // caused by a network error  when the network fails, we fall back to the\n      // browser behavior for offline navigations. In the future, Next.js may\n      // introduce its own custom handling of offline navigations, but that\n      // doesn't exist yet.\n      const isHardRetry = true\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    default: {\n      return exitStatus satisfies never\n    }\n  }\n}\n\nfunction waitForRequestsToFinish(\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n) {\n  // Custom async combinator logic. This could be replaced by Promise.any but\n  // we don't assume that's available.\n  //\n  // Each promise resolves once the server responsds and the data is written\n  // into the CacheNode tree. Resolve the combined promise once all the\n  // requests finish.\n  //\n  // Or, resolve as soon as one of the requests fails, without waiting for the\n  // others to finish.\n  return new Promise<NavigationTaskExitStatus>((resolve) => {\n    const onFulfill = (result: { exitStatus: NavigationTaskExitStatus }) => {\n      if (result.exitStatus === NavigationTaskExitStatus.Done) {\n        remainingCount--\n        if (remainingCount === 0) {\n          // All the requests finished successfully.\n          resolve(NavigationTaskExitStatus.Done)\n        }\n      } else {\n        // One of the requests failed. Exit with a failing status.\n        // NOTE: It's possible for one of the requests to fail with SoftRetry\n        // and a later one to fail with HardRetry. In this case, we choose to\n        // retry immediately, rather than delay the retry until all the requests\n        // finish. If it fails again, we will hard retry on the next\n        // attempt, anyway.\n        resolve(result.exitStatus)\n      }\n    }\n    // onReject shouldn't ever be called because fetchMissingDynamicData's\n    // entire body is wrapped in a try/catch. This is just defensive.\n    const onReject = () => resolve(NavigationTaskExitStatus.HardRetry)\n\n    // Attach the listeners to the promises.\n    let remainingCount = 1\n    primaryRequestPromise.then(onFulfill, onReject)\n    if (refreshRequestPromises !== null) {\n      remainingCount += refreshRequestPromises.length\n      refreshRequestPromises.forEach((refreshRequestPromise) =>\n        refreshRequestPromise.then(onFulfill, onReject)\n      )\n    }\n  })\n}\n\nfunction dispatchRetryDueToTreeMismatch(\n  isHardRetry: boolean,\n  retryUrl: URL,\n  retryNextUrl: string | null,\n  seed: NavigationSeed | null,\n  baseTree: FlightRouterState\n) {\n  // If this is the second time in a row that a navigation resulted in a\n  // mismatch, fall back to a hard (MPA) refresh.\n  isHardRetry = isHardRetry || previousNavigationDidMismatch\n  previousNavigationDidMismatch = true\n  const retryAction: ServerPatchAction = {\n    type: ACTION_SERVER_PATCH,\n    previousTree: baseTree,\n    url: retryUrl,\n    nextUrl: retryNextUrl,\n    seed,\n    mpa: isHardRetry,\n  }\n  dispatchAppRouterAction(retryAction)\n}\n\nasync function fetchMissingDynamicData(\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  url: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy\n): Promise<{\n  exitStatus: NavigationTaskExitStatus\n  url: URL\n  seed: NavigationSeed | null\n}> {\n  try {\n    const result = await fetchServerResponse(url, {\n      flightRouterState: dynamicRequestTree,\n      nextUrl,\n      isHmrRefresh: freshnessPolicy === FreshnessPolicy.HMRRefresh,\n    })\n    if (typeof result === 'string') {\n      // fetchServerResponse will return an href to indicate that the SPA\n      // navigation failed. For example, if the server triggered a hard\n      // redirect, or the fetch request errored. Initiate an MPA navigation\n      // to the given href.\n      return {\n        exitStatus: NavigationTaskExitStatus.HardRetry,\n        url: new URL(result, location.origin),\n        seed: null,\n      }\n    }\n    const seed = convertServerPatchToFullTree(\n      task.route,\n      result.flightData,\n      result.renderedSearch\n    )\n    const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(\n      task,\n      seed.tree,\n      seed.data,\n      seed.head,\n      result.debugInfo\n    )\n    return {\n      exitStatus: didReceiveUnknownParallelRoute\n        ? NavigationTaskExitStatus.SoftRetry\n        : NavigationTaskExitStatus.Done,\n      url: new URL(result.canonicalUrl, location.origin),\n      seed,\n    }\n  } catch {\n    // This shouldn't happen because fetchServerResponse's entire body is\n    // wrapped in a try/catch. If it does, though, it implies the server failed\n    // to respond with any tree at all. So we must fall back to a hard retry.\n    return {\n      exitStatus: NavigationTaskExitStatus.HardRetry,\n      url: url,\n      seed: null,\n    }\n  }\n}\n\nfunction writeDynamicDataIntoNavigationTask(\n  task: NavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData | null,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): boolean {\n  if (task.status === NavigationTaskStatus.Pending && dynamicData !== null) {\n    task.status = NavigationTaskStatus.Fulfilled\n    finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo)\n  }\n\n  const taskChildren = task.children\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null\n\n  // Detect whether the server sends a parallel route slot that the client\n  // doesn't know about.\n  let didReceiveUnknownParallelRoute = false\n\n  if (taskChildren !== null) {\n    for (const parallelRouteKey in serverChildren) {\n      const serverRouterStateChild: FlightRouterState =\n        serverChildren[parallelRouteKey]\n      const dynamicDataChild: CacheNodeSeedData | null | void =\n        dynamicDataChildren !== null\n          ? dynamicDataChildren[parallelRouteKey]\n          : null\n\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild === undefined) {\n        // The server sent a child segment that the client doesn't know about.\n        //\n        // When we receive an unknown parallel route, we must consider it a\n        // mismatch. This is unlike the case where the segment itself\n        // mismatches, because multiple routes can be active simultaneously.\n        // But a given layout should never have a mismatching set of\n        // child slots.\n        //\n        // Theoretically, this should only happen in development during an HMR\n        // refresh, because the set of parallel routes for a layout does not\n        // change over the lifetime of a build/deployment. In production, we\n        // should have already mismatched on either the build id or the segment\n        // path. But as an extra precaution, we validate in prod, too.\n        didReceiveUnknownParallelRoute = true\n      } else {\n        const taskSegment = taskChild.route[0]\n        if (\n          matchSegment(serverRouterStateChild[0], taskSegment) &&\n          dynamicDataChild !== null &&\n          dynamicDataChild !== undefined\n        ) {\n          // Found a match for this task. Keep traversing down the task tree.\n          const childDidReceiveUnknownParallelRoute =\n            writeDynamicDataIntoNavigationTask(\n              taskChild,\n              serverRouterStateChild,\n              dynamicDataChild,\n              dynamicHead,\n              debugInfo\n            )\n          if (childDidReceiveUnknownParallelRoute) {\n            didReceiveUnknownParallelRoute = true\n          }\n        }\n      }\n    }\n  }\n\n  return didReceiveUnknownParallelRoute\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n\n  if (dynamicSegmentData === null) {\n    // This is an empty CacheNode; this particular server request did not\n    // render this segment. There may be a separate pending request that will,\n    // though, so we won't abort the task until all pending requests finish.\n    return\n  }\n\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nfunction abortRemainingPendingTasks(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): NavigationTaskExitStatus {\n  let exitStatus\n  if (task.status === NavigationTaskStatus.Pending) {\n    // The data for this segment is still missing.\n    task.status = NavigationTaskStatus.Rejected\n    abortPendingCacheNode(task.node, error, debugInfo)\n\n    // If the server failed to fulfill the data for this segment, it implies\n    // that the route tree received from the server mismatched the tree that\n    // was previously prefetched.\n    //\n    // In an app with fully static routes and no proxy-driven redirects or\n    // rewrites, this should never happen, because the route for a URL would\n    // always be the same across multiple requests. So, this implies that some\n    // runtime routing condition changed, likely in a proxy, without being\n    // pushed to the client.\n    //\n    // When this happens, we treat this the same as a refresh(). The entire\n    // tree will be re-rendered from the root.\n    if (task.refreshUrl === null) {\n      // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n      // in a Server Action.\n      exitStatus = NavigationTaskExitStatus.SoftRetry\n    } else {\n      // The mismatch was discovered inside an inactive parallel route. This\n      // implies the inactive parallel route is no longer reachable at the URL\n      // that originally rendered it. Fall back to an MPA refresh.\n      // TODO: An alternative could be to trigger a soft refresh but to _not_\n      // re-use the inactive parallel routes this time. Similar to what would\n      // happen if were to do a hard refrehs, but without the HTML page.\n      exitStatus = NavigationTaskExitStatus.HardRetry\n    }\n  } else {\n    // This segment finished. (An error here is treated as Done because they are\n    // surfaced to the application during render.)\n    exitStatus = NavigationTaskExitStatus.Done\n  }\n\n  const taskChildren = task.children\n  if (taskChildren !== null) {\n    for (const [, taskChild] of taskChildren) {\n      const childExitStatus = abortRemainingPendingTasks(\n        taskChild,\n        error,\n        debugInfo\n      )\n      // Propagate the exit status up the tree. The statuses are ordered by\n      // their precedence.\n      if (childExitStatus > exitStatus) {\n        exitStatus = childExitStatus\n      }\n    }\n  }\n\n  return exitStatus\n}\n\nfunction abortPendingCacheNode(\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nexport function isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","import { deleteMapEntry } from './cache-map'\nimport type { UnknownMapEntry } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\nlet head: UnknownMapEntry | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: UnknownMapEntry) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: UnknownMapEntry) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n        prev.next = next\n        next.prev = prev\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteMapEntry(tail)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n","import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Represents a node in the cache map and LRU.\n * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n *\n * The LRU can contain entries of different value types\n * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n * the common structure needed for cache map and LRU operations without\n * requiring knowledge of the specific value type.\n */\nexport interface MapEntry<V extends MapValue> {\n  // Cache map structure fields\n  parent: MapEntry<V> | null\n  key: unknown\n  map: Map<unknown, MapEntry<V>> | null\n  value: V | null\n\n  // LRU linked list fields\n  prev: MapEntry<V> | null\n  next: MapEntry<V> | null\n  size: number\n}\n\n/**\n * A looser type for MapEntry\n * This allows the LRU to work with entries of different\n * value types while still providing type safety.\n *\n * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n * type since we're only reading from the map, not inserting into it.\n */\nexport type UnknownMapEntry = {\n  parent: UnknownMapEntry | null\n  key: unknown\n  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n  value: MapValue | null\n\n  prev: UnknownMapEntry | null\n  next: UnknownMapEntry | null\n  size: number\n}\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: MapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired(\n  now: number,\n  currentCacheVersion: number,\n  value: MapValue\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n    entry.value = null\n  }\n\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  entry.value = value\n  value.ref = entry\n\n  updateLruSize(entry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap(value: MapValue): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef(value: MapValue): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nexport function deleteMapEntry(entry: UnknownMapEntry): void {\n  // Delete the entry from the cache.\n  entry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = entry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = entry.parent\n    let key = entry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(entry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n","import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    value: NormalizedPathname\n    parent: {\n      value: NormalizedSearch\n      parent: {\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    value: string\n    parent: {\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    value: requestKey,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it  for example, if the server tells us that the response\n  // doesn't vary on a particular param  but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    value: originalVaryPath.value,\n    parent: {\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport { getCurrentCacheVersion } from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization  theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(\n      now,\n      FetchStrategy.PPR,\n      route,\n      route.metadata\n    ),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree  the part that doesn't exist on the current page  we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static  once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch  via <Link prefetch={true}>  implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state  it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response  it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    route,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    route,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        fetchStrategy,\n        route,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in  is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it  i.e. the one\n  // optionally passed to router.prefetch(onInvalidate)  then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete  this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert  should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time  it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationTask,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath> | null\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<MPANavigationResult | SuccessfulNavigationResult>\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = href === currentUrl.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      freshnessPolicy,\n      shouldScroll\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        freshnessPolicy,\n        shouldScroll\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      collectedDebugInfo\n    ),\n  }\n}\n\nexport function navigateToSeededRoute(\n  now: number,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.tree,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    null,\n    null,\n    false,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      navigationSeed.renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const seedData = null\n  const seedHead = null\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    freshnessPolicy,\n    seedData,\n    seedHead,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigationTaskToResult(\n  task: NavigationTask,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState: task.route,\n      cacheNode: task.node,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Because the request is still pending, we typically don't know yet\n        // whether the response will be partial. We shouldn't skip this segment\n        // during the dynamic navigation request. Otherwise, we might need to\n        // do yet another request to fill in the remaining data, creating\n        // a waterfall.\n        //\n        // The one exception is if this segment is being fetched with via\n        // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n        // we can assume the response will be full. This field is set to `false`\n        // for such segments.\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  collectedDebugInfo: Array<unknown>\n): Promise<MPANavigationResult | SuccessfulNavigationResult> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  return navigateToSeededRoute(\n    now,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll\n  )\n}\n\nexport type NavigationSeed = {\n  tree: FlightRouterState\n  renderedSearch: string\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  for (const {\n    segmentPath,\n    tree: treePatch,\n    seedData: dataPatch,\n    head: headPatch,\n  } of flightData) {\n    const result = convertServerPatchToFullTreeImpl(\n      baseTree,\n      baseData,\n      treePatch,\n      dataPatch,\n      segmentPath,\n      0\n    )\n    baseTree = result.tree\n    baseData = result.data\n    // This is the same for all patches per response, so just pick an\n    // arbitrary one\n    head = headPatch\n  }\n\n  return {\n    tree: baseTree,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    clonedTree[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nexport function handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n      // some confusing and subtle logic in `handleMutable` that decides what\n      // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n      // not convinced it's totally coherent but the tests assert on this\n      // particular behavior so I've ported the logic as-is from the previous\n      // router implementation, for now.\n      mutable.scrollableSegments = result.data.scrollableSegments ?? undefined\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    FreshnessPolicy.Default,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n","import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","import type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function refreshReducer(state: ReadonlyReducerState): ReducerState {\n  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n  // only client-side refreshes will have this behavior; the server-side\n  // `refresh` should send new data without purging the prefetch cache.\n  const currentNextUrl = state.nextUrl\n  const currentRouterState = state.tree\n  revalidateEntireCache(currentNextUrl, currentRouterState)\n  return refreshDynamicData(state, FreshnessPolicy.RefreshAll)\n}\n\nexport function refreshDynamicData(\n  state: ReadonlyReducerState,\n  freshnessPolicy: FreshnessPolicy.RefreshAll | FreshnessPolicy.HMRRefresh\n): ReducerState {\n  const currentNextUrl = state.nextUrl\n\n  // We always send the last next-url, not the current when performing a dynamic\n  // request. This is because we update the next-url after a navigation, but we\n  // want the same interception route to be matched that used the last next-url.\n  const nextUrlForRefresh = hasInterceptionRouteInCurrentTree(state.tree)\n    ? state.previousNextUrl || currentNextUrl\n    : null\n\n  // A refresh is modeled as a navigation to the current URL, but where any\n  // existing dynamic data (including in shared layouts) is re-fetched.\n  const currentCanonicalUrl = state.canonicalUrl\n  const currentUrl = new URL(currentCanonicalUrl, location.origin)\n  const currentFlightRouterState = state.tree\n  const shouldScroll = true\n\n  const navigationSeed = {\n    tree: state.tree,\n    renderedSearch: state.renderedSearch,\n    data: null,\n    head: null,\n  }\n\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    currentUrl,\n    currentCanonicalUrl,\n    navigationSeed,\n    currentUrl,\n    state.cache,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrlForRefresh,\n    shouldScroll\n  )\n\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  return handleNavigationResult(currentUrl, state, mutable, false, result)\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return handleExternalUrl(state, mutable, retryUrl.href, false)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  // A retry should not create a new history entry.\n  const pendingPush = false\n  const shouldScroll = true\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll\n  )\n  return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport type { Mutable } from '../router-reducer-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredCanonicalUrl = createHrefFromUrl(restoredUrl)\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.cache,\n    state.tree,\n    treeToRestore,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    null,\n    null,\n    false,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    const mutable: Mutable = {\n      preserveCustomHistoryState: true,\n    }\n    return handleExternalUrl(state, mutable, restoredCanonicalUrl, false)\n  }\n\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation\n  )\n\n  return {\n    // Set canonical url\n    canonicalUrl: restoredCanonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: task.node,\n    // Restore provided tree\n    tree: treeToRestore,\n\n    nextUrl: restoredNextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n","import type {\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { refreshDynamicData } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function hmrRefreshReducer(state: ReadonlyReducerState): ReducerState {\n  return refreshDynamicData(state, FreshnessPolicy.HMRRefresh)\n}\n","export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n","import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n","import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n","import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { getDeploymentId } from '../../../../shared/lib/deployment-id'\nimport {\n  navigateToSeededRoute,\n  navigate as navigateUsingSegmentCache,\n} from '../../segment-cache/navigation'\nimport type { NormalizedSearch } from '../../segment-cache/cache-key'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateDynamicOnly,\n  ActionDidRevalidateStaticAndDynamic,\n  type ActionRevalidationKind,\n} from '../../../../shared/lib/action-revalidation-kind'\nimport { isExternalURL } from '../../app-router-utils'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\n// TODO: Refactor to be a discriminated union. Or just get rid of it;\n// fetchServerAction only has one caller, no reason this intermediate type has\n// to exist.\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  revalidationKind: ActionRevalidationKind\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  actionFlightDataRenderedSearch: NormalizedSearch | undefined\n  actionFlightDataCouldBeIntercepted: boolean | undefined\n  isPrerender: boolean\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n\n  let revalidationKind: ActionRevalidationKind = ActionDidNotRevalidate\n  try {\n    const revalidationHeader = res.headers.get('x-action-revalidated')\n    if (revalidationHeader) {\n      const parsedKind = JSON.parse(revalidationHeader)\n      if (\n        parsedKind === ActionDidRevalidateStaticAndDynamic ||\n        parsedKind === ActionDidRevalidateDynamicOnly\n      ) {\n        revalidationKind = parsedKind\n      }\n    }\n  } catch {}\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  let actionFlightDataRenderedSearch: FetchServerActionResult['actionFlightDataRenderedSearch']\n  let actionFlightDataCouldBeIntercepted: FetchServerActionResult['actionFlightDataCouldBeIntercepted']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    const maybeFlightData = normalizeFlightData(response.f)\n    if (maybeFlightData !== '') {\n      actionFlightData = maybeFlightData\n      actionFlightDataRenderedSearch = response.q as NormalizedSearch\n      actionFlightDataCouldBeIntercepted = response.i\n    }\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n    actionFlightDataRenderedSearch = undefined\n    actionFlightDataCouldBeIntercepted = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    actionFlightDataRenderedSearch,\n    actionFlightDataCouldBeIntercepted,\n    redirectLocation,\n    redirectType,\n    revalidationKind,\n    isPrerender,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      revalidationKind,\n      actionResult,\n      actionFlightData: flightData,\n      actionFlightDataRenderedSearch: flightDataRenderedSearch,\n      actionFlightDataCouldBeIntercepted: flightDataCouldBeIntercepted,\n      redirectLocation,\n      redirectType,\n    }) => {\n      if (revalidationKind !== ActionDidNotRevalidate) {\n        // Store whether this action triggered any revalidation\n        // The action queue will use this information to potentially\n        // trigger a refresh action if the action was discarded\n        // (ie, due to a navigation, before the action completed)\n        action.didRevalidate = true\n\n        // If there was a revalidation, evict the entire prefetch cache.\n        // TODO: Evict only segments with matching tags and/or paths.\n        if (revalidationKind === ActionDidRevalidateStaticAndDynamic) {\n          revalidateEntireCache(nextUrl, state.tree)\n        }\n      }\n\n      const pendingPush = redirectType !== RedirectType.replace\n      state.pushRef.pendingPush = pendingPush\n      mutable.pendingPush = pendingPush\n\n      if (redirectLocation !== undefined) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const resolvedRedirectType = redirectType || RedirectType.push\n\n        if (isExternalURL(redirectLocation)) {\n          // External redirect. Triggers an MPA navigation.\n          const redirectHref = redirectLocation.href\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            resolvedRedirectType\n          )\n          reject(redirectError)\n          return handleExternalUrl(state, mutable, redirectHref, pendingPush)\n        } else {\n          // Internal redirect. Triggers an SPA navigation.\n          const redirectWithBasepath = createHrefFromUrl(\n            redirectLocation,\n            false\n          )\n          const redirectHref = hasBasePath(redirectWithBasepath)\n            ? removeBasePath(redirectWithBasepath)\n            : redirectWithBasepath\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            resolvedRedirectType\n          )\n          reject(redirectError)\n        }\n      } else {\n        // If there's no redirect, resolve the action with the result.\n        resolve(actionResult)\n      }\n\n      // Check if we can bail out without updating any state.\n      if (\n        // Did the action trigger a redirect?\n        redirectLocation === undefined &&\n        // Did the action revalidate any data?\n        revalidationKind === ActionDidNotRevalidate &&\n        // Did the server render new data?\n        flightData === undefined\n      ) {\n        // The action did not trigger any revalidations or redirects. No\n        // navigation is required.\n        return state\n      }\n\n      if (flightData === undefined && redirectLocation !== undefined) {\n        // The server redirected, but did not send any Flight data. This implies\n        // an external redirect.\n        // TODO: We should refactor the action response type to be more explicit\n        // about the various response types.\n        return handleExternalUrl(\n          state,\n          mutable,\n          redirectLocation.href,\n          pendingPush\n        )\n      }\n\n      if (typeof flightData === 'string') {\n        // If the flight data is just a string, something earlier in the\n        // response handling triggered an external redirect.\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // The action triggered a navigation  either a redirect, a revalidation,\n      // or both.\n\n      // If there was no redirect, then the target URL is the same as the\n      // current URL.\n      const currentUrl = new URL(state.canonicalUrl, location.origin)\n      const redirectUrl =\n        redirectLocation !== undefined ? redirectLocation : currentUrl\n      const currentFlightRouterState = state.tree\n      const shouldScroll = true\n\n      // If the action triggered a revalidation of the cache, we should also\n      // refresh all the dynamic data.\n      const freshnessPolicy =\n        revalidationKind === ActionDidNotRevalidate\n          ? FreshnessPolicy.Default\n          : FreshnessPolicy.RefreshAll\n\n      // The server may have sent back new data. If so, we will perform a\n      // \"seeded\" navigation that uses the data from the response.\n      if (flightData !== undefined) {\n        const normalizedFlightData = flightData[0]\n        if (\n          normalizedFlightData !== undefined &&\n          // TODO: Currently the server always renders from the root in\n          // response to a Server Action. In the case of a normal redirect\n          // with no revalidation, it should skip over the shared layouts.\n          normalizedFlightData.isRootRender &&\n          flightDataRenderedSearch !== undefined &&\n          flightDataCouldBeIntercepted !== undefined\n        ) {\n          // The server sent back new route data as part of the response. We\n          // will use this to render the new page. If this happens to be only a\n          // subset of the data needed to render the new page, we'll initiate a\n          // new fetch, like we would for a normal navigation.\n          const redirectCanonicalUrl = createHrefFromUrl(redirectUrl)\n          const navigationSeed = {\n            tree: normalizedFlightData.tree,\n            renderedSearch: flightDataRenderedSearch,\n            data: normalizedFlightData.seedData,\n            head: normalizedFlightData.head,\n          }\n          const now = Date.now()\n          const result = navigateToSeededRoute(\n            now,\n            redirectUrl,\n            redirectCanonicalUrl,\n            navigationSeed,\n            currentUrl,\n            state.cache,\n            currentFlightRouterState,\n            freshnessPolicy,\n            nextUrl,\n            shouldScroll\n          )\n          return handleNavigationResult(\n            redirectUrl,\n            state,\n            mutable,\n            pendingPush,\n            result\n          )\n        }\n      }\n\n      // The server did not send back new data. We'll perform a regular, non-\n      // seeded navigation  effectively the same as <Link> or router.push().\n      const result = navigateUsingSegmentCache(\n        redirectUrl,\n        currentUrl,\n        state.cache,\n        currentFlightRouterState,\n        nextUrl,\n        freshnessPolicy,\n        shouldScroll,\n        mutable\n      )\n      return handleNavigationResult(\n        redirectUrl,\n        state,\n        mutable,\n        pendingPush,\n        result\n      )\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n\nfunction createRedirectErrorForAction(\n  redirectHref: string,\n  resolvedRedirectType: RedirectType\n) {\n  const redirectError = getRedirectError(redirectHref, resolvedRedirectType)\n  // We mark the error as handled because we don't want the redirect to be tried later by\n  // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n  // again, as it's run within an effect.\n  // We don't actually need the RedirectBoundary to do a router.push because we already\n  // have all the necessary RSC data to render the new page within a single roundtrip.\n  ;(redirectError as any).handled = true\n  return redirectError\n}\n","import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport { PrefetchPriority, type PrefetchTaskFetchStrategy } from './types'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription  it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n","import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch({ type: ACTION_REFRESH }, setState)\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n","import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../shared/lib/app-router-types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n","import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n","import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  ReadonlyURLSearchParams,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo((): ReadonlyURLSearchParams => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null!\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams])\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  // We need the same class that was used to instantiate the context value\n  // Otherwise instanceof checks will fail in usercode\n  ReadonlyURLSearchParams,\n}\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  unstable_rethrow,\n} from './navigation.react-server'\n","'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n","import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n","/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n","'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { Params } from '../../server/request/params'\nimport {\n  createDevToolsInstrumentedPromise,\n  ReadonlyURLSearchParams,\n  type InstrumentedPromise,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\n\n/**\n * Promises are cached by tree to ensure stability across suspense retries.\n */\ntype LayoutSegmentPromisesCache = {\n  selectedLayoutSegmentPromises: Map<string, InstrumentedPromise<string | null>>\n  selectedLayoutSegmentsPromises: Map<string, InstrumentedPromise<string[]>>\n}\n\nconst layoutSegmentPromisesCache = new WeakMap<\n  FlightRouterState,\n  LayoutSegmentPromisesCache\n>()\n\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */\nfunction createLayoutSegmentPromises(\n  tree: FlightRouterState\n): LayoutSegmentPromisesCache | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Check if we already have cached promises for this tree\n  const cached = layoutSegmentPromisesCache.get(tree)\n  if (cached) {\n    return cached\n  }\n\n  // Create new promises and cache them\n  const segmentPromises = new Map<string, InstrumentedPromise<string | null>>()\n  const segmentsPromises = new Map<string, InstrumentedPromise<string[]>>()\n\n  const parallelRoutes = tree[1]\n  for (const parallelRouteKey of Object.keys(parallelRoutes)) {\n    const segments = getSelectedLayoutSegmentPath(tree, parallelRouteKey)\n\n    // Use the shared logic to compute the segment value\n    const segment = computeSelectedLayoutSegment(segments, parallelRouteKey)\n\n    segmentPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegment', segment)\n    )\n    segmentsPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegments', segments)\n    )\n  }\n\n  const result: LayoutSegmentPromisesCache = {\n    selectedLayoutSegmentPromises: segmentPromises,\n    selectedLayoutSegmentsPromises: segmentsPromises,\n  }\n\n  // Cache the result for future renders\n  layoutSegmentPromisesCache.set(tree, result)\n\n  return result\n}\n\nconst rootNavigationPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<string, NavigationPromises>\n>()\n\n/**\n * Creates instrumented navigation promises for the root app-router.\n */\nexport function createRootNavigationPromises(\n  tree: FlightRouterState,\n  pathname: string,\n  searchParams: URLSearchParams,\n  pathParams: Params\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Create stable cache keys from the values\n  const searchParamsString = searchParams.toString()\n  const pathParamsString = JSON.stringify(pathParams)\n  const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`\n\n  // Get or create the cache for this tree\n  let treeCache = rootNavigationPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<string, NavigationPromises>()\n    rootNavigationPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this combination\n  const cached = treeCache.get(cacheKey)\n  if (cached) {\n    return cached\n  }\n\n  const readonlySearchParams = new ReadonlyURLSearchParams(searchParams)\n\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n\n  const promises: NavigationPromises = {\n    pathname: createDevToolsInstrumentedPromise('usePathname', pathname),\n    searchParams: createDevToolsInstrumentedPromise(\n      'useSearchParams',\n      readonlySearchParams\n    ),\n    params: createDevToolsInstrumentedPromise('useParams', pathParams),\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(cacheKey, promises)\n\n  return promises\n}\n\nconst nestedLayoutPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<NavigationPromises | null, NavigationPromises>\n>()\n\n/**\n * Creates merged navigation promises for nested layouts.\n * Merges parent promises with layout-specific segment promises.\n */\nexport function createNestedLayoutNavigationPromises(\n  tree: FlightRouterState,\n  parentNavPromises: NavigationPromises | null\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  const parallelRoutes = tree[1]\n  const parallelRouteKeys = Object.keys(parallelRoutes)\n\n  // Only create promises if there are parallel routes at this level\n  if (parallelRouteKeys.length === 0) {\n    return null\n  }\n\n  // Get or create the cache for this tree\n  let treeCache = nestedLayoutPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<NavigationPromises | null, NavigationPromises>()\n    nestedLayoutPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this parent combination\n  const cached = treeCache.get(parentNavPromises)\n  if (cached) {\n    return cached\n  }\n\n  // Create merged promises\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n  const promises: NavigationPromises = {\n    ...parentNavPromises!,\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(parentNavPromises, promises)\n\n  return promises\n}\n","'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n","'use client'\n\nimport React from 'react'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\n\n// TODO: error on using forbidden and unauthorized in root layout\nexport function bailOnRootNotFound() {\n  throw new Error('notFound() is not allowed to use in root layout')\n}\n\nfunction NotAllowedRootHTTPFallbackError() {\n  bailOnRootNotFound()\n  return null\n}\n\nexport function DevRootHTTPAccessFallbackBoundary({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <HTTPAccessFallbackBoundary notFound={<NotAllowedRootHTTPFallbackError />}>\n      {children}\n    </HTTPAccessFallbackBoundary>\n  )\n}\n","import type { HmrMessageSentToBrowser } from '../../../server/dev/hot-reloader-types'\n\nexport const REACT_REFRESH_FULL_RELOAD =\n  '[Fast Refresh] performing full reload\\n\\n' +\n  \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n  'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n  'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n  'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n  'Fast Refresh requires at least one parent function component in your React tree.'\n\nexport const REACT_REFRESH_FULL_RELOAD_FROM_ERROR =\n  '[Fast Refresh] performing full reload because your application had an unrecoverable error'\n\nexport function reportInvalidHmrMessage(\n  message: HmrMessageSentToBrowser | MessageEvent<unknown>,\n  err: unknown\n) {\n  console.warn(\n    '[HMR] Invalid message: ' +\n      JSON.stringify(message) +\n      '\\n' +\n      ((err instanceof Error && err?.stack) || '')\n  )\n}\n","import { normalizedAssetPrefix } from '../../../shared/lib/normalized-asset-prefix'\n\nfunction getSocketProtocol(assetPrefix: string): string {\n  let protocol = window.location.protocol\n\n  try {\n    // assetPrefix is a url\n    protocol = new URL(assetPrefix).protocol\n  } catch {}\n\n  return protocol === 'http:' ? 'ws:' : 'wss:'\n}\n\nexport function getSocketUrl(assetPrefix: string | undefined): string {\n  const prefix = normalizedAssetPrefix(assetPrefix)\n  const protocol = getSocketProtocol(assetPrefix || '')\n\n  if (URL.canParse(prefix)) {\n    // since normalized asset prefix is ensured to be a URL format,\n    // we can safely replace the protocol\n    return prefix.replace(/^http/, 'ws')\n  }\n\n  const { hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? `:${port}` : ''}${prefix}`\n}\n","import { useContext, useEffect } from 'react'\nimport { GlobalLayoutRouterContext } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { getSocketUrl } from '../get-socket-url'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n  type TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport { reportInvalidHmrMessage } from '../shared'\nimport {\n  performFullReload,\n  processMessage,\n  type StaticIndicatorState,\n} from './hot-reloader-app'\nimport { logQueue } from '../../../../next-devtools/userspace/app/forward-logs'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { WEB_SOCKET_MAX_RECONNECTIONS } from '../../../../lib/constants'\n\nlet reconnections = 0\nlet reloading = false\nlet serverSessionId: number | null = null\nlet mostRecentCompilationHash: string | null = null\n\nexport function createWebSocket(\n  assetPrefix: string,\n  staticIndicatorState: StaticIndicatorState\n) {\n  if (!self.__next_r) {\n    throw new InvariantError(\n      `Expected a request ID to be defined for the document via self.__next_r.`\n    )\n  }\n\n  let webSocket: WebSocket\n  let timer: ReturnType<typeof setTimeout>\n\n  const sendMessage = (data: string) => {\n    if (webSocket && webSocket.readyState === webSocket.OPEN) {\n      webSocket.send(data)\n    }\n  }\n\n  const processTurbopackMessage = createProcessTurbopackMessage(sendMessage)\n\n  function init() {\n    if (webSocket) {\n      webSocket.close()\n    }\n\n    const newWebSocket = new window.WebSocket(\n      `${getSocketUrl(assetPrefix)}/_next/webpack-hmr?id=${self.__next_r}`\n    )\n\n    newWebSocket.binaryType = 'arraybuffer'\n\n    function handleOnline() {\n      logQueue.onSocketReady(newWebSocket)\n\n      reconnections = 0\n      window.console.log('[HMR] connected')\n    }\n\n    function handleMessage(event: MessageEvent) {\n      // While the page is reloading, don't respond to any more messages.\n      if (reloading) {\n        return\n      }\n\n      try {\n        const message: HmrMessageSentToBrowser =\n          event.data instanceof ArrayBuffer\n            ? parseBinaryMessage(event.data)\n            : JSON.parse(event.data)\n\n        // Check for server restart in Turbopack mode\n        if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED) {\n          if (\n            serverSessionId !== null &&\n            serverSessionId !== message.data.sessionId\n          ) {\n            // Either the server's session id has changed and it's a new server, or\n            // it's been too long since we disconnected and we should reload the page.\n            window.location.reload()\n            reloading = true\n            return\n          }\n          serverSessionId = message.data.sessionId\n        }\n\n        // Track webpack compilation hash for server restart detection\n        if (\n          message.type === HMR_MESSAGE_SENT_TO_BROWSER.SYNC &&\n          'hash' in message\n        ) {\n          // If we had previously reconnected and the hash changed, the server may have restarted\n          if (\n            mostRecentCompilationHash !== null &&\n            mostRecentCompilationHash !== message.hash\n          ) {\n            window.location.reload()\n            reloading = true\n            return\n          }\n          mostRecentCompilationHash = message.hash\n        }\n\n        processMessage(\n          message,\n          sendMessage,\n          processTurbopackMessage,\n          staticIndicatorState\n        )\n      } catch (err: unknown) {\n        reportInvalidHmrMessage(event, err)\n      }\n    }\n\n    function handleDisconnect() {\n      newWebSocket.onerror = null\n      newWebSocket.onclose = null\n      newWebSocket.close()\n      reconnections++\n\n      // After 25 reconnects we'll want to reload the page as it indicates the dev server is no longer running.\n      if (reconnections > WEB_SOCKET_MAX_RECONNECTIONS) {\n        reloading = true\n        window.location.reload()\n        return\n      }\n\n      clearTimeout(timer)\n      // Try again after 5 seconds\n      timer = setTimeout(init, reconnections > 5 ? 5000 : 1000)\n    }\n\n    newWebSocket.onopen = handleOnline\n    newWebSocket.onerror = handleDisconnect\n    newWebSocket.onclose = handleDisconnect\n    newWebSocket.onmessage = handleMessage\n\n    webSocket = newWebSocket\n    return newWebSocket\n  }\n\n  return init()\n}\n\nexport function createProcessTurbopackMessage(\n  sendMessage: (data: string) => void\n): (msg: TurbopackMessageSentToBrowser) => void {\n  if (!process.env.TURBOPACK) {\n    return () => {}\n  }\n\n  let queue: TurbopackMessageSentToBrowser[] = []\n  let callback: ((msg: TurbopackMessageSentToBrowser) => void) | undefined\n\n  const processTurbopackMessage = (msg: TurbopackMessageSentToBrowser) => {\n    if (callback) {\n      callback(msg)\n    } else {\n      queue.push(msg)\n    }\n  }\n\n  import(\n    // @ts-expect-error requires \"moduleResolution\": \"node16\" in tsconfig.json and not .ts extension\n    '@vercel/turbopack-ecmascript-runtime/browser/dev/hmr-client/hmr-client.ts'\n  ).then(({ connect }) => {\n    connect({\n      addMessageListener(cb: (msg: TurbopackMessageSentToBrowser) => void) {\n        callback = cb\n\n        // Replay all Turbopack messages before we were able to establish the HMR client.\n        for (const msg of queue) {\n          cb(msg)\n        }\n        queue.length = 0\n      },\n      sendMessage,\n      onUpdateError: (err: unknown) => performFullReload(err, sendMessage),\n    })\n  })\n\n  return processTurbopackMessage\n}\n\nexport function useWebSocketPing(webSocket: WebSocket | undefined) {\n  const { tree } = useContext(GlobalLayoutRouterContext)\n\n  useEffect(() => {\n    if (!webSocket) {\n      throw new InvariantError('Expected webSocket to be defined in dev mode.')\n    }\n\n    // Never send pings when using Turbopack as it's not used.\n    // Pings were originally used to keep track of active routes in on-demand-entries with webpack.\n    if (process.env.TURBOPACK) {\n      return\n    }\n\n    // Taken from on-demand-entries-client.js\n    const interval = setInterval(() => {\n      if (webSocket.readyState === webSocket.OPEN) {\n        webSocket.send(\n          JSON.stringify({\n            event: 'ping',\n            tree,\n            appDirRoute: true,\n          })\n        )\n      }\n    }, 2500)\n    return () => clearInterval(interval)\n  }, [tree, webSocket])\n}\n\nconst textDecoder = new TextDecoder()\n\nfunction parseBinaryMessage(data: ArrayBuffer): HmrMessageSentToBrowser {\n  assertByteLength(data, 1)\n  const view = new DataView(data)\n  const messageType = view.getUint8(0)\n\n  switch (messageType) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER: {\n      const serializedErrors = new Uint8Array(data, 1)\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER,\n        serializedErrors,\n      }\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      assertByteLength(data, 2)\n      const requestIdLength = view.getUint8(1)\n      assertByteLength(data, 2 + requestIdLength)\n\n      const requestId = textDecoder.decode(\n        new Uint8Array(data, 2, requestIdLength)\n      )\n\n      const chunk =\n        data.byteLength > 2 + requestIdLength\n          ? new Uint8Array(data, 2 + requestIdLength)\n          : null\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK,\n        requestId,\n        chunk,\n      }\n    }\n    default: {\n      throw new InvariantError(\n        `Invalid binary HMR message of type ${messageType}`\n      )\n    }\n  }\n}\n\nfunction assertByteLength(data: ArrayBuffer, expectedLength: number) {\n  if (data.byteLength < expectedLength) {\n    throw new InvariantError(\n      `Invalid binary HMR message: insufficient data (expected ${expectedLength} bytes, got ${data.byteLength})`\n    )\n  }\n}\n","declare global {\n  interface Window {\n    __NEXT_HMR_LATENCY_CB: ((latencyMs: number) => void) | undefined\n  }\n}\n\n/**\n * Logs information about a completed HMR to the console, the server (via a\n * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging\n * hook).\n *\n * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a\n *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by\n *   turbopack when we must report a message to the browser console (because we\n *   already logged a \"rebuilding\" message), but it's not a real HMR, so we\n *   don't want to impact our telemetry.\n */\nexport default function reportHmrLatency(\n  sendMessage: (message: string) => void,\n  updatedModules: ReadonlyArray<string | number>,\n  startMsSinceEpoch: number,\n  endMsSinceEpoch: number,\n  hasUpdate: boolean = true\n) {\n  const latencyMs = endMsSinceEpoch - startMsSinceEpoch\n  console.log(`[Fast Refresh] done in ${latencyMs}ms`)\n  if (!hasUpdate) {\n    return\n  }\n  sendMessage(\n    JSON.stringify({\n      event: 'client-hmr-latency',\n      id: window.__nextDevClientId,\n      startTime: startMsSinceEpoch,\n      endTime: endMsSinceEpoch,\n      page: window.location.pathname,\n      updatedModules,\n      // Whether the page (tab) was hidden at the time the event occurred.\n      // This can impact the accuracy of the event's timing.\n      isPageHidden: document.visibilityState === 'hidden',\n    })\n  )\n  if (self.__NEXT_HMR_LATENCY_CB) {\n    self.__NEXT_HMR_LATENCY_CB(latencyMs)\n  }\n}\n","import type { TurbopackMessage } from '../../../server/dev/hot-reloader-types'\nimport type { Update as TurbopackUpdate } from '../../../build/swc/types'\n\ndeclare global {\n  interface Window {\n    __NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS: boolean | undefined\n  }\n}\n\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100\n\ninterface HmrUpdate {\n  hasUpdates: boolean\n  updatedModules: Set<string>\n  startMsSinceEpoch: number\n  endMsSinceEpoch: number\n}\n\nexport class TurbopackHmr {\n  #updatedModules: Set<string>\n  #startMsSinceEpoch: number | undefined\n  #lastUpdateMsSinceEpoch: number | undefined\n  #deferredReportHmrStartId: ReturnType<typeof setTimeout> | undefined\n  #reportedHmrStart: boolean\n\n  constructor() {\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n  }\n\n  // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n  // as it reports *any* compilation, including fully no-op/cached compilations\n  // and those unrelated to HMR. Fixing this would require significant\n  // architectural changes.\n  //\n  // Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n  // a BUILT event within that threshold and nothing has changed, just suppress\n  // the message entirely.\n  #runDeferredReportHmrStart() {\n    if (this.#deferredReportHmrStartId != null) {\n      console.log('[Fast Refresh] rebuilding')\n      this.#reportedHmrStart = true\n      this.#cancelDeferredReportHmrStart()\n    }\n  }\n\n  #cancelDeferredReportHmrStart() {\n    clearTimeout(this.#deferredReportHmrStartId)\n    this.#deferredReportHmrStartId = undefined\n  }\n\n  onBuilding() {\n    this.#lastUpdateMsSinceEpoch = undefined\n    this.#cancelDeferredReportHmrStart()\n    this.#startMsSinceEpoch = Date.now()\n\n    // report the HMR start after a short delay\n    this.#deferredReportHmrStartId = setTimeout(\n      () => this.#runDeferredReportHmrStart(),\n      // debugging feature: don't defer/suppress noisy no-op HMR update messages\n      self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS\n        ? 0\n        : TURBOPACK_HMR_START_DELAY_MS\n    )\n  }\n\n  /** Helper for other `onEvent` methods. */\n  #onUpdate() {\n    this.#runDeferredReportHmrStart()\n    this.#lastUpdateMsSinceEpoch = Date.now()\n  }\n\n  onTurbopackMessage(msg: TurbopackMessage) {\n    this.#onUpdate()\n    const updatedModules = extractModulesFromTurbopackMessage(msg.data)\n    for (const module of updatedModules) {\n      this.#updatedModules.add(module)\n    }\n  }\n\n  onServerComponentChanges() {\n    this.#onUpdate()\n  }\n\n  onReloadPage() {\n    this.#onUpdate()\n  }\n\n  onPageAddRemove() {\n    this.#onUpdate()\n  }\n\n  /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */\n  onBuilt(): HmrUpdate | null {\n    // Check that we got *any* `TurbopackMessage`, even if\n    // `updatedModules` is empty (not everything gets recorded there).\n    //\n    // There's also a case where `onBuilt` gets called before `onBuilding`,\n    // which can happen during initial page load. Ignore that too!\n    const hasUpdates =\n      this.#lastUpdateMsSinceEpoch != null && this.#startMsSinceEpoch != null\n    if (!hasUpdates && !this.#reportedHmrStart) {\n      // suppress the update entirely\n      this.#cancelDeferredReportHmrStart()\n      return null\n    }\n    this.#runDeferredReportHmrStart()\n\n    const result = {\n      hasUpdates,\n      updatedModules: this.#updatedModules,\n      startMsSinceEpoch: this.#startMsSinceEpoch!,\n      endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now(),\n    }\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n    return result\n  }\n}\n\nfunction extractModulesFromTurbopackMessage(\n  data: TurbopackUpdate | TurbopackUpdate[]\n): Set<string> {\n  const updatedModules: Set<string> = new Set()\n\n  const updates = Array.isArray(data) ? data : [data]\n  for (const update of updates) {\n    // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n    if (\n      update.type !== 'partial' ||\n      update.instruction.type !== 'ChunkListUpdate' ||\n      update.instruction.merged === undefined\n    ) {\n      continue\n    }\n\n    for (const mergedUpdate of update.instruction.merged) {\n      for (const name of Object.keys(mergedUpdate.entries)) {\n        const res = /(.*)\\s+[([].*/.exec(name)\n        if (res === null) {\n          continue\n        }\n\n        updatedModules.add(res[1])\n      }\n    }\n  }\n\n  return updatedModules\n}\n","import { NEXT_REQUEST_ID_HEADER } from '../components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport interface DebugChannelReadableWriterPair {\n  readonly readable: ReadableStream<Uint8Array>\n  readonly writer: WritableStreamDefaultWriter<Uint8Array>\n}\n\nconst pairs = new Map<string, DebugChannelReadableWriterPair>()\n\nexport function getOrCreateDebugChannelReadableWriterPair(\n  requestId: string\n): DebugChannelReadableWriterPair {\n  let pair = pairs.get(requestId)\n\n  if (!pair) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>()\n    pair = { readable, writer: writable.getWriter() }\n    pairs.set(requestId, pair)\n    pair.writer.closed.finally(() => pairs.delete(requestId))\n  }\n\n  return pair\n}\n\nexport function createDebugChannel(\n  requestHeaders: Record<string, string> | undefined\n): {\n  writable?: WritableStream\n  readable?: ReadableStream\n} {\n  let requestId: string | undefined\n\n  if (requestHeaders) {\n    requestId = requestHeaders[NEXT_REQUEST_ID_HEADER] ?? undefined\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a ${JSON.stringify(NEXT_REQUEST_ID_HEADER)} request header.`\n      )\n    }\n  } else {\n    requestId = self.__next_r\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a request ID to be defined for the document via self.__next_r.`\n      )\n    }\n  }\n\n  const { readable } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n  return { readable }\n}\n","/// <reference types=\"webpack/module.d.ts\" />\n\nimport type { ReactNode } from 'react'\nimport { useEffect, startTransition } from 'react'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\nimport formatWebpackMessages from '../../../../shared/lib/format-webpack-messages'\nimport {\n  REACT_REFRESH_FULL_RELOAD,\n  REACT_REFRESH_FULL_RELOAD_FROM_ERROR,\n} from '../shared'\nimport {\n  dispatcher,\n  getSerializedOverlayState,\n  getSegmentTrieData,\n} from 'next/dist/compiled/next-devtools'\nimport { ReplaySsrOnlyErrors } from '../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors'\nimport { AppDevOverlayErrorBoundary } from '../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary'\nimport { useErrorHandler } from '../../../../next-devtools/userspace/app/errors/use-error-handler'\nimport { RuntimeErrorHandler } from '../../runtime-error-handler'\nimport { useWebSocketPing } from './web-socket'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  HMR_MESSAGE_SENT_TO_SERVER,\n} from '../../../../server/dev/hot-reloader-types'\nimport type {\n  HmrMessageSentToBrowser,\n  TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport type { McpErrorStateResponse } from '../../../../shared/lib/mcp-error-types'\nimport type { McpPageMetadataResponse } from '../../../../shared/lib/mcp-page-metadata-types'\nimport { useUntrackedPathname } from '../../../components/navigation-untracked'\nimport reportHmrLatency from '../../report-hmr-latency'\nimport { TurbopackHmr } from '../turbopack-hot-reloader-common'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../../components/app-router-headers'\nimport {\n  publicAppRouterInstance,\n  type GlobalErrorState,\n} from '../../../components/app-router-instance'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { getOrCreateDebugChannelReadableWriterPair } from '../../debug-channel'\n// TODO: Explicitly import from client.browser (doesn't work with Webpack).\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\n\nexport interface StaticIndicatorState {\n  pathname: string | null\n  appIsrManifest: Record<string, boolean> | null\n}\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n\nlet mostRecentCompilationHash: any = null\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now())\nlet reloading = false\nlet webpackStartMsSinceEpoch: number | null = null\nconst turbopackHmr: TurbopackHmr | null = process.env.TURBOPACK\n  ? new TurbopackHmr()\n  : null\n\nlet pendingHotUpdateWebpack = Promise.resolve()\nlet resolvePendingHotUpdateWebpack: () => void = () => {}\nfunction setPendingHotUpdateWebpack() {\n  pendingHotUpdateWebpack = new Promise((resolve) => {\n    resolvePendingHotUpdateWebpack = () => {\n      resolve()\n    }\n  })\n}\n\nexport function waitForWebpackRuntimeHotUpdate() {\n  return pendingHotUpdateWebpack\n}\n\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash: string) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash\n}\n\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */\nfunction isUpdateAvailable() {\n  if (process.env.TURBOPACK) {\n    return true\n  }\n\n  /* globals __webpack_hash__ */\n  // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_hash__\n}\n\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n  return module.hot.status() === 'idle'\n}\nfunction afterApplyUpdates(fn: any) {\n  if (canApplyUpdates()) {\n    fn()\n  } else {\n    function handler(status: any) {\n      if (status === 'idle') {\n        module.hot.removeStatusHandler(handler)\n        fn()\n      }\n    }\n    module.hot.addStatusHandler(handler)\n  }\n}\n\nexport function performFullReload(\n  err: any,\n  sendMessage: (data: string) => void\n) {\n  const stackTrace =\n    err &&\n    ((err.stack && err.stack.split('\\n').slice(0, 5).join('\\n')) ||\n      err.message ||\n      err + '')\n\n  sendMessage(\n    JSON.stringify({\n      event: 'client-full-reload',\n      stackTrace,\n      hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,\n      dependencyChain: err ? err.dependencyChain : undefined,\n    })\n  )\n\n  if (reloading) return\n  reloading = true\n  window.location.reload()\n}\n\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage: (message: string) => void) {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    resolvePendingHotUpdateWebpack()\n    dispatcher.onBuildOk()\n    reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch!, Date.now())\n    return\n  }\n\n  function handleApplyUpdates(\n    err: any,\n    updatedModules: (string | number)[] | null\n  ) {\n    if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n      if (err) {\n        console.warn(REACT_REFRESH_FULL_RELOAD)\n      } else if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n      }\n      performFullReload(err, sendMessage)\n      return\n    }\n\n    dispatcher.onBuildOk()\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdatesWebpack(sendMessage)\n      return\n    }\n\n    dispatcher.onRefresh()\n    resolvePendingHotUpdateWebpack()\n    reportHmrLatency(\n      sendMessage,\n      updatedModules,\n      webpackStartMsSinceEpoch!,\n      Date.now()\n    )\n\n    if (process.env.__NEXT_TEST_MODE) {\n      afterApplyUpdates(() => {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      })\n    }\n  }\n\n  // https://webpack.js.org/api/hot-module-replacement/#check\n  module.hot\n    .check(/* autoApply */ false)\n    .then((updatedModules: (string | number)[] | null) => {\n      if (updatedModules == null) {\n        return null\n      }\n\n      // We should always handle an update, even if updatedModules is empty (but\n      // non-null) for any reason. That's what webpack would normally do:\n      // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n      dispatcher.onBeforeRefresh()\n      // https://webpack.js.org/api/hot-module-replacement/#apply\n      return module.hot.apply()\n    })\n    .then(\n      (updatedModules: (string | number)[] | null) => {\n        handleApplyUpdates(null, updatedModules)\n      },\n      (err: any) => {\n        handleApplyUpdates(err, null)\n      }\n    )\n}\n\n/** Handles messages from the server for the App Router. */\nexport function processMessage(\n  message: HmrMessageSentToBrowser,\n  sendMessage: (message: string) => void,\n  processTurbopackMessage: (msg: TurbopackMessageSentToBrowser) => void,\n  staticIndicatorState: StaticIndicatorState\n) {\n  function handleErrors(errors: ReadonlyArray<unknown>) {\n    // \"Massage\" webpack messages.\n    const formatted = formatWebpackMessages({\n      errors: errors,\n      warnings: [],\n    })\n\n    // Only show the first error.\n    dispatcher.onBuildError(formatted.errors[0])\n\n    // Also log them to the console.\n    for (let i = 0; i < formatted.errors.length; i++) {\n      console.error(stripAnsi(formatted.errors[i]))\n    }\n\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (process.env.__NEXT_TEST_MODE) {\n      if (self.__NEXT_HMR_CB) {\n        self.__NEXT_HMR_CB(formatted.errors[0])\n        self.__NEXT_HMR_CB = null\n      }\n    }\n  }\n\n  function handleHotUpdate() {\n    if (process.env.TURBOPACK) {\n      const hmrUpdate = turbopackHmr!.onBuilt()\n      if (hmrUpdate != null) {\n        reportHmrLatency(\n          sendMessage,\n          [...hmrUpdate.updatedModules],\n          hmrUpdate.startMsSinceEpoch,\n          hmrUpdate.endMsSinceEpoch,\n          // suppress the `client-hmr-latency` event if the update was a no-op:\n          hmrUpdate.hasUpdates\n        )\n      }\n      dispatcher.onBuildOk()\n    } else {\n      tryApplyUpdatesWebpack(sendMessage)\n    }\n  }\n\n  switch (message.type) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST: {\n      if (process.env.__NEXT_DEV_INDICATOR) {\n        staticIndicatorState.appIsrManifest = message.data\n\n        // Handle the initial static indicator status on receiving the ISR\n        // manifest. Navigation is handled in an effect inside HotReload for\n        // pathname changes as we'll receive the updated manifest before\n        // usePathname triggers for a new value.\n\n        const isStatic = staticIndicatorState.pathname\n          ? message.data[staticIndicatorState.pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILDING: {\n      dispatcher.buildingIndicatorShow()\n\n      if (process.env.TURBOPACK) {\n        turbopackHmr!.onBuilding()\n      } else {\n        webpackStartMsSinceEpoch = Date.now()\n        setPendingHotUpdateWebpack()\n        console.log('[Fast Refresh] rebuilding')\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SYNC: {\n      dispatcher.buildingIndicatorHide()\n\n      if (message.hash) {\n        handleAvailableHash(message.hash)\n      }\n\n      const { errors, warnings } = message\n\n      // Is undefined when it's a 'built' event\n      if ('versionInfo' in message)\n        dispatcher.onVersionInfo(message.versionInfo)\n      if ('debug' in message && message.debug)\n        dispatcher.onDebugInfo(message.debug)\n      if ('devIndicator' in message)\n        dispatcher.onDevIndicator(message.devIndicator)\n      if ('devToolsConfig' in message)\n        dispatcher.onDevToolsConfig(message.devToolsConfig)\n\n      const hasErrors = Boolean(errors && errors.length)\n      // Compilation with errors (e.g. syntax error or missing modules).\n      if (hasErrors) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-error',\n            errorCount: errors.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        handleErrors(errors)\n        return\n      }\n\n      const hasWarnings = Boolean(warnings && warnings.length)\n      if (hasWarnings) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-warning',\n            warningCount: warnings.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        // Print warnings to the console.\n        const formattedMessages = formatWebpackMessages({\n          warnings: warnings,\n          errors: [],\n        })\n\n        for (let i = 0; i < formattedMessages.warnings.length; i++) {\n          if (i === 5) {\n            console.warn(\n              'There were more warnings in other files.\\n' +\n                'You can find a complete log in the terminal.'\n            )\n            break\n          }\n          console.warn(stripAnsi(formattedMessages.warnings[i]))\n        }\n\n        // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n      }\n\n      sendMessage(\n        JSON.stringify({\n          event: 'client-success',\n          clientId: __nextDevClientId,\n        })\n      )\n\n      if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n        handleHotUpdate()\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n        data: {\n          sessionId: message.data.sessionId,\n        },\n      })\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {\n      turbopackHmr!.onTurbopackMessage(message)\n      dispatcher.onBeforeRefresh()\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n        data: message.data,\n      })\n      if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n        performFullReload(null, sendMessage)\n      }\n      dispatcher.onRefresh()\n      break\n    }\n    // TODO-APP: make server component change more granular\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {\n      turbopackHmr?.onServerComponentChanges()\n      sendMessage(\n        JSON.stringify({\n          event: 'server-component-reload-page',\n          clientId: __nextDevClientId,\n          hash: message.hash,\n        })\n      )\n\n      // Store the latest hash in a session cookie so that it's sent back to the\n      // server with any subsequent requests.\n      document.cookie = `${NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`\n\n      if (\n        RuntimeErrorHandler.hadRuntimeError ||\n        document.documentElement.id === '__next_error__'\n      ) {\n        if (reloading) return\n        reloading = true\n        return window.location.reload()\n      }\n\n      startTransition(() => {\n        publicAppRouterInstance.hmrRefresh()\n        dispatcher.onRefresh()\n      })\n\n      if (process.env.__NEXT_TEST_MODE) {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE: {\n      turbopackHmr?.onReloadPage()\n      sendMessage(\n        JSON.stringify({\n          event: 'client-reload-page',\n          clientId: __nextDevClientId,\n        })\n      )\n      if (reloading) return\n      reloading = true\n      return window.location.reload()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n    case HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE: {\n      turbopackHmr?.onPageAddRemove()\n      // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n      return publicAppRouterInstance.hmrRefresh()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR: {\n      const { errorJSON } = message\n      if (errorJSON) {\n        const errorObject = JSON.parse(errorJSON)\n        const error = new Error(errorObject.message)\n        error.stack = errorObject.stack\n        handleErrors([error])\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG: {\n      dispatcher.onDevToolsConfig(message.data)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      const { requestId, chunk } = message\n      const { writer } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n      if (chunk) {\n        writer.ready.then(() => writer.write(chunk)).catch(console.error)\n      } else {\n        // A null chunk signals that no more chunks will be sent, which allows\n        // us to close the writer.\n        // TODO: Revisit this cleanup logic when we integrate the return channel\n        // that keeps the connection open to be able to lazily retrieve debug\n        // objects.\n        writer.ready.then(() => writer.close()).catch(console.error)\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE: {\n      const errorState = getSerializedOverlayState()\n      const response: McpErrorStateResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n        requestId: message.requestId,\n        errorState,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA: {\n      const segmentTrieData = getSegmentTrieData()\n      const response: McpPageMetadataResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n        requestId: message.requestId,\n        segmentTrieData,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR: {\n      dispatcher.onCacheIndicator(message.state)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER: {\n      createFromReadableStream<Error[]>(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue(message.serializedErrors)\n            controller.close()\n          },\n        }),\n        { findSourceMapURL }\n      ).then(\n        (errors) => {\n          for (const error of errors) {\n            console.error(error)\n          }\n        },\n        (err) => {\n          console.error(\n            new Error('Failed to deserialize errors.', { cause: err })\n          )\n        }\n      )\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n      // These action types are handled in src/client/page-bootstrap.ts\n      break\n    default: {\n      message satisfies never\n    }\n  }\n}\n\nexport default function HotReload({\n  children,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  children: ReactNode\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  useErrorHandler(dispatcher.onUnhandledError, dispatcher.onUnhandledRejection)\n  useWebSocketPing(webSocket)\n\n  // We don't want access of the pathname for the dev tools to trigger a dynamic\n  // access (as the dev overlay will never be present in production).\n  const pathname = useUntrackedPathname()\n\n  if (process.env.__NEXT_DEV_INDICATOR) {\n    // this conditional is only for dead-code elimination which\n    // isn't a runtime conditional only build-time so ignore hooks rule\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!staticIndicatorState) {\n        throw new InvariantError(\n          'Expected staticIndicatorState to be defined in dev mode.'\n        )\n      }\n\n      staticIndicatorState.pathname = pathname\n\n      if (staticIndicatorState.appIsrManifest) {\n        const isStatic = pathname\n          ? staticIndicatorState.appIsrManifest[pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n    }, [pathname, staticIndicatorState])\n  }\n\n  return (\n    <AppDevOverlayErrorBoundary globalError={globalError}>\n      <ReplaySsrOnlyErrors onBlockingError={dispatcher.openErrorOverlay} />\n      {children}\n    </AppDevOverlayErrorBoundary>\n  )\n}\n","import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\nimport { getDeploymentIdQueryOrEmptyString } from '../../shared/lib/deployment-id'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    // TODO: Use Navigation API if available\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = getDeploymentIdQueryOrEmptyString()\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n","import type { FlightDataPath } from '../../../shared/lib/app-router-types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\n\nimport type { AppRouterState } from './router-reducer-types'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\nimport { createInitialCacheNodeForHydration } from './ppr-navigations'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialRenderedSearch: string\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialRenderedSearch,\n  location,\n}: InitialRouterStateParameters): AppRouterState {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  const initialState = {\n    tree: initialTree,\n    cache: createInitialCacheNodeForHydration(\n      navigatedAt,\n      initialTree,\n      initialSeedData,\n      initialHead\n    ),\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    renderedSearch: initialRenderedSearch,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n\n  return initialState\n}\n","export function linkGc() {\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const callback = (mutationList: MutationRecord[]) => {\n      for (const mutation of mutationList) {\n        if (mutation.type === 'childList') {\n          for (const node of mutation.addedNodes) {\n            if (\n              'tagName' in node &&\n              (node as HTMLLinkElement).tagName === 'LINK'\n            ) {\n              const link = node as HTMLLinkElement\n              if (link.dataset.precedence?.startsWith('next')) {\n                const href = link.getAttribute('href')\n                if (href) {\n                  const [resource, version] = href.split('?v=', 2)\n                  if (version) {\n                    const currentOrigin = window.location.origin\n                    const allLinks = [\n                      ...document.querySelectorAll(\n                        'link[href^=\"' + resource + '\"]'\n                      ),\n                      // It's possible that the resource is a full URL or only pathname,\n                      // so we need to remove the alternative href as well.\n                      ...document.querySelectorAll(\n                        'link[href^=\"' +\n                          (resource.startsWith(currentOrigin)\n                            ? resource.slice(currentOrigin.length)\n                            : currentOrigin + resource) +\n                          '\"]'\n                      ),\n                    ] as HTMLLinkElement[]\n\n                    for (const otherLink of allLinks) {\n                      if (otherLink.dataset.precedence?.startsWith('next')) {\n                        const otherHref = otherLink.getAttribute('href')\n                        if (otherHref) {\n                          const [, otherVersion] = otherHref.split('?v=', 2)\n                          if (!otherVersion || +otherVersion < +version) {\n                            // Delay the removal of the stylesheet to avoid FOUC\n                            // caused by `@font-face` rules, as they seem to be\n                            // a couple of ticks delayed between the old and new\n                            // styles being swapped even if the font is cached.\n                            setTimeout(() => {\n                              otherLink.remove()\n                            }, 5)\n                            const preloadLink = document.querySelector(\n                              `link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`\n                            )\n                            if (preloadLink) {\n                              preloadLink.remove()\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Create an observer instance linked to the callback function\n    const observer = new MutationObserver(callback)\n    observer.observe(document.head, {\n      childList: true,\n    })\n  }\n}\n","import './app-globals'\nimport ReactDOMClient from 'react-dom/client'\nimport React from 'react'\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\nimport { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'\nimport { onRecoverableError } from './react-client-callbacks/on-recoverable-error'\nimport {\n  onCaughtError,\n  onUncaughtError,\n} from './react-client-callbacks/error-boundary-callbacks'\nimport { callServer } from './app-call-server'\nimport { findSourceMapURL } from './app-find-source-map-url'\nimport {\n  type AppRouterActionQueue,\n  createMutableActionQueue,\n} from './components/app-router-instance'\nimport AppRouter from './components/app-router'\nimport type { InitialRSCPayload } from '../shared/lib/app-router-types'\nimport { createInitialRouterState } from './components/router-reducer/create-initial-router-state'\nimport { MissingSlotContext } from '../shared/lib/app-router-context.shared-runtime'\nimport { setAppBuildId } from './app-build-id'\nimport type { StaticIndicatorState } from './dev/hot-reloader/app/hot-reloader-app'\nimport { createInitialRSCPayloadFromFallbackPrerender } from './flight-data-helpers'\n\n/// <reference types=\"react-dom/experimental\" />\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nconst appElement: HTMLElement | Document = document\n\nconst encoder = new TextEncoder()\n\nlet initialServerDataBuffer: (string | Uint8Array)[] | undefined = undefined\nlet initialServerDataWriter: ReadableStreamDefaultController | undefined =\n  undefined\nlet initialServerDataLoaded = false\nlet initialServerDataFlushed = false\n\nlet initialFormStateData: null | any = null\n\ntype FlightSegment =\n  | [isBootStrap: 0]\n  | [isNotBootstrap: 1, responsePartial: string]\n  | [isFormState: 2, formState: any]\n  | [isBinary: 3, responseBase64Partial: string]\n\ntype NextFlight = Omit<Array<FlightSegment>, 'push'> & {\n  push: (seg: FlightSegment) => void\n}\n\ndeclare global {\n  // If you're working in a browser environment\n  interface Window {\n    /**\n     * request ID, dev-only\n     */\n    __next_r?: string\n    __next_f: NextFlight\n  }\n}\n\nfunction nextServerDataCallback(seg: FlightSegment): void {\n  if (seg[0] === 0) {\n    initialServerDataBuffer = []\n  } else if (seg[0] === 1) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(encoder.encode(seg[1]))\n    } else {\n      initialServerDataBuffer.push(seg[1])\n    }\n  } else if (seg[0] === 2) {\n    initialFormStateData = seg[1]\n  } else if (seg[0] === 3) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    // Decode the base64 string back to binary data.\n    const binaryString = atob(seg[1])\n    const decodedChunk = new Uint8Array(binaryString.length)\n    for (var i = 0; i < binaryString.length; i++) {\n      decodedChunk[i] = binaryString.charCodeAt(i)\n    }\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(decodedChunk)\n    } else {\n      initialServerDataBuffer.push(decodedChunk)\n    }\n  }\n}\n\nfunction isStreamErrorOrUnfinished(ctr: ReadableStreamDefaultController) {\n  // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n  return ctr.desiredSize === null || ctr.desiredSize < 0\n}\n\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr: ReadableStreamDefaultController) {\n  if (initialServerDataBuffer) {\n    initialServerDataBuffer.forEach((val) => {\n      ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val)\n    })\n    if (initialServerDataLoaded && !initialServerDataFlushed) {\n      if (isStreamErrorOrUnfinished(ctr)) {\n        ctr.error(\n          new Error(\n            'The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'\n          )\n        )\n      } else {\n        ctr.close()\n      }\n      initialServerDataFlushed = true\n      initialServerDataBuffer = undefined\n    }\n  }\n\n  initialServerDataWriter = ctr\n}\n\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function () {\n  if (initialServerDataWriter && !initialServerDataFlushed) {\n    initialServerDataWriter.close()\n    initialServerDataFlushed = true\n    initialServerDataBuffer = undefined\n  }\n  initialServerDataLoaded = true\n}\n\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', DOMContentLoaded, false)\n} else {\n  // Delayed in marco task to ensure it's executed later than hydration\n  setTimeout(DOMContentLoaded)\n}\n\nconst nextServerDataLoadingGlobal = (self.__next_f = self.__next_f || [])\n\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback)\nnextServerDataLoadingGlobal.length = 0\n\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback\n\nconst readable = new ReadableStream({\n  start(controller) {\n    nextServerDataRegisterWriter(controller)\n  },\n})\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-expect-error\n  readable.name = 'hydration'\n}\n\nlet debugChannel:\n  | { readable?: ReadableStream; writable?: WritableStream }\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL &&\n  typeof window !== 'undefined'\n) {\n  const { createDebugChannel } =\n    require('./dev/debug-channel') as typeof import('./dev/debug-channel')\n\n  debugChannel = createDebugChannel(undefined)\n}\n\nconst clientResumeFetch: Promise<Response> | undefined =\n  // @ts-expect-error\n  window.__NEXT_CLIENT_RESUME\n\nlet initialServerResponse: Promise<InitialRSCPayload>\nif (clientResumeFetch) {\n  initialServerResponse = Promise.resolve(\n    createFromFetch<InitialRSCPayload>(clientResumeFetch, {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n    })\n  ).then(async (fallbackInitialRSCPayload) =>\n    createInitialRSCPayloadFromFallbackPrerender(\n      await clientResumeFetch,\n      fallbackInitialRSCPayload\n    )\n  )\n} else {\n  initialServerResponse = createFromReadableStream<InitialRSCPayload>(\n    readable,\n    {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n      startTime: 0,\n    }\n  )\n}\n\nfunction ServerRoot({\n  initialRSCPayload,\n  actionQueue,\n  webSocket,\n  staticIndicatorState,\n}: {\n  initialRSCPayload: InitialRSCPayload\n  actionQueue: AppRouterActionQueue\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}): React.ReactNode {\n  const router = (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorState={initialRSCPayload.G}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  if (process.env.NODE_ENV === 'development' && initialRSCPayload.m) {\n    // We provide missing slot information in a context provider only during development\n    // as we log some additional information about the missing slots in the console.\n    return (\n      <MissingSlotContext value={initialRSCPayload.m}>\n        {router}\n      </MissingSlotContext>\n    )\n  }\n\n  return router\n}\n\nconst StrictModeIfEnabled = process.env.__NEXT_STRICT_MODE_APP\n  ? React.StrictMode\n  : React.Fragment\n\nfunction Root({ children }: React.PropsWithChildren<{}>) {\n  if (process.env.__NEXT_TEST_MODE) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      window.__NEXT_HYDRATED = true\n      window.__NEXT_HYDRATED_AT = performance.now()\n      window.__NEXT_HYDRATED_CB?.()\n    }, [])\n  }\n\n  return children\n}\n\nconst enableTransitionIndicator = process.env.__NEXT_TRANSITION_INDICATOR\n\nfunction noDefaultTransitionIndicator() {\n  return () => {}\n}\n\nconst reactRootOptions: ReactDOMClient.RootOptions = {\n  onDefaultTransitionIndicator: enableTransitionIndicator\n    ? // TODO: Compose default with user-configureable (e.g. nprogress)\n      undefined\n    : noDefaultTransitionIndicator,\n  onRecoverableError,\n  onCaughtError,\n  onUncaughtError,\n}\n\nexport type ClientInstrumentationHooks = {\n  onRouterTransitionStart?: (\n    url: string,\n    navigationType: 'push' | 'replace' | 'traverse'\n  ) => void\n}\n\nexport async function hydrate(\n  instrumentationHooks: ClientInstrumentationHooks | null,\n  assetPrefix: string\n) {\n  let staticIndicatorState: StaticIndicatorState | undefined\n  let webSocket: WebSocket | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { createWebSocket } =\n      require('./dev/hot-reloader/app/web-socket') as typeof import('./dev/hot-reloader/app/web-socket')\n\n    staticIndicatorState = { pathname: null, appIsrManifest: null }\n    webSocket = createWebSocket(assetPrefix, staticIndicatorState)\n  }\n  const initialRSCPayload = await initialServerResponse\n  // setAppBuildId should be called only once, during JS initialization\n  // and before any components have hydrated.\n  setAppBuildId(initialRSCPayload.b)\n\n  const initialTimestamp = Date.now()\n  const actionQueue: AppRouterActionQueue = createMutableActionQueue(\n    createInitialRouterState({\n      navigatedAt: initialTimestamp,\n      initialFlightData: initialRSCPayload.f,\n      initialCanonicalUrlParts: initialRSCPayload.c,\n      initialRenderedSearch: initialRSCPayload.q,\n      location: window.location,\n    }),\n    instrumentationHooks\n  )\n\n  const reactEl = (\n    <StrictModeIfEnabled>\n      <HeadManagerContext.Provider value={{ appDir: true }}>\n        <Root>\n          <ServerRoot\n            initialRSCPayload={initialRSCPayload}\n            actionQueue={actionQueue}\n            webSocket={webSocket}\n            staticIndicatorState={staticIndicatorState}\n          />\n        </Root>\n      </HeadManagerContext.Provider>\n    </StrictModeIfEnabled>\n  )\n\n  if (document.documentElement.id === '__next_error__') {\n    let element = reactEl\n    // Server rendering failed, fall back to client-side rendering\n    if (process.env.NODE_ENV !== 'production') {\n      const { RootLevelDevOverlayElement } =\n        require('../next-devtools/userspace/app/client-entry') as typeof import('../next-devtools/userspace/app/client-entry')\n\n      // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n      element = (\n        <RootLevelDevOverlayElement>{element}</RootLevelDevOverlayElement>\n      )\n    }\n\n    ReactDOMClient.createRoot(appElement, reactRootOptions).render(element)\n  } else {\n    React.startTransition(() => {\n      ReactDOMClient.hydrateRoot(appElement, reactEl, {\n        ...reactRootOptions,\n        formState: initialFormStateData,\n      })\n    })\n  }\n\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const { linkGc } =\n      require('./app-link-gc') as typeof import('./app-link-gc')\n    linkGc()\n  }\n}\n","import { appBootstrap } from './app-bootstrap'\nimport { isRecoverableError } from './react-client-callbacks/on-recoverable-error'\n\nwindow.next.turbopack = true\n;(self as any).__webpack_hash__ = ''\n\n// eslint-disable-next-line @next/internal/typechecked-require\nconst instrumentationHooks = require('../lib/require-instrumentation-client')\n\nappBootstrap((assetPrefix) => {\n  const { hydrate } = require('./app-index') as typeof import('./app-index')\n  try {\n    hydrate(instrumentationHooks, assetPrefix)\n  } finally {\n    if (process.env.NODE_ENV !== 'production') {\n      const enableCacheIndicator = process.env.__NEXT_CACHE_COMPONENTS\n      const { getOwnerStack } =\n        require('../next-devtools/userspace/app/errors/stitched-error') as typeof import('../next-devtools/userspace/app/errors/stitched-error')\n      const { renderAppDevOverlay } =\n        require('next/dist/compiled/next-devtools') as typeof import('next/dist/compiled/next-devtools')\n      renderAppDevOverlay(\n        getOwnerStack,\n        isRecoverableError,\n        enableCacheIndicator\n      )\n    }\n  }\n})\n"],"names":["getAssetPrefix","currentScript","document","HTMLScriptElement","InvariantError","pathname","URL","src","nextIndex","indexOf","slice","setAttributesFromProps","DOMAttributeNames","acceptCharset","className","htmlFor","httpEquiv","noModule","ignoreProps","isBooleanScriptAttribute","attr","includes","el","props","p","value","Object","entries","hasOwnProperty","undefined","toLowerCase","tagName","setAttribute","String","removeAttribute","appBootstrap","version","process","env","__NEXT_VERSION","window","next","appDir","loadScriptsInSequence","scripts","hydrate","length","reduce","promise","src","props","then","Promise","resolve","reject","el","document","createElement","setAttributesFromProps","onload","onerror","innerHTML","children","setTimeout","head","appendChild","catch","err","console","error","assetPrefix","getAssetPrefix","self","__next_s","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","search","URLSearchParams","location","get","warn","reportGlobalError","reportError","error","globalThis","console","isRecoverableError","onRecoverableError","recoverableErrors","WeakSet","error","has","cause","isError","isBailoutToCSRError","process","env","NODE_ENV","decorateDevError","require","causeError","add","reportGlobalError","HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","error","digest","prefix","httpStatus","split","has","Number","status","RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","RedirectStatusCode","isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError","formatConsoleArgs","parseConsoleArgs","formatObject","arg","depth","Array","isArray","result","i","length","Object","prototype","hasOwnProperty","call","Error","keys","key","desc","getOwnPropertyDescriptor","get","set","jsonKey","JSON","stringify","value","String","args","message","idx","startQuote","char","code","parseInt","parseFloat","startsWith","environmentName","maybeError","trim","error","isError","process","env","NODE_ENV","require","ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ACTION_REVALIDATED_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","useUntrackedPathname","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useContext","PathnameContext","createHrefFromUrl","url","includeHash","pathname","search","hash","handleHardNavError","useNavFailureHandler","error","window","next","__pendingUrl","createHrefFromUrl","URL","location","href","console","toString","process","env","__NEXT_APP_NAV_FAIL_HANDLING","useEffect","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener","HandleISRError","workAsyncStorage","window","require","undefined","error","store","getStore","isStaticGeneration","console","ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","window","isBot","navigator","userAgent","React","Component","constructor","props","reset","setState","error","state","previousPathname","pathname","getDerivedStateFromError","isNextRouterError","getDerivedStateFromProps","process","env","__NEXT_APP_NAV_FAIL_HANDLING","handleHardNavError","render","HandleISRError","errorStyles","errorScripts","this","errorComponent","children","useUntrackedPathname","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","DefaultGlobalError","digest","html","id","head","body","HandleISRError","div","style","h2","window","location","hostname","p","RuntimeErrorHandler","hadRuntimeError","notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest","onCaughtError","onUncaughtError","devToolErrorMod","process","env","NODE_ENV","require","decorateDevError","error","handleClientError","originConsoleError","console","bind","thrownValue","errorInfo","errorBoundaryComponent","errorBoundary","constructor","isImplicitErrorBoundary","AppDevOverlayErrorBoundary","ErrorBoundaryHandler","props","errorComponent","DefaultErrorBoundary","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","Error","message","isBailoutToCSRError","isNextRouterError","errorBoundaryName","displayName","name","componentThatErroredFrame","componentStack","split","matches","match","componentThatErroredName","errorBoundaryMessage","componentErrorMessage","errorLocation","reportGlobalError","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","dispatchAppRouterAction","useActionQueue","dispatch","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","state","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","isThenable","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","then","asyncState","push","_debugInfo","set","use","callServer","actionId","actionArgs","Promise","resolve","reject","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_ACTION","findSourceMapURL","basePath","process","env","__NEXT_ROUTER_BASEPATH","pathname","NODE_ENV","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined","matchSegment","existingSegment","segment","computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","startsWith","undefined","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","split","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll","handleMutable","isNotUndefined","value","state","mutable","shouldScroll","previousNextUrl","nextUrl","patchedTree","changedPath","computeChangedPath","tree","canonicalUrl","renderedSearch","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","debugInfo","collectedDebugInfo","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","get","NEXT_REWRITTEN_QUERY_HEADER","URL","url","search","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathname","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","prefix","i","segment","ROOT_SEGMENT_REQUEST_KEY","startsWith","PAGE_SEGMENT_KEY","endsWith","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","split","result","key","value","entries","undefined","Array","isArray","push","createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","response","fallbackInitialRSCPayload","renderedPathname","getRenderedPathname","renderedSearch","getRenderedSearch","canonicalUrl","createHrefFromUrl","URL","location","href","originalFlightDataPath","f","originalFlightRouterState","b","c","split","q","i","fillInFallbackFlightRouterState","m","G","S","flightRouterState","pathnameParts","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","doesStaticSegmentAppearInURL","paramName","paramType","paramValue","parseDynamicParamFromURLPart","cacheKey","getCacheKeyForDynamicParam","childPathnamePartsIndex","children","newChildren","key","childFlightRouterState","newState","flightSegmentPath","flightData","map","isHmrRefresh","encodeURIComponent","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","Object","entries","result","shouldPreserveRefreshMarker","undefined","startsWith","PAGE_SEGMENT_KEY","Boolean","getAppBuildId","setAppBuildId","globalBuildId","buildId","setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","uniqueCacheKey","computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","rawQuery","startsWith","slice","pairs","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","doMpaNavigation","url","urlToUrlWithoutFlightMarker","URL","location","origin","toString","isPageUnloading","window","addEventListener","options","flightRouterState","nextUrl","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","NEXT_URL","originalUrl","__NEXT_CONFIG_OUTPUT","pathname","endsWith","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","responseUrl","canonicalUrl","redirected","contentType","get","interception","includes","postponed","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","staleTime","parseInt","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","getAppBuildId","b","normalizedFlightData","normalizeFlightData","f","flightData","renderedSearch","getRenderedSearch","couldBeIntercepted","prerendered","S","debugInfo","_debugInfo","err","console","error","fetchPriority","signal","__NEXT_TEST_MODE","deploymentId","getDeploymentId","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","undefined","fetchUrl","setCacheBustingSearchParam","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","searchParams","NEXT_RSC_UNION_QUERY","delete","rscResponse","href","status","requestHeaders","callServer","findSourceMapURL","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue","createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith","PAGE_SEGMENT_KEY","isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild","FreshnessPolicy","createInitialCacheNodeForHydration","isDeferredRsc","spawnDynamicRequests","startPPRNavigation","noop","navigatedAt","initialTree","seedData","seedHead","accumulation","scrollableSegments","separateRefreshUrls","task","createCacheNodeOnNavigation","undefined","node","oldUrl","oldCacheNode","oldRouterState","newRouterState","freshness","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshUrl","updateCacheNodeOnNavigation","parentSegmentPath","parentParallelRouteKey","oldSegment","newSegment","matchSegment","isNavigatingToNewRootLayout","NOT_FOUND_SEGMENT_KEY","segmentPath","concat","newRouterStateChildren","oldRouterStateChildren","seedDataChildren","prefetchDataChildren","isRootLayout","childDidFindRootLayout","oldParallelRoutes","parallelRoutes","shouldDropSiblingCaches","shouldRefreshDynamicData","newParallelRoutes","Map","isLeafSegment","Object","keys","length","newCacheNode","needsDynamicRequest","dropPrefetchRsc","reuseDynamicCacheNode","seedRsc","seedLoading","isSeedRscPartial","isSeedHeadPartial","readCacheNodeFromSeedData","prefetchRsc","prefetchLoading","isPrefetchRSCPartial","spawnNewCacheNode","href","refreshUrl","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","seedDataChild","prefetchDataChild","newSegmentChild","seedHeadChild","prefetchHeadChild","isPrefetchHeadPartialChild","DEFAULT_SEGMENT_KEY","reuseActiveSegmentInDefaultSlot","newSegmentKeyChild","createRouterCacheKey","oldCacheNodeChild","taskChild","set","newCacheNodeChild","newSegmentMapChild","taskChildRoute","route","dynamicRequestTreeChild","dynamicRequestTree","status","patchRouterStateWithNewChildren","createDynamicRequestTree","children","DYNAMIC_STALETIME_MS","oldRsc","rsc","oldRscDidResolve","push","baseRouterState","newChildren","clone","Set","add","reusedRouterState","oldRefreshMarker","createHrefFromUrl","existingCacheNode","cacheNode","head","loading","isPageSegment","createDeferredRsc","isHydration","previousNavigationDidMismatch","primaryUrl","nextUrl","freshnessPolicy","primaryRequestPromise","fetchMissingDynamicData","refreshRequestPromises","canonicalUrl","scopedDynamicRequestTree","URL","location","origin","voidPromise","finishNavigationTask","then","exitStatus","waitForRequestsToFinish","abortRemainingPendingTasks","isHardRetry","primaryRequestResult","dispatchRetryDueToTreeMismatch","url","seed","Promise","resolve","onFulfill","result","remainingCount","onReject","forEach","refreshRequestPromise","retryUrl","retryNextUrl","baseTree","retryAction","type","ACTION_SERVER_PATCH","previousTree","mpa","dispatchAppRouterAction","fetchServerResponse","flightRouterState","isHmrRefresh","convertServerPatchToFullTree","flightData","renderedSearch","didReceiveUnknownParallelRoute","writeDynamicDataIntoNavigationTask","tree","data","debugInfo","serverRouterState","dynamicData","dynamicHead","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","taskSegment","childDidReceiveUnknownParallelRoute","dynamicSegmentData","dynamicLoading","error","abortPendingCacheNode","childExitStatus","reject","DEFERRED","Symbol","value","tag","pendingRsc","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","_debugInfo","FetchStrategy","NavigationResultTag","PrefetchPriority","deleteFromLru","lruPut","updateLruSize","head","didScheduleCleanup","lruSize","maxLruSize","node","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteMapEntry","requestIdleCallback","cb","setTimeout","Fallback","createCacheMap","deleteFromCacheMap","deleteMapEntry","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","key","value","map","prev","next","size","getOrInitialize","keys","isRevalidation","entry","remainingKeys","previousKey","existingEntry","get","undefined","Map","newEntry","set","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","lruPut","staleAt","version","lazilyEvictIfNeeded","result","fallbackEntry","setMapEntryValue","updateLruSize","dropRef","oldEntry","ref","deleteFromLru","parentMap","delete","revalidatingEntry","appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","pathname","search","nextUrl","varyPath","value","parent","couldBeIntercepted","Fallback","parentPath","cacheKey","varyPathPart","requestKey","layoutVaryPath","renderedSearch","pageVaryPath","pageRequestKey","HEAD_REQUEST_KEY","fetchStrategy","tree","originalVaryPath","isPage","doesVaryOnSearchParams","FetchStrategy","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","pathname","search","cancelPrefetchTask","isPrefetchTaskDirty","pingPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","startRevalidationCooldown","scheduleMicrotask","queueMicrotask","fn","Promise","resolve","then","catch","error","setTimeout","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","key","treeAtTimeOfPrefetch","fetchStrategy","priority","onInvalidate","task","cacheVersion","getCurrentCacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","PrefetchPriority","Intent","heapResift","nextUrl","tree","currentCacheVersion","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","result","onPrefetchConnectionClosed","closed","value","now","Date","heapPeek","exitStatus","pingRoute","heapPop","background","route","readOrCreateRouteCacheEntry","pingRootRouteTree","search","url","URL","pathname","location","origin","keyWithoutSearch","createCacheKey","href","routeWithoutSearch","status","EntryStatus","Empty","Pending","fetchRouteOnCacheMiss","Fulfilled","Rejected","staleAt","blockedTasks","Set","add","FetchStrategy","PPR","isPPREnabled","LoadingBoundary","pingStaticHead","pingSharedPartOfCacheComponentsTree","spawnedEntries","Map","pingRuntimeHead","PPRRuntime","requestTree","pingRuntimePrefetches","needsDynamicRequest","size","fetchSegmentPrefetchesUsingDynamicRequest","Full","dynamicRequestTree","diffRouteTreeAgainstCurrent","pingStaticSegmentData","readOrCreateSegmentCacheEntry","metadata","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","segment","oldTreeChildren","newTreeChildren","slots","parallelRouteKey","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","undefined","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","hasRuntimePrefetch","requestKey","childTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","hasLoadingBoundary","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","convertRouteTreeToFlightRouterState","isRootLayout","refetchMarkerContext","refetchMarker","set","upgradeToPendingSegment","segmentHasLoadingBoundary","SegmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","isPartial","canNewFetchStrategyProvideMoreContent","pingFullSegmentRevalidation","has","routeKey","fetchSegmentOnCacheMiss","pingPPRSegmentRevalidation","revalidatingSegment","readOrCreateRevalidatingSegmentEntry","upsertSegmentOnCompletion","getSegmentVaryPathForRequest","pendingSegment","waitForSegmentCacheEntry","nonEmptyRevalidatingSegment","emptySegment","overwriteRevalidatingSegmentCacheEntry","noop","promise","varyPath","fulfilled","upsertSegmentEntry","currentSegment","cachedSegment","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","renderedSearch","matchSegment","compareQueuePriority","a","b","priorityDiff","phaseDiff","heap","node","index","length","push","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","parent","i","halfLength","leftIndex","left","rightIndex","right","normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","parsePath","__NEXT_TRAILING_SLASH","test","removeTrailingSlash","endsWith","addBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","required","normalizePathTrailingSlash","__NEXT_MANUAL_CLIENT_BASE_PATH","addPathPrefix","createPrefetchURL","isExternalURL","url","origin","window","location","href","isBot","navigator","userAgent","URL","addBasePath","_","Error","process","env","NODE_ENV","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","startTransition","setOptimisticLinkStatus","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","get","undefined","set","observe","coercePrefetchableUrl","href","window","createPrefetchURL","require","reportErrorFn","reportError","console","error","router","fetchStrategy","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","delete","cancelPrefetchTask","unobserve","entries","entry","intersectionRatio","target","process","env","NODE_ENV","add","rescheduleLinkPrefetch","PrefetchPriority","Default","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","FetchStrategy","Full","Intent","priority","existingPrefetchTask","getCurrentAppRouterState","appRouterState","treeAtTimeOfPrefetch","tree","nextUrl","cacheKey","createCacheKey","scheduleSegmentPrefetchTask","reschedulePrefetchTask","task","isPrefetchTaskDirty","EntryStatus","canNewFetchStrategyProvideMoreContent","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentCacheVersion","getStaleTimeMs","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","requestOptimisticRouteCacheEntry","revalidateEntireCache","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","staleTimeSeconds","Math","max","isOutputExportMode","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","createCacheMap","segmentCacheMap","invalidationListeners","currentCacheVersion","nextUrl","tree","startRevalidationCooldown","pingVisibleLinks","attachInvalidationListener","task","onInvalidate","Set","add","notifyInvalidationListener","error","reportError","console","tasks","isPrefetchTaskDirty","now","key","varyPath","getRouteVaryPath","pathname","search","isRevalidation","getFromCacheMap","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","promise","createPromiseWithResolvers","existingEntry","canonicalUrl","status","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","renderedSearch","ref","size","staleAt","Infinity","version","setInCacheMap","requestedUrl","requestedSearch","urlWithoutSearchParams","URL","routeWithNoSearchParams","createPrefetchRequestKey","href","canonicalUrlForRouteWithNoSearchParams","origin","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","location","optimisticCanonicalUrl","createHrefFromUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","slots","parallelRouteKey","childTree","isPage","requestKey","segment","clonePageVaryPathWithNewSearchParams","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","fetchStrategy","route","varyPathForRequest","getSegmentVaryPathForRequest","candidateEntry","isValueExpired","isPartial","rejectedEntry","loading","rsc","deleteFromCacheMap","emptyEntry","FetchStrategy","PPR","Full","pingBlockedTasks","entry","pingPrefetchTask","fulfillRouteCacheEntry","metadataVaryPath","HEAD_REQUEST_KEY","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","resolve","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","acc","pathnameParts","split","filter","p","index","rootSegment","ROOT_SEGMENT_REQUEST_KEY","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","finalizeLayoutVaryPath","childPrefetch","childParamName","name","childParamType","paramType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","parseDynamicParamFromURLPart","childParamKey","getCacheKeyForDynamicParam","appendLayoutVaryPath","doesStaticSegmentAppearInURL","childPathnamePartsIndex","childRequestKeyPart","createSegmentRequestKeyPart","childRequestKey","appendSegmentRequestKeyPart","endsWith","PAGE_SEGMENT_KEY","finalizePageVaryPath","finalizeMetadataVaryPath","SegmentHasLoadingBoundary","convertRootFlightRouterStateToRouteTree","flightRouterState","convertFlightRouterStateToRouteTree","parentPartialVaryPath","originalSegment","Array","isArray","paramCacheKey","parallelRoutes","childRouterState","undefined","routeTree","segmentPath","headers","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","url","response","urlAfterRedirects","headResponse","fetch","method","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","get","includes","closed","routeIsPPREnabled","NEXT_DID_POSTPONE_HEADER","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","setSizeInCacheMap","serverData","createFromNextReadableStream","buildId","getAppBuildId","getRenderedPathname","getRenderedSearch","staleTimeMs","staleTime","b","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","getFulfilledRouteVaryPath","value","routeKey","normalizedRequestKey","requestUrl","dynamicRequestTree","spawnedEntries","has","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","length","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","normalizeFlightData","f","flightData","isRootRender","parseInt","NEXT_ROUTER_STALE_TIME_HEADER","isNaN","STATIC_STALETIME_MS","entries","values","push","flightDatas","seedData","i","writeSeedDataIntoCache","head","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","seedDataChildren","childSeedData","ownedEntry","possiblyNewEntry","newEntry","fetchPriority","shouldImmediatelyDecode","createFetch","contentType","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","slice","staticExportFilename","convertSegmentPathToStaticExportFilename","currentStrategy","newStrategy","convertServerPatchToFullTree","navigate","navigateToSeededRoute","url","currentUrl","currentCacheNode","currentFlightRouterState","nextUrl","freshnessPolicy","shouldScroll","accumulation","now","Date","href","isSamePageNavigation","cacheKey","createCacheKey","route","readRouteCacheEntry","status","EntryStatus","Fulfilled","snapshot","readRenderSnapshotFromCache","tree","prefetchFlightRouterState","flightRouterState","prefetchSeedData","seedData","headSnapshot","readHeadSnapshotFromCache","prefetchHead","rsc","isPrefetchHeadPartial","isPartial","newCanonicalUrl","canonicalUrl","hash","renderedSearch","navigateUsingPrefetchedRouteTree","Rejected","optimisticRoute","requestOptimisticRouteCacheEntry","newRenderedSearch","collectedDebugInfo","undefined","tag","NavigationResultTag","Async","data","navigateDynamicallyWithNoPrefetch","navigationSeed","scrollableSegments","separateRefreshUrls","task","startPPRNavigation","head","spawnDynamicRequests","navigationTaskToResult","MPA","seedHead","Success","cacheNode","node","childRouterStates","childSeedDatas","slots","parallelRouteKey","childTree","childResult","loading","segmentEntry","readSegmentCacheEntry","varyPath","Pending","promiseForFulfilledEntry","waitForSegmentCacheEntry","then","entry","Empty","segment","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","hasRuntimePrefetch","isRootLayout","metadata","DynamicRequestTreeForEntireRoute","dynamicRequestTree","FreshnessPolicy","Default","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","fetchServerResponse","result","newUrl","flightData","debugInfo","debugInfoFromResponse","push","createHrefFromUrl","currentTree","baseTree","baseData","segmentPath","treePatch","dataPatch","headPatch","convertServerPatchToFullTreeImpl","baseRouterState","index","length","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newTreeChildren","newSeedDataChildren","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","isEmptySeedDataPartial","DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","generateSegmentsFromPatch","handleExternalUrl","handleNavigationResult","navigateReducer","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","getStaleTimeMs","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","handleMutable","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","result","tag","NavigationResultTag","MPA","newUrl","data","Success","cache","cacheNode","patchedTree","flightRouterState","renderedSearch","shouldScroll","hashFragment","hash","oldUrl","URL","onlyHashChange","pathname","search","Async","then","asyncResult","action","isExternalUrl","navigateType","href","createHrefFromUrl","preserveCustomHistoryState","toString","document","getElementById","currentUrl","location","origin","navigateUsingSegmentCache","tree","nextUrl","FreshnessPolicy","Default","hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","isInterceptionRouteAppPath","key","refreshDynamicData","refreshReducer","state","currentNextUrl","nextUrl","currentRouterState","tree","revalidateEntireCache","FreshnessPolicy","RefreshAll","freshnessPolicy","nextUrlForRefresh","hasInterceptionRouteInCurrentTree","previousNextUrl","currentCanonicalUrl","canonicalUrl","currentUrl","URL","location","origin","currentFlightRouterState","shouldScroll","navigationSeed","renderedSearch","data","head","now","Date","result","navigateToSeededRoute","cache","mutable","preserveCustomHistoryState","handleNavigationResult","serverPatchReducer","state","action","mutable","preserveCustomHistoryState","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","handleExternalUrl","href","currentUrl","canonicalUrl","previousTree","tree","refreshReducer","retryCanonicalUrl","createHrefFromUrl","retryNextUrl","nextUrl","pendingPush","shouldScroll","now","Date","result","navigateToSeededRoute","cache","FreshnessPolicy","RefreshAll","handleNavigationResult","restoreReducer","state","action","treeToRestore","renderedSearch","historyState","tree","currentUrl","URL","canonicalUrl","location","origin","restoredUrl","url","restoredCanonicalUrl","createHrefFromUrl","restoredNextUrl","extractPathFromFlightRouterState","pathname","now","Date","accumulation","scrollableSegments","separateRefreshUrls","task","startPPRNavigation","cache","FreshnessPolicy","HistoryTraversal","mutable","preserveCustomHistoryState","handleExternalUrl","spawnDynamicRequests","pushRef","pendingPush","mpaNavigation","focusAndScrollRef","node","nextUrl","previousNextUrl","debugInfo","hmrRefreshReducer","state","refreshDynamicData","FreshnessPolicy","HMRRefresh","UnrecognizedActionError","unstable_isUnrecognizedActionError","Error","constructor","args","name","error","assignLocation","location","url","startsWith","urlBase","origin","pathname","URL","endsWith","addBasePath","href","getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","getStore","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","split","slice","join","Number","at","hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","pathHasPrefix","removeBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","__NEXT_MANUAL_CLIENT_BASE_PATH","hasBasePath","length","slice","startsWith","serverActionReducer","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","info","extractInfoFromServerReferenceId","usedArgs","type","omitUnusedArgs","body","encodeReply","headers","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","tree","deploymentId","getDeploymentId","NEXT_URL","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","location","_redirectType","split","redirectType","RedirectType","push","replace","undefined","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidationKind","ActionDidNotRevalidate","revalidationHeader","parsedKind","JSON","parse","ActionDidRevalidateStaticAndDynamic","ActionDidRevalidateDynamicOnly","redirectLocation","assignLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","actionFlightDataRenderedSearch","actionFlightDataCouldBeIntercepted","response","Promise","resolve","callServer","findSourceMapURL","debugChannel","a","maybeFlightData","normalizeFlightData","f","q","i","action","reject","mutable","preserveCustomHistoryState","previousNextUrl","hasInterceptionRouteInCurrentTree","then","flightData","flightDataRenderedSearch","flightDataCouldBeIntercepted","didRevalidate","revalidateEntireCache","pendingPush","pushRef","resolvedRedirectType","isExternalURL","redirectHref","redirectError","createRedirectErrorForAction","handleExternalUrl","redirectWithBasepath","createHrefFromUrl","hasBasePath","removeBasePath","currentUrl","origin","redirectUrl","currentFlightRouterState","shouldScroll","freshnessPolicy","FreshnessPolicy","Default","RefreshAll","normalizedFlightData","isRootRender","redirectCanonicalUrl","navigationSeed","renderedSearch","data","seedData","head","now","Date","result","navigateToSeededRoute","cache","handleNavigationResult","navigateUsingSegmentCache","e","getRedirectError","handled","reducer","clientReducer","state","action","type","ACTION_NAVIGATE","navigateReducer","ACTION_SERVER_PATCH","serverPatchReducer","ACTION_RESTORE","restoreReducer","ACTION_REFRESH","refreshReducer","ACTION_HMR_REFRESH","hmrRefreshReducer","ACTION_SERVER_ACTION","serverActionReducer","Error","serverReducer","_action","window","prefetch","href","nextUrl","treeAtTimeOfPrefetch","fetchStrategy","onInvalidate","url","createPrefetchURL","cacheKey","createCacheKey","schedulePrefetchTask","PrefetchPriority","Default","createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","prevState","state","payload","actionResult","handleResult","nextState","discarded","ACTION_SERVER_ACTION","didRevalidate","resolve","isThenable","then","err","reject","dispatchAction","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","globalActionQueue","initialState","instrumentationHooks","result","reducer","onRouterTransitionStart","window","Error","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","location","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","historyState","back","history","forward","prefetch","options","prefetchKind","kind","PrefetchKind","AUTO","fetchStrategy","FetchStrategy","PPR","FULL","Full","prefetchWithSegmentCache","nextUrl","tree","onInvalidate","replace","scroll","push","refresh","hmrRefresh","NODE_ENV","ACTION_HMR_REFRESH","router","AppRouterAnnouncer","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","tree","portalNode","setPortalNode","useState","useEffect","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","undefined","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal","forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest","unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest","unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","Error","cause","DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err","StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error","unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","isPrerenderInterruptedError","Error","cause","unstable_rethrow","window","require","ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","Error","ReadonlyURLSearchParams","RedirectType","ServerInsertedHTMLContext","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","useDynamicRouteParams","window","require","undefined","useDynamicSearchParams","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","process","env","NODE_ENV","React","navigationPromises","use","NavigationPromisesContext","pathname","PathnameContext","router","AppRouterContext","Error","params","PathParamsContext","parallelRouteKey","context","LayoutRouterContext","promise","selectedLayoutSegmentsPromises","get","getSelectedLayoutSegmentPath","parentTree","selectedLayoutSegments","selectedLayoutSegmentPromises","computeSelectedLayoutSegment","RedirectBoundary","RedirectErrorBoundary","HandleRedirect","redirect","reset","redirectType","router","useRouter","useEffect","React","startTransition","RedirectType","push","replace","Component","constructor","props","state","getDerivedStateFromError","error","isRedirectError","url","getURLFromRedirectError","getRedirectTypeFromError","render","setState","children","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","cacheNode","item","unresolvedThenable","then","GracefulDegradeBoundary","getDomNodeAttributes","node","result","i","attributes","length","attr","name","value","Component","constructor","props","state","hasError","rootHtml","htmlAttributes","htmlRef","createRef","getDerivedStateFromError","_","componentDidMount","htmlNode","current","Object","entries","forEach","key","setAttribute","render","window","document","documentElement","innerHTML","html","ref","suppressHydrationWarning","dangerouslySetInnerHTML","__html","children","RootErrorBoundary","isBotUserAgent","window","isBot","navigator","userAgent","children","errorComponent","errorStyles","errorScripts","GracefulDegradeBoundary","ErrorBoundary","createNestedLayoutNavigationPromises","createRootNavigationPromises","layoutSegmentPromisesCache","WeakMap","createLayoutSegmentPromises","tree","process","env","NODE_ENV","cached","get","segmentPromises","Map","segmentsPromises","parallelRoutes","parallelRouteKey","Object","keys","segments","getSelectedLayoutSegmentPath","segment","computeSelectedLayoutSegment","set","createDevToolsInstrumentedPromise","result","selectedLayoutSegmentPromises","selectedLayoutSegmentsPromises","rootNavigationPromisesCache","pathname","searchParams","pathParams","searchParamsString","toString","pathParamsString","JSON","stringify","cacheKey","treeCache","readonlySearchParams","ReadonlyURLSearchParams","layoutSegmentPromises","promises","params","nestedLayoutPromisesCache","parentNavPromises","parallelRouteKeys","length","HTTPAccessFallbackBoundary","HTTPAccessFallbackErrorBoundary","React","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","process","env","NODE_ENV","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","warnOnce","getDerivedStateFromError","error","isHTTPAccessFallbackError","httpStatus","getAccessFallbackHTTPStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getAccessFallbackErrorTypeByStatus","useUntrackedPathname","useContext","MissingSlotContext","hasErrorFallback","DevRootHTTPAccessFallbackBoundary","bailOnRootNotFound","Error","NotAllowedRootHTTPFallbackError","children","HTTPAccessFallbackBoundary","notFound","REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","reportInvalidHmrMessage","message","err","console","warn","JSON","stringify","Error","stack","getSocketUrl","getSocketProtocol","assetPrefix","protocol","window","location","URL","prefix","normalizedAssetPrefix","canParse","replace","hostname","port","createProcessTurbopackMessage","createWebSocket","useWebSocketPing","reconnections","reloading","serverSessionId","mostRecentCompilationHash","assetPrefix","staticIndicatorState","self","__next_r","InvariantError","webSocket","timer","sendMessage","data","readyState","OPEN","send","processTurbopackMessage","init","close","newWebSocket","window","WebSocket","getSocketUrl","binaryType","handleOnline","logQueue","onSocketReady","console","log","handleMessage","event","message","ArrayBuffer","parseBinaryMessage","JSON","parse","type","HMR_MESSAGE_SENT_TO_BROWSER","TURBOPACK_CONNECTED","sessionId","location","reload","SYNC","hash","processMessage","err","reportInvalidHmrMessage","handleDisconnect","onerror","onclose","WEB_SOCKET_MAX_RECONNECTIONS","clearTimeout","setTimeout","onopen","onmessage","process","env","TURBOPACK","queue","callback","msg","push","then","connect","addMessageListener","cb","length","onUpdateError","performFullReload","tree","useContext","GlobalLayoutRouterContext","useEffect","interval","setInterval","stringify","appDirRoute","clearInterval","textDecoder","TextDecoder","assertByteLength","view","DataView","messageType","getUint8","ERRORS_TO_SHOW_IN_BROWSER","serializedErrors","Uint8Array","REACT_DEBUG_CHUNK","requestIdLength","requestId","decode","chunk","byteLength","expectedLength","reportHmrLatency","sendMessage","updatedModules","startMsSinceEpoch","endMsSinceEpoch","hasUpdate","latencyMs","console","log","JSON","stringify","event","id","window","__nextDevClientId","startTime","endTime","page","location","pathname","isPageHidden","document","visibilityState","self","__NEXT_HMR_LATENCY_CB","TurbopackHmr","TURBOPACK_HMR_START_DELAY_MS","constructor","Set","console","log","clearTimeout","undefined","onBuilding","Date","now","setTimeout","self","__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS","onTurbopackMessage","msg","updatedModules","extractModulesFromTurbopackMessage","data","module","add","onServerComponentChanges","onReloadPage","onPageAddRemove","onBuilt","hasUpdates","result","startMsSinceEpoch","endMsSinceEpoch","updates","Array","isArray","update","type","instruction","merged","mergedUpdate","name","Object","keys","entries","res","exec","createDebugChannel","getOrCreateDebugChannelReadableWriterPair","pairs","Map","requestId","pair","get","readable","writable","TransformStream","writer","getWriter","set","closed","finally","delete","requestHeaders","NEXT_REQUEST_ID_HEADER","undefined","InvariantError","JSON","stringify","self","__next_r","HotReload","performFullReload","processMessage","waitForWebpackRuntimeHotUpdate","createFromReadableStream","createFromReadableStreamBrowser","mostRecentCompilationHash","__nextDevClientId","Math","round","random","Date","now","reloading","webpackStartMsSinceEpoch","turbopackHmr","process","env","TURBOPACK","TurbopackHmr","pendingHotUpdateWebpack","Promise","resolve","resolvePendingHotUpdateWebpack","setPendingHotUpdateWebpack","handleAvailableHash","hash","isUpdateAvailable","__webpack_hash__","canApplyUpdates","module","hot","status","afterApplyUpdates","fn","handler","removeStatusHandler","addStatusHandler","err","sendMessage","stackTrace","stack","split","slice","join","message","JSON","stringify","event","hadRuntimeError","RuntimeErrorHandler","dependencyChain","undefined","window","location","reload","tryApplyUpdatesWebpack","dispatcher","onBuildOk","reportHmrLatency","handleApplyUpdates","updatedModules","console","warn","REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","onRefresh","__NEXT_TEST_MODE","self","__NEXT_HMR_CB","check","then","onBeforeRefresh","apply","processTurbopackMessage","staticIndicatorState","handleErrors","errors","formatted","formatWebpackMessages","warnings","onBuildError","i","length","error","stripAnsi","handleHotUpdate","hmrUpdate","onBuilt","startMsSinceEpoch","endMsSinceEpoch","hasUpdates","type","HMR_MESSAGE_SENT_TO_BROWSER","ISR_MANIFEST","__NEXT_DEV_INDICATOR","appIsrManifest","data","isStatic","pathname","onStaticIndicator","BUILDING","buildingIndicatorShow","onBuilding","log","BUILT","SYNC","buildingIndicatorHide","onVersionInfo","versionInfo","debug","onDebugInfo","onDevIndicator","devIndicator","onDevToolsConfig","devToolsConfig","hasErrors","Boolean","errorCount","clientId","hasWarnings","warningCount","formattedMessages","TURBOPACK_CONNECTED","sessionId","TURBOPACK_MESSAGE","onTurbopackMessage","SERVER_COMPONENT_CHANGES","onServerComponentChanges","document","cookie","NEXT_HMR_REFRESH_HASH_COOKIE","documentElement","id","startTransition","publicAppRouterInstance","hmrRefresh","RELOAD_PAGE","onReloadPage","ADDED_PAGE","REMOVED_PAGE","onPageAddRemove","SERVER_ERROR","errorJSON","errorObject","parse","Error","DEV_PAGES_MANIFEST_UPDATE","DEVTOOLS_CONFIG","REACT_DEBUG_CHUNK","requestId","chunk","writer","getOrCreateDebugChannelReadableWriterPair","ready","write","catch","close","REQUEST_CURRENT_ERROR_STATE","errorState","getSerializedOverlayState","response","HMR_MESSAGE_SENT_TO_SERVER","MCP_ERROR_STATE_RESPONSE","url","href","REQUEST_PAGE_METADATA","segmentTrieData","getSegmentTrieData","MCP_PAGE_METADATA_RESPONSE","CACHE_INDICATOR","onCacheIndicator","state","ERRORS_TO_SHOW_IN_BROWSER","ReadableStream","start","controller","enqueue","serializedErrors","findSourceMapURL","cause","MIDDLEWARE_CHANGES","CLIENT_CHANGES","SERVER_ONLY_CHANGES","children","globalError","webSocket","useErrorHandler","onUnhandledError","onUnhandledRejection","useWebSocketPing","useUntrackedPathname","useEffect","InvariantError","AppDevOverlayErrorBoundary","ReplaySsrOnlyErrors","onBlockingError","openErrorOverlay","AppRouter","globalMutable","HistoryUpdater","appRouterState","useInsertionEffect","process","env","__NEXT_APP_NAV_FAIL_HANDLING","window","next","__pendingUrl","undefined","tree","pushRef","canonicalUrl","renderedSearch","appHistoryState","historyState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","createHrefFromUrl","URL","location","href","pushState","replaceState","useEffect","pingVisibleLinks","nextUrl","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","head","prefetchHead","resolvedPrefetchRsc","useDeferredValue","Router","actionQueue","globalError","webSocket","staticIndicatorState","useActionQueue","searchParams","pathname","useMemo","url","hasBasePath","removeBasePath","NODE_ENV","cache","nd","router","publicAppRouterInstance","handlePageShow","event","persisted","pendingMpaPath","dispatchAppRouterAction","type","ACTION_RESTORE","addEventListener","removeEventListener","handleUnhandledRedirect","error","reason","isRedirectError","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","RedirectType","push","replace","mpaNavigation","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","startTransition","_unused","_N","onPopState","reload","dispatchTraverseAction","focusAndScrollRef","previousNextUrl","matchingHead","findHeadInCache","pathParams","getSelectedParams","instrumentedNavigationPromises","createRootNavigationPromises","require","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","RedirectBoundary","RootLayoutBoundary","rsc","AppRouterAnnouncer","DevRootHTTPAccessFallbackBoundary","HotReloader","default","RootErrorBoundary","errorComponent","errorStyles","RuntimeStyles","NavigationPromisesContext","Provider","value","PathParamsContext","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","Set","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","size","add","forEach","cb","Promise","resolve","forceUpdate","React","useState","renderedStylesSize","changed","c","delete","dplId","getDeploymentIdQueryOrEmptyString","map","i","link","rel","precedence","createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","location","initialCanonicalUrl","join","normalizedFlightData","getFlightDataPartsFromPath","tree","initialTree","seedData","initialSeedData","head","initialHead","canonicalUrl","createHrefFromUrl","initialState","cache","createInitialCacheNodeForHydration","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","renderedSearch","nextUrl","extractPathFromFlightRouterState","pathname","previousNextUrl","debugInfo","linkGc","process","env","NODE_ENV","callback","mutationList","mutation","type","node","addedNodes","tagName","link","dataset","precedence","startsWith","href","getAttribute","resource","version","split","currentOrigin","window","location","origin","allLinks","document","querySelectorAll","slice","length","otherLink","otherHref","otherVersion","setTimeout","remove","preloadLink","querySelector","observer","MutationObserver","observe","head","childList","hydrate","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","appElement","document","encoder","TextEncoder","initialServerDataBuffer","undefined","initialServerDataWriter","initialServerDataLoaded","initialServerDataFlushed","initialFormStateData","nextServerDataCallback","seg","Error","enqueue","encode","push","binaryString","atob","decodedChunk","Uint8Array","length","i","charCodeAt","isStreamErrorOrUnfinished","ctr","desiredSize","nextServerDataRegisterWriter","forEach","val","error","close","DOMContentLoaded","readyState","addEventListener","setTimeout","nextServerDataLoadingGlobal","self","__next_f","readable","ReadableStream","start","controller","process","env","NODE_ENV","name","debugChannel","__NEXT_REACT_DEBUG_CHANNEL","window","createDebugChannel","require","clientResumeFetch","__NEXT_CLIENT_RESUME","initialServerResponse","Promise","resolve","callServer","findSourceMapURL","then","fallbackInitialRSCPayload","createInitialRSCPayloadFromFallbackPrerender","startTime","ServerRoot","initialRSCPayload","actionQueue","webSocket","staticIndicatorState","router","AppRouter","globalErrorState","G","m","MissingSlotContext","value","StrictModeIfEnabled","__NEXT_STRICT_MODE_APP","React","StrictMode","Fragment","Root","children","__NEXT_TEST_MODE","useEffect","__NEXT_HYDRATED","__NEXT_HYDRATED_AT","performance","now","__NEXT_HYDRATED_CB","enableTransitionIndicator","__NEXT_TRANSITION_INDICATOR","noDefaultTransitionIndicator","reactRootOptions","onDefaultTransitionIndicator","onRecoverableError","onCaughtError","onUncaughtError","instrumentationHooks","assetPrefix","createWebSocket","pathname","appIsrManifest","setAppBuildId","b","initialTimestamp","Date","createMutableActionQueue","createInitialRouterState","navigatedAt","initialFlightData","f","initialCanonicalUrlParts","c","initialRenderedSearch","q","location","reactEl","HeadManagerContext","Provider","appDir","documentElement","id","element","RootLevelDevOverlayElement","ReactDOMClient","createRoot","render","startTransition","hydrateRoot","formState","linkGc","window","next","turbopack","self","__webpack_hash__","instrumentationHooks","require","appBootstrap","assetPrefix","hydrate","process","env","NODE_ENV","enableCacheIndicator","__NEXT_CACHE_COMPONENTS","getOwnerStack","renderAppDevOverlay","isRecoverableError"],"decodedMappings":[[],[],[],[],[],[],[],[[31,0,2,16,0],[49,0,2,16,0]],[],[],[[15,0,2,16,0]],[],[],[[32,0,0,31]],[[0,0,2,7],[9,0,2,16,0]],[[4,0,3,2],[10,0,3,8,1],[26,0,3,24,2],[35,0,3,33,1],[48,0,3,46]],[[4,0,5,2],[8,0,5,6],[9,0,5,8,1],[10,0,5,8,1],[35,0,5,33,3],[52,0,5,49],[55,0,5,53]],[[8,0,6,4],[14,0,6,10],[21,0,6,10],[35,0,8,5],[36,0,6,10],[40,0,6,14,4],[56,0,6,14,4],[70,0,6,28],[71,0,7,6],[72,0,7,7],[139,0,7,74],[141,0,7,76,1],[155,0,7,90],[164,0,7,99],[165,0,7,100],[168,0,6,10],[189,0,6,10]],[[19,0,6,10]],[[24,0,6,10]],[[26,0,6,10]],[[8,0,8,4]],[[4,0,9,2]],[[4,0,11,2],[10,0,11,8],[12,0,11,10,5],[20,0,11,18],[22,0,11,20],[25,0,11,23],[29,0,11,27,6],[33,0,11,31,1],[47,0,11,45,7],[50,0,11,48]],[[4,0,12,2],[10,0,12,8,8],[22,0,12,20,5],[31,0,12,29,9],[38,0,12,36],[39,0,12,37]],[[4,0,14,2],[8,0,14,6,8],[22,0,14,20],[23,0,14,21],[26,0,14,24]],[[8,0,15,4],[14,0,15,10],[21,0,15,10],[35,0,17,5],[36,0,15,10],[40,0,15,14,4],[56,0,15,14,4],[70,0,15,28],[71,0,16,6],[72,0,16,7],[139,0,16,74],[141,0,16,76,1],[155,0,16,90,7],[158,0,16,93],[159,0,16,94],[168,0,16,103],[169,0,16,104],[172,0,15,10],[193,0,15,10]],[[19,0,15,10]],[[24,0,15,10]],[[26,0,15,10]],[[8,0,17,4]],[[4,0,18,2]],[[4,0,20,2],[11,0,20,9,5],[20,0,20,18,10],[25,0,20,23],[26,0,20,24],[29,0,20,27,8]],[[0,0,21,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,1,24,16,11],[57,1,24,16,11]],[],[],[[15,1,24,16,11]],[],[],[[0,1,0,0],[6,1,0,6,12],[26,1,0,50]],[[4,1,1,2,13],[19,1,1,17]],[[4,1,2,2,14],[15,1,2,13]],[[4,1,3,2,15],[13,1,3,11]],[[4,1,4,2,16],[15,1,4,13]],[[4,1,5,2,17],[14,1,5,12]],[[0,1,6,0]],[[0,1,8,0],[6,1,8,6,18],[20,1,8,20]],[[4,1,9,2]],[[4,1,10,2]],[[4,1,11,2]],[[4,1,12,2]],[[4,1,13,2]],[[4,1,14,2]],[[4,1,15,2]],[[1,1,16,1]],[[0,1,18,0],[9,1,18,9,19],[34,1,19,2,20],[38,1,19,14]],[[4,1,21,2],[11,1,21,9]],[[8,1,21,10]],[[8,1,21,19]],[[8,1,21,28]],[[5,1,21,39],[6,1,21,40,21],[14,1,21,48],[15,1,21,49,20]],[[0,1,22,0]],[[0,1,24,7],[9,1,24,16,11],[32,1,24,39,22],[34,1,24,54],[36,1,24,56,23],[41,1,24,69]],[[4,1,25,2],[9,1,25,7],[15,1,25,13],[16,1,25,14,24],[19,1,25,17,25],[25,1,25,23],[29,1,25,27,26],[36,1,25,34,27],[43,1,25,41],[44,1,25,42,23],[51,1,25,50]],[[8,1,26,4],[12,1,26,8],[13,1,26,9,23],[19,1,26,15,28],[33,1,26,29],[34,1,26,30,24],[38,1,26,34]],[[8,1,27,4],[12,1,27,8,18],[24,1,27,20,21],[32,1,27,28],[33,1,27,29,24],[37,1,27,33]],[[8,1,29,4],[53,1,29,49]],[[8,1,30,4],[12,1,30,8,25],[22,1,30,18,29],[33,1,30,29]],[[12,1,31,6]],[[8,1,32,4]],[[8,1,34,4],[14,1,34,10,20],[21,1,34,17,12],[38,1,34,34],[39,1,34,35,24],[41,1,34,37],[45,1,34,41,24],[47,1,34,43,30],[58,1,34,54]],[[8,1,36,4],[12,1,36,8,22],[15,1,36,11,31],[22,1,36,18],[27,1,36,23],[39,1,36,35,19],[64,1,36,60,20],[71,1,36,67]],[[12,1,37,6],[57,1,37,51]],[[12,1,38,6],[59,1,38,53]],[],[[12,1,39,8,22],[14,1,39,32],[15,1,39,33,20],[20,1,39,38],[23,1,39,41],[24,1,39,42],[25,1,39,43,25]],[[8,1,40,4],[15,1,40,11]],[[12,1,41,6,22],[15,1,41,9,32],[27,1,41,21],[28,1,41,22,20],[34,1,41,28,33],[41,1,41,35,25]],[[8,1,42,4]],[[8,1,44,4],[85,1,44,81]],[[8,1,45,4],[115,1,45,111]],[[8,1,46,4],[12,1,47,6,25],[22,1,47,16],[31,1,48,7,22],[34,1,48,10,31],[41,1,48,17],[46,1,48,22],[58,1,49,8,19],[83,1,49,33,20],[92,1,50,9],[93,1,50,9],[94,1,50,10,25],[103,1,50,19,25],[113,1,50,29],[120,1,50,35],[123,1,51,6]],[[12,1,52,6],[107,1,52,101]],[[12,1,53,6],[87,1,53,81]],[[12,1,54,6,22],[15,1,54,9,32],[27,1,54,21],[28,1,54,22,20],[34,1,54,28]],[[12,1,55,6,22],[15,1,55,9,34],[30,1,55,24],[31,1,55,25,20]],[[8,1,56,4]],[[4,1,57,2]],[[0,1,58,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,2,65,8,37],[8,2,65,16,38],[11,2,65,19],[12,2,65,20,74],[54,2,65,62],[59,2,65,67],[64,2,65,72]],[[0,2,0,0]],[],[],[],[],[[1,2,5,1],[4,2,5,1]],[],[],[],[[31,2,57,16,35],[47,2,57,16,35]],[],[],[[15,2,57,16,35]],[],[],[[29,2,7,31]],[[40,2,8,39]],[[0,2,10,0],[6,2,10,6,36],[16,2,10,16,37],[24,2,10,24,38],[27,2,10,27],[28,2,10,28,39],[42,2,10,42]],[[0,2,12,0,40],[7,2,12,7,41],[11,2,12,11],[14,2,12,14]],[[4,2,13,2,36]],[[4,2,14,2,42],[12,2,14,10]],[[0,2,15,0]],[[0,2,17,0],[9,2,17,9,43],[31,2,18,2,44],[38,2,18,58],[40,2,19,2,45],[47,2,19,21]],[[4,2,21,2],[8,2,21,6],[9,2,21,7,44],[20,2,21,18],[21,2,21,19,44],[29,2,21,27,46],[35,2,21,33],[37,2,21,35]],[[8,2,22,4],[15,2,22,11,45]],[[4,2,23,2]],[[4,2,25,2],[11,2,25,9,44],[19,2,26,5,47],[25,2,26,11],[26,2,26,12],[27,2,26,13,48],[36,2,26,22],[37,2,26,23,49],[42,2,26,28,50],[48,2,26,34]],[[8,2,27,6],[15,2,27,13,48],[23,2,27,21,51],[27,2,27,25],[28,2,27,26]],[[12,2,28,8],[19,2,28,15],[23,2,28,19,52],[31,2,28,33],[32,2,28,34,53],[41,2,28,43,54]],[[16,2,29,10],[22,2,29,16,55],[27,2,29,21,56],[36,2,29,30,57],[49,2,29,43],[50,2,29,44]],[[16,2,31,10],[20,2,31,14,50],[27,2,31,21]],[[20,2,32,12,58],[21,2,32,12,58],[24,2,32,12,58],[48,2,32,12,58],[70,2,32,34],[72,2,32,35,55],[76,2,32,39,50]],[[16,2,33,10]],[[16,2,35,10],[20,2,35,14,49],[25,2,35,19]],[[20,2,36,12,55],[23,2,36,15,49],[26,2,36,18],[29,2,36,21,49]],[[20,2,37,12,55],[23,2,37,15,59],[29,2,37,21],[32,2,37,24],[36,2,37,30,53]],[[20,2,38,12,55],[23,2,38,15,60],[30,2,38,22],[33,2,38,25,54]],[[16,2,39,10],[23,2,39,17],[27,2,39,21,50],[34,2,39,28]],[[20,2,40,12,55],[23,2,40,15,61],[32,2,40,24],[35,2,40,27,50],[41,2,40,33,62],[49,2,40,41]],[[20,2,41,12,63],[31,2,41,23,53]],[[16,2,42,10]],[[16,2,44,10,56],[25,2,44,19,64],[29,2,44,23],[30,2,44,24,65],[41,2,44,35],[42,2,44,36,55]],[[12,2,45,8]],[[8,2,46,6]],[[4,2,47,4],[7,2,47,7,52],[15,2,47,15,53],[22,2,47,22],[26,2,48,5,66],[31,2,48,10],[32,2,48,11],[33,2,48,12,67]],[[8,2,49,6,68],[16,2,49,14,69],[21,2,49,19],[22,2,49,20,67]],[[4,2,50,6],[53,2,50,55]],[[4,2,51,4],[7,2,52,5,51],[11,2,52,9],[12,2,52,10]],[[8,2,53,6,45]],[[4,2,54,4]],[[0,2,55,0]],[[0,2,57,7],[9,2,57,16,35],[22,2,57,29,45],[29,2,57,67]],[[4,2,58,2],[10,2,58,8,70],[24,2,58,22,71],[25,2,58,22,71],[28,2,58,22,71],[41,2,58,22,71],[55,2,58,36]],[[4,2,60,2,43],[26,2,60,25,72],[31,2,60,38,73],[39,2,60,46],[41,2,60,48]],[[8,2,61,4],[71,2,61,67]],[[8,2,62,4],[74,2,62,70]],[[8,2,63,4],[79,2,63,75]],[[8,2,64,4],[64,2,64,60]],[[8,2,65,4]],[],[[8,2,78,4,45],[16,2,78,12,70]],[[4,2,79,2]],[[0,2,80,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,3,0,13,80],[52,3,0,13,80]],[],[],[[15,3,0,13,80]],[],[],[[0,3,0,7],[6,3,0,13,80],[26,3,1,2],[33,3,1,9,81],[49,3,1,25],[62,3,3,6],[62,3,4,6,81],[76,3,5,6],[77,3,5,7,82],[104,3,3,48]],[[4,3,6,8],[33,3,6,37]],[[4,3,7,8,83],[15,3,7,19,84],[22,3,7,26],[23,3,7,27,82],[28,3,7,32],[29,3,7,33,82]],[[0,3,8,6]],[],[],[],[],[],[],[],[],[],[],[],[[0,4,21,6,94],[8,4,21,14,95],[11,4,21,17],[12,4,21,18,96],[20,4,21,26],[25,4,21,31]],[[0,4,0,0],[69,4,0,69]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,4,9,16,85],[22,4,9,34],[24,4,9,34]],[[15,4,9,16,85]],[],[[4,4,13,13,86],[22,4,13,31],[24,4,13,31]],[[15,4,13,13,86]],[],[],[],[[30,4,3,36]],[[66,4,4,20]],[[35,4,5,34]],[[0,4,7,0],[6,4,7,6,87],[26,4,7,26],[30,4,7,30,88]],[[0,4,9,7],[9,4,9,16,85],[28,4,9,35,89],[33,4,9,47]],[[4,4,10,2],[11,4,10,9,87],[29,4,10,27,90],[32,4,10,30],[33,4,10,31,89]],[[0,4,11,0]],[[0,4,13,7],[6,4,13,13,86],[27,4,13,74],[28,4,14,2,89]],[[4,4,16,2],[58,4,16,56]],[[4,4,17,2],[8,4,17,6,91],[16,4,17,14,92],[17,4,17,14,92],[20,4,17,14,92],[29,4,17,14,92],[36,4,17,21],[38,4,17,22,89],[48,4,17,32],[59,4,17,43,89],[67,4,17,51,89],[73,4,17,57,91],[78,4,17,62],[81,4,17,65,89]],[[4,4,18,2],[81,4,18,79]],[[4,4,19,2],[8,4,19,6,93],[9,4,19,6,93],[12,4,19,6,93],[26,4,19,6,93],[45,4,19,25],[47,4,19,26,91],[55,4,19,34]],[[4,4,21,2],[44,4,21,45]],[[8,4,22,4],[14,4,22,10],[16,4,22,12,97],[32,4,22,28],[34,4,22,30],[37,4,23,6,98],[45,4,23,14]],[[8,4,24,4],[14,4,24,10,99],[27,4,24,23,97],[44,4,24,40,91]],[[8,4,25,4,87],[26,4,25,22,100],[29,4,25,25],[30,4,25,26,99]],[[8,4,26,4,91],[16,4,26,12,99]],[[4,4,27,2]],[[4,4,29,2,101],[5,4,29,2,101],[8,4,29,2,101],[27,4,29,2,101],[44,4,29,19],[46,4,29,20,91]],[[0,4,30,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,5,0,13,102],[25,5,0,34],[27,5,0,34]],[[15,5,0,13,102]],[],[[4,5,8,13,103],[34,5,8,43],[36,5,8,43]],[[15,5,8,13,103]],[],[[4,5,47,16,104],[38,5,47,50],[40,5,47,50]],[[15,5,47,16,104]],[],[[4,5,40,16,105],[31,5,40,43],[33,5,40,43]],[[15,5,40,16,105]],[],[[4,5,21,16,106],[29,5,21,41],[31,5,21,41]],[[15,5,21,16,106]],[],[],[[0,5,0,7],[6,5,0,13,102],[30,5,0,37]],[[4,5,1,2,107],[15,5,1,13]],[[4,5,2,2,108],[15,5,2,13]],[[4,5,3,2,109],[18,5,3,16]],[[0,5,4,0]],[[0,5,6,0],[6,5,6,6,110],[22,5,6,22],[26,5,6,26,111],[30,5,6,30,112],[37,5,6,37,113],[43,5,6,43],[44,5,6,44,102]],[[0,5,8,7],[6,5,8,13,103],[39,5,8,46]],[[0,5,21,7],[9,5,21,16,106],[35,5,22,2,114],[40,5,22,16]],[[4,5,24,2],[8,5,25,4],[15,5,25,11,114],[25,5,25,21],[37,5,26,4,114],[47,5,26,14],[55,5,27,4],[56,5,27,6],[57,5,27,6],[69,5,27,18,114],[74,5,27,22],[79,5,28,4],[86,5,28,11,114],[92,5,28,17,115],[98,5,28,23],[103,5,28,28],[113,5,29,4]],[[8,5,30,4],[15,5,30,11]],[[4,5,31,2]],[[4,5,32,2],[10,5,32,8],[11,5,32,9,116],[19,5,32,17,117],[30,5,32,28],[33,5,32,31,114],[39,5,32,37,115],[45,5,32,43],[46,5,32,44,118],[51,5,32,49],[52,5,32,50]],[[4,5,34,2],[11,5,35,4,116],[22,5,35,15,103],[56,5,36,4,110],[70,5,36,18,119],[73,5,36,21],[74,5,36,22,120],[81,5,36,29,117]],[[0,5,38,0]],[[0,5,40,7],[9,5,40,16,105],[37,5,41,2,114],[42,5,41,32]],[[4,5,43,2],[10,5,43,8,117],[23,5,43,21,114],[29,5,43,27,115],[35,5,43,33],[36,5,43,34,118],[41,5,43,39],[42,5,43,40],[46,5,43,44],[47,5,43,45],[49,5,43,47]],[[4,5,44,2],[11,5,44,9,120],[18,5,44,16,117]],[[0,5,45,0]],[[0,5,47,7],[9,5,47,16,104],[44,5,48,2,121],[50,5,48,16]],[[4,5,50,2],[11,5,50,10,121]],[[8,5,51,4],[13,5,51,9]],[[12,5,52,6],[19,5,52,13]],[[8,5,53,4],[13,5,53,9]],[[12,5,54,6],[19,5,54,13]],[[8,5,55,4],[13,5,55,9]],[[12,5,56,6],[19,5,56,13]],[[8,5,57,4]],[[12,5,58,6]],[[4,5,59,2]],[[0,5,60,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,6,0,12,122],[53,6,0,12,122]],[],[],[[15,6,0,12,122]],[],[],[[0,6,0,7],[4,6,0,12,122],[25,6,0,12,122],[36,6,0,12,122],[39,6,0,12,122],[48,6,0,12,122],[66,6,0,12,122]],[],[],[],[[11,6,0,12,122]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,7,2,13,123],[23,7,2,32],[25,7,2,32]],[[15,7,2,13,123]],[],[[4,7,4,12,124],[16,7,4,24],[18,7,4,24]],[[15,7,4,12,124]],[],[[4,7,20,16,125],[19,7,20,31],[21,7,20,31]],[[15,7,20,16,125]],[],[],[[36,7,0,35]],[[0,7,2,7],[6,7,2,13,123],[28,7,2,35]],[[0,7,4,7],[4,7,4,12,124],[19,7,4,12,124],[30,7,4,12,124],[33,7,4,12,124],[42,7,4,12,124],[54,7,4,12,124]],[],[],[[11,7,4,12,124]],[],[[0,7,20,7],[9,7,20,16,125],[25,7,20,32,126],[30,7,20,46]],[[4,7,21,2],[8,7,22,4],[15,7,22,11,126],[25,7,22,21],[37,7,23,4,126],[47,7,23,14],[55,7,24,4],[56,7,24,6],[57,7,24,6],[69,7,24,18,126],[74,7,24,22],[79,7,25,4],[86,7,25,11,126],[92,7,25,17,127],[98,7,25,23],[103,7,25,28],[113,7,26,4]],[[8,7,27,4],[15,7,27,11]],[[4,7,28,2]],[[4,7,30,2],[10,7,30,8,127],[19,7,30,17,126],[25,7,30,23,127],[31,7,30,29],[32,7,30,30,128],[37,7,30,35],[38,7,30,36]],[[4,7,31,2],[10,7,31,8],[11,7,31,9,129],[22,7,31,20,130],[27,7,31,25],[30,7,31,28,127]],[[4,7,32,2],[10,7,32,8,131],[24,7,32,22,127],[31,7,32,29,132],[36,7,32,34],[37,7,32,35],[40,7,32,38],[41,7,32,39],[44,7,32,42,133],[48,7,32,46],[49,7,32,47]],[[4,7,33,2],[10,7,33,8,134],[19,7,33,17,127],[26,7,33,24,135],[28,7,33,26],[29,7,33,27],[30,7,33,28]],[[4,7,35,2],[10,7,35,8,136],[23,7,35,21,137],[30,7,35,28,134]],[[4,7,37,2],[11,7,38,4,129],[25,7,38,18,123],[48,7,39,5,130],[49,7,39,5,130],[58,7,39,14],[71,7,39,27,130],[80,7,39,36],[86,7,39,41],[91,7,40,4],[98,7,40,11,131],[114,7,40,27],[126,7,41,4],[127,7,41,5,138],[133,7,41,11,136],[148,7,42,4,136],[162,7,42,18,139],[182,7,42,18,139],[200,7,42,36]],[[0,7,44,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,8,11,16,140],[52,8,11,16,140]],[],[],[[15,8,11,16,140]],[],[],[[36,8,3,7]],[[31,8,4,52]],[[0,8,11,7],[9,8,11,16,140],[27,8,12,2,141],[32,8,12,16]],[[4,8,14,2],[11,8,14,9,142],[12,8,14,9,142],[15,8,14,9,142],[30,8,14,9,142],[45,8,14,24],[47,8,14,25,141],[57,8,14,35,143],[58,8,14,35,143],[61,8,14,35,143],[81,8,14,35,143],[106,8,14,60],[108,8,14,61,141]],[[0,8,15,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,9,61,16,144],[21,9,61,33],[23,9,61,33]],[[15,9,61,16,144]],[],[[4,9,120,16,145],[20,9,120,32],[22,9,120,32]],[[15,9,120,16,145]],[],[],[],[[66,9,0,20]],[[0,9,2,0],[9,9,2,9,146],[22,9,2,22,147],[25,9,2,34],[27,9,2,36,148],[32,9,2,49]],[[4,9,3,2],[11,9,3,10],[18,9,3,17,147]],[[8,9,4,4],[13,9,4,9]],[[12,9,5,6],[16,9,5,10,147],[24,9,5,18],[30,9,5,24]],[[16,9,6,8],[23,9,6,15]],[[12,9,7,6],[19,9,7,13],[23,9,7,17,149],[29,9,7,23,150],[36,9,7,30],[37,9,7,31,147],[43,9,7,37]],[[16,9,8,8],[20,9,8,12,151],[29,9,8,21]],[[16,9,9,8],[20,9,9,12,148],[28,9,9,20],[31,9,9,23]],[[20,9,10,10],[24,9,10,15],[28,9,10,19,152],[32,9,10,23],[35,9,10,26,152],[39,9,10,30,147],[43,9,10,34,153],[49,9,10,40],[51,9,10,42,152],[55,9,10,47]],[[24,9,11,12],[28,9,11,16,151],[39,9,11,27],[44,9,11,32]],[[28,9,12,14,151],[38,9,12,24]],[[24,9,13,12]],[[24,9,14,12],[28,9,14,16,154],[35,9,14,23,155],[44,9,14,32],[45,9,14,33,156],[59,9,14,47],[60,9,14,48,157],[64,9,14,52],[65,9,14,53,147],[70,9,14,58,152],[74,9,14,62]],[[28,9,15,14,151],[38,9,15,24,146],[51,9,15,37,147],[54,9,15,40],[55,9,15,41,152],[57,9,15,43],[59,9,15,45,148],[67,9,15,53]],[[24,9,16,12]],[[20,9,17,10]],[[16,9,18,8],[23,9,18,15]],[[20,9,19,10,151],[30,9,19,20,147],[34,9,19,24,153],[40,9,19,30],[43,9,19,33],[47,9,19,37],[55,9,19,45]],[[16,9,20,8]],[[16,9,21,8,151],[26,9,21,18]],[[16,9,22,8],[23,9,22,15,151]],[[12,9,23,6],[19,9,23,13],[23,9,23,17,147],[38,9,23,32,158],[45,9,23,39]],[[16,9,24,8],[23,9,24,15,147],[29,9,24,21]],[[12,9,25,6],[19,9,25,13]],[[16,9,26,8],[22,9,26,14,159],[29,9,26,21,154],[36,9,26,28,159],[40,9,26,32],[41,9,26,33,147]],[[16,9,27,8],[20,9,27,12,151],[29,9,27,21]],[[16,9,28,8],[20,9,28,12,148],[28,9,28,20],[31,9,28,23]],[[20,9,29,10],[24,9,29,15],[28,9,29,19,152],[32,9,29,23],[35,9,29,26,152],[39,9,29,30,159],[44,9,29,35,153],[50,9,29,41],[52,9,29,43,152],[56,9,29,48]],[[24,9,30,12],[30,9,30,18,160],[36,9,30,24,159],[40,9,30,28],[41,9,30,29,152],[43,9,30,31]],[[24,9,31,12],[30,9,31,18,161],[37,9,31,25,154],[44,9,31,32,162],[68,9,31,56],[69,9,31,57,147],[74,9,31,62]],[[24,9,32,12],[28,9,32,16,161],[36,9,32,24],[37,9,32,25,161],[42,9,32,30,163],[45,9,32,33],[49,9,32,37],[50,9,32,38,161],[55,9,32,43,164],[58,9,32,46],[60,9,32,48]],[[28,9,33,14],[34,9,33,20,165],[44,9,33,30,166],[49,9,33,35,167],[58,9,33,44],[59,9,33,45,160]],[[28,9,34,14],[32,9,34,18,165],[44,9,34,30],[50,9,34,36,160],[56,9,34,42],[61,9,34,47]],[[32,9,35,16,151],[42,9,35,26,165],[52,9,35,36]],[[28,9,36,14],[35,9,36,21]],[[32,9,37,16,151],[42,9,37,26,160],[48,9,37,32]],[[28,9,38,14]],[[28,9,39,14,151],[38,9,39,24,146],[51,9,39,37,161],[56,9,39,42,168],[61,9,39,47],[63,9,39,49,148],[71,9,39,57]],[[24,9,40,12]],[[20,9,41,10]],[[16,9,42,8],[23,9,42,15]],[[20,9,43,10,151],[30,9,43,20,159],[35,9,43,25,153],[41,9,43,31],[44,9,43,34],[48,9,43,38],[56,9,43,46]],[[16,9,44,8]],[[16,9,45,8,151],[26,9,45,18]],[[16,9,46,8],[23,9,46,15,151]],[[12,9,47,6]],[[8,9,48,4],[13,9,48,9]],[[12,9,49,6],[19,9,49,13,166],[24,9,49,18,167],[33,9,49,27],[34,9,49,28,147]],[[8,9,50,4],[13,9,50,9]],[[8,9,51,4],[13,9,51,9]],[[8,9,52,4],[13,9,52,9]],[[8,9,53,4],[13,9,53,9]],[[8,9,54,4],[13,9,54,9]],[[8,9,55,4],[13,9,55,9]],[[8,9,56,4]],[[12,9,57,6],[19,9,57,13,169],[26,9,57,20,147]],[[4,9,58,2]],[[0,9,59,0]],[[0,9,61,7],[9,9,61,16,144],[27,9,61,34,170],[31,9,61,49]],[[4,9,62,2],[8,9,62,6,171]],[[4,9,63,2],[8,9,63,6,172]],[[4,9,64,2],[8,9,64,6],[15,9,64,13,170],[19,9,64,17],[20,9,64,18],[22,9,64,20],[27,9,64,25],[37,9,64,35]],[[8,9,65,4,171],[18,9,65,14,170],[22,9,65,18],[23,9,65,19],[25,9,65,21]],[[8,9,66,4,172],[14,9,66,10]],[[4,9,67,2],[11,9,67,9]],[[8,9,68,4,171],[18,9,68,14]],[[8,9,69,4,172],[14,9,69,10]],[[4,9,70,2]],[[4,9,71,2],[8,9,71,6,151],[17,9,71,15]],[[4,9,72,2],[8,9,72,6,173],[21,9,72,19]],[[4,9,73,2],[8,9,73,7],[12,9,73,11,152],[16,9,73,15],[19,9,73,18,152],[23,9,73,22,171],[31,9,73,30,153],[37,9,73,36],[39,9,73,38],[41,9,73,40,152],[43,9,73,43]],[[8,9,74,4],[14,9,74,10,174],[21,9,74,17,171],[28,9,74,24],[29,9,74,25,152],[31,9,74,27]],[[8,9,75,4],[12,9,75,8,174],[21,9,75,17],[28,9,75,24,152],[34,9,75,30,171],[42,9,75,38,153],[48,9,75,44],[51,9,75,47],[56,9,75,52,172],[63,9,75,59,170],[68,9,75,64,153],[74,9,75,70],[76,9,75,72]],[[12,9,76,6,151],[22,9,76,16,174]],[[12,9,77,6]],[[8,9,78,4]],[[8,9,80,4],[14,9,80,10,175],[21,9,80,17,171],[28,9,80,24],[29,9,80,25],[31,9,80,27,152],[33,9,80,29]],[[8,9,81,4],[15,9,81,12,175]],[[12,9,82,6],[17,9,82,11]],[[16,9,82,16]],[[20,9,83,8],[91,9,83,79]],[[20,9,84,8],[38,9,84,26]],[[20,9,85,8,151],[29,9,85,17,173],[42,9,85,30],[45,9,85,33,151],[52,9,85,40],[53,9,85,41],[54,9,85,42],[57,9,85,45],[58,9,85,46],[59,9,85,47],[61,9,85,49,151],[69,9,85,57]],[[20,9,86,8,173],[33,9,86,21],[34,9,86,22,173]],[[20,9,87,8,172]],[[20,9,88,8]],[[16,9,89,6]],[[12,9,90,6],[17,9,90,11]],[[12,9,91,6],[17,9,91,11]],[[16,9,91,16]],[[20,9,92,8,151],[30,9,92,18,146],[43,9,92,31,170],[47,9,92,35],[48,9,92,36,172],[54,9,92,42],[56,9,92,44]],[[20,9,93,8]],[[16,9,94,6]],[[12,9,95,6],[17,9,95,11]],[[12,9,96,6],[17,9,96,11]],[[16,9,96,16]],[[20,9,97,8,151],[30,9,97,18,176],[39,9,97,27,170],[43,9,97,31],[44,9,97,32,172],[50,9,97,38],[52,9,97,47]],[[20,9,98,8]],[[16,9,99,6]],[[12,9,100,6],[17,9,100,11]],[[16,9,100,16]],[[20,9,101,8,151],[30,9,101,18,177],[41,9,101,29,170],[45,9,101,33],[46,9,101,34,172],[52,9,101,40]],[[20,9,102,8]],[[16,9,103,6]],[[12,9,104,6],[17,9,104,11]],[[16,9,104,16]],[[20,9,105,8,151],[30,9,105,18,169],[37,9,105,25,170],[41,9,105,29],[42,9,105,30,172],[48,9,105,36]],[[20,9,106,8]],[[16,9,107,6]],[[12,9,108,6]],[[16,9,109,8,151],[26,9,109,18],[32,9,109,24,175]],[[8,9,110,4]],[[4,9,111,2]],[[4,9,113,2],[10,9,113,9,172],[16,9,113,15,170],[21,9,113,20,153],[27,9,113,26],[29,9,113,28,172],[35,9,113,35]],[[8,9,114,4,151],[18,9,114,15,172],[19,9,114,15,172],[25,9,114,21],[29,9,114,25],[35,9,114,31],[37,9,114,32],[41,9,114,37,146],[54,9,114,50,170],[58,9,114,54],[59,9,114,55,172],[63,9,114,59],[65,9,114,61]],[[4,9,115,2]],[[4,9,117,2],[11,9,117,9,151]],[[0,9,118,0]],[[0,9,120,7],[9,9,120,16,145],[26,9,120,33,170],[30,9,120,48]],[[4,9,124,2],[10,9,124,8]],[[4,9,125,2],[156,9,125,154]],[[4,9,126,2],[6,9,126,4]],[[4,9,127,2],[52,9,127,50]],[[4,9,128,2],[8,9,128,6]],[[4,9,129,2],[34,9,129,32]],[[4,9,130,2],[36,9,130,34]],[[4,9,131,2],[54,9,131,52]],[[4,9,132,2],[12,9,132,10]],[[4,9,133,2],[15,9,133,13]],[[4,9,134,2],[61,9,134,59]],[[4,9,135,2],[12,9,135,10]],[[4,9,136,2],[8,9,136,6]],[[4,9,137,2],[8,9,138,4,170],[13,9,138,9,153],[19,9,138,15],[22,9,138,18],[27,9,139,4],[34,9,139,11,170],[38,9,139,15],[39,9,139,16],[41,9,139,18],[46,9,139,23],[58,9,140,4,170],[62,9,140,8],[63,9,140,9],[65,9,140,11],[66,9,140,12,178],[76,9,140,22],[77,9,140,23],[90,9,141,4],[97,9,141,11,170],[101,9,141,15],[102,9,141,16],[104,9,141,18],[109,9,141,23],[121,9,142,4],[128,9,142,11,170],[132,9,142,15],[133,9,142,16],[135,9,142,18],[140,9,142,23],[152,9,143,4],[159,9,143,11,170],[163,9,143,15],[164,9,143,16],[166,9,143,18],[171,9,143,23],[181,9,144,4]],[[8,9,145,4],[14,9,145,10,179],[32,9,145,28,170],[36,9,145,32],[37,9,145,33],[39,9,145,35]],[[8,9,146,4],[14,9,146,10,180],[27,9,146,23,170],[31,9,146,27],[32,9,146,28],[34,9,146,30]],[[8,9,148,4],[15,9,148,11]],[[12,9,149,6,179],[29,9,149,23,179],[45,9,149,39,181],[49,9,149,43]],[[12,9,150,6,182],[19,9,150,13,183],[20,9,150,13,183],[23,9,150,13,183],[32,9,150,13,183],[39,9,150,20],[41,9,150,21,180],[55,9,150,35,180],[68,9,150,48]],[[8,9,151,4]],[[4,9,152,2]],[[4,9,154,2],[11,9,154,9]],[[8,9,155,4,179],[25,9,155,21]],[[8,9,156,4,182],[15,9,156,11]],[[4,9,157,2]],[[0,9,158,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,10,4,4,184],[8,10,4,12,185],[11,10,4,15],[12,10,4,16,186],[20,10,4,24],[25,10,4,29]],[[0,10,0,0],[61,10,0,61]],[],[],[],[],[],[[0,10,3,0],[37,10,3,37]],[[0,10,4,0],[40,10,4,43]],[],[[0,10,6,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,11,0,0]],[],[],[],[[1,11,4,1],[4,11,6,0],[18,11,6,14]],[],[],[[31,11,19,13,188],[58,11,19,13,188]],[],[],[[15,11,19,13,188]],[],[],[[0,11,7,0],[6,11,7,6,189],[43,11,7,43,190]],[[4,11,8,2,191],[17,11,8,16]],[[8,11,9,4],[13,11,9,9],[14,11,10,6]],[[4,11,12,2]],[[0,11,13,0]],[[0,11,19,7],[6,11,19,13,188],[38,11,19,45,192]],[[4,11,20,2],[172,11,20,170],[175,11,21,2,193],[184,11,21,11]],[[8,11,22,4],[14,11,22,10],[18,11,22,14,189]],[[4,11,23,2]],[[4,11,24,2],[172,11,24,170],[175,11,25,2,194],[184,11,25,11]],[[8,11,26,4],[14,11,26,10],[18,11,26,14,189]],[[4,11,27,2]],[[4,11,28,2],[172,11,28,170],[175,11,29,2,195],[181,11,29,8]],[[8,11,30,4],[14,11,30,10],[18,11,30,14,189]],[[4,11,31,2]],[[4,11,32,2],[172,11,32,170],[175,11,33,2,196],[182,11,33,9]],[[8,11,34,4],[14,11,34,10],[18,11,34,14,189]],[[4,11,35,2]],[[0,11,36,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,12,1,13,197],[17,12,1,26],[19,12,1,26]],[[15,12,1,13,197]],[],[[4,12,18,13,198],[18,12,18,27],[20,12,18,27]],[[15,12,18,13,198]],[],[[4,12,33,13,199],[32,12,33,41],[34,12,33,41]],[[15,12,33,13,199]],[],[[4,12,38,13,200],[34,12,38,43],[36,12,38,43]],[[15,12,38,13,200]],[],[[4,12,29,13,201],[28,12,29,37],[30,12,29,37]],[[15,12,29,13,201]],[],[[4,12,14,13,202],[32,12,14,41],[34,12,14,41]],[[15,12,14,13,202]],[],[[4,12,13,13,203],[27,12,13,36],[29,12,13,36]],[[15,12,13,13,203]],[],[[4,12,35,13,204],[31,12,35,40],[33,12,35,40]],[[15,12,35,13,204]],[],[[4,12,32,13,205],[28,12,32,37],[30,12,32,37]],[[15,12,32,13,205]],[],[[4,12,34,13,206],[26,12,34,35],[28,12,34,35]],[[15,12,34,13,206]],[],[[4,12,30,13,207],[30,12,30,39],[32,12,30,39]],[[15,12,30,13,207]],[],[[4,12,31,13,208],[31,12,31,40],[33,12,31,40]],[[15,12,31,13,208]],[],[[4,12,6,13,209],[31,12,6,40],[33,12,6,40]],[[15,12,6,13,209]],[],[[4,12,11,13,210],[39,12,11,48],[41,12,11,48]],[[15,12,11,13,210]],[],[[4,12,28,13,211],[33,12,28,42],[35,12,28,42]],[[15,12,28,13,211]],[],[[4,12,5,13,212],[33,12,5,42],[35,12,5,42]],[[15,12,5,13,212]],[],[[4,12,26,13,213],[24,12,26,33],[26,12,26,33]],[[15,12,26,13,213]],[],[[4,12,15,13,214],[12,12,15,21],[14,12,15,21]],[[15,12,15,13,214]],[],[[4,12,16,13,215],[27,12,16,36],[29,12,16,36]],[[15,12,16,13,215]],[],[[4,12,0,13,216],[14,12,0,23],[16,12,0,23]],[[15,12,0,13,216]],[],[],[[0,12,0,7],[6,12,0,13,216],[19,12,0,26]],[[0,12,1,7],[6,12,1,13,197],[22,12,1,29]],[[0,12,5,7],[6,12,5,13,212],[38,12,5,45]],[[0,12,6,7],[6,12,6,13,209],[36,12,6,43]],[[0,12,11,7],[6,12,11,13,210],[44,12,12,2]],[[0,12,13,7],[6,12,13,13,203],[32,12,13,39]],[[0,12,14,7],[6,12,14,13,202],[37,12,14,44]],[[0,12,15,7],[6,12,15,13,214],[17,12,15,24]],[[0,12,16,7],[6,12,16,13,215],[32,12,16,39]],[[0,12,18,7],[6,12,18,13,198],[23,12,18,30]],[[4,12,19,2,216]],[[4,12,20,2,212]],[[4,12,21,2,209]],[[4,12,22,2,203]],[[4,12,23,2,210]],[[1,12,24,1]],[[0,12,26,7],[6,12,26,13,213],[29,12,26,36]],[[0,12,28,7],[6,12,28,13,211],[38,12,28,45]],[[0,12,29,7],[6,12,29,13,201],[33,12,29,40]],[[0,12,30,7],[6,12,30,13,207],[35,12,30,42]],[[0,12,31,7],[6,12,31,13,208],[36,12,31,43]],[[0,12,32,7],[6,12,32,13,205],[33,12,32,40]],[[0,12,33,7],[6,12,33,13,199],[37,12,33,44]],[[0,12,34,7],[6,12,34,13,206],[31,12,34,38]],[[0,12,35,7],[6,12,35,13,204],[36,12,35,43]],[[0,12,38,7],[6,12,38,13,200],[39,12,38,46]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,13,53,16,217],[55,13,53,16,217]],[],[],[[15,13,53,16,217]],[],[],[[23,13,0,27]],[[49,13,1,32]],[[0,13,3,0]],[],[],[],[],[],[[1,13,9,1],[4,13,10,0],[13,13,10,9,218]],[[4,13,11,2],[8,13,11,6],[15,13,11,13,219],[26,13,11,24],[39,13,11,37]],[[8,13,12,4],[73,13,12,69]],[[8,13,13,4],[14,13,13,10],[16,13,13,12,220],[36,13,13,32],[38,13,13,34],[41,13,14,6,221],[49,13,14,14]],[[8,13,16,4],[14,13,16,10,222],[30,13,16,26,220],[51,13,16,47,223],[59,13,16,55]],[[8,13,17,4],[12,13,17,8],[13,13,17,9,222],[28,13,17,24],[35,13,17,31]],[[8,13,19,4],[15,13,19,12,222],[29,13,19,26,224],[33,13,19,30]],[[12,13,20,6],[17,13,20,11]],[[12,13,21,6],[17,13,21,11]],[[12,13,22,6],[17,13,22,11]],[[16,13,23,8],[22,13,23,14,225],[39,13,23,31,222],[53,13,23,45,226],[72,13,23,64]],[[16,13,24,8],[23,13,24,15,225],[40,13,24,32,225],[55,13,24,47,227],[59,13,24,51],[62,13,24,54],[66,13,24,58]],[[12,13,25,6],[17,13,25,11]],[[12,13,26,6],[17,13,26,11]],[[12,13,27,6],[17,13,27,11]],[[12,13,28,6],[17,13,28,11]],[[12,13,29,6],[17,13,29,11]],[[12,13,30,6],[17,13,30,11]],[[16,13,31,8]],[[12,13,32,6]],[[16,13,33,8,222]],[[8,13,34,4]],[[8,13,36,4],[15,13,36,11]],[[4,13,37,2]],[[4,13,39,2],[11,13,39,9]],[[0,13,40,0]],[[0,13,53,7],[9,13,53,16,217]],[[4,13,54,2],[73,13,54,71]],[[4,13,55,2],[82,13,55,80]],[[4,13,56,2],[82,13,56,80]],[[4,13,57,2],[27,13,57,25]],[[4,13,58,2],[8,13,58,6,218],[34,13,58,32]],[[8,13,59,4],[15,13,59,11]],[[4,13,60,2]],[[4,13,62,2],[79,13,62,77]],[[4,13,63,2],[57,13,63,55]],[[4,13,64,2],[58,13,64,56]],[[4,13,65,2],[11,13,65,9,228],[12,13,65,9,228],[15,13,65,9,228],[22,13,65,9,228],[32,13,65,19],[34,13,65,20,229],[67,13,65,20,229],[82,13,65,35]],[[0,13,66,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,14,0,16,230],[52,14,0,16,230]],[],[],[[15,14,0,16,230]],[],[],[[0,14,0,7],[9,14,0,16,230],[27,14,1,2,231],[30,14,1,48],[32,14,2,2,232],[46,14,2,25],[50,14,2,29]],[[4,14,4,2],[11,14,4,9,231],[15,14,4,13,233],[23,14,4,21],[26,14,4,24,231],[30,14,4,28,234],[36,14,4,34],[39,14,4,38,232],[40,14,4,38,232],[54,14,4,52,231],[58,14,4,56,235],[62,14,4,60],[65,14,4,63],[67,14,4,64]],[[0,14,5,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,15,22,6,248],[8,15,22,14,249],[11,15,22,17],[12,15,22,18,250],[40,15,22,46],[42,15,22,48]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,15,3,16,236],[22,15,3,34],[24,15,3,34]],[[15,15,3,16,236]],[],[[4,15,21,16,237],[24,15,21,36],[26,15,21,36]],[[15,15,21,16,237]],[],[],[[23,15,0,26]],[[35,15,1,34]],[[0,15,3,7],[9,15,3,16,236],[28,15,3,35,238],[33,15,3,49]],[[4,15,4,2],[8,15,5,4,238],[17,15,6,4],[24,15,6,11,239],[35,15,6,22],[50,15,7,4,239],[57,15,7,11,240],[61,15,7,15],[62,15,7,16,241],[74,15,7,28],[78,15,8,4,242],[79,15,8,4,242],[82,15,8,4,242],[101,15,8,4,242],[118,15,8,21],[120,15,8,22],[124,15,8,26,243],[128,15,8,30,239],[135,15,8,37,244],[143,15,8,45],[144,15,8,46,245],[148,15,8,50],[155,15,9,6,242],[156,15,9,6,242],[159,15,9,6,242],[178,15,9,6,242],[195,15,9,23],[197,15,9,24,239],[204,15,9,31,240],[208,15,9,35],[209,15,9,36,241],[221,15,9,48],[224,15,10,4]],[[8,15,11,4,246],[16,15,11,12,238],[21,15,11,17],[22,15,12,6],[23,15,12,7],[88,15,12,72],[89,15,12,73],[91,15,13,6,238]],[[8,15,15,4,239],[15,15,15,11,244],[23,15,15,19],[24,15,15,20,245],[28,15,15,24],[31,15,15,27,239],[38,15,15,34,240],[42,15,15,38],[43,15,15,39,241],[55,15,15,51],[56,15,15,52,247],[64,15,15,60]],[[8,15,16,4],[15,15,16,11]],[[4,15,17,2]],[[4,15,18,2],[11,15,18,9]],[[0,15,19,0]],[[0,15,21,7],[9,15,21,16,237]],[[4,15,22,2]],[],[[0,15,46,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,16,10,16,257],[49,16,10,16,257]],[],[],[[15,16,10,16,257]],[],[],[[0,16,0,0],[6,16,0,6,258],[25,16,1,2],[32,16,1,9,259],[43,16,1,20],[57,16,3,8,260],[65,16,3,16],[192,16,4,8,258],[208,16,4,24],[211,16,5,6,261]],[[0,16,10,7],[9,16,10,16,257],[24,16,10,31],[26,16,10,33,262],[31,16,10,38],[33,16,10,56]],[[4,16,11,2],[8,16,11,6,258],[26,16,11,24]],[[8,16,12,4],[14,16,12,10,263],[22,16,12,18,258],[39,16,12,35,264],[47,16,12,43]],[[8,16,13,4],[12,16,13,8,263],[19,16,13,15,265],[39,16,13,35]],[[12,16,14,6],[16,16,14,10,262],[23,16,14,17]],[[16,16,15,8,266],[24,16,15,16,262],[29,16,15,21],[30,16,15,22,262]],[[12,16,16,6]],[[12,16,17,6],[18,16,17,12,262]],[[8,16,18,4]],[[4,16,19,2]],[[4,16,21,2],[11,16,21,9]],[[0,16,22,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,17,65,8,287],[8,17,65,16,288],[11,17,65,19],[12,17,65,20,289],[40,17,65,48],[42,17,65,50]],[[0,17,0,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,17,128,16,267],[17,17,128,29],[19,17,128,29]],[[15,17,128,16,267]],[],[[4,17,36,13,268],[24,17,36,33],[26,17,36,33]],[[15,17,36,13,268]],[],[],[],[],[[64,17,2,32]],[[37,17,3,37]],[[35,17,4,34]],[[35,17,5,35]],[[32,17,6,31]],[[23,17,7,22]],[[0,17,9,0],[6,17,9,6,269],[23,17,10,2],[30,17,10,9,270],[41,17,10,20],[56,17,10,35,271],[57,17,10,35,271],[60,17,10,35,271],[67,17,10,35,271],[72,17,10,40],[74,17,10,41,270],[81,17,10,48,272],[90,17,10,57],[91,17,10,58,273],[100,17,10,67]],[[0,17,36,7],[6,17,36,13,268],[35,17,36,42,274],[42,17,36,42,274],[49,17,36,47],[50,17,36,48,275],[59,17,36,57]],[[4,17,40,2,276],[16,17,40,14,277],[21,17,40,46],[22,17,40,48]],[[8,17,41,4],[13,17,41,9],[14,17,41,10,277],[22,17,41,10,277],[26,17,41,10,277],[27,17,93,2,278],[32,17,93,2,278],[35,17,93,10]],[[12,17,94,4],[16,17,94,8],[17,17,94,9,279],[25,17,94,17],[26,17,94,18]],[[16,17,94,20,280],[23,17,94,27]],[[12,17,94,32]],[[8,17,95,2]],[[8,17,42,4],[12,17,42,8],[13,17,42,9,281],[18,17,42,14],[21,17,42,17]],[[12,17,42,19,280],[19,17,42,26]],[[12,17,42,32,282],[30,17,42,50],[34,17,42,54],[35,17,42,55,277],[40,17,42,60],[41,17,42,61,283],[49,17,42,69]],[[8,17,42,70]],[[4,17,43,2]],[[4,17,45,2],[11,17,45,9,284],[36,17,45,34,280],[41,17,45,46],[43,17,45,48]],[[8,17,46,4],[12,17,46,8,285],[13,17,46,8,285],[16,17,46,8,285],[35,17,46,8,285],[52,17,46,25],[54,17,46,26,280],[62,17,46,34]],[[12,17,47,6],[75,17,47,69]],[[12,17,48,6],[120,17,48,114]],[[12,17,49,6],[18,17,49,12,280]],[[8,17,50,4]],[[8,17,52,4],[15,17,52,11]],[[12,17,52,13,280]],[[8,17,52,19]],[[4,17,53,2]],[[4,17,55,2],[11,17,55,9,286],[36,17,56,4,277],[41,17,56,36],[43,17,57,4,281],[48,17,57,36],[50,17,58,38]],[[8,17,59,4],[14,17,59,10],[16,17,59,12,280],[21,17,59,17],[23,17,59,19],[26,17,59,22,281]],[[8,17,61,4],[41,17,61,37]],[[8,17,62,4],[54,17,62,50]],[[8,17,63,4],[57,17,63,53]],[[8,17,64,4],[53,17,64,49]],[[8,17,65,4]],[],[[8,17,75,4]],[],[],[],[],[[5,17,80,5],[8,17,81,4],[12,17,81,8,277],[18,17,81,14,283],[26,17,81,22],[31,17,81,27,281],[37,17,81,33,282],[53,17,81,49],[57,17,81,53,281],[63,17,81,59,280],[68,17,81,64],[70,17,81,66]],[[12,17,82,6],[19,17,82,13]],[[16,17,83,8,280],[23,17,83,15]],[[16,17,84,8,282],[34,17,84,26,277],[40,17,84,32,283],[48,17,84,40]],[[12,17,85,6]],[[8,17,86,4]],[[8,17,87,4],[15,17,87,11]],[[12,17,88,6,280],[19,17,88,13,281],[25,17,88,19,280],[30,17,88,24]],[[12,17,89,6,282],[30,17,89,24,277],[36,17,89,30,283],[44,17,89,38]],[[8,17,90,4]],[[4,17,91,2]],[[4,17,97,2],[141,17,97,139]],[[4,17,98,2,291],[13,17,98,28]],[[8,17,99,4],[95,17,99,91]],[[8,17,100,4],[121,17,100,117]],[[8,17,101,4],[12,17,101,8],[16,17,101,12],[17,17,101,13,281],[22,17,101,18],[23,17,101,19,280],[28,17,101,24],[32,17,101,28],[33,17,101,29,269],[49,17,101,45]],[[12,17,102,6],[19,17,102,6],[30,17,102,6],[33,17,103,8],[34,17,103,8],[37,17,103,8],[49,17,103,8],[53,17,103,8],[55,17,103,8],[67,17,103,8],[75,17,103,8],[77,17,103,8]],[],[[34,17,104,10],[35,17,104,10],[38,17,104,10],[50,17,104,10],[53,17,104,10],[55,17,104,11,292],[71,17,104,11,292],[85,17,104,25],[87,17,104,25]],[[24,17,104,26,280],[31,17,104,33],[35,17,104,37],[36,17,104,38,281],[41,17,104,43],[42,17,104,44,280],[47,17,104,49]],[],[[20,17,105,11],[24,17,105,15],[25,17,105,16,277],[30,17,105,21],[31,17,105,22,293],[42,17,105,33]],[[20,17,106,11],[24,17,106,15],[25,17,106,16,277],[30,17,106,21],[31,17,106,22,294],[43,17,106,34]],[[34,17,107,10],[35,17,107,10],[38,17,107,10],[50,17,107,10],[53,17,107,10],[55,17,107,11,295],[59,17,107,15],[60,17,107,16,277],[65,17,107,21],[66,17,107,22,296],[80,17,107,36],[82,17,107,36]],[[24,17,108,12,280],[31,17,108,19],[35,17,108,23],[36,17,108,24,281],[41,17,108,29],[42,17,108,30,280],[47,17,108,35]],[[24,17,109,12,278],[31,17,109,19],[35,17,109,23],[36,17,109,24,278],[41,17,109,29]],[],[],[],[[8,17,113,4]],[[8,17,115,4],[15,17,115,11],[19,17,115,15],[20,17,115,16,277],[25,17,115,21],[26,17,115,22,297],[34,17,115,30]],[[4,17,116,2]],[[0,17,117,0]],[[0,17,128,7],[9,17,128,16,267],[23,17,128,30],[25,17,129,2,296],[39,17,129,16],[41,17,130,2,293],[52,17,130,13],[54,17,131,2,294],[66,17,131,14],[68,17,132,2,297],[76,17,132,10],[78,17,135,1]],[[4,17,136,2],[81,17,136,79]],[[4,17,137,2],[73,17,137,71]],[[4,17,138,2],[76,17,138,74]],[[4,17,139,2],[72,17,139,70]],[[4,17,140,2],[10,17,140,8,283],[21,17,140,19,298],[22,17,140,19,298],[25,17,140,19,298],[46,17,140,19,298],[66,17,140,39]],[[4,17,141,2],[8,17,141,6,296],[24,17,141,22]],[[8,17,142,4],[15,17,142,4],[26,17,142,4],[29,17,143,6],[30,17,143,6],[33,17,143,6],[45,17,143,6],[48,17,143,6],[50,17,143,7,268],[72,17,143,7,268]],[[12,17,144,8,283],[22,17,144,18,283]],[[12,17,145,8,296],[28,17,145,24,296]],[[12,17,146,8,293],[25,17,146,21,293]],[[12,17,147,8,294],[26,17,147,22,294]],[[22,17,149,9,297]],[],[[4,17,152,2]],[[4,17,154,2],[11,17,154,2],[22,17,154,2],[25,17,154,9],[26,17,154,9],[29,17,154,9],[41,17,154,9],[44,17,154,9],[46,17,154,9],[58,17,154,9],[66,17,154,9],[68,17,154,9]],[[18,17,154,12,297]],[],[[0,17,155,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,18,51,0],[31,18,50,0],[74,18,51,43],[111,18,50,80]],[[0,18,52,0],[11,18,52,0]],[],[],[[15,18,52,0]],[],[],[],[[32,18,2,31]],[[0,18,4,0],[6,18,4,6,299],[15,18,4,15]],[[4,18,5,2,300],[11,18,5,9]],[[8,18,6,4],[98,18,6,94]],[[8,18,7,4,301],[20,18,8,6]],[[8,18,9,4,302],[16,18,9,12]],[[8,18,10,4,303],[19,18,10,15]],[[8,18,11,4,304],[17,18,11,13]],[[8,18,12,4,305],[23,18,12,19]],[[8,18,13,4,306],[20,18,13,16]],[[8,18,14,4,307],[24,18,14,20]],[[4,18,15,2]],[[4,18,16,2,308],[10,18,16,8]],[[8,18,17,4,309],[18,18,17,14]],[[8,18,18,4,310],[20,18,18,16]],[[8,18,19,4,311],[20,18,19,16]],[[8,18,20,4,312],[16,18,20,12]],[[4,18,21,2]],[[0,18,22,0]],[[0,18,27,0],[9,18,27,9,313],[28,18,27,28],[30,18,27,30,300],[35,18,27,35],[37,18,27,53]],[[4,18,28,2],[10,18,28,8,314],[19,18,28,37,300],[26,18,28,44,314]],[[4,18,29,2],[11,18,29,2],[22,18,29,2],[25,18,30,4],[26,18,30,4],[29,18,30,4],[41,18,30,4],[45,18,30,4],[47,18,30,5,315],[55,18,30,5,315]],[[8,18,30,10,316],[12,18,30,13]],[],[[26,18,31,6],[27,18,31,6],[30,18,31,6],[42,18,31,6],[45,18,31,6],[47,18,31,7,317],[55,18,31,7,317],[56,18,31,7,317]],[[26,18,32,6],[27,18,32,6],[30,18,32,6],[42,18,32,6],[46,18,32,6],[48,18,32,7,318],[56,18,32,7,318]],[],[[34,18,33,8],[35,18,33,8],[38,18,33,8],[50,18,33,8],[53,18,33,8],[55,18,33,9,319],[71,18,33,9,319],[85,18,33,23],[87,18,33,23]],[[24,18,33,24,300],[31,18,33,31,300]],[],[[34,18,34,8],[35,18,34,8],[38,18,34,8],[50,18,34,8],[53,18,34,8],[55,18,34,9,320],[62,18,34,9,320]],[[24,18,34,13,321],[31,18,34,20,299],[38,18,34,27,300],[43,18,34,32]],[[34,18,35,10],[45,18,35,10],[48,18,35,10],[49,18,35,10],[52,18,35,10],[64,18,35,10],[68,18,35,10],[70,18,35,11,320],[77,18,35,11,320]],[],[[46,18,36,12],[47,18,36,12],[50,18,36,12],[62,18,36,12],[66,18,36,12],[68,18,36,13,322],[74,18,36,13,322]],[[36,18,36,16,321],[43,18,36,23,299],[50,18,36,30,308],[54,18,36,34]],[],[[40,18,36,36]],[[40,18,37,36,314],[49,18,37,45],[60,18,37,56]],[[40,18,37,65]],[[40,18,38,42,323],[47,18,38,49,324],[55,18,38,57],[56,18,38,58,325],[64,18,38,66]],[[40,18,38,67]],[[40,18,38,77]],[[40,18,39,15,314],[49,18,39,24],[65,18,39,40]],[[40,18,39,58]],[],[],[[32,18,42,13,314],[41,18,42,13,314],[52,18,42,13,314],[55,18,42,22],[56,18,42,22],[59,18,42,22],[71,18,42,22],[74,18,42,22],[76,18,42,23,326],[81,18,42,23,326]],[[36,18,42,25,321],[43,18,42,32,299],[50,18,42,39,308],[54,18,42,43]],[[46,18,42,46],[47,18,42,47],[55,18,42,55],[57,18,42,57,314],[65,18,42,65]],[[37,18,42,73]],[],[],[],[],[],[],[],[[0,18,48,0]],[[6,18,52,0],[17,18,52,15,313]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,19,0,13,327],[54,19,0,13,327]],[],[],[[15,19,0,13,327]],[],[],[[0,19,0,7],[6,19,0,13,327],[28,19,0,35]],[[4,19,1,2,328],[21,19,1,19]],[[0,19,2,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,20,22,16,329],[43,20,22,16,329]],[],[],[[15,20,22,16,329]],[],[],[[36,20,3,7]],[[0,20,5,0]],[],[],[],[],[],[],[],[],[],[],[],[],[[1,20,18,1],[4,20,20,0],[10,20,20,6,330],[19,20,20,15],[22,20,20,18,331],[42,20,20,18,331],[72,20,20,48],[73,20,20,49],[77,20,20,53],[78,20,20,54]],[[0,20,22,7],[9,20,22,16,329]],[[4,20,23,2],[10,20,23,8,332],[18,20,23,16],[25,20,23,16],[39,20,23,33],[40,20,23,16],[44,20,23,20,333],[50,20,23,26,330],[59,20,23,16],[80,20,23,16]],[[15,20,23,16]],[[20,20,23,16]],[[22,20,23,16]],[[4,20,23,32]],[[4,20,24,4,332],[10,20,24,38,334],[16,20,24,44],[19,20,24,47,330]],[[4,20,26,2],[10,20,26,8,332]],[[0,20,27,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,21,10,2,338],[8,21,10,10,339],[11,21,10,13],[12,21,10,14,340],[20,21,10,22],[25,21,10,27],[40,21,11,7,341],[48,21,11,15]],[[0,21,0,0],[81,21,0,81]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,21,18,16,335],[17,21,18,29],[19,21,18,29]],[[15,21,18,16,335]],[],[[4,21,97,16,336],[19,21,97,31],[21,21,97,31]],[[15,21,97,16,336]],[],[],[],[[35,21,3,34]],[[30,21,4,36]],[[35,21,5,34]],[[31,21,6,37]],[[70,21,7,33]],[[0,21,9,0],[6,21,9,6,337],[195,21,12,6]],[[0,21,18,7],[9,21,18,16,335],[23,21,19,2,348],[34,21,19,22],[36,21,20,2,349],[45,21,20,60]],[[4,21,22,2],[10,21,22,8,350],[35,21,22,33,349],[45,21,22,43,351],[58,21,22,56],[60,21,22,58,352]],[[4,21,24,2],[8,21,24,6,353]],[[4,21,26,2],[8,21,26,6,338],[16,21,26,14,339],[19,21,26,17],[20,21,26,18,340],[28,21,26,26],[33,21,26,31],[44,21,26,45]],[[8,21,27,4],[14,21,27,10],[16,21,27,12,354],[42,21,27,38],[44,21,27,40],[47,21,28,6,341],[55,21,28,14]],[[8,21,30,4,353],[34,21,31,6,350],[61,21,31,33,354]],[[4,21,32,2]],[[4,21,34,2,353],[30,21,35,4,353],[57,21,36,5,350],[84,21,36,32,355],[99,21,36,32,355],[119,21,36,52],[123,21,37,7,349],[133,21,37,17,351],[146,21,37,30],[147,21,38,9,356],[152,21,38,14],[153,21,38,15,357],[167,21,38,29],[172,21,38,34,358],[185,21,38,34,358],[192,21,38,54]],[[4,21,40,2],[48,21,40,46]],[[4,21,41,2],[8,21,41,6,338],[16,21,41,14,339],[19,21,41,17],[20,21,41,18,340],[28,21,41,26],[33,21,41,31],[44,21,41,45]],[[8,21,42,4],[14,21,42,10],[16,21,42,12,359],[56,21,42,52],[58,21,42,54],[61,21,43,6,341],[69,21,43,14]],[[8,21,44,4],[12,21,45,6,348],[35,21,45,29,360],[44,21,46,6,348],[56,21,46,18,361],[63,21,46,25],[68,21,46,30,359],[110,21,47,6]],[[12,21,48,6]],[[8,21,49,4]],[[4,21,50,2]],[[4,21,52,2],[8,21,52,6,353],[33,21,52,31]],[[8,21,53,4],[85,21,53,81]],[[8,21,54,4],[63,21,54,59]],[[8,21,55,4],[69,21,55,65]],[[8,21,56,4],[15,21,56,11,336],[31,21,56,27,348]],[[4,21,57,2]],[[4,21,59,2],[81,21,59,79]],[[4,21,60,2],[8,21,60,6,362],[9,21,60,6,362],[12,21,60,6,362],[26,21,60,6,362],[45,21,60,25],[47,21,60,26,348],[63,21,60,42,363],[64,21,60,42,363],[67,21,60,42,363],[86,21,60,42,363],[103,21,60,59],[105,21,60,60,348],[119,21,60,74]],[[4,21,62,2],[8,21,62,6,338],[16,21,62,14,339],[19,21,62,17],[20,21,62,18,340],[28,21,62,26],[33,21,62,31],[44,21,62,45]],[[8,21,63,4],[14,21,63,10,364],[34,21,65,6],[34,21,64,6],[34,21,65,7,350],[58,21,65,39,365],[69,21,64,41],[73,21,66,6,350],[97,21,66,30,366],[105,21,67,6]],[[8,21,69,4],[14,21,69,10,367],[42,21,69,38,349],[53,21,69,49,368],[69,21,69,65,369],[75,21,69,71],[80,21,69,76],[81,21,69,77],[83,21,69,79]],[[8,21,71,4],[45,21,71,41]],[[8,21,72,4],[14,21,72,10,370],[24,21,73,6],[24,21,74,6],[78,21,73,60],[125,21,74,107]],[[8,21,75,6],[104,21,75,102]],[[8,21,76,6,367],[35,21,76,33,371],[41,21,76,39],[69,21,76,67],[71,21,76,69]],[[8,21,77,4],[14,21,77,10,372],[41,21,77,37,370],[48,21,77,44],[49,21,77,45],[51,21,77,47],[55,21,77,51,370],[62,21,77,58],[63,21,77,59],[65,21,77,61],[69,21,77,65]],[[8,21,79,4],[137,21,79,133]],[[8,21,80,4],[14,21,80,10,373],[37,21,80,33],[38,21,80,34],[61,21,80,57],[63,21,80,59,364],[81,21,80,77],[98,21,80,94],[99,21,80,95]],[[8,21,81,4],[14,21,81,10,374],[38,21,81,34,372],[77,21,82,8],[78,21,82,9],[111,21,82,42],[113,21,82,44,372],[138,21,82,69],[150,21,82,81],[151,21,82,82],[154,21,83,8],[155,21,83,9],[206,21,83,60],[207,21,83,61]],[[8,21,85,4],[14,21,85,10,375],[30,21,85,26],[33,21,85,29,374],[55,21,85,51],[56,21,85,52],[58,21,85,54,373],[80,21,85,76]],[[8,21,86,4],[14,21,86,10,343],[22,21,86,18,337],[38,21,86,34,342],[54,21,86,50],[55,21,86,51,348]],[[8,21,88,4],[87,21,88,83]],[[8,21,89,4,337],[24,21,89,20,345],[42,21,89,38],[43,21,89,39],[55,21,89,51,348],[68,21,89,64,375]],[[8,21,91,4,337],[24,21,91,20,344],[41,21,91,37],[42,21,91,38,343]],[[4,21,92,2],[11,21,92,9]],[],[[0,21,95,0]],[[0,21,97,7],[9,21,97,16,336],[25,21,97,32,348],[36,21,97,52]],[[4,21,98,2],[81,21,98,79]],[[4,21,99,2],[8,21,99,6,362],[9,21,99,6,362],[12,21,99,6,362],[26,21,99,6,362],[45,21,99,25],[47,21,99,26,348],[63,21,99,42,363],[64,21,99,42,363],[67,21,99,42,363],[86,21,99,42,363],[103,21,99,59],[105,21,99,60,348],[119,21,99,74]],[[4,21,101,2],[8,21,101,6,338],[16,21,101,14,339],[19,21,101,17],[20,21,101,18,340],[28,21,101,26],[33,21,101,31],[44,21,101,45]],[[8,21,102,4],[14,21,102,10,343],[22,21,102,18,337],[38,21,102,34,342],[54,21,102,50],[55,21,102,51,348]],[[8,21,104,4],[92,21,104,88]],[[8,21,105,4,376],[9,21,105,4,376],[12,21,105,4,376],[31,21,105,4,376],[48,21,105,21],[50,21,105,22,343]],[[4,21,106,2],[11,21,106,9]],[],[[0,21,109,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,22,12,13,377],[22,22,12,31],[24,22,12,31]],[[15,22,12,13,377]],[],[[4,22,9,13,378],[19,22,9,28],[21,22,9,28]],[[15,22,9,13,378]],[],[[4,22,8,13,379],[18,22,8,27],[20,22,8,27]],[[15,22,8,13,379]],[],[[4,22,10,13,380],[18,22,10,27],[20,22,10,27]],[[15,22,10,13,380]],[],[[4,22,13,13,381],[24,22,13,33],[26,22,13,33]],[[15,22,13,13,381]],[],[[4,22,11,13,382],[23,22,11,32],[25,22,11,32]],[[15,22,11,13,382]],[],[[4,22,150,12,383],[16,22,150,24],[18,22,150,24]],[[15,22,150,12,383]],[],[],[[0,22,8,7],[6,22,8,13,379],[23,22,8,30]],[[0,22,9,7],[6,22,9,13,378],[24,22,9,31]],[[0,22,10,7],[6,22,10,13,380],[23,22,10,30]],[[0,22,11,7],[6,22,11,13,382],[28,22,11,35]],[[0,22,12,7],[6,22,12,13,377],[27,22,12,34]],[[0,22,13,7],[6,22,13,13,381],[29,22,13,36]],[[0,22,150,7],[4,22,150,12,383],[19,22,150,12,383],[30,22,150,12,383],[33,22,150,12,383],[42,22,150,12,383],[54,22,150,12,383]],[],[],[[11,22,150,12,383]],[],[],[],[],[],[],[],[],[],[],[],[],[[0,23,24,16,390],[8,23,24,24,391],[11,23,24,27],[12,23,24,28,392],[20,23,24,36]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,23,15,16,384],[27,23,15,39],[29,23,15,39]],[[15,23,15,16,384]],[],[[4,23,30,16,385],[18,23,30,30],[20,23,30,30]],[[15,23,30,16,385]],[],[],[],[[65,23,1,36]],[[28,23,2,27]],[[0,23,10,0],[77,23,10,77]],[[0,23,11,0],[79,23,11,79]],[[0,23,12,0],[14,23,12,14]],[[0,23,13,0],[4,23,13,4,386],[15,23,13,48]],[[0,23,15,7],[9,23,15,16,384],[33,23,15,40,387],[39,23,15,62]],[[4,23,16,2],[8,23,16,6,386],[21,23,16,19],[27,23,16,25]],[[8,23,17,4],[14,23,17,10],[21,23,17,10],[35,23,19,5],[36,23,17,10],[40,23,17,14,388],[46,23,18,6],[122,23,17,10],[143,23,17,10]],[[19,23,17,10]],[[24,23,17,10]],[[26,23,17,10]],[[8,23,19,4]],[[4,23,20,2]],[[4,23,21,2,386],[13,23,21,11,387]],[[0,23,22,0]],[[0,23,24,0],[6,23,24,6,389],[68,23,24,41]],[[0,23,25,0],[6,23,25,6,393],[30,23,28,4,389],[69,23,28,14],[73,23,28,18,394],[85,23,28,31]],[[0,23,30,7],[9,23,30,16,385],[24,23,31,2,395],[35,23,31,35]],[[4,23,33,2],[10,23,33,8],[11,23,33,9,396],[18,23,33,16,397],[27,23,33,25],[30,23,33,28,398],[37,23,33,28,398],[44,23,33,33],[45,23,33,34,399],[53,23,33,42],[54,23,33,57,395],[66,23,33,69,396],[71,23,33,74]],[[4,23,35,2],[81,23,35,79]],[[4,23,36,2],[81,23,36,79]],[[4,23,37,2],[77,23,37,75]],[[4,23,38,2],[75,23,38,73]],[[4,23,39,2],[80,23,39,78]],[[4,23,40,2],[80,23,40,78]],[[4,23,41,2],[36,23,41,34]],[[4,23,42,2],[8,23,42,6,390],[16,23,42,14,391],[19,23,42,17],[20,23,42,18,392],[28,23,42,26],[33,23,42,31],[44,23,42,45]],[[8,23,43,4],[14,23,43,10],[16,23,43,12,400],[43,23,43,39],[45,23,43,41],[48,23,44,6,401],[56,23,44,14]],[[8,23,45,4],[62,23,45,58]],[[8,23,46,4],[14,23,46,10,402],[41,23,46,37,400]],[[8,23,48,4,386],[19,23,48,15],[20,23,48,16,387]],[[12,23,49,6,402],[37,23,49,31]],[[16,23,50,8,395],[28,23,50,20,386],[36,23,50,28],[37,23,50,29,387],[45,23,50,37,397]],[[12,23,51,6]],[[8,23,52,4]],[[4,23,53,2],[11,23,53,9]],[],[[4,23,58,2],[79,23,58,77]],[[4,23,59,2],[78,23,59,76]],[[4,23,60,2],[77,23,60,75]],[[4,23,61,2],[80,23,61,78]],[[4,23,62,2],[29,23,62,27]],[[4,23,63,2],[10,23,63,8,403],[31,23,63,29,404],[32,23,63,29,404],[35,23,63,29,404],[42,23,63,29,404],[49,23,63,36],[51,23,63,37]],[[8,23,64,4],[12,23,64,8],[13,23,64,9,389],[22,23,64,18]],[],[[8,23,68,4],[12,23,68,8,405],[13,23,68,8,405],[16,23,68,8,405],[28,23,68,8,405],[38,23,68,18],[40,23,68,19,396],[48,23,68,27]],[[12,23,69,6],[90,23,69,84]],[[12,23,70,6],[94,23,70,88]],[[12,23,71,6],[16,23,71,10,406],[39,23,71,33,393],[61,23,71,55,407],[64,23,71,58],[65,23,71,59,396]],[[12,23,72,6],[16,23,72,10,406],[41,23,72,35,408],[52,23,72,46]],[[16,23,73,8],[22,23,73,14,409],[34,23,73,42],[36,23,73,44]],[[16,23,74,8,406],[39,23,74,31,410],[47,23,74,39,411],[54,23,74,46],[55,23,74,47,396],[62,23,74,54,412],[66,23,74,58],[67,23,74,59],[68,23,74,60,413]],[[20,23,75,10],[24,23,75,14,413],[35,23,75,25,409],[44,23,75,34],[49,23,75,39],[55,23,75,45]],[[24,23,76,12,409],[34,23,76,22,414],[38,23,76,26],[42,23,76,30,413],[53,23,76,41,409],[62,23,76,50]],[[20,23,77,10]],[[20,23,78,10],[27,23,78,17,413]],[[16,23,79,8]],[[16,23,80,8,406],[37,23,80,29,415],[47,23,80,39],[50,23,80,42,409]],[[16,23,82,8,393],[38,23,82,30,416],[41,23,82,33],[42,23,82,34,396],[49,23,82,41,406]],[[12,23,83,6]],[[12,23,85,6],[19,23,85,13,406]],[[8,23,86,4]],[[8,23,87,4],[15,23,87,11,396]],[[4,23,88,2],[7,23,88,5]],[[8,23,88,6,396]],[[5,23,88,12]],[[4,23,90,2],[11,23,90,9,405],[12,23,90,9,405],[15,23,90,9,405],[27,23,90,9,405],[37,23,90,19],[39,23,90,20,403],[61,23,91,6,417],[62,23,91,6,417],[65,23,91,6,417],[72,23,91,6,417],[75,23,91,9],[77,23,91,10,403],[99,23,92,6,403]],[[0,23,93,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,24,4,22,418],[45,24,4,22,418]],[],[],[[15,24,4,22,418]],[],[],[[23,24,0,32]],[[36,24,1,37]],[[32,24,2,40]],[[0,24,4,7],[15,24,4,22,418],[26,24,4,33,419],[34,24,4,49],[36,24,4,51,420],[46,24,4,68]],[[4,24,5,2],[11,24,5,9],[15,24,5,13,421],[23,24,5,21],[24,24,5,22,422],[33,24,5,31,423]],[[8,24,6,4,424],[9,24,6,4,424],[12,24,6,4,424],[19,24,6,4,424],[34,24,6,19],[36,24,6,20]],[[12,24,7,6,425],[13,24,7,6,425],[16,24,7,6,425],[32,24,7,6,425],[55,24,7,29],[57,24,7,30]],[[16,24,8,8,426],[22,24,8,14,427],[42,24,8,14,427],[62,24,8,34]],[[16,24,9,8,419]],[[16,24,10,8,420]],[[16,24,11,8,422]],[[16,24,12,8,423]],[[12,24,13,6]],[[8,24,14,4]],[[4,24,15,2]],[[0,24,16,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,25,0,17,430],[8,25,0,25,431],[11,25,0,28],[12,25,0,29,432],[34,25,0,51]],[],[],[],[],[[31,25,3,13,428],[51,25,3,13,428]],[],[],[[15,25,3,13,428]],[],[],[[0,25,0,0],[6,25,0,6,429],[57,25,0,55]],[[0,25,1,0],[6,25,1,6,433],[17,25,1,17],[20,25,1,20,429],[29,25,1,29],[49,25,1,49],[50,25,1,50]],[[0,25,3,7],[6,25,3,13,428],[25,25,4,2,430],[33,25,4,10,431],[36,25,4,13],[37,25,4,14,434],[45,25,4,22],[50,25,4,27],[64,25,5,6],[73,25,5,15,428],[90,25,5,32,435],[98,25,5,48]],[[4,25,6,8],[8,25,6,12,435],[21,25,6,25],[25,25,6,29]],[[8,25,7,10],[15,25,7,17]],[[4,25,8,8]],[[4,25,10,8],[8,25,11,10,435],[17,25,11,19,436],[27,25,11,29],[28,25,11,30,437],[37,25,11,39,438],[45,25,11,47],[46,25,11,48,439],[52,25,11,54],[57,25,12,10,435],[66,25,12,19,440],[74,25,12,27],[75,25,12,28],[93,25,13,10]],[[8,25,14,10],[74,25,14,76]],[[8,25,15,10],[75,25,15,77]],[[8,25,16,10],[77,25,16,79]],[[8,25,17,10],[75,25,17,77]],[[8,25,18,10],[77,25,18,79]],[[8,25,19,10],[68,25,19,70]],[[8,25,20,10],[53,25,20,55]],[[8,25,21,10],[15,25,21,17],[18,25,21,20,435],[27,25,21,29],[31,25,21,33],[32,25,21,34]],[[4,25,22,8]],[[4,25,24,8],[10,25,24,14,441],[16,25,24,20],[20,25,24,24,442],[24,25,24,28,433],[34,25,24,38,437],[43,25,24,47,438],[51,25,24,55],[52,25,24,56,439],[58,25,24,62]],[[4,25,25,8,441],[8,25,25,12,443],[20,25,25,24],[21,25,25,25,444],[24,25,25,28],[25,25,25,29],[37,25,25,41,435]],[[4,25,27,8],[11,25,27,15,441],[15,25,27,19,445],[19,25,27,23]],[[0,25,28,6],[4,25,29,6,446]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,26,2,13,447],[47,26,2,13,447]],[],[],[[15,26,2,13,447]],[],[],[[0,26,2,7],[6,26,2,13,447],[21,26,2,28],[22,26,3,2,448],[39,26,4,2,449]],[[4,26,6,2],[40,26,6,38]],[[4,26,7,2],[8,26,7,6],[15,26,7,13,448],[35,26,7,33],[45,26,7,43]],[[8,26,8,4],[12,26,8,8],[19,26,8,15,449],[31,26,8,27],[41,26,8,37]],[[12,26,9,6],[52,26,9,46]],[[12,26,10,6],[19,26,10,13,448],[39,26,10,33,449]],[[8,26,11,4]],[[8,26,12,4],[15,26,12,11]],[[4,26,13,2]],[[4,26,15,2],[8,26,15,6],[15,26,15,13,449],[27,26,15,25],[37,26,15,35]],[[8,26,16,4],[15,26,16,11]],[[4,26,17,2]],[[4,26,18,2],[11,26,18,9,448],[26,26,18,24],[27,26,18,25],[29,26,18,27],[34,26,18,32,449],[41,26,18,39],[42,26,18,40],[44,26,18,42],[48,26,18,46,448],[63,26,18,61],[64,26,18,62],[66,26,18,64],[71,26,18,69,449],[78,26,18,76],[79,26,18,77],[81,26,18,79]],[[0,26,19,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,27,120,16,450],[22,27,120,34],[24,27,120,34]],[[15,27,120,16,450]],[],[[4,27,42,16,451],[36,27,42,48],[38,27,42,48]],[[15,27,42,16,451]],[],[[4,27,137,16,452],[21,27,137,33],[23,27,137,33]],[[15,27,137,16,452]],[],[],[[36,27,4,43]],[[25,27,10,7]],[[31,27,11,29]],[[0,27,13,0],[6,27,13,6,453],[27,27,13,27],[28,27,13,28,454]],[[4,27,14,2],[11,27,14,9,454],[18,27,14,16],[19,27,14,17],[21,27,14,19],[26,27,14,24],[32,27,14,30,454],[40,27,14,38,455],[45,27,14,43],[46,27,14,44],[51,27,14,49,454]],[[0,27,15,0]],[[0,27,17,0],[6,27,17,6,456],[26,27,17,26],[27,27,17,27,454]],[[4,27,18,2],[8,27,18,6],[15,27,18,13,454],[27,27,18,25],[37,27,18,35]],[[8,27,19,4],[127,27,19,123]],[[8,27,20,4],[120,27,20,116]],[[8,27,21,4],[12,27,21,8,454],[24,27,21,20],[36,27,21,32],[43,27,21,39]],[[8,27,23,4],[15,27,23,11,454]],[[4,27,24,2]],[[4,27,26,2],[11,27,26,9,454],[18,27,26,16],[19,27,26,17],[21,27,26,19]],[[0,27,27,0]],[[0,27,29,0],[9,27,29,9,457],[27,27,29,27,458],[35,27,29,45]],[[4,27,30,2],[11,27,31,4,458],[20,27,31,13,459],[26,27,31,19],[27,27,31,20],[28,27,31,21,460],[33,27,31,26,454]],[[8,27,32,6,454],[18,27,32,16,453],[37,27,32,35,454]],[[8,27,33,6],[12,27,33,10,454],[24,27,33,22],[30,27,33,28,461],[31,27,33,28,461],[34,27,33,28,461],[43,27,33,28,461],[57,27,33,42],[59,27,33,43,454],[69,27,33,53]],[[12,27,34,8],[19,27,34,15,460]],[[8,27,35,6]],[[8,27,37,6],[15,27,37,13],[18,27,37,16,460],[22,27,37,20],[23,27,37,21],[25,27,37,23,454],[34,27,37,32]],[[4,27,38,4],[7,27,38,7],[14,27,38,14]],[[0,27,40,0]],[[0,27,42,7],[9,27,42,16,451],[42,27,43,2,462],[59,27,43,38]],[[4,27,45,2],[10,27,45,8,454],[20,27,45,18,463],[26,27,45,24,464],[33,27,45,31],[34,27,45,32,462],[51,27,45,49],[52,27,45,50],[54,27,45,52],[58,27,46,6,462],[75,27,46,23],[76,27,46,24],[78,27,46,26],[79,27,46,27],[81,27,46,29],[84,27,47,6,462],[101,27,47,23],[102,27,47,24],[104,27,47,26]],[[4,27,49,2],[8,27,50,4,454],[20,27,50,16,465],[29,27,50,16,465],[48,27,50,35],[52,27,51,4,466],[72,27,51,4,466],[98,27,51,30],[99,27,51,31,467],[103,27,51,35],[104,27,51,36],[105,27,51,37,468],[109,27,51,43,454],[117,27,51,51,469],[127,27,51,61],[128,27,51,62,468],[133,27,53,4],[140,27,53,11,470]],[[4,27,55,2],[8,27,55,6,454],[16,27,55,14,469],[26,27,55,24],[27,27,55,25,471],[36,27,55,25,471],[52,27,55,41],[55,27,55,44],[62,27,55,51]],[[4,27,57,2],[10,27,57,8,458],[21,27,57,19]],[[8,27,57,20,456],[26,27,57,38,454]],[[5,27,57,47]],[[4,27,58,2],[10,27,58,8,472],[27,27,58,25,462],[44,27,58,42],[45,27,58,43],[47,27,58,45],[51,27,58,49],[52,27,58,50]],[[4,27,60,2],[10,27,60,8,473],[25,27,60,23,472],[40,27,60,38,474],[48,27,60,46],[51,27,61,6,451],[84,27,61,39,472],[99,27,61,54,474],[107,27,61,62],[111,27,62,6,470]],[[4,27,64,2],[8,27,64,6,473],[25,27,64,23,470],[36,27,64,34]],[[8,27,65,4,458],[17,27,65,13,475],[21,27,65,17],[22,27,65,18,473]],[[4,27,66,2],[11,27,66,9]],[[8,27,67,4],[13,27,67,9],[19,27,67,15],[20,27,67,16,476],[25,27,67,21,477],[31,27,67,27],[35,27,67,31,478],[42,27,67,38,479],[49,27,67,45],[50,27,67,46,472],[66,27,67,63]],[[12,27,68,6],[16,27,68,10,476],[24,27,68,18],[36,27,68,30]],[[12,27,70,6],[18,27,70,12,480],[30,27,70,24,451],[63,27,70,57,477]],[[12,27,72,6],[16,27,72,10,480],[30,27,72,24,470],[41,27,72,35]],[[16,27,73,8,458],[25,27,73,17,475],[29,27,73,21],[30,27,73,22,480]],[[12,27,74,6]],[[8,27,75,4]],[[4,27,76,2]],[[4,27,78,2],[11,27,78,9,457],[29,27,78,27,458]],[[0,27,79,0]],[[0,27,81,0],[9,27,81,9,481],[32,27,82,2,482],[37,27,82,26],[39,27,83,2,483],[44,27,83,26]],[[4,27,85,2],[10,27,85,8],[11,27,85,9,484],[21,27,85,19,485],[37,27,85,35],[40,27,85,38,482]],[[4,27,86,2],[10,27,86,8],[11,27,86,9,486],[21,27,86,19,487],[37,27,86,35],[40,27,86,38,483]],[[4,27,88,2],[10,27,88,8,488],[31,27,88,29,456],[49,27,88,47,484]],[[4,27,89,2],[10,27,89,8,489],[31,27,89,29,456],[49,27,89,47,486]],[[4,27,91,2],[8,27,92,4,466],[28,27,92,4,466],[54,27,92,30],[55,27,92,31,467],[59,27,92,35],[60,27,93,6],[61,27,93,7,468],[65,27,94,8,488],[84,27,94,27,469],[94,27,94,37],[95,27,94,38,468],[101,27,94,44,489],[120,27,94,63,469],[130,27,94,73],[131,27,94,74,468],[136,27,96,4]],[[8,27,97,4],[15,27,97,11]],[[4,27,98,2]],[[4,27,100,2],[8,27,100,6],[9,27,100,7,490],[10,27,100,7,490],[13,27,100,7,490],[28,27,100,7,490],[40,27,100,19],[42,27,100,20,484],[52,27,100,30,486],[63,27,100,41]],[[8,27,101,4],[102,27,101,98]],[[8,27,102,4],[15,27,102,11,451],[48,27,102,44,483],[58,27,102,54]],[[4,27,103,2]],[[4,27,105,2],[8,27,105,7],[14,27,105,13,491],[35,27,105,34,485],[51,27,105,51]],[[8,27,106,4],[12,27,106,8,487],[27,27,106,23],[28,27,106,24,491],[46,27,106,42],[48,27,106,44]],[[12,27,107,6],[18,27,107,12,492],[32,27,107,26,481],[55,27,108,8,485],[70,27,108,23],[71,27,108,24,491],[89,27,108,42],[91,27,109,8,487],[106,27,109,23],[107,27,109,24,491],[125,27,109,42]],[[12,27,111,6],[16,27,111,10,492],[32,27,111,26],[38,27,111,32]],[[16,27,112,8],[23,27,112,15],[26,27,112,18,456],[44,27,112,36,486],[54,27,112,46],[55,27,112,47],[57,27,112,49,492],[70,27,112,62]],[[12,27,113,6]],[[8,27,114,4]],[[4,27,115,2]],[[4,27,117,2],[11,27,117,9]],[[0,27,118,0]],[[0,27,120,7],[9,27,120,16,450],[28,27,121,2,482],[33,27,121,26],[35,27,122,2,483],[40,27,122,26]],[[4,27,124,2],[10,27,124,8,492],[24,27,124,22,481],[47,27,124,45,482],[54,27,124,52,483]],[[4,27,126,2],[8,27,126,6,492],[23,27,126,21],[31,27,126,29,492],[47,27,126,45],[52,27,126,50]],[[8,27,127,4],[15,27,127,11,492]],[[4,27,128,2]],[[4,27,130,2],[55,27,130,53]],[[4,27,131,2],[11,27,131,9,457],[29,27,131,27,492],[41,27,131,39,493],[46,27,131,44],[47,27,131,45]],[[0,27,132,0]],[[0,27,137,7],[9,27,137,16,452],[27,27,138,2,494],[38,27,138,32],[40,27,139,2,495],[49,27,139,19],[50,27,139,20],[51,27,139,21]],[[4,27,141,2],[10,27,141,8,472],[27,27,141,25,494],[38,27,141,36],[39,27,141,37],[41,27,141,39]],[[4,27,143,2],[9,27,143,7],[15,27,143,13,496],[32,27,143,30,478],[39,27,143,37,497],[45,27,143,43],[46,27,143,44,472],[62,27,143,61]],[[8,27,144,4],[14,27,144,10,454],[24,27,144,20,496],[37,27,144,33],[38,27,144,34],[40,27,144,36]],[[8,27,145,4],[14,27,145,10,498],[35,27,145,31,463],[41,27,145,37,464],[48,27,145,44],[49,27,145,45,454]],[[8,27,146,4],[14,27,146,10,499],[29,27,146,25,498],[50,27,146,46,454],[57,27,146,53],[58,27,146,54],[60,27,146,56],[63,27,146,59,454]],[[8,27,147,4],[12,27,147,8],[13,27,147,9,499],[29,27,147,25,499],[42,27,147,38,469],[52,27,147,48],[53,27,147,49,471],[62,27,147,49,471],[78,27,147,65],[81,27,147,68]],[[8,27,149,4],[73,27,149,69]],[[8,27,150,4],[14,27,150,10,500],[27,27,151,6,498],[49,27,151,29,454],[50,27,151,29,454],[57,27,151,36],[58,27,151,37],[60,27,151,39],[65,27,151,44],[72,27,151,51,454],[79,27,151,58],[80,27,151,59],[82,27,151,61],[87,27,151,66],[91,27,151,69]],[[8,27,153,4],[12,27,153,8,500],[24,27,153,20]],[[12,27,154,6,495],[18,27,154,12],[19,27,154,13,454],[26,27,154,20],[27,27,154,21],[29,27,154,23],[30,27,154,24],[33,27,154,27,454],[40,27,154,34],[41,27,154,35],[43,27,154,37],[44,27,154,38,493],[49,27,154,43],[50,27,154,44]],[[8,27,155,4],[15,27,155,11],[19,27,155,15,498],[39,27,155,35]],[[12,27,156,6,495],[18,27,156,12],[19,27,156,13,454],[26,27,156,20],[27,27,156,21],[29,27,156,23],[30,27,156,24],[33,27,156,27,454],[40,27,156,34],[41,27,156,35],[43,27,156,37]],[[8,27,157,4]],[[8,27,159,4,495],[17,27,159,13,452],[35,27,159,31,496],[50,27,159,46,495]],[[4,27,160,2]],[[4,27,162,2],[11,27,162,9,495]],[[0,27,163,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,28,11,16,501],[48,28,11,16,501]],[],[],[[15,28,11,16,501]],[],[],[[36,28,0,35]],[[0,28,7,0],[9,28,7,9,502],[24,28,7,27,503],[29,28,7,35]],[[4,28,8,2],[11,28,8,9],[18,28,8,16,503],[28,28,8,26]],[[0,28,9,0]],[[0,28,11,7],[9,28,11,16,501],[23,28,12,2,504],[28,28,12,29],[30,28,13,2,505],[37,28,13,18]],[[4,28,15,2],[62,28,15,60]],[[4,28,16,2],[10,28,16,8,506],[25,28,16,23,505],[33,28,16,31,506],[45,28,16,43],[49,28,16,47]],[[4,28,18,2],[8,28,18,6,507],[26,28,18,24,504],[32,28,18,30,507],[47,28,18,45]],[[4,28,19,2],[8,28,19,6,508],[18,28,19,16,504],[24,28,19,22,508],[31,28,19,29]],[[4,28,21,2],[8,28,21,6,502],[23,28,21,21,505],[31,28,21,29,509],[42,28,21,40],[45,28,21,43]],[[8,28,22,4],[78,28,22,74]],[[8,28,23,4],[14,28,23,10,510],[28,28,23,24,511],[29,28,23,24,511],[32,28,23,24,511],[52,28,23,24,511],[70,28,23,42],[72,28,23,43,504],[78,28,23,49,512],[82,28,23,53],[84,28,23,55,505],[92,28,23,63,509],[103,28,23,74]],[[8,28,24,4],[12,28,24,8,510],[25,28,24,21]],[[12,28,25,6],[65,28,25,59]],[[12,28,26,6,507],[30,28,26,24,508]],[[12,28,27,6,508],[22,28,27,16,510]],[[8,28,28,4],[15,28,28,11],[19,28,28,15],[20,28,28,16,508],[29,28,28,25]],[[12,28,29,6],[137,28,29,131]],[[12,28,30,6,508],[22,28,30,16,504],[28,28,30,22,513],[40,28,30,34]],[[8,28,31,4]],[[4,28,32,4],[78,28,32,78]],[[4,28,33,2]],[[4,28,35,2],[11,28,35,9]],[[8,28,36,4],[20,28,36,16]],[[8,28,37,4,513],[22,28,37,18,505],[30,28,37,26,513],[42,28,37,38],[46,28,37,42,504],[52,28,37,48,513],[64,28,37,60]],[[8,28,38,4,514],[24,28,38,20,505],[32,28,38,28,514],[46,28,38,42],[50,28,38,46,504],[56,28,38,52,514],[70,28,38,66]],[[8,28,39,4,515],[17,28,39,13]],[[12,28,40,6,516],[25,28,40,19,502],[40,28,40,34,505],[48,28,40,42,516],[59,28,40,53],[63,28,41,10,505],[71,28,41,18,516],[82,28,41,29],[85,28,42,10,504],[91,28,42,16,515],[98,28,42,23],[99,28,42,24,516],[110,28,42,35]],[[12,28,43,6,517],[27,28,43,21,502],[42,28,43,36,505],[50,28,43,44,517],[63,28,43,57],[67,28,44,10,505],[75,28,44,18,517],[88,28,44,31],[91,28,45,10,504],[97,28,45,16,515],[104,28,45,23],[105,28,45,24,517],[118,28,45,37]],[[12,28,46,6,518],[40,28,46,34,502],[55,28,47,8,505],[63,28,47,16,518],[89,28,47,42],[93,28,49,10,505],[101,28,49,18,518],[127,28,49,44],[130,28,50,10,504],[136,28,50,16,515],[143,28,50,23],[144,28,50,24,518],[170,28,50,50]],[[8,28,51,4]],[[8,28,52,4],[74,28,52,70]],[[8,28,53,4,519],[27,28,53,23]],[[12,28,54,6,520],[19,28,54,13,506],[34,28,55,10,502],[49,28,55,25,505],[58,28,55,34,521],[80,28,56,12],[87,28,57,12,504],[93,28,57,18,519],[110,28,57,35],[111,28,57,36,520],[116,28,57,41],[119,28,59,10]],[[12,28,60,6,522],[28,28,60,22,505],[36,28,60,30,522],[50,28,60,44],[54,28,60,48]],[[12,28,61,6,523],[26,28,61,20,506],[41,28,63,10],[41,28,64,10,505],[49,28,64,18,523],[61,28,64,30],[65,28,64,34,505],[73,28,64,42,523],[77,28,63,46],[85,28,64,54],[90,28,64,59],[95,28,66,12,524],[114,28,66,31,505],[122,28,66,39,523],[134,28,66,51],[135,28,66,52,525],[140,28,66,57],[141,28,66,58],[147,28,67,12,504],[153,28,67,18,519],[170,28,67,35],[171,28,67,36,523],[183,28,67,48],[186,28,69,10]],[[12,28,70,6,526],[26,28,70,20,506],[41,28,71,11,505],[50,28,71,20,521],[72,28,71,42,504],[78,28,71,48,519],[95,28,71,65],[96,28,71,66,526],[108,28,71,78],[111,28,73,10],[113,28,73,12]],[[8,28,74,4]],[[8,28,75,4],[23,28,75,19]],[[8,28,76,4,527],[15,28,76,11,505],[23,28,76,19,527],[28,28,76,24],[31,28,76,27,505],[39,28,76,35,527],[44,28,76,40],[47,28,76,43,504],[53,28,76,49,527],[58,28,76,54]],[[8,28,77,4],[38,28,77,34]],[[8,28,78,4,512],[14,28,78,10,502],[29,28,78,25,505],[37,28,78,33,509],[48,28,78,44],[52,28,79,8,505],[60,28,79,16,509],[71,28,79,27],[74,28,80,8,504],[80,28,80,14,512],[84,28,80,18]],[[8,28,81,4,508]],[[8,28,82,4,507],[25,28,82,21,507]],[[8,28,83,4,528],[19,28,83,15,505],[27,28,83,23,529],[45,28,83,41],[49,28,83,45]],[[4,28,84,2]],[[0,28,85,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,29,183,6,577],[8,29,183,14,578],[11,29,183,17],[12,29,183,18,579],[20,29,183,26],[25,29,183,31],[39,29,183,45]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,29,129,16,530],[32,29,129,44],[34,29,129,44]],[[15,29,129,16,530]],[],[[4,29,157,16,531],[30,29,157,42],[32,29,157,42]],[[15,29,157,16,531]],[],[[4,29,197,16,532],[29,29,197,41],[31,29,197,41]],[[15,29,197,16,532]],[],[[4,29,39,16,533],[23,29,39,35],[25,29,39,35]],[[15,29,39,16,533]],[],[[4,29,21,16,534],[21,29,21,33],[23,29,21,33]],[[15,29,21,16,534]],[],[[4,29,51,16,535],[32,29,51,44],[34,29,51,44]],[[15,29,51,16,535]],[],[[4,29,216,16,536],[35,29,216,47],[37,29,216,47]],[[15,29,216,16,536]],[],[[4,29,180,16,537],[31,29,180,43],[33,29,180,43]],[[15,29,180,16,537]],[],[],[[25,29,5,7]],[[38,29,6,41]],[[34,29,11,7]],[[0,29,21,7],[9,29,21,16,534],[27,29,22,2,538],[35,29,22,43]],[[4,29,24,2],[78,29,24,76]],[[4,29,25,2],[79,29,25,77]],[[4,29,26,2],[80,29,26,78]],[[4,29,27,2],[10,29,27,8,539],[27,29,27,25,538],[36,29,27,34,540],[43,29,27,41],[44,29,27,42,541],[47,29,27,45],[48,29,27,46,542],[66,29,27,46,542],[93,29,27,73]],[[4,29,28,2],[8,29,28,6,539],[27,29,28,25],[33,29,28,31]],[[8,29,29,4],[15,29,30,6,539],[34,29,30,25],[39,29,30,30],[44,29,30,35],[50,29,30,41,539]],[[4,29,32,2]],[[4,29,33,2],[79,29,33,77]],[[4,29,34,2],[33,29,34,31]],[[4,29,35,2],[11,29,35,9,537],[39,29,35,37],[43,29,35,41,543],[47,29,35,45,538],[56,29,35,54,544],[59,29,35,57],[62,29,36,5,545],[68,29,36,11]],[[0,29,37,0]],[[0,29,39,7],[9,29,39,16,533],[29,29,40,2,538],[37,29,40,43]],[[4,29,42,2],[73,29,42,71]],[[4,29,43,2],[81,29,43,79]],[[4,29,44,2],[76,29,44,74]],[[4,29,45,2],[10,29,45,8,546],[26,29,45,24,538],[35,29,45,33,540],[42,29,45,40],[43,29,45,41,541],[46,29,45,44],[47,29,45,45,547],[65,29,45,45,547],[91,29,45,71]],[[4,29,46,2],[11,29,46,10,546],[28,29,47,4,537],[56,29,47,32],[60,29,47,36,543],[64,29,47,40,538],[73,29,47,49,544],[76,29,47,52],[79,29,48,7,548],[87,29,48,15]],[[0,29,49,0]],[[0,29,51,7],[9,29,51,16,535],[38,29,52,2,549],[47,29,52,35],[49,29,53,2,550],[62,29,53,30],[64,29,54,2,551],[73,29,54,19]],[[4,29,56,2],[64,29,56,62]],[[4,29,57,2],[11,29,57,10,549]],[[8,29,58,4],[20,29,58,16]],[[8,29,59,4],[13,29,59,9]],[[12,29,59,14]],[[16,29,60,6],[81,29,60,71]],[[16,29,61,6],[67,29,61,57]],[[16,29,62,6],[23,29,62,13,551],[35,29,62,25,550],[49,29,62,39,552],[55,29,62,45],[58,29,63,10,550],[72,29,63,24,553],[77,29,63,29],[78,29,63,30,551],[89,29,63,41,554],[92,29,63,44],[93,29,63,45],[94,29,63,46,555],[98,29,63,52,556],[117,29,63,71,555],[123,29,64,10],[125,29,64,12]],[[12,29,65,4]],[[8,29,66,4],[31,29,66,27]],[[8,29,67,4],[13,29,67,9]],[[8,29,68,4],[13,29,68,9]],[[8,29,69,4],[13,29,69,9]],[[8,29,70,4],[13,29,70,9]],[[12,29,70,20]],[[16,29,71,6],[22,29,71,12,557],[31,29,71,21,549],[41,29,71,31,552],[47,29,71,37],[50,29,71,40]],[[16,29,72,6],[23,29,72,13,551],[35,29,72,25,550],[49,29,72,39,552],[55,29,72,45],[58,29,73,10,550],[72,29,73,24,553],[77,29,73,29],[78,29,73,30,551],[89,29,73,41,554],[92,29,73,44],[93,29,73,45],[94,29,73,46,555],[97,29,73,49,558]],[[20,29,74,12],[24,29,74,16,558],[30,29,74,22],[33,29,74,25]],[[24,29,75,14],[31,29,75,21,556],[50,29,75,40,555],[52,29,75,42,553],[57,29,75,47],[58,29,75,48,557]],[[20,29,76,12]],[[20,29,78,12],[27,29,78,19,556],[46,29,78,38,555]],[[16,29,79,10],[21,29,80,10],[23,29,80,12]],[[12,29,81,4]],[[8,29,82,4],[29,29,82,25]],[[8,29,83,4],[13,29,83,9]],[[12,29,83,15]],[[16,29,84,6],[89,29,84,79]],[[16,29,85,6],[75,29,85,65]],[[16,29,86,6],[23,29,86,13,551],[35,29,86,25,550],[49,29,86,39,552],[55,29,86,45],[58,29,87,10,550],[72,29,87,24,553],[77,29,87,29],[78,29,87,30,551],[89,29,87,41,554],[92,29,87,44],[93,29,87,45],[94,29,87,46,555],[98,29,87,52,556],[117,29,87,71,555],[123,29,88,10]],[[12,29,89,4]],[[8,29,90,4],[18,29,90,14]],[[8,29,91,4],[13,29,91,9]],[[12,29,91,14]],[[16,29,92,6],[20,29,92,10,551],[33,29,92,23,550],[47,29,92,37,552],[53,29,92,43],[55,29,92,45]],[[20,29,93,8],[91,29,93,79]],[[20,29,94,8],[92,29,94,80]],[[20,29,95,8],[86,29,95,74]],[[20,29,96,8],[89,29,96,77]],[[20,29,97,8],[90,29,97,78]],[[20,29,98,8],[81,29,98,69]],[[20,29,99,8],[40,29,99,28]],[[20,29,100,8],[27,29,100,15]],[[16,29,101,6]],[[16,29,102,6],[23,29,102,13,556],[42,29,102,32,550],[55,29,102,45],[56,29,102,46,551],[66,29,102,56]],[[12,29,103,4]],[[8,29,104,4],[30,29,104,26]],[[8,29,105,4],[13,29,105,9]],[[8,29,106,4],[13,29,106,9]],[[8,29,107,4],[13,29,107,9]],[[8,29,108,4],[13,29,108,9]],[[12,29,108,20]],[[16,29,109,6],[22,29,109,12,557],[31,29,109,21,549],[41,29,109,31,552],[47,29,109,37],[50,29,109,40]],[[16,29,110,6],[20,29,110,10,551],[33,29,110,23,550],[47,29,110,37,552],[53,29,110,43],[55,29,110,45]],[[20,29,111,8],[91,29,111,79]],[[20,29,112,8],[92,29,112,80]],[[20,29,113,8],[86,29,113,74]],[[20,29,114,8],[89,29,114,77]],[[20,29,115,8],[90,29,115,78]],[[20,29,116,8],[81,29,116,69]],[[20,29,117,8],[40,29,117,28]],[[20,29,118,8],[27,29,118,15]],[[16,29,119,6]],[[16,29,121,6],[23,29,121,13,556],[42,29,121,32,550],[55,29,121,45],[56,29,121,46,551],[66,29,121,56],[67,29,121,57,553],[72,29,121,62],[73,29,121,63,557]],[[12,29,122,4]],[[8,29,123,4]],[[12,29,124,6,549]],[[12,29,125,6],[19,29,125,13]],[[4,29,126,2]],[[0,29,127,0]],[[0,29,129,7],[9,29,129,16,530],[38,29,129,45,559],[45,29,129,60]],[[4,29,130,2],[73,29,130,71]],[[4,29,131,2],[78,29,131,76]],[[4,29,132,2],[76,29,132,74]],[[4,29,133,2],[42,29,133,40]],[[4,29,134,2],[76,29,134,74]],[[4,29,135,2],[75,29,135,73]],[[4,29,136,2],[53,29,136,51]],[[4,29,137,2],[8,29,138,4,559],[20,29,138,16,560],[42,29,138,16,560],[66,29,138,40],[70,29,139,4],[139,29,139,73]],[[4,29,140,4],[73,29,140,73]],[[4,29,141,4],[70,29,141,70]],[[4,29,142,4],[25,29,142,25]],[[4,29,143,4],[74,29,143,74]],[[4,29,144,4,559],[12,29,144,12,561],[22,29,144,22],[23,29,144,23,562],[32,29,144,23,562],[48,29,144,39],[53,29,145,4],[69,29,145,20]],[[4,29,146,5,559],[11,29,146,12],[12,29,146,13],[14,29,146,15],[19,29,146,20],[26,29,146,27,559],[34,29,146,35,563],[42,29,146,43],[43,29,146,44],[51,29,147,4,559],[63,29,147,16,564],[72,29,147,16,564],[91,29,147,35],[95,29,148,4,559],[107,29,148,16],[122,29,149,4]],[[8,29,150,4],[15,29,150,11]],[[4,29,151,2],[11,29,151,9]],[[8,29,152,4],[52,29,152,48]],[[8,29,153,4],[15,29,153,11]],[[4,29,154,2]],[[0,29,155,0]],[[0,29,157,7],[9,29,157,16,531],[36,29,158,2,565],[46,29,158,29],[48,29,159,2,566],[62,29,159,34]],[[4,29,161,2],[81,29,161,79]],[[4,29,162,2],[77,29,162,75]],[[4,29,163,2],[18,29,163,16]],[[4,29,164,2],[8,29,164,6],[15,29,164,13,565],[30,29,164,28],[40,29,164,38]],[[8,29,165,4],[82,29,165,78]],[[8,29,166,4],[76,29,166,72]],[[8,29,167,4],[57,29,167,53]],[[8,29,168,4],[14,29,168,10,567],[44,29,168,40,568],[45,29,168,40,568],[48,29,168,40,568],[57,29,168,40,568],[85,29,168,68],[87,29,169,6,565],[99,29,170,6,569],[106,29,170,13,570],[117,29,170,24],[118,29,170,25],[122,29,170,29,571],[138,29,170,45,566]],[[8,29,172,4],[15,29,172,11,567]],[[4,29,173,2],[11,29,173,9],[15,29,173,13,565],[30,29,173,28],[36,29,173,34]],[[8,29,174,4],[15,29,174,11]],[[4,29,175,2],[11,29,175,9]],[[8,29,176,4],[15,29,176,11,565],[26,29,176,22,572],[30,29,176,26],[31,29,176,27]],[[4,29,177,2]],[[0,29,178,0]],[[0,29,180,7],[9,29,180,16,537],[37,29,180,44,544],[40,29,180,52]],[[4,29,181,2],[10,29,181,8,573],[39,29,181,37],[43,29,181,41,543],[47,29,181,45,544]],[[4,29,182,2,573],[31,29,182,29,574],[43,29,182,41],[44,29,182,42,575],[50,29,182,48],[51,29,182,49,576],[69,29,182,49,576],[89,29,182,69]],[[4,29,183,2]],[],[[4,29,194,2],[11,29,194,9,573]],[[0,29,195,0]],[[0,29,197,7],[9,29,197,16,532],[35,29,198,2,581],[48,29,198,23],[50,29,199,2,549],[59,29,199,35]],[[4,29,201,2],[82,29,201,80]],[[4,29,202,2],[76,29,202,74]],[[4,29,203,2],[10,29,203,8,582],[23,29,203,21,549],[37,29,203,35],[44,29,203,42,549],[58,29,203,56]],[[4,29,204,2],[8,29,204,6,582],[20,29,204,18]],[[8,29,205,4],[73,29,205,69]],[[8,29,206,4],[55,29,206,51]],[[8,29,207,4],[80,29,207,76]],[[8,29,208,4],[79,29,208,75]],[[8,29,209,4],[82,29,209,78]],[[8,29,210,4],[41,29,210,37]],[[8,29,211,4],[15,29,211,11,581],[29,29,211,25,583],[34,29,211,30],[35,29,211,31]],[[4,29,212,2]],[[4,29,213,2],[11,29,213,9,581]],[[0,29,214,0]],[[0,29,216,7],[9,29,216,16,536],[41,29,217,2,574],[53,29,217,31]],[[4,29,219,2],[81,29,219,79]],[[4,29,220,2],[69,29,220,67]],[[4,29,221,2],[28,29,221,26]],[[4,29,222,2],[10,29,222,8,584],[19,29,222,33],[20,29,222,34]],[[4,29,223,2],[9,29,223,7],[15,29,223,13],[16,29,223,14,585],[21,29,223,19,586],[27,29,223,25],[31,29,223,29,574],[44,29,223,42,587],[51,29,223,49],[54,29,223,53]],[[8,29,224,4],[12,29,224,8,584],[18,29,224,14],[19,29,224,15,585],[23,29,224,19],[28,29,224,24,588],[39,29,224,35]],[[12,29,225,6,584],[18,29,225,12],[19,29,225,13,585],[23,29,225,17],[26,29,225,20,586]],[[8,29,226,4],[15,29,226,11],[19,29,226,15,589],[25,29,226,21,590],[32,29,226,28],[33,29,226,29,584],[39,29,226,35],[40,29,226,36,585],[44,29,226,40],[47,29,226,43]],[[12,29,227,6,584],[18,29,227,12],[19,29,227,13,585],[23,29,227,17],[24,29,227,18,591],[28,29,227,22],[29,29,227,23,586]],[[8,29,228,4],[15,29,228,11]],[[12,29,229,6,584],[18,29,229,12],[19,29,229,13,585],[23,29,229,17],[26,29,229,20]],[[16,29,229,21,584],[22,29,229,27],[23,29,229,28,585],[27,29,229,32]],[[16,29,229,34,586]],[[13,29,229,40]],[[8,29,230,4]],[[4,29,231,2]],[[4,29,232,2],[11,29,232,9,584]],[[0,29,233,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,30,70,16,592],[48,30,70,60],[50,30,70,60]],[[15,30,70,16,592]],[],[[4,30,42,16,593],[30,30,42,42],[32,30,42,42]],[[15,30,42,16,593]],[],[[4,30,192,16,594],[28,30,192,40],[30,30,192,40]],[[15,30,192,16,594]],[],[[4,30,200,16,595],[23,30,200,35],[25,30,200,35]],[[15,30,200,16,595]],[],[[4,30,222,16,596],[38,30,222,50],[40,30,222,50]],[[15,30,222,16,596]],[],[],[[25,30,10,33]],[[29,30,18,7]],[[35,30,19,34]],[[0,30,42,7],[9,30,42,16,593],[36,30,43,2,597],[50,30,43,32]],[[4,30,45,2],[108,30,45,106]],[[4,30,46,2],[10,30,46,8,598],[33,30,46,31]],[[4,30,47,2],[90,30,47,88]],[[4,30,48,2],[10,30,48,8],[11,30,48,9,599],[17,30,48,15,600],[27,30,48,25,601],[33,30,48,31,602],[47,30,48,45],[50,30,49,4,597],[65,30,49,19,603],[70,30,49,24],[71,30,49,25],[72,30,49,26,598]],[[4,30,50,2],[113,30,50,111]],[[4,30,51,2],[10,30,51,8,604],[24,30,51,22,597],[39,30,51,37,603],[44,30,51,42],[45,30,51,43],[48,30,51,46],[49,30,51,47,598]],[[4,30,53,2],[11,30,53,9]],[[8,30,54,4],[106,30,54,102]],[[8,30,55,4],[110,30,55,106]],[[8,30,56,4],[61,30,56,57]],[[8,30,57,4,605],[23,30,57,19,604],[35,30,57,31,603],[40,30,57,36],[41,30,57,37],[44,30,57,40],[45,30,57,41]],[[8,30,58,4,604]],[[8,30,59,4],[90,30,59,86]],[[8,30,60,4],[42,30,60,38]],[[8,30,61,4,606],[17,30,61,13,604],[28,30,61,24],[29,30,61,25,604],[41,30,61,37,607],[47,30,61,43],[50,30,61,46],[52,30,61,48],[56,30,61,52]],[[8,30,62,4,599]],[[8,30,63,4,600]],[[8,30,64,4,601]],[[8,30,65,4,602]],[[8,30,66,4,608],[22,30,66,18,597],[37,30,66,33,607],[43,30,66,39],[48,30,66,44,598]],[[4,30,67,2]],[[0,30,68,0]],[[0,30,70,7],[9,30,70,16,592],[54,30,71,2,609],[62,30,71,20],[64,30,72,2,610],[89,30,72,46]],[[4,30,74,2],[79,30,74,77]],[[4,30,75,2],[79,30,75,77]],[[4,30,76,2],[73,30,76,71]],[[4,30,77,2],[77,30,77,75]],[[4,30,78,2],[79,30,78,77]],[[4,30,79,2],[81,30,79,79]],[[4,30,80,2],[79,30,80,77]],[[4,30,81,2],[81,30,81,79]],[[4,30,82,2],[75,30,82,73]],[[4,30,83,2],[16,30,83,14]],[[4,30,84,2],[6,30,84,4]],[[4,30,85,2],[79,30,85,77]],[[4,30,86,2],[79,30,86,77]],[[4,30,87,2],[79,30,87,77]],[[4,30,88,2],[74,30,88,72]],[[4,30,89,2],[75,30,89,73]],[[4,30,90,2],[73,30,90,71]],[[4,30,91,2],[74,30,91,72]],[[4,30,92,2],[27,30,92,25]],[[4,30,94,2],[78,30,94,76]],[[4,30,95,2],[38,30,95,36]],[[4,30,96,2],[10,30,96,8,611],[29,30,96,27,612],[30,30,96,27,612],[33,30,96,27,612],[46,30,96,27,612],[65,30,96,46],[67,30,96,47,609]],[[4,30,97,2],[10,30,97,8,613],[27,30,97,25,614],[28,30,97,25,614],[31,30,97,25,614],[44,30,97,25,614],[61,30,97,42],[63,30,97,43,609]],[[4,30,98,2],[10,30,98,8,615],[25,30,98,23,616],[26,30,98,23,616],[29,30,98,23,616],[48,30,98,23,616],[65,30,98,40],[67,30,98,41],[71,30,98,45,617],[75,30,98,49,618],[84,30,98,58,619],[88,30,98,62]],[[4,30,99,2],[10,30,99,8,620],[35,30,99,33,610],[61,30,99,59,621],[62,30,99,60],[63,30,99,61],[65,30,99,63]],[[4,30,100,2],[10,30,100,8,622],[38,30,100,36,620],[60,30,100,58],[61,30,100,59],[63,30,100,61]],[[4,30,101,2],[11,30,101,9]],[[8,30,102,4,623],[11,30,102,7,610],[37,30,102,33,623],[38,30,102,34]],[[8,30,103,4,624],[11,30,103,7,615],[24,30,103,20,625],[29,30,103,25],[30,30,103,26]],[[8,30,104,4,626],[11,30,104,7,613]],[[8,30,105,4,627],[11,30,105,7,610],[37,30,105,33,627],[38,30,105,34]],[[8,30,106,4,621],[11,30,106,7]],[[12,30,107,6]],[[16,30,108,8,628],[48,30,109,10,622],[75,30,110,10,611],[93,30,111,10,613]],[[16,30,113,8,620],[38,30,113,30],[39,30,113,31],[41,30,113,33]],[[16,30,114,8,620],[38,30,114,30],[39,30,114,31],[41,30,114,33]],[[16,30,115,8,620],[38,30,115,30],[39,30,115,31],[41,30,115,33]],[[13,30,116,7]],[[9,30,117,5]],[[8,30,118,4,629],[11,30,118,7,610],[37,30,118,33,629],[38,30,118,34]],[[8,30,119,4,630],[11,30,119,7,610],[37,30,119,33,630],[38,30,119,34]],[[8,30,120,4,631],[11,30,120,7,610],[37,30,120,33,631],[38,30,120,34]],[[4,30,121,2]],[[0,30,122,0]],[[0,30,124,0],[9,30,124,9,628],[41,30,125,2,632],[58,30,125,38],[60,30,126,2,611],[76,30,126,26],[78,30,127,2,613],[92,30,127,34]],[[4,30,129,2],[10,30,129,8,633],[26,30,129,24,611],[43,30,129,41,625],[48,30,129,46],[49,30,129,47],[54,30,129,52,634],[60,30,129,58],[61,30,129,59],[62,30,129,60,635],[66,30,129,66,635],[72,30,129,72]],[[4,30,130,2],[10,30,130,8,636],[18,30,130,16]],[[4,30,131,2],[11,30,131,9,637],[47,30,132,4,632],[66,30,133,4,613],[82,30,134,4,633],[97,30,135,4,636]],[[0,30,137,0]],[[0,30,139,0],[9,30,139,9,637],[45,30,140,2,632],[62,30,140,38],[64,30,141,2,613],[78,30,141,34],[80,30,142,2,633],[93,30,142,30],[95,30,143,2,638],[113,30,143,28]],[[4,30,145,2],[10,30,145,8,639],[28,30,145,26,632],[45,30,145,43],[46,30,145,44],[48,30,145,46]],[[4,30,146,2],[8,30,146,6,640]],[[4,30,147,2],[8,30,147,6,641]],[[4,30,148,2],[8,30,148,6],[15,30,148,13,639],[35,30,148,33],[45,30,148,43]],[[8,30,149,4,640],[21,30,149,17,639]],[[8,30,150,4,641],[26,30,150,22,642],[27,30,150,22,642],[30,30,150,22,642],[43,30,150,22,642],[71,30,150,50],[73,30,150,51,639]],[[4,30,151,2],[11,30,151,9]],[[8,30,152,4],[14,30,152,10,643],[26,30,152,22,639],[41,30,152,37],[42,30,152,38],[44,30,152,40]],[[8,30,153,4],[14,30,153,10,644],[26,30,153,22,639],[41,30,153,37],[42,30,153,38],[44,30,153,40]],[[8,30,154,4],[14,30,154,10,645],[27,30,154,23,646],[28,30,154,23,646],[31,30,154,23,646],[44,30,154,23,646],[72,30,154,51],[74,30,155,6,644],[85,30,156,6,633],[100,30,157,6,638]],[[8,30,159,4],[14,30,159,10,647],[25,30,159,21,648],[26,30,159,21,648],[29,30,159,21,648],[42,30,159,21,648],[68,30,159,47],[70,30,159,48,645],[82,30,159,60,613]],[[8,30,160,4,640],[21,30,160,17]],[[12,30,160,18,643]],[[12,30,160,29,647]],[[12,30,160,39,644]],[[9,30,160,49]],[[8,30,161,4,641],[26,30,161,22]],[[4,30,162,2]],[[4,30,164,2],[76,30,164,74]],[[4,30,165,2],[66,30,165,64]],[[4,30,166,2],[10,30,166,8,649],[36,30,166,34,641],[54,30,167,6,638],[75,30,167,27],[79,30,168,6,638]],[[4,30,170,2],[10,30,170,8,650],[21,30,170,19,632],[38,30,170,36],[39,30,170,37],[41,30,170,39]],[[4,30,171,2],[10,30,171,8,651],[24,30,171,60],[25,30,171,61]],[[4,30,172,2],[8,30,172,7],[12,30,172,11,652],[19,30,172,18,650],[28,30,172,28]],[[8,30,173,4],[14,30,173,10,653],[39,30,173,35,650],[47,30,173,43],[48,30,173,44,652],[52,30,173,48]],[[8,30,174,4,651],[19,30,174,15],[20,30,174,16,652],[24,30,174,20],[27,30,174,23,637],[63,30,175,6,653],[87,30,176,6,613],[103,30,177,6,633],[118,30,178,6,649]],[[4,30,180,2]],[[4,30,182,2],[10,30,182,8,654],[21,30,182,38]],[[8,30,183,4,640]],[[8,30,184,4,651]],[[8,30,185,4]],[[8,30,186,4,632],[25,30,186,21],[26,30,186,22],[28,30,186,24]],[[8,30,187,4,632],[25,30,187,21],[26,30,187,22],[28,30,187,24]],[[5,30,188,3]],[[4,30,189,2],[11,30,189,9,654]],[[0,30,190,0]],[[0,30,192,7],[9,30,192,16,594],[34,30,193,2,655],[51,30,193,38]],[[4,30,195,2],[112,30,195,110]],[[4,30,196,2],[36,30,196,34]],[[4,30,197,2],[11,30,197,9,655],[29,30,197,27,603],[34,30,197,32],[35,30,197,33]],[[0,30,198,0]],[[0,30,200,7],[9,30,200,16,595],[29,30,201,2,656],[39,30,201,24]],[[4,30,203,2],[95,30,203,93]],[[4,30,204,2],[102,30,204,100]],[[4,30,205,2],[8,30,205,6],[15,30,205,13,656],[30,30,205,28],[40,30,205,38]],[[8,30,206,4],[15,30,206,11,656]],[[4,30,207,2]],[[4,30,209,2],[11,30,209,9,656],[22,30,209,20,657],[25,30,209,23],[26,30,209,24],[27,30,209,25,597],[44,30,210,4,593],[71,30,210,31,597]],[[0,30,212,0]],[[0,30,222,7],[9,30,222,16,596],[44,30,223,2,632],[61,30,223,38],[63,30,224,2,658],[75,30,224,24]],[[4,30,226,2],[80,30,226,78]],[[4,30,227,2],[8,30,227,6,658],[22,30,227,20]],[[8,30,228,4],[15,30,228,11,659],[34,30,228,30,660],[39,30,228,35,661],[48,30,228,44],[49,30,228,45,632]],[[4,30,229,2]],[[4,30,231,2],[11,30,231,9,659],[30,30,232,4,660],[35,30,232,9,661],[44,30,232,18],[45,30,232,19,662],[86,30,232,60,632]],[[0,30,234,0]],[[0,30,236,0]],[],[],[[1,30,239,1],[4,30,240,0],[13,30,240,9,662],[54,30,241,2,632],[71,30,241,38]],[[4,30,243,2],[10,30,243,8],[11,30,244,4,606],[20,30,245,4,663],[36,30,246,4,664],[42,30,247,4,665],[57,30,248,4,666],[71,30,249,4,667],[90,30,250,3],[93,30,250,6,632]],[[4,30,252,2],[71,30,252,69]],[[4,30,253,2],[30,30,253,28]],[[4,30,254,2],[10,30,254,8,668],[27,30,254,25,669],[60,30,254,58,606]],[[4,30,256,2],[42,30,256,40]],[[4,30,257,2],[10,30,257,8,670],[34,30,257,70],[35,30,257,71]],[[4,30,258,2],[9,30,258,7],[15,30,258,13],[16,30,258,14,652],[21,30,258,19,671],[32,30,258,30],[36,30,258,34,672],[43,30,258,41,673],[50,30,258,48],[51,30,258,49,663],[67,30,258,66]],[[8,30,259,4,670],[29,30,259,25],[30,30,259,26,652],[34,30,259,30],[37,30,260,6,662],[78,30,260,47,671]],[[4,30,261,2]],[[4,30,263,2],[10,30,263,8,674],[19,30,263,36]],[[8,30,264,4,668]],[[8,30,265,4,670]],[[8,30,266,4]],[[8,30,267,4,675],[36,30,267,32,665],[53,30,267,49,665],[69,30,267,65]],[[5,30,268,3]],[[4,30,270,2],[40,30,270,38]],[[4,30,271,2],[8,30,271,6,666],[25,30,271,23,676],[36,30,271,34]],[[8,30,272,4,674],[14,30,272,10],[15,30,272,11],[17,30,272,13],[20,30,272,16,666]],[[4,30,273,2]],[[4,30,274,2],[8,30,274,6,667],[31,30,274,29,676],[42,30,274,40]],[[8,30,275,4,674],[14,30,275,10],[15,30,275,11],[17,30,275,13],[20,30,275,16,667]],[[4,30,276,2]],[[4,30,278,2],[11,30,278,9,674]],[[0,30,279,0]],[[0,30,281,0]],[],[],[[1,30,284,1],[4,30,285,0],[13,30,285,9,669],[46,30,285,42,606],[53,30,285,58]],[[4,30,286,2],[8,30,287,4],[15,30,287,11,606],[27,30,287,23],[39,30,288,4,606],[47,30,288,12,677],[57,30,288,22],[58,30,288,23,678],[67,30,288,23,678],[83,30,288,39],[86,30,288,42],[92,30,289,4]],[[8,30,290,4],[15,30,290,11,678],[24,30,290,11,678],[40,30,290,27]],[[4,30,291,2]],[[4,30,292,2],[11,30,292,9,606]],[[0,30,293,0]],[[0,30,295,0]],[],[],[],[[1,30,299,1],[4,30,300,0],[13,30,300,9,675],[41,30,301,2,665],[54,30,301,37]],[[4,30,303,2],[11,30,303,9,679],[19,30,303,17,665],[36,30,303,34,665],[54,30,303,52]],[[0,30,304,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,31,0,0],[76,31,0,76]],[[0,31,1,0],[76,31,1,76]],[[0,31,2,0],[56,31,2,56]],[[0,31,3,0],[2,31,3,2]],[[0,31,4,0],[79,31,4,79]],[[0,31,5,0],[76,31,5,76]],[[0,31,6,0],[38,31,6,38]],[[0,31,8,0],[74,31,8,74]],[[0,31,9,0],[70,31,9,70]],[[0,31,10,0],[77,31,10,77]],[[0,31,11,0],[73,31,11,73]],[[0,31,12,0],[77,31,12,77]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,31,19,16,680],[17,31,19,29],[19,31,19,29]],[[15,31,19,16,680]],[],[[4,31,15,16,681],[17,31,15,29],[19,31,15,29]],[[15,31,15,16,681]],[],[],[[0,31,13,0],[4,31,13,4,682],[20,31,13,28]],[[0,31,15,7],[9,31,15,16,681],[23,31,15,30,683],[30,31,15,45]],[[4,31,16,2,682],[20,31,16,18,683]],[[0,31,17,0]],[[0,31,19,7],[9,31,19,16,680]],[[4,31,20,2],[11,31,20,9,682]],[[0,31,21,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,32,28,13,684],[30,32,28,39],[32,32,28,39]],[[15,32,28,13,684]],[],[[4,32,57,13,685],[38,32,57,47],[40,32,57,47]],[[15,32,57,13,685]],[],[],[[41,32,2,47]],[[34,32,9,7]],[[0,32,28,7],[6,32,28,13,684],[35,32,28,42],[36,32,29,2,686],[41,32,30,2,687]],[[4,32,32,2],[10,32,32,8,688],[27,32,32,25,689],[28,32,32,25,689],[31,32,32,25,689],[56,32,32,25,689],[86,32,32,55],[88,32,33,4,687],[95,32,33,11],[96,32,33,12,690],[114,32,33,12,690],[141,32,33,39],[142,32,33,40],[144,32,34,4,687],[151,32,34,11],[152,32,34,12,691],[170,32,34,12,691],[205,32,34,47],[206,32,34,48],[208,32,35,4,687],[215,32,35,11],[216,32,35,12,692],[234,32,35,12,692],[263,32,35,41],[264,32,35,42],[266,32,36,4,687],[273,32,36,11],[274,32,36,12,693],[292,32,36,12,693],[300,32,36,20],[301,32,36,21]],[[4,32,38,2,685],[39,32,38,37,686],[44,32,38,42,688]],[[0,32,39,0]],[[0,32,57,7],[6,32,57,13,685],[43,32,57,50],[44,32,58,2,686],[49,32,59,2,694]],[[4,32,61,2]],[],[],[],[],[],[],[],[],[],[[3,32,71,3],[6,32,72,2],[12,32,72,8,695],[29,32,72,25,686],[33,32,72,29,696],[39,32,72,35]],[[4,32,73,2],[10,32,73,8,697],[21,32,73,19,695],[36,32,73,34,698],[46,32,73,44],[47,32,73,45],[54,32,74,6,695],[69,32,74,21,699],[74,32,74,26],[75,32,74,27],[80,32,75,6,695]],[[4,32,77,2],[83,32,77,81]],[[4,32,78,2],[65,32,78,63]],[[4,32,79,2],[10,32,79,8,700],[18,32,79,16,697],[27,32,80,5,701],[32,32,80,10],[33,32,80,11],[38,32,81,5,702],[44,32,81,11],[45,32,81,12],[46,32,81,13,703],[53,32,81,22,703],[61,32,81,30],[62,32,81,31,703],[67,32,81,36,698],[77,32,81,46],[78,32,81,47],[81,32,81,50,704],[99,32,81,50,704],[119,32,81,70],[120,32,81,71],[121,32,81,72],[122,32,81,73]],[[4,32,83,2],[8,32,83,6,694],[13,32,83,11,705],[19,32,83,17],[22,32,83,20],[25,32,83,23]],[[8,32,84,4,700],[14,32,84,10,706],[18,32,84,14],[19,32,84,15],[22,32,84,18,704],[40,32,84,18,704],[60,32,84,38],[61,32,84,39],[62,32,84,40],[64,32,84,42,694],[70,32,84,48]],[[4,32,85,2],[11,32,85,9]],[[8,32,86,4,700],[14,32,86,10,706],[18,32,86,14],[19,32,86,15],[22,32,86,18,704],[40,32,86,18,704],[60,32,86,38],[62,32,86,40]],[[4,32,87,2]],[[4,32,88,2,686],[8,32,88,6,696],[14,32,88,12],[17,32,88,15,700],[23,32,88,21,705],[29,32,88,27],[32,32,88,30],[33,32,88,31],[34,32,88,32],[36,32,88,34,700],[42,32,88,40,707],[46,32,88,44],[47,32,88,45],[53,32,88,51],[56,32,88,54]],[[0,32,89,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,33,54,2,716],[8,33,54,10,717],[11,33,54,13],[12,33,54,14,718],[20,33,54,22],[25,33,54,27],[41,33,55,2,716],[49,33,55,10,717],[52,33,55,13],[53,33,55,14,719],[79,33,55,40],[81,33,56,2]],[[0,33,0,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,33,295,22,708],[15,33,295,33],[17,33,295,33]],[[15,33,295,22,708]],[],[[4,33,451,16,709],[32,33,451,44],[34,33,451,44]],[[15,33,451,16,709]],[],[[4,33,124,22,710],[23,33,124,41],[25,33,124,41]],[[15,33,124,22,710]],[],[],[[24,33,7,7]],[[34,33,27,7]],[[31,33,28,27]],[[37,33,29,33]],[[35,33,34,7]],[[28,33,35,30]],[[44,33,36,43]],[[29,33,40,7]],[[30,33,42,32]],[[0,33,44,0],[6,33,44,6,711],[33,33,45,2,712],[41,33,45,2,712],[65,33,45,33]],[[0,33,46,0],[6,33,46,6,713],[24,33,47,2,714],[32,33,47,2,714],[47,33,47,24]],[[0,33,49,0],[4,33,49,4,715]],[[0,33,53,0]],[],[[0,33,99,0],[9,33,99,9,721],[25,33,99,25,722],[28,33,99,36]],[[4,33,100,2],[11,33,100,9,723],[12,33,100,9,723],[15,33,100,9,723],[28,33,100,9,723],[55,33,100,36],[57,33,100,37],[61,33,100,41,724],[65,33,100,45,722],[70,33,100,50,725],[79,33,100,59,726],[85,33,100,65],[88,33,100,68,727],[96,33,100,76]],[[0,33,101,0]],[[0,33,103,0],[4,33,103,4,728],[22,33,103,22]],[[0,33,105,0],[4,33,105,4],[11,33,105,11,729],[22,33,105,22],[35,33,105,35]],[[4,33,106,2],[74,33,106,72]],[[4,33,107,2],[81,33,107,79]],[[4,33,108,2],[65,33,108,63]],[[4,33,109,2,729],[11,33,109,9,730],[27,33,109,25],[28,33,109,26],[40,33,109,38]],[[8,33,110,4,728],[26,33,110,22]],[[4,33,111,2]],[[4,33,113,2],[79,33,113,77]],[[4,33,114,2],[52,33,114,50]],[[4,33,115,2,729],[11,33,115,9,730],[27,33,115,25],[28,33,115,26],[40,33,115,38]],[[8,33,116,4,728],[26,33,116,22]],[[4,33,117,2]],[[0,33,118,0]],[[0,33,124,7],[15,33,124,22,710],[35,33,125,2,722],[38,33,125,10],[40,33,126,2,731],[47,33,126,37]],[[4,33,128,2],[10,33,128,8],[12,33,128,10,732],[29,33,128,27],[31,33,128,29,733],[38,33,128,36],[40,33,128,38],[43,33,128,41,731]],[[4,33,130,2],[10,33,130,8,734],[20,33,130,34]],[[8,33,131,4],[33,33,131,29]],[[8,33,132,4],[9,33,132,5,735],[27,33,132,5,735],[37,33,132,15],[38,33,132,16],[40,33,132,18]],[[8,33,133,4],[43,33,133,39]],[[8,33,134,4],[9,33,134,5,736],[27,33,134,5,736],[56,33,134,34],[57,33,134,35],[59,33,134,37,737],[60,33,134,37,737],[63,33,134,37,737],[82,33,134,37,737],[116,33,134,71],[118,33,135,6,732],[137,33,136,6,731],[145,33,136,14,738],[157,33,136,26]],[[4,33,138,2]],[[4,33,140,2],[8,33,140,6,716],[16,33,140,14,717],[19,33,140,17],[20,33,140,18,718],[28,33,140,26],[60,33,140,31],[77,33,140,48,731],[85,33,140,56,738],[97,33,140,68],[99,33,140,70]],[[8,33,141,4,734],[15,33,141,11],[16,33,141,12,739],[34,33,141,12,739],[57,33,141,35],[58,33,141,36],[61,33,141,39]],[[4,33,142,2]],[[4,33,144,2],[8,33,144,6,733],[17,33,144,15]],[[8,33,145,4,734],[15,33,145,11],[16,33,145,12,740],[34,33,145,12,740],[42,33,145,20],[43,33,145,21],[46,33,145,24,733]],[[4,33,146,2]],[[4,33,148,2],[81,33,148,79]],[[4,33,149,2],[88,33,149,86]],[[4,33,150,2],[10,33,150,8,741],[24,33,150,22,722]],[[4,33,152,2],[8,33,152,6]],[[8,33,153,4],[12,33,153,8,716],[20,33,153,16,717],[23,33,153,19],[24,33,153,20,718],[32,33,153,28],[37,33,153,33],[51,33,153,47]],[],[[8,33,167,4],[80,33,167,76]],[[8,33,168,4],[66,33,168,62]],[[8,33,169,4],[67,33,169,63]],[[8,33,170,4],[14,33,170,10,745],[28,33,171,6,716],[36,33,171,14,717],[39,33,171,17],[40,33,171,18,746],[50,33,171,28],[71,33,171,32],[72,33,171,33,716],[80,33,171,41,717],[83,33,171,44],[84,33,171,45,747],[107,33,171,68]],[[8,33,172,4],[14,33,172,10,748],[40,33,172,36],[41,33,172,37,745]],[[8,33,173,4],[14,33,173,10,749],[20,33,173,16],[26,33,173,22,708],[38,33,174,6,722],[43,33,175,6,734],[52,33,176,6],[60,33,177,6,748]],[[8,33,180,4],[14,33,180,10,750],[28,33,180,24,723],[29,33,180,24,723],[32,33,180,24,723],[45,33,180,24,723],[72,33,180,51],[74,33,180,52],[78,33,180,56,724],[82,33,180,60,749],[86,33,180,64,722],[89,33,180,67]],[[8,33,181,4],[14,33,181,10,751],[29,33,181,25,749],[33,33,181,29,752],[43,33,181,39],[46,33,181,42,750],[60,33,181,56,741]],[[8,33,183,4],[14,33,183,10,753],[28,33,183,24,749],[32,33,183,28,734],[39,33,183,35],[40,33,183,36,754],[43,33,183,39],[44,33,183,40],[63,33,183,59]],[[8,33,184,4],[14,33,184,10,755],[29,33,184,25],[30,33,184,26],[31,33,184,27,749],[35,33,184,31,734],[42,33,184,38],[43,33,184,39,754],[46,33,184,42],[47,33,184,43],[56,33,184,52,756],[65,33,184,61,740],[83,33,184,61,740],[91,33,184,69]],[[8,33,185,4],[14,33,185,10,757],[26,33,185,22],[27,33,185,23],[28,33,185,24,749],[32,33,185,28,734],[39,33,185,35],[40,33,185,36,754],[43,33,185,39],[44,33,185,40,758],[62,33,185,40,758],[86,33,185,64]],[[8,33,186,4],[14,33,186,10,759],[39,33,186,35,749],[43,33,186,39,734],[50,33,186,46],[51,33,186,47,754],[54,33,186,50],[55,33,187,6,760],[73,33,187,6,760],[102,33,187,35]],[[8,33,189,4],[14,33,189,10,761],[26,33,190,6,759],[53,33,190,33],[60,33,191,10,762],[69,33,191,19,759],[93,33,191,43],[99,33,191,49],[106,33,192,10],[107,33,192,11]],[[8,33,193,4],[12,33,193,8,763],[31,33,193,27,753],[43,33,193,39,764],[53,33,193,49],[54,33,193,50,765],[72,33,193,50,765],[95,33,193,73]],[[8,33,195,4],[12,33,195,8,716],[20,33,195,16,717],[23,33,195,19],[24,33,195,20,718],[32,33,195,28],[37,33,195,33],[51,33,195,47]],[],[[8,33,203,4],[100,33,203,96]],[[8,33,204,4],[76,33,204,72]],[[8,33,205,4],[12,33,205,8],[13,33,205,9,763],[33,33,205,29],[34,33,205,30,749],[38,33,205,34,766],[40,33,205,36],[44,33,205,40],[45,33,205,41,749],[49,33,205,45,767],[53,33,205,49],[55,33,205,51]],[[12,33,206,6],[103,33,206,97]],[[12,33,207,6],[16,33,207,10,722],[20,33,207,14,768],[24,33,207,18],[26,33,207,20]],[[16,33,208,8,750],[28,33,208,20,768],[32,33,208,24],[35,33,208,27,722],[39,33,208,31,768],[43,33,208,35]],[[12,33,209,6]],[[12,33,211,6],[19,33,211,13,721],[35,33,211,29,750],[47,33,211,41,727],[55,33,211,49]],[[8,33,212,4]],[[8,33,214,4],[79,33,214,75]],[[8,33,215,4],[66,33,215,62]],[[8,33,216,4],[64,33,216,60]],[[8,33,217,4],[108,33,217,104]],[[8,33,218,4],[59,33,218,55]],[[8,33,219,4],[83,33,219,79]],[[8,33,220,4],[29,33,220,25]],[[8,33,221,4],[12,33,221,8,716],[20,33,221,16,717],[23,33,221,19],[24,33,221,20,718],[32,33,221,28],[37,33,221,33],[53,33,221,49],[54,33,221,50,716],[62,33,221,58,717],[65,33,221,61],[66,33,221,62,769],[75,33,221,71],[77,33,221,73]],[],[[8,33,227,4],[12,33,227,8,771],[36,33,227,32,749],[40,33,227,36,772],[54,33,227,50]],[[8,33,228,4],[12,33,228,8,771],[38,33,228,34],[44,33,228,40]],[[12,33,229,6],[79,33,229,73]],[[12,33,230,6],[79,33,230,73]],[[12,33,231,6],[85,33,231,79]],[[12,33,232,6],[76,33,232,70]],[[12,33,233,6],[26,33,233,20]],[[12,33,234,6],[18,33,234,12,773],[33,33,234,27,757],[45,33,235,10,774],[75,33,235,40,749],[79,33,235,44,767],[83,33,235,48],[87,33,236,10,749],[91,33,236,14,767],[95,33,236,18]],[[12,33,237,6,771],[36,33,238,8,709],[65,33,239,10,773],[79,33,240,10,734]],[[8,33,242,4]],[[8,33,244,4],[14,33,244,10,772],[31,33,244,27],[37,33,244,33,771]],[[8,33,246,4],[12,33,246,8,775],[13,33,246,8,775],[16,33,246,8,775],[28,33,246,8,775],[41,33,246,21],[49,33,246,28,772],[64,33,246,43,776],[65,33,246,44],[67,33,246,46]],[[12,33,247,6],[19,33,247,13,721],[35,33,247,29,749],[39,33,247,33,722],[42,33,247,36]],[[8,33,248,4]],[[8,33,250,4],[14,33,250,10,777],[37,33,250,33,778],[38,33,250,33,778],[41,33,250,33,778],[60,33,250,33,778],[79,33,250,52],[81,33,250,53,772],[96,33,250,68,779],[97,33,250,69]],[[8,33,251,4],[12,33,251,8],[19,33,251,15,777],[44,33,251,40],[54,33,251,50]],[[12,33,252,6],[19,33,252,13,721],[35,33,252,29,777]],[[8,33,253,4]],[[8,33,255,4],[15,33,255,11]],[[12,33,256,6,780],[24,33,256,18,777]],[[12,33,257,6,751],[26,33,257,20,751]],[[12,33,258,6,781],[28,33,258,22,782],[29,33,258,22,782],[32,33,258,22,782],[45,33,258,22,782],[62,33,258,39],[64,33,258,40,749]],[[12,33,259,6,783],[32,33,259,26,755]],[[12,33,260,6,784],[25,33,260,19,772],[40,33,260,34,785],[41,33,260,35]],[[12,33,261,6,757]],[[12,33,262,6,761]],[[12,33,263,6,786],[23,33,263,17,771],[45,33,263,39,787],[55,33,263,49],[59,33,263,53]],[[8,33,264,4]],[[4,33,265,2],[6,33,265,4],[13,33,265,11,788],[18,33,265,16]],[[8,33,266,4],[12,33,266,8],[13,33,266,9,728],[30,33,266,26]],[[12,33,267,6,789],[20,33,267,14,790],[25,33,267,19],[26,33,268,8],[27,33,268,9],[59,33,268,41],[61,33,268,43,741],[73,33,268,55],[110,33,268,92],[111,33,268,93],[113,33,269,8,788]],[[8,33,271,4]],[[8,33,273,4],[57,33,273,53]],[[8,33,274,4],[125,33,274,121]],[[8,33,275,4],[105,33,275,101]],[[8,33,276,4],[15,33,276,11,741],[27,33,276,23,727],[35,33,276,31]],[[4,33,277,2]],[[0,33,278,0]],[[0,33,295,7],[15,33,295,22,708],[27,33,296,2,722],[30,33,296,10],[32,33,297,2,734],[39,33,297,25],[41,33,298,2,791],[54,33,298,47],[56,33,299,2,748],[79,33,299,34],[81,33,300,2,792],[87,33,300,22]],[[4,33,302,2],[81,33,302,79]],[[4,33,303,2],[62,33,303,60]],[[4,33,304,2],[27,33,304,25]],[[4,33,306,2],[8,33,306,6,716],[16,33,306,14,717],[19,33,306,17],[20,33,306,18,793],[36,33,306,34],[40,33,306,38,791],[58,33,306,56],[64,33,306,62]],[],[[4,33,310,2],[10,33,310,8,794],[25,33,310,23,795],[26,33,310,23,795],[29,33,310,23,795],[43,33,310,23,795],[58,33,310,38]],[[4,33,311,2],[8,33,311,6,794],[22,33,311,20]],[[8,33,312,4,734],[15,33,312,11],[16,33,312,12],[34,33,312,30],[37,33,312,33,794]],[[4,33,313,2]],[[4,33,315,2],[8,33,315,6,716],[16,33,315,14,717],[19,33,315,17],[20,33,315,18,718],[28,33,315,26],[33,33,315,31],[44,33,315,45]],[[8,33,316,4],[12,33,316,8,796],[17,33,316,13,797],[25,33,316,21],[27,33,316,23]],[[12,33,317,6,734],[19,33,317,13],[20,33,317,14,798],[38,33,317,14,798],[65,33,317,41],[66,33,317,42],[69,33,317,45,796],[74,33,317,50,797],[82,33,317,58]],[[8,33,318,4]],[[8,33,320,4],[81,33,320,77]],[[8,33,321,4],[80,33,321,76]],[[8,33,322,4],[81,33,322,77]],[[8,33,323,4,734],[15,33,323,11],[16,33,323,12,799],[34,33,323,12,799],[56,33,323,34],[57,33,323,35],[60,33,323,38,800],[67,33,324,7,801],[82,33,324,22],[83,33,324,23],[87,33,324,27,802],[99,33,324,39],[102,33,324,42],[103,33,324,43],[105,33,324,45],[106,33,325,7,727],[114,33,325,15],[115,33,325,16]],[[4,33,326,2]],[[4,33,328,2],[10,33,328,8,803],[25,33,328,36]],[[8,33,329,4],[96,33,329,92]],[[8,33,330,4,804],[21,33,330,17]],[[8,33,331,4,734]],[[8,33,332,4,805],[18,33,332,14,791],[35,33,332,31,806]],[[8,33,333,4,792]],[[4,33,334,2]],[[4,33,335,2],[81,33,335,79]],[[4,33,336,2],[79,33,336,77]],[[4,33,337,2],[29,33,337,27]],[[4,33,338,2],[8,33,338,6,807],[19,33,338,17],[23,33,338,21,724],[27,33,338,25,722]],[[4,33,339,2,808],[5,33,339,2,808],[8,33,339,2,808],[36,33,339,2,808],[62,33,339,28],[64,33,339,29,807],[74,33,339,39,734]],[[4,33,340,2],[8,33,340,6,809],[23,33,340,21,810],[29,33,340,27,807],[39,33,340,37,803]],[[4,33,341,2],[80,33,341,78]],[[4,33,342,2],[82,33,342,80]],[[4,33,343,2],[62,33,343,60]],[[4,33,344,2],[6,33,344,4]],[[4,33,345,2],[81,33,345,79]],[[4,33,346,2],[62,33,346,60]],[[4,33,347,2],[78,33,347,76]],[[4,33,348,2],[77,33,348,75]],[[4,33,349,2],[81,33,349,79]],[[4,33,350,2],[40,33,350,38]],[[4,33,351,2],[8,33,351,6,771],[32,33,351,30,748],[58,33,352,6,811],[78,33,352,29,809],[92,33,352,43,734],[103,33,353,6]],[[4,33,354,2],[8,33,354,6,812],[26,33,354,24],[32,33,354,30,809]],[[4,33,356,2],[76,33,356,74]],[[4,33,357,2],[74,33,357,72]],[[4,33,358,2],[76,33,358,74]],[[4,33,359,2],[78,33,359,76]],[[4,33,360,2],[81,33,360,79]],[[4,33,361,2],[18,33,361,16]],[[4,33,362,2],[6,33,362,4]],[[4,33,363,2],[82,33,363,80]],[[4,33,364,2],[81,33,364,79]],[[4,33,365,2],[39,33,365,37]],[[4,33,366,2],[6,33,366,4]],[[4,33,367,2],[77,33,367,75]],[[4,33,368,2],[82,33,368,80]],[[4,33,369,2],[18,33,369,16]],[[4,33,370,2],[6,33,370,4]],[[4,33,371,2],[78,33,371,76]],[[4,33,372,2],[82,33,372,80]],[[4,33,373,2],[6,33,373,4]],[[4,33,374,2],[76,33,374,74]],[[4,33,375,2],[78,33,375,76]],[[4,33,376,2],[52,33,376,50]],[[4,33,378,2],[8,33,378,6,752],[21,33,378,19,812],[37,33,378,35,752],[47,33,378,45]],[[4,33,379,2],[8,33,379,6,716],[16,33,379,14,717],[19,33,379,17],[20,33,379,18,813],[62,33,379,60],[64,33,379,62]],[],[[4,33,420,2],[81,33,420,79]],[[4,33,421,2],[45,33,421,43]],[[4,33,422,2],[10,33,422,8,750],[24,33,422,22],[28,33,422,26,724],[32,33,422,30,812],[48,33,422,46,722],[51,33,422,49],[53,33,422,51,807]],[[4,33,423,2,750],[16,33,423,14,816],[28,33,423,26],[29,33,423,27,818],[35,33,423,33],[36,33,423,34,817],[54,33,423,34,817],[74,33,423,54]],[[4,33,425,2],[10,33,425,8,819],[24,33,425,38]],[[8,33,426,4,722],[13,33,426,9,750],[25,33,426,21,820],[29,33,426,25]],[[8,33,428,4],[78,33,428,74]],[[8,33,429,4],[61,33,429,57]],[[8,33,430,4],[80,33,430,76]],[[8,33,431,4],[76,33,431,72]],[[8,33,432,4,752]],[[8,33,434,4],[77,33,434,73]],[[8,33,435,4],[80,33,435,76]],[[8,33,436,4],[37,33,436,33]],[[8,33,437,4,766],[12,33,437,8,812],[28,33,437,24,766],[30,33,437,26]],[[8,33,438,4,734],[17,33,438,13,812],[33,33,438,29,734],[40,33,438,36]],[[8,33,439,4,767],[14,33,439,10,812],[30,33,439,26,767],[34,33,439,30]],[[8,33,440,4,821],[16,33,440,12,812],[32,33,440,28,821],[38,33,440,34]],[[8,33,442,4],[79,33,442,75]],[[8,33,443,4],[82,33,443,78]],[[8,33,444,4],[39,33,444,35]],[[8,33,445,4,772],[24,33,445,20,771]],[[4,33,446,2]],[[4,33,448,2],[11,33,448,9,819]],[[0,33,449,0]],[[0,33,451,7],[9,33,451,16,709],[38,33,452,2,773],[50,33,452,42],[52,33,453,2,822],[66,33,453,32]],[[4,33,455,2],[11,33,455,9,711],[36,33,455,34,773],[50,33,455,48]],[[8,33,456,4,823],[20,33,456,4,823],[35,33,456,4,823],[45,33,456,14]],[[8,33,457,4,824],[26,33,457,4,824],[47,33,457,4,824],[63,33,457,20]],[[8,33,458,4,825],[22,33,458,18,715],[44,33,458,40,715],[63,33,458,59,822]],[[4,33,459,2]],[[0,33,460,0]],[[0,33,462,0],[9,33,462,9,811],[29,33,463,2,826],[47,33,463,39],[49,33,464,2,822],[63,33,464,32]],[[4,33,466,2],[11,33,466,9,713],[27,33,466,25,826],[47,33,466,45]],[[8,33,467,4,823],[20,33,467,4,823],[35,33,467,4,823],[45,33,467,14]],[[8,33,468,4,824],[26,33,468,4,824],[47,33,468,4,824],[63,33,468,20]],[[8,33,469,4,825],[22,33,469,18,715],[44,33,469,40,715],[63,33,469,59,822]],[[4,33,470,2]],[[0,33,471,0]],[[0,33,473,0],[9,33,473,9,774],[39,33,474,2,827],[59,33,474,50]],[[4,33,476,2],[78,33,476,76]],[[4,33,477,2],[80,33,477,78]],[[4,33,478,2],[75,33,478,73]],[[4,33,479,2],[78,33,479,76]],[[4,33,480,2],[66,33,480,64]],[[4,33,481,2],[47,33,481,45]],[[4,33,482,2],[6,33,482,4]],[[4,33,483,2],[79,33,483,77]],[[4,33,484,2],[78,33,484,76]],[[4,33,485,2],[82,33,485,80]],[[4,33,486,2],[35,33,486,33]],[[4,33,487,2],[10,33,487,8,828],[19,33,487,17,827],[40,33,487,38,829],[49,33,487,47]],[[4,33,488,2],[11,33,488,9],[15,33,488,13,830],[30,33,488,28]],[[8,33,489,4],[14,33,489,10,831],[20,33,489,15,832],[30,33,489,25]],[[12,33,490,6],[18,33,490,13],[23,33,490,19]],[[16,33,491,8],[22,33,491,14],[24,33,491,16,833],[28,33,491,20],[30,33,491,22,834],[35,33,491,27],[37,33,491,29],[40,33,491,32],[46,33,491,38,828],[53,33,491,45,835],[57,33,491,49]],[[16,33,492,8],[20,33,492,12],[21,33,492,13,833],[27,33,492,19]],[[20,33,493,10],[87,33,493,77]],[[20,33,494,10],[39,33,494,29]],[[20,33,495,10,832],[31,33,495,21,836],[38,33,495,28],[39,33,495,29,834]],[[20,33,496,10]],[[16,33,497,8]],[[16,33,498,8],[85,33,498,77]],[[16,33,499,8],[37,33,499,29]],[[16,33,500,8]],[[12,33,501,6]],[[8,33,502,4]],[[4,33,503,2]],[[0,33,504,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,34,3,16,837],[55,34,3,16,837]],[],[],[[15,34,3,16,837]],[],[],[[25,34,1,33]],[[0,34,3,7],[9,34,3,16,837],[30,34,4,2,838],[37,34,4,18],[39,34,5,2,839],[65,34,5,37],[70,34,5,42]],[[4,34,7,2],[66,34,7,64]],[[4,34,8,2],[107,34,8,105]],[[4,34,9,2],[8,34,9,6,840],[14,34,9,12,841],[21,34,9,19],[22,34,9,20,838],[32,34,9,30]],[[8,34,10,4],[15,34,10,11],[18,34,10,14,838],[25,34,10,21],[26,34,10,22],[28,34,10,24],[29,34,10,25],[30,34,10,26],[32,34,10,28,838],[39,34,10,35],[40,34,10,36],[42,34,10,38],[43,34,10,39],[44,34,10,40],[46,34,10,42,838],[53,34,10,49],[54,34,10,50],[56,34,10,52],[58,34,10,54]],[[4,34,11,2]],[[4,34,13,2],[70,34,13,68]],[[4,34,14,2],[86,34,14,84]],[[4,34,15,2],[8,34,15,6,839],[35,34,15,33,838],[43,34,15,41,842],[53,34,15,51],[54,34,15,52,843],[63,34,15,52,843],[79,34,15,68],[82,34,15,71]],[[8,34,16,4],[15,34,16,11,843],[24,34,16,11,843],[40,34,16,27]],[[4,34,17,2]],[[4,34,19,2],[11,34,19,9,838]],[[0,34,20,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,35,2,16,844],[62,35,2,16,844]],[],[],[[15,35,2,16,844]],[],[],[[0,35,2,7],[9,35,2,16,844],[37,35,3,2,845],[48,35,3,32],[50,35,4,2,846],[58,35,4,29]],[[4,35,6,2],[23,35,6,21]],[[4,35,7,2],[10,35,7,8,847],[31,35,7,29,845],[42,35,7,40],[43,35,7,41],[45,35,7,43]],[[4,35,8,2],[10,35,8,8,848],[28,35,8,26,846],[36,35,8,34],[37,35,8,35],[39,35,8,37]],[[4,35,10,2],[95,35,10,93]],[[4,35,11,2],[64,35,11,62]],[[4,35,12,2],[139,35,12,137]],[[4,35,13,2],[8,35,13,6,849],[14,35,13,12,850],[21,35,13,19],[22,35,13,20,847],[45,35,13,43,849],[51,35,13,49,850],[58,35,13,56],[59,35,13,57,848],[77,35,13,75]],[[8,35,14,4],[126,35,14,122]],[[8,35,15,4],[111,35,15,107]],[[8,35,16,4],[12,35,17,6,847],[30,35,17,24],[31,35,17,25],[33,35,17,27],[38,35,17,32,848],[53,35,17,47],[54,35,17,48],[56,35,17,50],[60,35,18,6,847],[78,35,18,24],[79,35,18,25],[81,35,18,27],[86,35,18,32,848],[101,35,18,47],[102,35,18,48],[104,35,18,50],[106,35,19,6]],[[12,35,20,6],[19,35,20,13]],[[8,35,21,4]],[[4,35,22,2],[11,35,22,9],[15,35,22,13,847],[38,35,22,36,848],[55,35,22,53]],[[8,35,23,4],[15,35,23,11]],[[4,35,24,2]],[[4,35,26,2],[37,35,26,35]],[[4,35,27,2],[8,35,27,6,845],[19,35,27,17],[20,35,27,18],[22,35,27,20],[24,35,27,22]],[[8,35,28,4],[84,35,28,80]],[[8,35,29,4],[15,35,29,11],[16,35,29,12,846],[24,35,29,20],[25,35,29,21],[27,35,29,23]],[[4,35,30,2]],[[4,35,31,2],[72,35,31,70]],[[4,35,32,2],[8,35,32,6,846],[16,35,32,14],[17,35,32,15],[19,35,32,17],[21,35,32,19]],[[8,35,33,4],[15,35,33,11]],[[4,35,34,2]],[[4,35,35,2],[112,35,35,110]],[[4,35,36,2],[95,35,36,93]],[[4,35,37,2],[55,35,37,53]],[[4,35,38,2],[10,35,38,8,851],[29,35,38,27,852],[36,35,38,34,853],[42,35,38,40],[43,35,38,41,845],[54,35,38,52],[55,35,38,53],[57,35,38,55],[58,35,38,56],[59,35,38,57],[61,35,38,59]],[[4,35,39,2],[10,35,39,8,854],[26,35,39,24,852],[33,35,39,31,853],[39,35,39,37],[40,35,39,38,846],[48,35,39,46],[49,35,39,47],[51,35,39,49],[52,35,39,50],[53,35,39,51],[55,35,39,53]],[[4,35,40,2],[8,35,40,6],[9,35,40,7,851],[29,35,40,27],[30,35,40,28,854],[45,35,40,43],[52,35,40,50]],[[4,35,41,2],[11,35,41,9,844],[39,35,41,37,851],[57,35,41,55,854]],[[0,35,42,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,36,57,18,855],[19,36,57,33],[21,36,57,33]],[[15,36,57,18,855]],[],[[4,36,99,16,856],[38,36,99,50],[40,36,99,50]],[[15,36,99,16,856]],[],[[4,36,1739,16,857],[17,36,1739,29],[19,36,1739,29]],[[15,36,1739,16,857]],[],[[4,36,1177,16,858],[24,36,1177,36],[26,36,1177,36]],[[15,36,1177,16,858]],[],[[4,36,174,16,859],[22,36,174,34],[24,36,174,34]],[[15,36,174,16,859]],[],[],[[25,36,16,7]],[[31,36,17,29]],[[35,36,18,34]],[[38,36,19,37]],[[37,36,20,36]],[[32,36,21,40]],[[36,36,25,7]],[[45,36,26,44]],[[33,36,27,37]],[[28,36,31,7]],[[0,36,57,7],[4,36,57,18,855],[22,36,57,18,855],[33,36,57,18,855],[36,36,57,18,855],[45,36,57,18,855],[60,36,57,18,855]],[],[],[],[],[],[[11,36,57,18,855]],[],[[0,36,97,0],[6,36,97,6,860],[13,36,97,13],[18,36,97,20]],[[0,36,99,7],[9,36,99,16,856],[44,36,100,2,861],[55,36,100,21],[57,36,101,2,862],[68,36,101,32],[70,36,102,2,863],[78,36,102,36],[80,36,103,2,864],[88,36,103,20]],[[4,36,105,2],[75,36,105,73]],[[4,36,106,2],[21,36,106,19]],[[4,36,107,2],[10,36,107,8,865],[25,36,107,54]],[[8,36,108,4,866],[28,36,108,24]],[[8,36,109,4,867],[29,36,109,25]],[[4,36,110,2]],[[4,36,111,2],[10,36,111,8,868],[17,36,111,15,869],[45,36,112,4,861],[58,36,113,4,862],[71,36,114,4,870],[82,36,114,4,870],[85,36,116,4,863],[95,36,117,4,864],[105,36,118,4],[111,36,119,4],[117,36,120,4],[124,36,121,4],[130,36,122,4],[136,36,123,4],[143,36,124,4,865]],[[4,36,127,2],[82,36,127,80]],[[4,36,128,2],[78,36,128,76]],[[4,36,129,2],[16,36,129,14]],[[4,36,130,2],[6,36,130,4]],[[4,36,131,2],[81,36,131,79]],[[4,36,132,2],[82,36,132,80]],[[4,36,133,2],[68,36,133,66]],[[4,36,134,2],[6,36,134,4]],[[4,36,135,2],[77,36,135,75]],[[4,36,136,2],[82,36,136,80]],[[4,36,137,2],[80,36,137,78]],[[4,36,138,2],[81,36,138,79]],[[4,36,139,2],[80,36,139,78]],[[4,36,140,2],[22,36,140,20]],[[4,36,142,2],[11,36,142,9,868],[16,36,142,14,871],[20,36,142,18]],[[0,36,143,0]],[[0,36,174,7],[9,36,174,16,859],[28,36,175,2,861],[39,36,175,21],[41,36,176,2,872],[47,36,176,13],[49,36,177,2,873],[61,36,177,32],[63,36,178,2,874],[77,36,178,35],[79,36,179,2,875],[93,36,179,35],[95,36,180,2,876],[104,36,180,28],[106,36,181,2,863],[114,36,181,36],[116,36,182,2,864],[124,36,182,27],[126,36,183,2,877],[138,36,183,40],[140,36,184,2,878],[152,36,184,31],[154,36,185,2,879],[175,36,185,32],[177,36,186,2,880],[197,36,186,31],[199,36,187,2,865],[211,36,187,45]],[[4,36,189,2],[10,36,189,8,881],[30,36,189,28]],[[4,36,190,2],[10,36,190,8,882],[38,36,190,36]],[[4,36,191,2],[10,36,191,8,883],[29,36,191,27]],[[4,36,192,2],[11,36,192,9,884],[39,36,193,4,861],[52,36,194,4,872],[60,36,195,4,873],[77,36,195,21],[84,36,195,28,873],[99,36,195,43,870],[110,36,196,4,874],[126,36,197,4,875],[142,36,198,4,876],[153,36,199,4,881],[172,36,200,4,863],[182,36,201,4,864],[192,36,202,4,877],[206,36,203,4,878],[220,36,204,4,879],[243,36,205,4,880],[265,36,206,4],[271,36,207,4],[277,36,208,4,882],[304,36,209,4,883],[322,36,210,4,865]],[[0,36,212,0]],[[0,36,214,0],[9,36,214,9,884],[37,36,215,2,861],[48,36,215,21],[50,36,216,2,872],[56,36,216,13],[58,36,217,2,873],[70,36,217,32],[72,36,218,2,874],[86,36,218,35],[88,36,219,2,875],[102,36,219,35],[104,36,220,2,876],[113,36,220,28],[115,36,221,2,881],[132,36,221,28],[134,36,222,2,863],[142,36,222,36],[144,36,223,2,864],[152,36,223,27],[154,36,224,2,877],[166,36,224,40],[168,36,225,2,878],[180,36,225,31],[182,36,226,2,879],[203,36,226,32],[205,36,227,2,880],[225,36,227,31],[227,36,228,2,885],[244,36,228,45],[246,36,229,2,886],[268,36,229,39],[270,36,230,2,882],[295,36,230,36],[297,36,231,2,883],[313,36,231,33],[315,36,232,2,865],[327,36,232,45]],[[4,36,234,2],[67,36,234,65]],[[4,36,235,2],[10,36,235,8,887],[23,36,235,21,874],[37,36,235,35],[38,36,235,36],[40,36,235,38]],[[4,36,236,2],[10,36,236,8,888],[23,36,236,21,875],[37,36,236,35],[38,36,236,36],[40,36,236,38]],[[4,36,237,2],[8,36,237,6],[9,36,237,7,889],[10,36,237,7,889],[13,36,237,7,889],[28,36,237,7,889],[40,36,237,19],[42,36,237,20,888],[54,36,237,32,887],[67,36,237,45]],[[8,36,238,4],[81,36,238,77]],[[8,36,239,4],[69,36,239,65]],[[8,36,240,4],[12,36,262,6],[12,36,241,6],[12,36,242,6],[79,36,241,73],[80,36,242,74]],[[8,36,243,6],[79,36,243,77]],[[8,36,244,6],[78,36,244,76]],[[8,36,245,6],[22,36,245,20]],[[8,36,246,6],[10,36,246,8]],[[8,36,247,6],[79,36,247,77]],[[8,36,248,6],[79,36,248,77]],[[8,36,249,6],[75,36,249,73]],[[8,36,250,6],[79,36,250,77]],[[8,36,251,6],[61,36,251,59]],[[8,36,252,6],[10,36,252,8]],[[8,36,253,6],[79,36,253,77]],[[8,36,254,6],[80,36,254,78]],[[8,36,255,6],[10,36,255,8]],[[8,36,256,6],[60,36,256,58]],[[8,36,257,6],[10,36,257,8]],[[8,36,258,6],[78,36,258,76]],[[8,36,259,6],[73,36,259,71]],[[8,36,260,6],[74,36,260,72]],[[8,36,261,6],[73,36,261,71]],[[8,36,262,7],[9,36,262,8,881],[30,36,263,8,890],[31,36,263,8,890],[34,36,263,8,890],[63,36,263,8,890],[90,36,263,35],[92,36,263,36,874],[108,36,263,52,875],[127,36,264,6],[196,36,264,75]],[[8,36,265,6],[79,36,265,77]],[[8,36,266,6],[62,36,266,60]],[[8,36,267,6],[10,36,267,8]],[[8,36,268,6],[72,36,268,70]],[[8,36,269,6],[32,36,269,30]],[[8,36,270,6],[10,36,270,8]],[[8,36,271,6],[78,36,271,76]],[[8,36,272,6],[75,36,272,73]],[[8,36,273,6],[47,36,273,45]],[[8,36,274,6,888],[23,36,274,21,891],[32,36,274,21,891],[53,36,274,42],[55,36,275,6]],[[12,36,276,6],[19,36,276,13]],[[8,36,277,4]],[[8,36,278,4],[12,36,278,8,885],[34,36,278,30],[42,36,278,38,886],[69,36,278,65],[75,36,278,71]],[[12,36,279,6],[82,36,279,76]],[[12,36,280,6],[77,36,280,71]],[[12,36,281,6],[31,36,281,25]],[[12,36,282,6],[19,36,282,13]],[[8,36,283,4]],[[8,36,284,4],[15,36,284,11,869],[43,36,285,6,861],[56,36,286,6,875],[72,36,287,6,873],[86,36,288,6,876],[97,36,289,6,863],[107,36,290,6,864],[117,36,291,6,877],[131,36,292,6,878],[145,36,293,6,879],[168,36,294,6,885],[187,36,295,6,886],[211,36,296,6,882],[238,36,297,6,865]],[[4,36,299,2]],[[4,36,301,2],[75,36,301,73]],[[4,36,302,2],[77,36,302,75]],[[4,36,303,2],[80,36,303,78]],[[4,36,304,2],[80,36,304,78]],[[4,36,305,2],[48,36,305,46]],[[4,36,306,2],[10,36,306,8,892],[24,36,307,4,886],[51,36,307,31],[59,36,307,39,885],[81,36,307,61],[88,36,308,8,885],[106,36,308,26,893],[112,36,308,32],[113,36,308,33]],[[8,36,308,34,886]],[[8,36,308,58,888]],[[5,36,308,69],[9,36,310,8],[11,36,310,10]],[[4,36,312,2],[10,36,312,8,894],[35,36,312,33,875],[49,36,312,47],[50,36,312,48],[52,36,312,50]],[[4,36,313,2],[10,36,313,8,895],[35,36,313,33,874],[49,36,313,47],[50,36,313,48],[52,36,313,50]],[[4,36,314,2],[10,36,314,8,896],[29,36,314,27,863],[42,36,314,40],[49,36,314,47,863],[57,36,314,55],[58,36,314,56],[60,36,314,58],[63,36,314,61]],[[4,36,315,2],[10,36,315,8,897],[33,36,315,31,877],[50,36,315,48],[57,36,315,55,877],[69,36,315,67],[70,36,315,68],[72,36,315,70],[75,36,315,73]],[[4,36,317,2],[76,36,317,74]],[[4,36,318,2],[78,36,318,76]],[[4,36,319,2],[33,36,319,31]],[[4,36,320,2],[10,36,320,8,898],[25,36,320,23,875],[39,36,320,37],[40,36,320,38],[42,36,320,40],[47,36,320,45]],[[4,36,321,2],[10,36,321,8,899],[35,36,321,33,881],[56,36,321,54,898]],[[4,36,323,2],[10,36,323,8,900],[30,36,324,4,873],[47,36,324,21,870],[59,36,324,33,873],[72,36,324,46,901],[86,36,324,60],[89,36,324,63,870]],[[4,36,326,2],[79,36,326,77]],[[4,36,327,2],[20,36,327,18]],[[4,36,328,2],[78,36,328,76]],[[4,36,329,2],[78,36,329,76]],[[4,36,330,2],[80,36,330,78]],[[4,36,331,2],[79,36,331,77]],[[4,36,332,2],[78,36,332,76]],[[4,36,333,2],[75,36,333,73]],[[4,36,334,2],[77,36,334,75]],[[4,36,335,2],[76,36,335,74]],[[4,36,336,2],[35,36,336,33]],[[4,36,337,2],[8,36,337,6,902],[34,36,337,41]],[[4,36,338,2],[8,36,338,6,903],[35,36,338,42]],[[4,36,339,2],[11,36,339,10,876]],[[8,36,340,4],[13,36,340,4]],[[8,36,341,4],[13,36,341,4]],[[8,36,342,4],[13,36,342,4]],[[12,36,343,6],[81,36,343,75]],[[12,36,344,6],[25,36,344,19]],[[12,36,345,6,902],[38,36,345,32]],[[12,36,346,6,903],[39,36,346,33]],[[12,36,347,6]],[[8,36,348,4],[13,36,348,4]],[[8,36,349,4],[13,36,349,4]],[[12,36,350,6,902],[38,36,350,32]],[[12,36,351,6,903],[39,36,351,33]],[[12,36,352,6]],[[8,36,353,4]],[[12,36,354,6,876]],[[12,36,355,6]],[[4,36,356,2]],[[4,36,357,2],[10,36,357,8,904],[30,36,357,28],[34,36,357,32,905],[38,36,358,4,902],[64,36,358,30,870],[76,36,358,42,900]],[[4,36,361,2],[73,36,361,71]],[[4,36,362,2],[74,36,362,72]],[[4,36,363,2],[74,36,363,72]],[[4,36,364,2],[76,36,364,74]],[[4,36,365,2],[61,36,365,59]],[[4,36,366,2],[10,36,366,8,906],[26,36,366,24,907],[33,36,366,31,908],[37,36,366,35],[38,36,366,36,894],[62,36,366,60,909],[68,36,366,66],[73,36,366,71]],[[4,36,368,2],[78,36,368,76]],[[4,36,369,2],[79,36,369,77]],[[4,36,370,2],[78,36,370,76]],[[4,36,371,2],[79,36,371,77]],[[4,36,372,2],[8,36,372,6,910]],[[4,36,373,2],[8,36,373,6,911]],[[4,36,374,2],[8,36,375,4,873],[25,36,375,21,870],[38,36,376,4],[39,36,376,5,903],[67,36,377,4],[136,36,377,73]],[[4,36,378,4],[5,36,378,6,906],[6,36,378,6,906],[23,36,378,23,880],[43,36,378,42],[46,36,379,4]],[[8,36,380,4],[39,36,380,35]],[[8,36,381,4],[14,36,381,10,912],[32,36,381,28]],[[8,36,382,4,910],[23,36,382,19,913],[45,36,383,6,912],[62,36,384,6,873],[76,36,385,6,904]],[[8,36,387,4,911],[30,36,387,26]],[[4,36,388,2],[11,36,388,9],[15,36,388,13,863],[28,36,388,26],[36,36,388,34,863],[44,36,388,42],[45,36,388,43],[47,36,388,45],[52,36,388,50],[58,36,388,56]],[[8,36,389,4],[76,36,389,72]],[[8,36,390,4],[78,36,390,74]],[[8,36,391,4],[79,36,391,75]],[[8,36,392,4],[73,36,392,69]],[[8,36,393,4],[71,36,393,67]],[[8,36,394,4],[28,36,394,24]],[[8,36,395,4],[14,36,395,10,914],[24,36,395,20,863],[32,36,395,28],[33,36,395,29],[35,36,395,31]],[[8,36,396,4],[14,36,396,10,915],[28,36,396,24,863],[36,36,396,32],[37,36,396,33],[39,36,396,35]],[[8,36,397,4],[14,36,397,10,916],[33,36,397,29]],[[8,36,398,4],[14,36,398,10,917],[34,36,398,30,864],[47,36,398,43]],[[8,36,399,4,910],[23,36,399,19,918],[49,36,400,6,914],[58,36,401,6,915],[71,36,402,6,916],[89,36,403,6,864],[99,36,404,6,917],[118,36,405,6,906],[133,36,406,6,904],[152,36,407,6,861]],[[8,36,409,4,911],[30,36,409,26,906],[47,36,409,43,917]],[[4,36,410,2],[11,36,410,9],[15,36,410,13,877],[32,36,410,30],[38,36,410,36]],[[8,36,411,4],[38,36,411,34]],[[8,36,412,4],[14,36,412,10,919],[28,36,412,24,877],[40,36,412,36],[41,36,412,37],[43,36,412,39]],[[8,36,413,4],[14,36,413,10,920],[32,36,413,28,877],[44,36,413,40],[45,36,413,41],[47,36,413,43]],[[8,36,414,4],[14,36,414,10,921],[37,36,414,33,877],[49,36,414,45],[50,36,414,46],[52,36,414,48]],[[8,36,415,4,910],[23,36,415,19,918],[49,36,416,6,919],[62,36,417,6,920],[79,36,418,6,921],[101,36,419,6,878],[115,36,420,6,879],[138,36,421,6,906],[153,36,422,6,904],[172,36,423,6,861]],[[8,36,425,4,911],[30,36,426,6,921],[54,36,426,31,906],[71,36,426,48,879]],[[4,36,427,2],[11,36,427,9]],[[8,36,428,4],[61,36,428,57]],[[8,36,429,4,910],[23,36,429,19,922],[41,36,430,6,904],[60,36,431,6,906],[75,36,432,6,861],[88,36,433,6,876]],[[8,36,435,4,911],[30,36,435,26]],[[4,36,436,2]],[[4,36,438,2],[76,36,438,74]],[[4,36,439,2],[73,36,439,71]],[[4,36,440,2],[73,36,440,71]],[[4,36,441,2],[77,36,441,75]],[[4,36,442,2],[63,36,442,61]],[[4,36,443,2],[10,36,443,8,923],[17,36,443,15,875],[31,36,443,29],[32,36,443,30],[34,36,443,32]],[[4,36,444,2],[10,36,444,8,924],[23,36,445,4],[30,36,445,11,923],[39,36,445,20],[51,36,445,32,875],[65,36,445,46],[66,36,445,47],[68,36,445,49],[73,36,445,54],[85,36,448,8,923],[85,36,447,8],[92,36,450,8,883],[135,36,447,58]],[[4,36,452,2],[78,36,452,76]],[[4,36,453,2],[79,36,453,77]],[[4,36,454,2],[36,36,454,34]],[[4,36,455,2],[8,36,455,6,911],[31,36,455,29,924],[46,36,455,44],[52,36,455,50]],[[8,36,456,4,925],[29,36,456,25,865],[43,36,456,39,924]],[[4,36,457,2]],[[4,36,459,2],[80,36,459,78]],[[4,36,460,2],[80,36,460,78]],[[4,36,461,2],[79,36,461,77]],[[4,36,462,2],[81,36,462,79]],[[4,36,463,2],[23,36,463,21]],[[4,36,464,2],[8,36,464,6,926],[37,36,466,6],[38,36,466,7]],[[4,36,467,2],[8,36,467,6,927],[23,36,467,21]],[[4,36,469,2],[75,36,469,73]],[[4,36,470,2],[81,36,470,79]],[[4,36,471,2],[68,36,471,66]],[[4,36,472,2],[6,36,472,4]],[[4,36,473,2],[80,36,473,78]],[[4,36,474,2],[74,36,474,72]],[[4,36,475,2],[6,36,475,4]],[[4,36,476,2],[75,36,476,73]],[[4,36,477,2],[41,36,477,39]],[[4,36,478,2],[8,36,478,6,928],[35,36,478,33]],[[4,36,479,2],[80,36,479,78]],[[4,36,480,2],[78,36,480,76]],[[4,36,481,2],[80,36,481,78]],[[4,36,482,2],[48,36,482,46]],[[4,36,483,2],[79,36,483,77]],[[4,36,484,2],[61,36,484,59]],[[4,36,485,2],[30,36,485,28]],[[4,36,486,2],[8,36,486,6,929],[37,36,488,6],[38,36,488,7]],[[4,36,490,2],[8,36,490,7],[12,36,490,11,930],[32,36,490,31,894],[55,36,490,55]],[[8,36,491,4],[12,36,491,8,931],[34,36,492,6,894],[56,36,492,28],[57,36,492,29,930],[74,36,492,46]],[[8,36,493,4],[14,36,493,10,932],[36,36,494,6,895],[58,36,494,28],[59,36,494,29,930],[76,36,494,46]],[[8,36,495,4],[12,36,495,8,932],[36,36,495,32,870],[47,36,495,43]],[[12,36,496,6],[80,36,496,74]],[[12,36,497,6],[63,36,497,57]],[[12,36,498,6],[19,36,498,13]],[[8,36,499,4]],[[8,36,500,4],[14,36,500,10,933],[35,36,501,6,900],[57,36,501,28,870],[69,36,502,10,900],[87,36,502,28,934],[90,36,502,31],[91,36,502,32,930],[111,36,503,10,870]],[[8,36,505,4],[12,36,505,8,935],[28,36,506,6,896],[49,36,506,27],[56,36,506,34,896],[72,36,506,50],[73,36,506,51,930],[90,36,506,68],[93,36,506,71]],[[8,36,507,4],[12,36,507,8,936],[32,36,508,6,897],[57,36,508,31],[64,36,509,10,897],[84,36,509,30],[85,36,509,31,930],[102,36,509,48],[105,36,510,10]],[[8,36,512,4],[12,36,512,8,937],[30,36,512,26,931],[49,36,512,45],[50,36,512,46],[52,36,512,48]],[[8,36,513,4],[12,36,513,8,938],[28,36,513,24,864]],[[8,36,514,4],[12,36,514,8,939],[32,36,514,28,878]],[[8,36,515,4],[12,36,515,8,940],[41,36,515,37,879]],[[8,36,516,4],[12,36,517,6],[12,36,518,6],[54,36,518,48],[84,36,517,78]],[[8,36,519,6,876],[22,36,519,6,876],[27,36,520,6,937],[47,36,520,26,941],[56,36,520,26,941],[75,36,520,45],[77,36,521,6]],[[12,36,522,6],[85,36,522,79]],[[12,36,523,6],[81,36,523,75]],[[12,36,524,6],[65,36,524,59]],[[12,36,525,6,931],[34,36,525,28,942],[66,36,526,8,872],[74,36,527,8,932]],[[12,36,529,6,937],[30,36,529,24,931],[49,36,529,43],[50,36,529,44],[52,36,529,46]],[[12,36,531,6],[76,36,531,70]],[[12,36,532,6],[71,36,532,65]],[[12,36,533,6,935],[28,36,533,22]],[[12,36,534,6,938],[28,36,534,22]],[[12,36,535,6,936],[32,36,535,26]],[[12,36,536,6,939],[32,36,536,26]],[[12,36,537,6,940],[41,36,537,35]],[[8,36,538,4]],[[8,36,540,4],[14,36,540,10,943],[35,36,540,31,944],[36,36,540,31,944],[39,36,540,31,944],[61,36,540,31,944],[81,36,540,51],[83,36,540,52,937]],[[8,36,541,4],[14,36,541,10,945],[34,36,542,6,933],[57,36,542,29,870],[69,36,543,10,933],[88,36,543,29,934],[91,36,543,32],[92,36,543,33,943],[114,36,544,10,870]],[[8,36,546,4],[14,36,546,10,946],[26,36,546,22,884],[54,36,547,6,861],[67,36,548,6,872],[75,36,549,6,945],[94,36,550,6,932],[115,36,551,6,931],[136,36,552,6,876],[147,36,553,6,899],[171,36,554,6,935],[188,36,554,23],[194,36,555,6,938],[209,36,556,6,936],[230,36,556,27],[236,36,557,6,939],[255,36,558,6,940],[283,36,559,6,880],[305,36,560,6,892],[318,36,561,6,930],[336,36,562,6,882],[365,36,562,35,911],[386,36,563,6,924],[398,36,564,6,865]],[[8,36,567,4],[12,36,567,8,946],[26,36,567,22],[32,36,567,28]],[[12,36,568,6],[77,36,568,71]],[[12,36,569,6],[84,36,569,78]],[[12,36,570,6],[36,36,570,30]],[[12,36,571,6],[19,36,571,13]],[[8,36,572,4]],[[8,36,574,4],[52,36,574,48]],[[8,36,575,4],[12,36,575,8,927],[29,36,575,25],[35,36,575,31]],[[12,36,576,6,927],[27,36,576,21],[31,36,576,25,905]],[[8,36,577,4]],[[8,36,578,4,927],[21,36,578,17,947],[24,36,578,20],[25,36,578,21,930],[43,36,578,39,946]],[[8,36,579,4],[14,36,579,10,948],[34,36,579,30,946],[44,36,579,40,871],[48,36,579,44]],[[8,36,580,4],[12,36,580,8,948],[34,36,580,30],[40,36,580,36]],[[12,36,581,6],[18,36,581,12,949],[39,36,581,50],[43,36,581,54,905],[47,36,582,8,902],[73,36,582,34,870],[85,36,582,46,933]],[[12,36,584,6,949],[31,36,584,25,947],[34,36,584,28],[35,36,584,29,943],[55,36,584,49,948]],[[12,36,585,6,904],[30,36,585,24,947],[33,36,585,27],[34,36,585,28,930],[52,36,585,46,949]],[[8,36,586,4]],[[8,36,588,4],[76,36,588,72]],[[8,36,589,4],[79,36,589,75]],[[8,36,590,4],[20,36,590,16]],[[8,36,591,4],[14,36,591,10,950],[31,36,591,27,946],[41,36,591,37,951],[46,36,591,42]],[[8,36,592,4,926],[34,36,592,30],[35,36,592,31,930],[52,36,592,48],[55,36,592,51,950]],[[8,36,594,4],[14,36,594,10,952],[40,36,594,36,946],[50,36,594,46,953],[68,36,594,64]],[[8,36,595,4],[12,36,595,8,952],[40,36,595,36],[46,36,595,42]],[[12,36,596,6],[54,36,596,48]],[[12,36,597,6,928],[39,36,597,33]],[[12,36,598,6,929],[38,36,598,32],[39,36,598,33,930],[56,36,598,50],[59,36,598,53,952]],[[8,36,599,4],[15,36,599,11]],[[12,36,600,6,929],[38,36,600,32],[39,36,600,33,930],[56,36,600,50],[59,36,600,53,950]],[[8,36,601,4]],[[4,36,602,2]],[[4,36,604,2],[11,36,604,9]],[[8,36,605,4,954],[16,36,605,12,911],[38,36,605,12,911],[42,36,605,12,911]],[[8,36,608,4,951],[15,36,608,11,955],[47,36,609,6,875],[63,36,610,6,926]],[[8,36,612,4,871],[14,36,612,10,910]],[[8,36,613,4,953],[28,36,613,24,956],[53,36,614,6,875],[69,36,615,6,929],[97,36,616,6,911],[118,36,617,6,928],[144,36,618,6,882]],[[8,36,620,4,924]],[[8,36,621,4,957],[18,36,621,14,927]],[[4,36,622,2]],[[0,36,623,0]],[[0,36,625,0],[9,36,625,9,869],[37,36,626,2,861],[48,36,626,21],[50,36,627,2,875],[64,36,627,35],[66,36,628,2,873],[78,36,628,32],[80,36,629,2,876],[89,36,629,28],[91,36,630,2,863],[99,36,630,36],[101,36,631,2,864],[109,36,631,27],[111,36,632,2,877],[123,36,632,40],[125,36,633,2,878],[137,36,633,31],[139,36,634,2,879],[160,36,634,32],[162,36,635,2,885],[179,36,635,45],[181,36,636,2,886],[203,36,636,39],[205,36,637,2,882],[230,36,637,36],[232,36,638,2,865],[244,36,638,45]],[[4,36,640,2],[82,36,640,80]],[[4,36,641,2],[82,36,641,80]],[[4,36,642,2],[79,36,642,77]],[[4,36,643,2],[72,36,643,70]],[[4,36,644,2],[6,36,644,4]],[[4,36,645,2],[81,36,645,79]],[[4,36,646,2],[78,36,646,76]],[[4,36,647,2],[79,36,647,77]],[[4,36,648,2],[52,36,648,50]],[[4,36,650,2],[10,36,650,8,888],[23,36,650,21,875],[37,36,650,35],[38,36,650,36],[40,36,650,38]],[[4,36,651,2],[10,36,651,8,892],[24,36,652,4,886],[51,36,652,31],[59,36,652,39,885],[81,36,652,61],[88,36,653,8,885],[106,36,653,26,893],[112,36,653,32],[113,36,653,33]],[[8,36,653,34,886]],[[8,36,653,58,888]],[[5,36,653,69],[9,36,655,8],[11,36,655,10]],[[4,36,657,2],[10,36,657,8,894],[35,36,657,33,875],[49,36,657,47],[50,36,657,48],[52,36,657,50]],[[4,36,658,2],[10,36,658,8,897],[33,36,658,31,877],[50,36,658,48],[57,36,658,55,877],[69,36,658,67],[70,36,658,68],[72,36,658,70],[75,36,658,73]],[[4,36,659,2],[10,36,659,8,896],[29,36,659,27,863],[42,36,659,40],[49,36,659,47,863],[57,36,659,55],[58,36,659,56],[60,36,659,58],[63,36,659,61]],[[4,36,660,2],[10,36,660,8,900],[30,36,661,4,873],[47,36,661,21,870],[59,36,661,33,873],[72,36,661,46,901],[86,36,661,60],[89,36,661,63,870]],[[4,36,663,2],[8,36,663,6,902],[34,36,663,41]],[[4,36,664,2],[8,36,664,6,903],[35,36,664,42]],[[4,36,665,2],[8,36,665,6,912],[26,36,665,33]],[[4,36,666,2],[11,36,666,10,876]],[[8,36,667,4],[13,36,667,4]],[[12,36,668,6],[80,36,668,74]],[[12,36,669,6],[25,36,669,19]],[[12,36,670,6,902],[38,36,670,32]],[[12,36,672,6],[84,36,672,78]],[[12,36,673,6],[85,36,673,79]],[[12,36,674,6],[84,36,674,78]],[[12,36,675,6],[34,36,675,28]],[[12,36,676,6],[14,36,676,8]],[[12,36,677,6],[75,36,677,69]],[[12,36,678,6,903],[39,36,679,8,873],[56,36,679,25,870],[69,36,680,8,861],[83,36,680,22,873],[96,36,680,35,861],[107,36,680,46],[111,36,680,50,958],[128,36,680,50,958],[148,36,680,70]],[[12,36,682,6,912],[30,36,682,24]],[[12,36,683,6]],[[8,36,684,4],[13,36,684,4]],[[12,36,685,6],[78,36,685,72]],[[12,36,686,6],[39,36,686,33]],[[12,36,687,6,903],[39,36,687,33]],[[12,36,688,6,902],[38,36,688,32]],[[12,36,689,6,912],[30,36,689,24]],[[12,36,690,6]],[[8,36,691,4],[13,36,691,4]],[[12,36,692,6],[84,36,692,78]],[[12,36,693,6],[38,36,693,32]],[[12,36,694,6,903],[39,36,694,33]],[[12,36,695,6,903],[39,36,695,33]],[[12,36,697,6],[83,36,697,77]],[[12,36,698,6],[84,36,698,78]],[[12,36,699,6],[50,36,699,44]],[[12,36,700,6],[14,36,700,8]],[[12,36,701,6],[86,36,701,80]],[[12,36,702,6],[84,36,702,78]],[[12,36,703,6],[86,36,703,80]],[[12,36,704,6],[83,36,704,77]],[[12,36,705,6],[86,36,705,80]],[[12,36,706,6],[49,36,706,43]],[[12,36,707,6],[16,36,707,10,873],[33,36,707,27,870],[44,36,707,38]],[[16,36,708,8],[22,36,708,14,959],[31,36,708,23,873],[44,36,708,36,960],[47,36,708,39]],[[16,36,709,8],[22,36,709,14,961],[41,36,710,10],[42,36,710,11,857],[56,36,710,25,959],[67,36,710,36,959],[74,36,710,43,954],[80,36,710,49],[85,36,710,54]],[[16,36,711,8,912],[34,36,711,26,961]],[[12,36,712,6],[19,36,712,13]],[[16,36,713,8,912],[34,36,713,26]],[[12,36,714,6]],[[12,36,715,6]],[[8,36,716,4],[13,36,716,4]],[[8,36,717,4],[13,36,717,4]],[[12,36,718,6],[37,36,718,31]],[[12,36,719,6,903],[39,36,719,33]],[[12,36,720,6,902],[38,36,720,32]],[[12,36,721,6,912],[30,36,721,24]],[[12,36,722,6]],[[8,36,723,4]],[[12,36,724,6,876]],[[12,36,725,6]],[[4,36,726,2]],[[4,36,728,2],[10,36,728,8,904],[30,36,728,28],[34,36,728,32,905],[38,36,729,4,902],[64,36,729,30,870],[76,36,729,42,900]],[[4,36,731,2],[10,36,731,8,906],[26,36,731,24,907],[33,36,731,31,908],[37,36,731,35],[38,36,731,36,894],[62,36,731,60,909],[68,36,731,66],[73,36,731,71]],[[4,36,733,2],[8,36,733,6,906],[23,36,733,21]],[[8,36,734,4],[79,36,734,75]],[[8,36,735,4],[84,36,735,80]],[[8,36,736,4],[52,36,736,48]],[[8,36,737,4],[10,36,737,6]],[[8,36,738,4],[68,36,738,64]],[[8,36,739,4],[10,36,739,6]],[[8,36,740,4],[80,36,740,76]],[[8,36,741,4],[77,36,741,73]],[[8,36,742,4],[67,36,742,63]],[[8,36,743,4],[12,36,743,8,865],[25,36,743,21,866],[43,36,743,39],[48,36,743,44],[54,36,743,50]],[[12,36,744,6,865],[25,36,744,19,866],[43,36,744,37],[46,36,744,40],[48,36,744,42]],[[8,36,745,4]],[[8,36,746,4,865],[21,36,746,17,866],[39,36,746,35],[40,36,746,36,962],[44,36,746,40],[45,36,746,41,892]],[[4,36,747,2]],[[4,36,749,2],[8,36,749,6,910]],[[4,36,750,2],[8,36,750,6,911]],[[4,36,751,2],[8,36,751,6],[9,36,751,7,903],[37,36,751,35,873],[54,36,751,52,870],[65,36,751,63]],[[8,36,752,4],[39,36,752,35]],[[8,36,753,4,910],[23,36,753,19,913],[45,36,754,6,912],[62,36,755,6,873],[76,36,756,6,904]],[[8,36,758,4,911],[30,36,758,26]],[[4,36,759,2],[11,36,759,9],[15,36,759,13,863],[28,36,759,26],[36,36,759,34,863],[44,36,759,42],[45,36,759,43],[47,36,759,45],[52,36,759,50],[58,36,759,56]],[[8,36,760,4],[76,36,760,72]],[[8,36,761,4],[78,36,761,74]],[[8,36,762,4],[79,36,762,75]],[[8,36,763,4],[73,36,763,69]],[[8,36,764,4],[71,36,764,67]],[[8,36,765,4],[28,36,765,24]],[[8,36,766,4],[14,36,766,10,914],[24,36,766,20,863],[32,36,766,28],[33,36,766,29],[35,36,766,31]],[[8,36,767,4],[14,36,767,10,915],[28,36,767,24,863],[36,36,767,32],[37,36,767,33],[39,36,767,35]],[[8,36,768,4],[14,36,768,10,916],[33,36,768,29]],[[8,36,769,4],[14,36,769,10,917],[34,36,770,6,864],[47,36,770,19],[55,36,770,27,876],[69,36,770,27,876]],[[8,36,771,4,910],[23,36,771,19,918],[49,36,772,6,914],[58,36,773,6,915],[71,36,774,6,916],[89,36,775,6,864],[99,36,776,6,917],[118,36,777,6,906],[133,36,778,6,904],[152,36,779,6,861]],[[8,36,781,4,911],[30,36,781,26,906],[47,36,781,43,917]],[[4,36,782,2],[11,36,782,9],[15,36,783,4,876],[29,36,783,4,876],[34,36,784,4,906],[51,36,785,4,864],[64,36,785,17],[70,36,786,4]],[[8,36,787,4],[81,36,787,77]],[[8,36,788,4],[74,36,788,70]],[[8,36,789,4],[82,36,789,78]],[[8,36,790,4],[55,36,790,51]],[[8,36,791,4],[14,36,791,10,914],[24,36,791,20]],[[8,36,792,4],[14,36,792,10,915],[28,36,792,24]],[[8,36,793,4],[14,36,793,10,916],[33,36,793,29]],[[8,36,794,4],[14,36,794,10,917],[34,36,794,30]],[[8,36,795,4,910],[23,36,795,19,918],[49,36,796,6,914],[58,36,797,6,915],[71,36,798,6,916],[89,36,799,6,864],[99,36,800,6,917],[118,36,801,6,906],[133,36,802,6,904],[152,36,803,6,861]],[[8,36,805,4,911],[30,36,805,26]],[[4,36,806,2],[11,36,806,9],[15,36,806,13,876],[29,36,806,13,876],[34,36,806,56,877],[51,36,806,73],[57,36,806,79]],[[8,36,807,4],[38,36,807,34]],[[8,36,808,4],[14,36,808,10,919],[28,36,808,24,877],[40,36,808,36],[41,36,808,37],[43,36,808,39]],[[8,36,809,4],[14,36,809,10,920],[32,36,809,28,877],[44,36,809,40],[45,36,809,41],[47,36,809,43]],[[8,36,810,4],[14,36,810,10,921],[37,36,810,33,877],[49,36,810,45],[50,36,810,46],[52,36,810,48]],[[8,36,811,4,910],[23,36,811,19,918],[49,36,812,6,919],[62,36,813,6,920],[79,36,814,6,921],[101,36,815,6,878],[115,36,816,6,879],[138,36,817,6,906],[153,36,818,6,904],[172,36,819,6,861]],[[8,36,821,4,911],[30,36,822,6,921],[54,36,822,31,906],[71,36,822,48,879]],[[4,36,823,2],[11,36,823,9]],[[8,36,824,4],[61,36,824,57]],[[8,36,825,4,910],[23,36,825,19,922],[41,36,826,6,904],[60,36,827,6,906],[75,36,828,6,861],[88,36,829,6,876]],[[8,36,831,4,911],[30,36,831,26]],[[4,36,832,2]],[[4,36,834,2],[8,36,834,6,926],[37,36,836,6],[38,36,836,7]],[[4,36,837,2],[8,36,837,6,927],[23,36,837,21]],[[4,36,839,2],[8,36,839,6,928],[35,36,839,33]],[[4,36,840,2],[8,36,840,6,929],[37,36,842,6],[38,36,842,7]],[[4,36,844,2],[8,36,844,7],[12,36,844,11,930],[32,36,844,31,894],[55,36,844,55]],[[8,36,845,4],[14,36,845,10,931],[36,36,846,6,894],[58,36,846,28],[59,36,846,29,930],[76,36,846,46]],[[8,36,847,4],[14,36,847,10,933],[35,36,848,6,900],[57,36,848,28,870],[69,36,849,10,900],[87,36,849,28,934],[90,36,849,31],[91,36,849,32,930],[111,36,850,10,870]],[[8,36,851,4],[14,36,851,10,935],[30,36,852,6,896],[51,36,852,27],[58,36,852,34,896],[74,36,852,50],[75,36,852,51,930],[92,36,852,68],[95,36,852,71]],[[8,36,853,4],[14,36,853,10,936],[34,36,854,6,897],[59,36,854,31],[66,36,855,10,897],[86,36,855,30],[87,36,855,31,930],[104,36,855,48],[107,36,856,10]],[[8,36,858,4],[14,36,858,10,937],[32,36,858,28,931],[51,36,858,47],[52,36,858,48],[54,36,858,50]],[[8,36,859,4],[14,36,859,10,943],[35,36,859,31,944],[36,36,859,31,944],[39,36,859,31,944],[61,36,859,31,944],[81,36,859,51],[83,36,859,52,937]],[[8,36,861,4],[14,36,861,10,945],[34,36,862,6,933],[57,36,862,29,870],[69,36,863,10,933],[88,36,863,29,934],[91,36,863,32],[92,36,863,33,943],[114,36,864,10,870]],[[8,36,866,4],[14,36,866,10,946],[26,36,866,22,869],[54,36,867,6,861],[67,36,868,6,931],[88,36,869,6,945],[107,36,870,6,876],[118,36,871,6,935],[135,36,871,23],[141,36,872,6,864],[151,36,873,6,936],[172,36,873,27],[178,36,874,6,878],[192,36,875,6,879],[215,36,876,6,892],[228,36,877,6,930],[246,36,878,6,882],[275,36,878,35,911],[296,36,879,6,865]],[[8,36,882,4],[12,36,882,8,927],[29,36,882,25],[35,36,882,31]],[[12,36,883,6,927],[27,36,883,21],[31,36,883,25,905]],[[8,36,884,4]],[[8,36,885,4,927],[21,36,885,17,947],[24,36,885,20],[25,36,885,21,930],[43,36,885,39,946]],[[8,36,886,4],[14,36,886,10,948],[34,36,886,30,946],[44,36,886,40,871],[48,36,886,44]],[[8,36,887,4],[12,36,887,8,948],[34,36,887,30],[40,36,887,36]],[[12,36,888,6],[18,36,888,12,949],[39,36,888,50],[43,36,888,54,905],[47,36,889,8,902],[73,36,889,34,870],[85,36,889,46,933]],[[12,36,891,6,949],[31,36,891,25,947],[34,36,891,28],[35,36,891,29,943],[55,36,891,49,948]],[[12,36,892,6,904],[30,36,892,24,947],[33,36,892,27],[34,36,892,28,930],[52,36,892,46,949]],[[8,36,893,4]],[[8,36,895,4],[14,36,895,10,950],[31,36,895,27,946],[41,36,895,37,951],[46,36,895,42]],[[8,36,896,4,926],[34,36,896,30],[35,36,896,31,930],[52,36,896,48],[55,36,896,51,950]],[[8,36,898,4],[14,36,898,10,952],[40,36,898,36,946],[50,36,898,46,953],[68,36,898,64]],[[8,36,899,4],[12,36,899,8,952],[40,36,899,36],[46,36,899,42]],[[12,36,900,6,928],[39,36,900,33]],[[12,36,901,6,929],[38,36,901,32],[39,36,901,33,930],[56,36,901,50],[59,36,901,53,952]],[[8,36,902,4],[15,36,902,11]],[[12,36,903,6,929],[38,36,903,32],[39,36,903,33,930],[56,36,903,50],[59,36,903,53,950]],[[8,36,904,4]],[[4,36,905,2]],[[4,36,907,2],[11,36,907,9]],[[8,36,908,4,954],[16,36,908,12,911],[38,36,908,12,911],[42,36,908,12,911]],[[8,36,911,4,951],[15,36,911,11,955],[47,36,912,6,875],[63,36,913,6,926]],[[8,36,915,4,871],[14,36,915,10,910]],[[8,36,916,4,953],[28,36,916,24,956],[53,36,917,6,875],[69,36,918,6,929],[97,36,919,6,911],[118,36,920,6,928],[144,36,921,6,882]],[[8,36,923,4],[78,36,923,74]],[[8,36,924,4],[33,36,924,29]],[[8,36,925,4,924],[20,36,925,16]],[[8,36,926,4,957],[18,36,926,14,927]],[[4,36,927,2]],[[0,36,928,0]],[[0,36,930,0],[9,36,930,9,955],[41,36,931,2,963],[56,36,931,36],[58,36,932,2,964],[69,36,932,64]],[[4,36,934,2],[10,36,934,8,965],[18,36,934,35]],[[8,36,934,36,963],[23,36,934,51],[24,36,934,52],[26,36,934,54]],[[8,36,934,56,964]],[[5,36,934,68]],[[4,36,935,2],[80,36,935,78]],[[4,36,936,2],[79,36,936,77]],[[4,36,937,2],[43,36,937,41]],[[4,36,938,2],[8,36,938,6],[13,36,938,11,963],[30,36,938,28]],[[8,36,939,4,965],[13,36,939,9],[14,36,939,10],[16,36,939,12],[19,36,939,15,963],[34,36,939,30],[35,36,939,31],[37,36,939,33]],[[4,36,940,2]],[[4,36,941,2],[8,36,941,6],[13,36,941,11,963],[30,36,941,28]],[[8,36,942,4,965],[13,36,942,9],[14,36,942,10],[16,36,942,12],[19,36,942,15,963],[34,36,942,30],[35,36,942,31],[37,36,942,33]],[[4,36,943,2]],[[4,36,944,2],[8,36,944,6],[13,36,944,11,963],[30,36,944,28]],[[8,36,945,4,965],[13,36,945,9],[14,36,945,10],[16,36,945,12],[19,36,945,15,963],[34,36,945,30],[35,36,945,31],[37,36,945,33]],[[4,36,946,2]],[[4,36,947,2],[11,36,947,9,965]],[[0,36,948,0]],[[0,36,950,0],[9,36,950,9,956],[34,36,951,2,875],[48,36,951,35],[50,36,952,2,929],[76,36,952,63],[78,36,953,2,911],[97,36,953,30],[99,36,954,2,928],[123,36,954,35],[125,36,955,2,882],[150,36,955,36]],[[4,36,957,2],[77,36,957,75]],[[4,36,958,2],[25,36,958,23]],[[4,36,959,2],[6,36,959,4]],[[4,36,960,2],[78,36,960,76]],[[4,36,961,2],[49,36,961,47]],[[4,36,962,2],[8,36,962,6,953],[29,36,962,53]],[[4,36,963,2],[8,36,963,6,911],[29,36,963,27]],[[8,36,964,4,953],[29,36,964,25,955],[61,36,965,6,875],[77,36,966,6,929]],[[8,36,968,4],[80,36,968,76]],[[8,36,969,4],[63,36,969,59]],[[8,36,970,4],[12,36,970,8],[13,36,970,9,882],[40,36,970,36]],[[12,36,971,6,953],[30,36,971,24],[31,36,971,25],[33,36,971,27],[36,36,971,30]],[[8,36,972,4]],[[4,36,973,2],[11,36,973,9],[15,36,973,13,928],[41,36,973,39]],[[8,36,974,4],[74,36,974,70]],[[8,36,975,4],[25,36,975,21]],[[8,36,976,4,953],[29,36,976,25,955],[61,36,977,6,875],[77,36,978,6,929]],[[4,36,980,2],[11,36,980,9]],[[8,36,981,4,953],[29,36,981,25]],[[4,36,982,2]],[[4,36,983,2],[11,36,983,9,953]],[[0,36,984,0]],[[0,36,986,0],[9,36,986,9,925],[30,36,987,2,865],[42,36,987,45],[44,36,988,2,924],[54,36,988,20]],[[4,36,990,2],[77,36,990,75]],[[4,36,991,2],[75,36,991,73]],[[4,36,992,2],[72,36,992,70]],[[4,36,993,2],[50,36,993,48]],[[4,36,994,2],[6,36,994,4]],[[4,36,995,2],[79,36,995,77]],[[4,36,996,2],[78,36,996,76]],[[4,36,997,2],[72,36,997,70]],[[4,36,998,2],[59,36,998,57]],[[4,36,999,2],[48,36,999,46]],[[4,36,1000,2],[10,36,1000,8,867],[32,36,1000,30,865],[45,36,1000,43,867],[64,36,1000,62]],[[4,36,1001,2],[8,36,1001,6,867],[32,36,1001,30],[38,36,1001,36]],[[8,36,1002,4,865],[21,36,1002,17,867],[40,36,1002,36],[43,36,1002,39],[47,36,1002,43,966],[51,36,1002,47]],[[12,36,1002,48,924]],[[9,36,1002,59]],[[4,36,1003,2],[11,36,1003,9]],[[8,36,1004,4,867],[28,36,1004,24,967],[31,36,1004,27],[32,36,1004,28,924]],[[4,36,1005,2]],[[0,36,1006,0]],[[0,36,1008,0],[9,36,1008,9,942],[41,36,1009,2,872],[47,36,1009,13],[49,36,1010,2,874],[63,36,1010,35]],[[4,36,1012,2],[79,36,1012,77]],[[4,36,1013,2],[79,36,1013,77]],[[4,36,1014,2],[80,36,1014,78]],[[4,36,1015,2],[82,36,1015,80]],[[4,36,1016,2],[51,36,1016,49]],[[4,36,1017,2],[6,36,1017,4]],[[4,36,1018,2],[80,36,1018,78]],[[4,36,1019,2],[82,36,1019,80]],[[4,36,1020,2],[69,36,1020,67]],[[4,36,1021,2],[8,36,1021,6,968]],[[4,36,1023,2],[10,36,1023,8,969],[29,36,1023,27,874],[43,36,1023,41],[44,36,1023,42],[46,36,1023,44]],[[4,36,1024,2],[8,36,1024,6,969],[29,36,1024,27],[40,36,1024,38]],[[8,36,1025,4],[77,36,1025,73]],[[8,36,1026,4],[43,36,1026,39]],[[8,36,1027,4,968],[28,36,1027,24,874]],[[4,36,1028,2],[11,36,1028,9]],[[8,36,1029,4],[81,36,1029,77]],[[8,36,1030,4],[59,36,1030,55]],[[8,36,1031,4,968],[28,36,1031,24,955],[60,36,1032,6,874],[76,36,1033,6,874],[90,36,1033,20],[91,36,1033,21],[93,36,1033,23]],[[8,36,1035,4,968],[25,36,1035,21],[26,36,1035,22],[28,36,1035,24],[31,36,1035,27,970],[32,36,1035,27,970],[35,36,1035,27,970],[54,36,1035,27,970],[71,36,1035,44],[73,36,1035,45,872]],[[8,36,1036,4,968],[25,36,1036,21],[26,36,1036,22],[28,36,1036,24],[31,36,1036,27]],[[4,36,1037,2]],[[4,36,1039,2],[11,36,1039,9,968]],[[0,36,1040,0]],[[0,36,1042,0],[9,36,1042,9,913],[31,36,1043,2,912],[46,36,1043,26],[48,36,1044,2,971],[65,36,1044,30],[67,36,1045,2,901],[81,36,1045,46]],[[4,36,1047,2],[72,36,1047,70]],[[4,36,1048,2],[10,36,1048,8,972],[22,36,1048,31]],[[8,36,1049,4,960],[13,36,1049,9,971],[31,36,1049,27,960],[34,36,1049,30]],[[8,36,1050,4,919],[21,36,1050,17,912],[39,36,1050,35],[46,36,1050,42,971],[64,36,1050,60,919],[75,36,1050,71]],[[8,36,1051,4,973],[14,36,1051,10,971],[32,36,1051,28,973],[36,36,1051,32]],[[8,36,1052,4,878],[22,36,1052,18,912],[40,36,1052,36],[47,36,1052,43,971],[65,36,1052,61,878],[77,36,1052,73]],[[8,36,1053,4,974],[17,36,1053,13,971],[35,36,1053,31,974],[42,36,1053,38]],[[8,36,1055,4,901]],[[8,36,1057,4],[70,36,1057,66]],[[8,36,1058,4],[25,36,1058,21]],[[8,36,1059,4,861],[21,36,1059,17,971],[39,36,1059,35,861],[50,36,1059,46]],[[4,36,1060,2]],[[4,36,1061,2],[11,36,1061,9,972]],[[0,36,1062,0]],[[0,36,1064,0],[9,36,1064,9,918],[35,36,1065,2,914],[42,36,1065,26],[44,36,1066,2,915],[55,36,1066,61],[57,36,1067,2,916],[73,36,1067,27],[75,36,1068,2,864],[83,36,1068,27],[85,36,1069,2,917],[102,36,1069,28],[104,36,1070,2,975],[117,36,1070,24],[119,36,1071,2,901],[133,36,1071,46],[135,36,1072,2,861],[146,36,1072,21]],[[4,36,1074,2],[78,36,1074,76]],[[4,36,1075,2],[77,36,1075,75]],[[4,36,1076,2],[58,36,1076,56]],[[4,36,1078,2],[8,36,1078,6,960]],[[4,36,1079,2],[8,36,1079,6,919]],[[4,36,1080,2],[8,36,1080,6,916],[26,36,1080,24]],[[8,36,1081,4],[84,36,1081,80]],[[8,36,1082,4],[79,36,1082,75]],[[8,36,1083,4,919],[22,36,1083,18,914]],[[8,36,1084,4,960],[14,36,1084,10,976]],[[4,36,1085,2],[11,36,1085,9]],[[8,36,1086,4],[60,36,1086,56]],[[8,36,1087,4,919],[22,36,1087,18]],[[8,36,1088,4,960],[14,36,1088,10,914]],[[4,36,1089,2]],[[4,36,1091,2],[53,36,1091,51]],[[4,36,1092,2],[8,36,1092,6,878]],[[4,36,1093,2],[8,36,1093,6,973]],[[4,36,1094,2],[8,36,1094,6,975],[23,36,1094,21]],[[8,36,1095,4],[12,36,1095,8,917],[31,36,1095,27]],[[12,36,1096,6,878],[27,36,1096,21,864]],[[12,36,1097,6,973],[19,36,1097,13,976]],[[8,36,1098,4],[15,36,1098,11]],[[12,36,1099,6,878],[27,36,1099,21]],[[12,36,1100,6,973],[19,36,1100,13,864]],[[8,36,1101,4]],[[4,36,1102,2],[11,36,1102,9]],[[8,36,1103,4,878],[23,36,1103,19]],[[8,36,1104,4,973],[15,36,1104,11]],[[4,36,1105,2]],[[4,36,1107,2],[10,36,1107,8,972],[22,36,1107,31]],[[8,36,1108,4,960]],[[8,36,1109,4,919]],[[8,36,1110,4,973]],[[8,36,1111,4,878]],[[8,36,1112,4],[79,36,1112,75]],[[8,36,1113,4],[80,36,1113,76]],[[8,36,1114,4],[58,36,1114,54]],[[8,36,1115,4,974],[17,36,1115,13,915]],[[8,36,1116,4,901]],[[8,36,1117,4,861]],[[4,36,1118,2]],[[4,36,1120,2],[11,36,1120,9,972]],[[0,36,1121,0]],[[0,36,1123,0],[9,36,1123,9,922],[27,36,1124,2,901],[41,36,1124,46],[43,36,1125,2,906],[56,36,1125,24],[58,36,1126,2,861],[69,36,1126,21],[71,36,1127,2,876],[80,36,1127,28]],[[4,36,1129,2],[81,36,1129,79]],[[4,36,1130,2],[78,36,1130,76]],[[4,36,1131,2],[56,36,1131,54]],[[4,36,1132,2],[6,36,1132,4]],[[4,36,1133,2],[76,36,1133,74]],[[4,36,1134,2],[73,36,1134,71]],[[4,36,1135,2],[78,36,1135,76]],[[4,36,1136,2],[42,36,1136,40]],[[4,36,1137,2],[6,36,1137,4]],[[4,36,1138,2],[76,36,1138,74]],[[4,36,1139,2],[79,36,1139,77]],[[4,36,1140,2],[74,36,1140,72]],[[4,36,1141,2],[76,36,1141,74]],[[4,36,1142,2],[43,36,1142,41]],[[4,36,1143,2],[10,36,1143,8,977],[24,36,1143,22,876],[38,36,1143,22,876]],[[4,36,1145,2],[10,36,1145,8,972],[22,36,1145,31]],[[8,36,1146,4,960],[13,36,1146,9],[14,36,1146,10,977],[28,36,1146,24,976],[50,36,1146,46]],[[8,36,1147,4,919],[21,36,1147,17]],[[8,36,1148,4,973],[14,36,1148,10],[15,36,1148,11,977],[30,36,1148,26,906],[46,36,1148,42,976],[68,36,1148,64]],[[8,36,1149,4,878],[22,36,1149,18]],[[8,36,1150,4,974],[17,36,1150,13],[18,36,1150,14,977],[32,36,1150,28,976],[54,36,1150,69]],[[8,36,1151,4,901]],[[8,36,1152,4,861]],[[4,36,1153,2]],[[4,36,1154,2],[11,36,1154,9,972]],[[0,36,1155,0]],[[0,36,1157,0],[80,36,1157,80]],[[0,36,1158,0],[75,36,1158,75]],[[0,36,1159,0],[79,36,1159,79]],[[0,36,1160,0],[4,36,1160,4,978],[36,36,1160,36]],[[0,36,1177,7],[9,36,1177,16,858],[30,36,1178,2,868],[34,36,1178,22],[36,36,1179,2,979],[46,36,1179,17],[48,36,1180,2,980],[55,36,1180,24],[57,36,1181,2,981],[72,36,1181,34],[74,36,1182,2,865],[86,36,1182,45]],[[4,36,1184,2],[10,36,1184,8,953],[31,36,1184,29,868],[36,36,1184,34,953],[54,36,1184,52]],[[4,36,1185,2],[8,36,1185,6,953],[31,36,1185,29],[37,36,1185,35]],[[8,36,1186,4],[84,36,1186,80]],[[8,36,1187,4,978],[40,36,1187,36]],[[8,36,1188,4]],[[4,36,1189,2]],[[4,36,1191,2],[80,36,1191,78]],[[4,36,1192,2],[75,36,1192,73]],[[4,36,1193,2],[72,36,1193,70]],[[4,36,1194,2],[30,36,1194,28]],[[4,36,1195,2],[6,36,1195,4]],[[4,36,1196,2],[81,36,1196,79]],[[4,36,1197,2],[73,36,1197,71]],[[4,36,1198,2],[74,36,1198,72]],[[4,36,1199,2],[52,36,1199,50]],[[4,36,1200,2],[10,36,1200,8,982],[34,36,1200,32,983],[58,36,1201,4,868],[64,36,1202,4,953],[84,36,1203,4,979],[96,36,1204,4,980],[105,36,1205,4,981]],[[4,36,1208,2],[10,36,1208,8,867],[32,36,1208,30,865],[45,36,1208,43,867],[64,36,1208,62]],[[4,36,1209,2],[8,36,1209,6,984],[33,36,1211,13]],[[4,36,1212,2],[8,36,1212,6,867],[32,36,1212,30],[38,36,1212,36]],[[8,36,1213,4],[78,36,1213,74]],[[8,36,1214,4],[83,36,1214,79]],[[8,36,1215,4],[82,36,1215,78]],[[8,36,1216,4],[72,36,1216,68]],[[8,36,1218,4],[78,36,1218,74]],[[8,36,1219,4],[79,36,1219,75]],[[8,36,1220,4],[78,36,1220,74]],[[8,36,1221,4],[76,36,1221,72]],[[8,36,1222,4],[50,36,1222,46]],[[8,36,1224,4],[78,36,1224,74]],[[8,36,1225,4],[76,36,1225,72]],[[8,36,1226,4],[29,36,1226,25]],[[8,36,1227,4,984],[33,36,1227,29],[35,36,1227,31]],[[8,36,1228,4],[14,36,1228,10,985],[29,36,1228,25,970],[30,36,1228,25,970],[33,36,1228,25,970],[52,36,1228,25,970],[69,36,1228,42],[71,36,1228,43,979]],[[8,36,1229,4],[13,36,1229,9],[19,36,1229,15,924],[33,36,1229,29,867],[53,36,1229,50]],[[12,36,1230,6],[16,36,1230,10,924],[31,36,1230,25,985],[45,36,1230,39]],[[16,36,1235,8]],[[12,36,1236,6]],[[12,36,1237,6],[82,36,1237,76]],[[12,36,1238,6],[83,36,1238,77]],[[12,36,1239,6],[82,36,1239,76]],[[12,36,1240,6],[80,36,1240,74]],[[12,36,1241,6],[54,36,1241,48]],[[12,36,1242,6],[80,36,1242,74]],[[12,36,1243,6],[18,36,1243,12,986],[45,36,1243,39,953]],[[12,36,1244,6],[16,36,1244,10,986],[45,36,1244,39],[51,36,1244,45]],[[16,36,1245,8,984],[39,36,1245,31,962],[43,36,1245,35],[44,36,1246,10,983],[68,36,1247,12,868],[74,36,1248,12,986],[100,36,1249,12],[104,36,1249,16,987],[108,36,1249,20,924],[120,36,1249,32,988],[129,36,1249,41,989],[135,36,1249,47],[138,36,1250,12],[138,36,1251,12],[204,36,1251,78],[205,36,1250,79]],[[16,36,1252,12],[82,36,1252,78]],[[16,36,1253,12],[74,36,1253,70]],[[16,36,1254,12],[32,36,1254,28]],[[16,36,1255,12,980],[25,36,1256,12,981]],[[12,36,1259,6]],[[8,36,1260,4]],[[4,36,1261,2]],[[4,36,1263,2],[72,36,1263,70]],[[4,36,1264,2],[46,36,1264,44]],[[4,36,1265,2],[10,36,1265,8,990],[24,36,1265,22,991],[45,36,1266,4,868],[51,36,1267,4,980],[60,36,1268,4,982],[83,36,1269,4,984]],[[4,36,1271,2],[81,36,1271,79]],[[4,36,1272,2],[38,36,1272,36]],[[4,36,1273,2,990],[16,36,1273,14,992],[20,36,1273,18],[21,36,1273,19,860],[27,36,1273,25,860]],[[0,36,1274,0]],[[0,36,1276,0],[15,36,1276,15,991],[36,36,1277,2,868],[40,36,1277,22],[42,36,1278,2,980],[49,36,1278,24],[51,36,1279,2,982],[72,36,1279,67],[74,36,1280,2,984],[96,36,1282,10]],[[4,36,1284,2],[73,36,1284,71]],[[4,36,1285,2],[8,36,1285,6,993],[21,36,1285,19],[27,36,1285,25,994],[51,36,1286,4,982],[74,36,1287,4,984]],[[4,36,1290,2],[80,36,1290,78]],[[4,36,1291,2],[80,36,1291,78]],[[4,36,1292,2],[81,36,1292,79]],[[4,36,1293,2],[80,36,1293,78]],[[4,36,1294,2],[81,36,1294,79]],[[4,36,1295,2],[33,36,1295,31]],[[4,36,1296,2],[8,36,1296,6,993],[23,36,1296,6,993],[26,36,1296,52]],[[8,36,1297,4,993],[21,36,1297,17,995],[48,36,1297,44,868],[54,36,1297,50],[60,36,1297,56]],[[4,36,1298,2]],[[4,36,1300,2],[11,36,1300,10,993]],[[8,36,1301,4],[13,36,1301,4]],[[12,36,1301,40]],[[16,36,1302,6],[83,36,1302,73]],[[16,36,1303,6,978],[48,36,1303,38]],[[16,36,1304,6]],[[12,36,1305,4]],[[8,36,1306,4],[13,36,1306,4]],[[12,36,1306,45]],[[16,36,1307,6],[76,36,1307,66]],[[16,36,1308,6],[82,36,1308,72]],[[16,36,1309,6],[88,36,1309,78]],[[16,36,1310,6],[62,36,1310,52]],[[16,36,1311,6],[22,36,1311,12,996],[36,36,1311,26]],[[16,36,1312,6],[22,36,1312,12,997],[45,36,1312,35],[51,36,1312,41,982]],[[16,36,1313,6,998],[47,36,1314,8,996],[60,36,1315,8,997],[81,36,1315,29,999],[84,36,1315,32],[86,36,1316,8,980],[95,36,1317,8,997],[116,36,1317,29,1000],[120,36,1317,33],[122,36,1318,8,868],[127,36,1318,13,951],[132,36,1318,18]],[[16,36,1320,6]],[[12,36,1321,4]],[[8,36,1322,4],[13,36,1322,4]],[[12,36,1322,45]],[[16,36,1323,6],[89,36,1323,79]],[[16,36,1324,6],[60,36,1324,50]],[[16,36,1325,6],[18,36,1325,8]],[[16,36,1326,6],[86,36,1326,76]],[[16,36,1327,6],[90,36,1327,80]],[[16,36,1328,6],[87,36,1328,77]],[[16,36,1329,6],[85,36,1329,75]],[[16,36,1330,6],[37,36,1330,27]],[[16,36,1331,6],[22,36,1331,12,996],[36,36,1331,26]],[[16,36,1332,6],[22,36,1332,12,997],[45,36,1332,35],[51,36,1332,41,982]],[[16,36,1333,6,998],[47,36,1334,8,996],[60,36,1335,8,997],[81,36,1335,29,999],[84,36,1335,32],[86,36,1336,8,980],[95,36,1337,8,997],[116,36,1337,29,1000],[120,36,1337,33],[122,36,1338,8,868],[127,36,1338,13,951],[132,36,1338,18]],[[16,36,1340,6]],[[12,36,1341,4]],[[8,36,1342,4]],[[12,36,1342,13]],[[16,36,1343,6],[23,36,1343,13,993]],[[12,36,1344,4]],[[4,36,1345,2]],[[0,36,1346,0]],[[0,36,1348,0],[9,36,1348,9,994],[33,36,1349,2,982],[54,36,1349,67],[56,36,1350,2,984],[78,36,1352,10]],[[4,36,1354,2],[79,36,1354,77]],[[4,36,1355,2],[40,36,1355,38]],[[4,36,1356,2],[6,36,1356,4]],[[4,36,1357,2],[78,36,1357,76]],[[4,36,1358,2],[73,36,1358,71]],[[4,36,1359,2],[23,36,1359,21]],[[4,36,1360,2],[6,36,1360,4]],[[4,36,1361,2],[80,36,1361,78]],[[4,36,1362,2],[24,36,1362,22]],[[4,36,1363,2],[11,36,1363,9],[15,36,1363,13,1001],[23,36,1363,47],[24,36,1363,48,1002]],[[8,36,1364,4],[14,36,1364,10,1003],[26,36,1364,22],[27,36,1364,23,1004]],[[12,36,1365,6],[16,36,1365,10,1004],[23,36,1365,17,993],[33,36,1365,27],[38,36,1365,27],[41,36,1365,63]],[[16,36,1366,8,1005]],[[16,36,1367,8],[20,36,1367,12,1005],[39,36,1367,31],[42,36,1367,34]],[[20,36,1368,10],[62,36,1368,52]],[[20,36,1369,10,1002],[28,36,1369,10,1002]],[[16,36,1370,8]],[[12,36,1371,6],[19,36,1371,13]],[[16,36,1372,8],[74,36,1372,66]],[[16,36,1373,8],[85,36,1373,77]],[[16,36,1374,8],[85,36,1374,77]],[[16,36,1375,8],[88,36,1375,80]],[[16,36,1376,8],[76,36,1376,68]],[[16,36,1377,8],[35,36,1377,27]],[[16,36,1378,8,1002],[24,36,1378,16,1004],[31,36,1378,23,993],[41,36,1378,33]],[[12,36,1379,6]],[[8,36,1380,4]],[[8,36,1381,4],[78,36,1381,74]],[[8,36,1382,4],[73,36,1382,69]],[[8,36,1383,4],[14,36,1383,10,1006],[25,36,1383,21],[29,36,1383,27,1002],[37,36,1383,27,1002]],[[8,36,1385,4],[48,36,1385,44]],[[8,36,1386,4],[12,36,1386,8,1005],[29,36,1386,25]],[[8,36,1387,4,982],[30,36,1387,26,992],[34,36,1387,30],[35,36,1387,31,1003],[46,36,1387,42,1006]],[[8,36,1388,4],[12,36,1388,8,984],[39,36,1388,35],[45,36,1388,41]],[[12,36,1389,6,1005],[30,36,1389,24,984],[53,36,1389,47,909],[59,36,1389,53]],[[12,36,1390,6,984],[35,36,1390,29,1007],[42,36,1390,36],[43,36,1390,37],[44,36,1390,38,1008],[68,36,1391,8,1008],[90,36,1391,30,992],[94,36,1391,34],[95,36,1391,35,1003],[106,36,1391,46,1006]],[[8,36,1393,4]],[[4,36,1394,2]],[[0,36,1395,0]],[[0,36,1397,0],[9,36,1397,9,998],[40,36,1398,2,996],[51,36,1398,22],[53,36,1399,2,1009],[61,36,1399,15],[63,36,1400,2,1010],[75,36,1400,29],[77,36,1401,2,1000],[81,36,1401,29],[83,36,1402,2,1011],[91,36,1402,29]],[[4,36,1404,2],[74,36,1404,72]],[[4,36,1405,2],[51,36,1405,49]],[[4,36,1406,2,996],[18,36,1406,16,996],[33,36,1406,31,978]],[[4,36,1407,2,978],[36,36,1407,34]],[[4,36,1408,2],[10,36,1408,8,1012],[24,36,1408,41]],[[8,36,1409,4,1013],[14,36,1409,10,1014],[34,36,1409,10,1014],[53,36,1409,29]],[[8,36,1410,4,1015],[22,36,1410,18,1011]],[[8,36,1411,4,999],[13,36,1411,9,1009]],[[8,36,1412,4,980],[17,36,1412,13,1010]],[[8,36,1413,4,1000]],[[8,36,1414,4,1016],[13,36,1414,9,996]],[[4,36,1415,2]],[[4,36,1416,2,1017],[5,36,1416,2,1017],[8,36,1416,2,1017],[24,36,1416,2,1017],[47,36,1416,25],[49,36,1416,26,1012]],[[0,36,1417,0]],[[0,36,1419,0],[15,36,1419,15,983],[39,36,1420,2,868],[43,36,1420,22],[45,36,1421,2,953],[63,36,1421,39],[65,36,1422,2,999],[68,36,1422,10],[70,36,1423,2,980],[77,36,1423,24],[79,36,1424,2,981],[94,36,1424,34]],[[4,36,1430,2],[8,36,1430,6]],[[8,36,1431,4],[14,36,1431,10,1004],[23,36,1431,19],[29,36,1431,25,1018],[30,36,1431,25,1018],[33,36,1431,25,1018],[54,36,1431,25,1018],[73,36,1431,44],[75,36,1431,45,999],[80,36,1431,50]],[[12,36,1432,6,1019],[31,36,1432,25,953]],[[12,36,1433,6,980]],[[12,36,1434,6,1020],[26,36,1434,20,981],[46,36,1434,20,981]],[[8,36,1435,4]],[[8,36,1436,4],[12,36,1436,8],[19,36,1436,15,1004],[30,36,1436,26],[40,36,1436,36]],[[12,36,1437,6],[79,36,1437,73]],[[12,36,1438,6],[77,36,1438,71]],[[12,36,1439,6],[81,36,1439,75]],[[12,36,1440,6],[33,36,1440,27]],[[12,36,1441,6],[19,36,1441,13]],[[16,36,1442,8,993],[26,36,1442,18],[28,36,1442,18]],[[16,36,1443,8,999],[21,36,1443,13],[25,36,1443,17,987],[29,36,1443,21,1004],[37,36,1443,29,988],[46,36,1443,38,989],[52,36,1443,44]],[[16,36,1444,8,1000],[22,36,1444,14]],[[12,36,1445,6]],[[8,36,1446,4]],[[8,36,1447,4],[14,36,1447,10,1000],[21,36,1447,17,1021],[22,36,1447,17,1021],[25,36,1447,17,1021],[37,36,1447,17,1021],[65,36,1447,45],[67,36,1448,6,868],[72,36,1448,11,951],[77,36,1448,16],[79,36,1449,6,1004],[86,36,1449,13,1022],[96,36,1449,23],[98,36,1450,6,1004],[105,36,1450,13,1023],[119,36,1450,27]],[[8,36,1452,4],[14,36,1452,10,1024],[47,36,1452,43,1025],[82,36,1453,6,868],[88,36,1454,6,1000],[93,36,1454,11,1026],[97,36,1454,15],[99,36,1455,6,1000],[104,36,1455,11,1027],[108,36,1455,15],[110,36,1456,6,1000],[115,36,1456,11,973],[119,36,1456,15],[121,36,1457,6,1004],[128,36,1457,13,1028],[137,36,1457,22]],[[8,36,1459,4],[15,36,1459,11]],[[12,36,1460,6,993],[24,36,1460,18,1024],[57,36,1460,18,1024],[61,36,1460,18,1024]],[[12,36,1463,6,999],[17,36,1463,11],[21,36,1463,15,987],[25,36,1463,19,1004],[32,36,1463,26,985],[44,36,1463,38],[46,36,1463,40,988],[55,36,1463,49,989],[61,36,1463,55]],[[12,36,1464,6,1000]],[[8,36,1465,4]],[[4,36,1466,2],[6,36,1466,4],[13,36,1466,10]],[[8,36,1467,4],[77,36,1467,73]],[[8,36,1468,4],[83,36,1468,79]],[[8,36,1469,4],[81,36,1469,77]],[[8,36,1470,4],[15,36,1470,11]],[[12,36,1471,6,993],[22,36,1471,16],[24,36,1471,16]],[[12,36,1472,6,999],[17,36,1472,11,999]],[[12,36,1473,6,1000],[18,36,1473,12]],[[8,36,1474,4]],[[4,36,1475,2]],[[0,36,1476,0]],[[0,36,1478,0],[9,36,1478,9,1025],[44,36,1479,2,868],[48,36,1479,22],[50,36,1480,2,1029],[67,36,1480,38],[69,36,1481,2,1030],[80,36,1481,39],[82,36,1482,2,1031],[93,36,1482,23],[95,36,1483,2,1028],[104,36,1483,30]],[[4,36,1485,2],[8,36,1485,6,868],[13,36,1485,11,954],[19,36,1485,17],[24,36,1485,17],[29,36,1485,54,1030],[45,36,1485,70],[51,36,1485,76]],[[8,36,1486,4,868],[13,36,1486,9,954],[19,36,1486,15],[22,36,1486,15]],[[8,36,1487,4,1032],[31,36,1487,27,868],[36,36,1487,32,871],[40,36,1487,36],[42,36,1487,38,1030],[55,36,1487,51,1031],[68,36,1487,64,1028]],[[4,36,1488,2]],[[4,36,1490,2],[10,36,1490,8,927],[25,36,1490,23,868],[30,36,1490,28,957],[38,36,1490,36]],[[4,36,1491,2],[10,36,1491,8,1033],[27,36,1491,25,1029],[44,36,1491,42],[45,36,1491,43],[47,36,1491,45]],[[4,36,1492,2],[10,36,1492,8,1034],[32,36,1492,30,1030],[48,36,1492,46],[55,36,1492,53,1030],[66,36,1492,64],[67,36,1492,65],[69,36,1492,67],[72,36,1492,70]],[[4,36,1494,2],[76,36,1494,74]],[[4,36,1495,2],[26,36,1495,24]],[[4,36,1496,2],[8,36,1496,6,1024],[41,36,1496,39]],[[4,36,1498,2],[8,36,1498,6,927],[25,36,1498,23],[31,36,1498,29]],[[8,36,1499,4],[12,36,1499,9],[18,36,1499,15,930],[38,36,1499,35,1033],[53,36,1499,51]],[[12,36,1500,6],[18,36,1500,12,1035],[43,36,1501,8,1033],[57,36,1501,22],[58,36,1501,23,930],[75,36,1501,40]],[[12,36,1502,6],[18,36,1502,12,1036],[37,36,1503,8,1034],[61,36,1503,32],[68,36,1504,12,1034],[87,36,1504,31],[88,36,1504,32,930],[105,36,1504,49],[108,36,1505,12]],[[12,36,1507,6],[18,36,1507,12,946],[30,36,1507,24,927],[43,36,1507,37,934],[46,36,1507,40],[47,36,1507,41,930]],[[12,36,1508,6],[16,36,1508,10,946],[30,36,1508,24,870],[41,36,1508,35]],[[16,36,1509,8],[86,36,1509,78]],[[16,36,1510,8],[18,36,1510,10]],[[16,36,1511,8],[83,36,1511,75]],[[16,36,1512,8],[77,36,1512,69]],[[16,36,1513,8],[84,36,1513,76]],[[16,36,1514,8],[76,36,1514,68]],[[16,36,1515,8],[31,36,1515,23]],[[16,36,1516,8],[18,36,1516,10]],[[16,36,1517,8],[86,36,1517,78]],[[16,36,1518,8],[84,36,1518,76]],[[16,36,1519,8],[84,36,1519,76]],[[16,36,1520,8],[87,36,1520,79]],[[16,36,1521,8],[78,36,1521,70]],[[16,36,1522,8,1024],[49,36,1522,41]],[[12,36,1523,6],[19,36,1523,13]],[[16,36,1524,8],[22,36,1524,14,1037],[36,36,1524,28,946],[46,36,1524,38,951],[51,36,1524,43],[52,36,1524,44],[54,36,1524,46]],[[16,36,1525,8],[20,36,1526,10,889],[21,36,1526,10,889],[24,36,1526,10,889],[39,36,1526,10,889],[51,36,1526,22],[53,36,1526,23,1035],[75,36,1526,45],[76,36,1526,46],[78,36,1526,48],[80,36,1526,50,1037],[96,36,1527,10,1036],[117,36,1527,31],[125,36,1528,10,1036],[146,36,1528,31,870],[157,36,1529,10]],[[20,36,1530,10],[87,36,1530,77]],[[20,36,1531,10],[26,36,1531,16,1038],[64,36,1532,12,1025],[99,36,1533,14,946],[110,36,1534,14,1035],[134,36,1535,14,1036],[152,36,1536,14,1031],[165,36,1537,14,1028]],[[20,36,1539,10],[24,36,1539,14,1038],[61,36,1539,51]],[[24,36,1540,12,1024],[57,36,1540,45]],[[20,36,1541,10]],[[16,36,1542,8]],[[12,36,1543,6]],[[8,36,1544,4]],[[4,36,1545,2]],[[4,36,1547,2],[11,36,1547,9,1024]],[[0,36,1548,0]],[[0,36,1550,0],[9,36,1550,9,1032],[32,36,1551,2,972],[41,36,1551,22],[43,36,1552,2,1030],[54,36,1552,32],[56,36,1553,2,1031],[67,36,1553,23],[69,36,1554,2,1028],[78,36,1554,30]],[[4,36,1556,2],[82,36,1556,80]],[[4,36,1557,2],[82,36,1557,80]],[[4,36,1558,2],[80,36,1558,78]],[[4,36,1559,2],[82,36,1559,80]],[[4,36,1560,2],[66,36,1560,64]],[[4,36,1561,2],[33,36,1561,31]],[[4,36,1562,2],[6,36,1562,4]],[[4,36,1563,2],[73,36,1563,71]],[[4,36,1564,2],[82,36,1564,80]],[[4,36,1565,2],[68,36,1565,66]],[[4,36,1567,2],[79,36,1567,77]],[[4,36,1568,2],[25,36,1568,23]],[[4,36,1569,2],[10,36,1569,8,960],[16,36,1569,14,972],[26,36,1569,24,960],[29,36,1569,27]],[[4,36,1570,2],[10,36,1570,8,1039],[31,36,1570,29,1030],[42,36,1570,40],[43,36,1570,41],[45,36,1570,43]],[[4,36,1572,2],[8,36,1572,6,1039],[31,36,1572,29],[37,36,1572,35]],[[8,36,1573,4],[77,36,1573,73]],[[8,36,1574,4],[82,36,1574,78]],[[8,36,1575,4],[80,36,1575,76]],[[8,36,1576,4]],[[4,36,1577,2]],[[4,36,1579,2],[8,36,1579,6,960],[16,36,1579,14],[22,36,1579,20]],[[8,36,1580,4],[76,36,1580,72]],[[8,36,1581,4],[77,36,1581,73]],[[8,36,1582,4,972],[18,36,1582,14,960],[21,36,1582,17],[24,36,1582,20,1039]],[[4,36,1583,2],[11,36,1583,9],[15,36,1583,13,857],[29,36,1583,27,960],[35,36,1583,33]],[[8,36,1584,4],[82,36,1584,78]],[[8,36,1585,4],[78,36,1585,74]],[[8,36,1586,4],[78,36,1586,74]],[[8,36,1587,4,960],[12,36,1587,8,1002],[19,36,1587,15],[20,36,1587,16,1039],[40,36,1587,36,1028]],[[4,36,1588,2],[11,36,1588,9]],[[4,36,1589,4],[75,36,1589,75]],[[4,36,1590,4],[74,36,1590,74]],[[4,36,1591,2]],[[4,36,1593,2],[89,36,1593,87]],[[4,36,1594,2],[89,36,1594,87]],[[4,36,1595,2],[10,36,1595,8,974],[20,36,1595,18,972],[30,36,1595,28,974],[37,36,1595,35]],[[4,36,1596,2],[8,36,1596,6,857],[22,36,1596,20,974],[32,36,1596,30]],[[8,36,1597,4],[14,36,1597,10,1040],[31,36,1597,27,1030],[42,36,1597,38],[43,36,1597,39],[45,36,1597,41]],[[8,36,1598,4,974],[16,36,1598,12,1002],[23,36,1598,19],[24,36,1598,20,1040],[40,36,1598,36,1028]],[[4,36,1599,2]],[[4,36,1601,2],[82,36,1601,80]],[[4,36,1602,2],[77,36,1602,75]],[[4,36,1603,2],[18,36,1603,16]],[[4,36,1604,2],[10,36,1604,8,973],[17,36,1604,15,972],[27,36,1604,25,973],[31,36,1604,29]],[[4,36,1605,2],[8,36,1605,6,857],[22,36,1605,20,973],[29,36,1605,27]],[[8,36,1606,4,973],[13,36,1606,9,1002],[20,36,1606,16],[21,36,1606,17,1031],[34,36,1606,30,1028]],[[4,36,1607,2]],[[0,36,1608,0]],[[0,36,1610,0],[9,36,1610,9,995],[36,36,1611,2,868],[40,36,1611,22],[42,36,1612,2,1041],[47,36,1612,12],[49,36,1613,2,1028],[58,36,1613,30]],[[4,36,1615,2],[8,36,1615,6,993]],[[4,36,1616,2],[8,36,1616,6,868],[13,36,1616,11,954],[19,36,1616,17],[24,36,1616,17],[27,36,1616,52]],[[8,36,1617,4],[54,36,1617,50]],[[8,36,1618,4,868],[13,36,1618,9,954],[19,36,1618,15],[22,36,1618,15]],[[8,36,1619,4,1042],[30,36,1619,26,868],[35,36,1619,31,871],[39,36,1619,35],[41,36,1619,37,1041],[48,36,1619,44,1028]],[[8,36,1621,4],[80,36,1621,76]],[[8,36,1622,4],[80,36,1622,76]],[[8,36,1623,4],[37,36,1623,33]],[[8,36,1624,4],[10,36,1624,6]],[[8,36,1625,4],[78,36,1625,74]],[[8,36,1626,4],[80,36,1626,76]],[[8,36,1627,4],[82,36,1627,78]],[[8,36,1628,4],[78,36,1628,74]],[[8,36,1629,4],[32,36,1629,28]],[[8,36,1630,4],[10,36,1630,6]],[[8,36,1631,4],[79,36,1631,75]],[[8,36,1632,4],[50,36,1632,46]],[[8,36,1633,4],[12,36,1633,8,868],[17,36,1633,13,924],[27,36,1633,23],[32,36,1633,28],[38,36,1633,34]],[[12,36,1634,6],[84,36,1634,78]],[[12,36,1635,6],[34,36,1635,28]],[[12,36,1636,6,993],[25,36,1636,6,993]],[[8,36,1637,4],[15,36,1637,11]],[[12,36,1638,6],[82,36,1638,76]],[[12,36,1639,6],[84,36,1639,78]],[[12,36,1640,6],[72,36,1640,66]],[[12,36,1641,6],[83,36,1641,77]],[[12,36,1642,6],[83,36,1642,77]],[[12,36,1643,6],[78,36,1643,72]],[[12,36,1644,6,993],[25,36,1644,6,993]],[[8,36,1645,4]],[[4,36,1646,2],[11,36,1646,9]],[[8,36,1647,4],[84,36,1647,80]],[[8,36,1648,4],[54,36,1648,50]],[[8,36,1649,4,993],[21,36,1649,4,993]],[[4,36,1650,2]],[[4,36,1652,2],[10,36,1652,8,927],[25,36,1652,23,868],[30,36,1652,28,957],[38,36,1652,36]],[[4,36,1653,2],[8,36,1653,6,927],[25,36,1653,23],[31,36,1653,29]],[[8,36,1654,4],[13,36,1654,9],[19,36,1654,15],[22,36,1654,18,946],[32,36,1654,28],[36,36,1654,32,927],[49,36,1654,46]],[[12,36,1655,6],[18,36,1655,12,1043],[36,36,1655,30,995],[63,36,1656,8,946],[74,36,1657,8,1041],[81,36,1658,8,1028]],[[12,36,1660,6],[81,36,1660,75]],[[12,36,1661,6],[32,36,1661,26]],[[12,36,1662,6],[16,36,1662,10,1043],[34,36,1662,28,993],[46,36,1662,40]],[[16,36,1663,8,993],[29,36,1663,21,1043]],[[12,36,1664,6]],[[8,36,1665,4]],[[4,36,1666,2]],[[4,36,1668,2],[11,36,1668,9,993]],[[0,36,1669,0]],[[0,36,1671,0],[9,36,1671,9,1042],[31,36,1672,2,972],[40,36,1672,22],[42,36,1673,2,1041],[47,36,1673,12],[49,36,1674,2,1028],[58,36,1674,30]],[[4,36,1676,2],[10,36,1676,8,960],[16,36,1676,14,972],[26,36,1676,24,960],[29,36,1676,27]],[[4,36,1677,2],[8,36,1677,6,857],[22,36,1677,20,960],[28,36,1677,26]],[[8,36,1678,4],[12,36,1678,8,1041],[22,36,1678,18],[28,36,1678,24]],[[12,36,1679,6],[60,36,1679,54]],[[12,36,1680,6,960],[16,36,1680,10,1002],[23,36,1680,17],[24,36,1680,18],[30,36,1680,24,1028]],[[8,36,1681,4],[15,36,1681,11]],[[12,36,1682,6],[59,36,1682,53]],[[12,36,1683,6,960],[16,36,1683,10,1044],[22,36,1683,16],[23,36,1683,17,1041],[30,36,1683,24,1028]],[[8,36,1684,4]],[[4,36,1685,2]],[[4,36,1687,2],[10,36,1687,8,974],[20,36,1687,18,972],[30,36,1687,28,974],[37,36,1687,35]],[[4,36,1688,2],[8,36,1688,6,857],[22,36,1688,20,974],[32,36,1688,30]],[[8,36,1689,4,974],[16,36,1689,12,1002],[23,36,1689,19],[24,36,1689,20],[30,36,1689,26,1028]],[[4,36,1690,2]],[[4,36,1692,2],[82,36,1692,80]],[[4,36,1693,2],[80,36,1693,78]],[[4,36,1694,2],[79,36,1694,77]],[[4,36,1695,2],[65,36,1695,63]],[[4,36,1696,2],[10,36,1696,8,973],[17,36,1696,15,972],[27,36,1696,25,973],[31,36,1696,29]],[[4,36,1697,2],[8,36,1697,6,857],[22,36,1697,20,973],[29,36,1697,27]],[[8,36,1698,4,973],[13,36,1698,9,1002],[20,36,1698,16],[21,36,1698,17],[27,36,1698,23,1028]],[[4,36,1699,2]],[[0,36,1700,0]],[[0,36,1702,0],[6,36,1702,6,1045],[17,36,1702,17,1046]],[[0,36,1739,7],[9,36,1739,16,857],[23,36,1739,30,1047],[28,36,1739,40]],[[4,36,1740,2],[11,36,1740,9,1047],[20,36,1740,18],[27,36,1740,25,1047],[37,36,1740,35],[49,36,1740,47,1047],[55,36,1740,53,1048],[58,36,1740,56],[63,36,1740,61,1045]],[[0,36,1741,0]],[[0,36,1743,0],[9,36,1743,9,976]],[[4,36,1746,2],[78,36,1746,76]],[[4,36,1747,2],[81,36,1747,79]],[[4,36,1748,2],[82,36,1748,80]],[[4,36,1749,2],[37,36,1749,35]],[[4,36,1751,2],[79,36,1751,77]],[[4,36,1752,2],[79,36,1752,77]],[[4,36,1753,2],[79,36,1753,77]],[[4,36,1754,2],[32,36,1754,30]],[[4,36,1755,2],[6,36,1755,4]],[[4,36,1756,2],[80,36,1756,78]],[[4,36,1757,2],[79,36,1757,77]],[[4,36,1758,2],[31,36,1758,29]],[[4,36,1759,2],[10,36,1759,8,1028],[22,36,1759,32],[24,36,1759,34]],[[4,36,1761,2],[8,36,1761,6,1002]],[[4,36,1762,2],[8,36,1762,6,1044]],[[4,36,1763,2],[10,36,1763,8,1049],[23,36,1763,21],[27,36,1763,25,1001],[35,36,1763,36],[36,36,1763,37,1050],[41,36,1763,42,1051]],[[8,36,1764,4,1002],[18,36,1764,14,1050]],[[8,36,1765,4,1044],[17,36,1765,13,1051]],[[4,36,1766,2]],[[4,36,1767,2,1049],[15,36,1767,13,954],[21,36,1767,19],[24,36,1767,22]],[[4,36,1768,2,1049],[15,36,1768,13,1002],[22,36,1768,20],[25,36,1768,23],[26,36,1768,24,1047],[33,36,1768,34,1052]],[[8,36,1769,4],[12,36,1769,8,1049],[23,36,1769,19,954],[29,36,1769,25],[34,36,1769,30],[45,36,1769,41]],[[12,36,1770,6],[18,36,1770,12,1053],[33,36,1770,52,1049]],[[12,36,1771,6,1053],[25,36,1771,19,954],[31,36,1771,25],[34,36,1771,28]],[[12,36,1772,6,1053],[25,36,1772,19,1047],[30,36,1772,24],[33,36,1772,27,1047]],[[12,36,1773,6],[16,36,1773,10,1052],[38,36,1773,32],[44,36,1773,38]],[[16,36,1774,8],[66,36,1774,58]],[[16,36,1775,8,1028],[26,36,1775,18,962],[30,36,1775,22],[31,36,1775,23,1054],[36,36,1775,28],[37,36,1775,29,1028],[48,36,1775,40,1052]],[[12,36,1776,6]],[[12,36,1777,6,1002],[20,36,1777,14,1047]],[[8,36,1778,4]],[[4,36,1779,2]],[[4,36,1780,2,1049],[15,36,1780,13,1044],[21,36,1780,19],[24,36,1780,22],[25,36,1780,23,1041],[32,36,1780,35,1052]],[[8,36,1781,4],[12,36,1781,8,1049],[23,36,1781,19,954],[29,36,1781,25],[34,36,1781,30],[45,36,1781,41]],[[12,36,1782,6],[18,36,1782,12,1055],[32,36,1782,50,1049]],[[12,36,1783,6,1055],[24,36,1783,18,954],[30,36,1783,24],[33,36,1783,27]],[[12,36,1784,6,1055],[24,36,1784,18,1056],[30,36,1784,24],[33,36,1784,27,1041]],[[12,36,1785,6],[16,36,1785,10,1052],[38,36,1785,32],[44,36,1785,38]],[[16,36,1786,8],[66,36,1786,58]],[[16,36,1787,8,1028],[26,36,1787,18,962],[30,36,1787,22],[31,36,1787,23,1054],[36,36,1787,28],[37,36,1787,29,1028],[48,36,1787,40,1052]],[[12,36,1788,6]],[[12,36,1789,6,1044],[19,36,1789,13,1041]],[[8,36,1790,4]],[[4,36,1791,2]],[[4,36,1792,2,1049],[15,36,1792,13,1048],[18,36,1792,16],[21,36,1792,19,1045]],[[4,36,1793,2,1049],[15,36,1793,13,1057],[25,36,1793,23],[28,36,1793,26,1028]],[[4,36,1795,2],[11,36,1795,9,1049]],[[0,36,1796,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,37,0,0]],[],[[1,37,2,1]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,37,33,18,1058],[17,37,33,31],[19,37,33,31]],[[15,37,33,18,1058]],[],[[4,37,4,18,1059],[23,37,4,37],[25,37,4,37]],[[15,37,4,18,1059]],[],[[4,37,14,18,1060],[20,37,14,34],[22,37,14,34]],[[15,37,14,18,1060]],[],[],[[0,37,4,7],[4,37,4,18,1059],[26,37,4,18,1059],[37,37,4,18,1059],[40,37,4,18,1059],[49,37,4,18,1059],[68,37,4,18,1059]],[],[],[],[],[[11,37,4,18,1059]],[],[[0,37,14,7],[4,37,14,18,1060],[23,37,14,18,1060],[34,37,14,18,1060],[37,37,14,18,1060],[46,37,14,18,1060],[62,37,14,18,1060]],[[4,37,15,2]],[],[],[],[],[[3,37,20,3],[6,37,20,3],[22,37,20,3],[23,37,20,3],[39,37,20,3],[40,37,20,3],[49,37,20,3],[52,37,20,3],[54,37,20,3],[57,37,20,3]],[[4,37,22,2]],[],[[3,37,24,3],[6,37,24,3],[22,37,24,3],[23,37,24,3],[39,37,24,3],[40,37,24,3],[50,37,24,3],[53,37,24,3],[55,37,24,3],[58,37,24,3]],[[4,37,26,2]],[],[],[[3,37,29,3],[6,37,29,3],[22,37,29,3],[23,37,29,3],[39,37,29,3],[40,37,29,3],[53,37,29,3],[56,37,29,3],[58,37,29,3],[61,37,29,3]],[[11,37,14,18,1060]],[],[[0,37,33,7],[4,37,33,18,1058],[20,37,33,18,1058],[31,37,33,18,1058],[34,37,33,18,1058],[43,37,33,18,1058],[56,37,33,18,1058]],[[4,37,34,2],[65,37,34,63]],[[4,37,35,2],[67,37,35,65]],[[4,37,36,2],[55,37,36,53]],[],[],[],[],[[11,37,33,18,1058]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,38,68,16,1061],[17,38,68,29],[19,38,68,29]],[[15,38,68,16,1061]],[],[[4,38,15,16,1062],[10,38,15,22],[12,38,15,22]],[[15,38,15,16,1062]],[],[[4,38,54,16,1063],[17,38,54,29],[19,38,54,29]],[[15,38,54,16,1063]],[],[],[[26,38,0,31]],[[0,38,3,0],[78,38,3,78]],[[0,38,4,0],[59,38,4,59]],[[0,38,6,0],[4,38,6,4,1064],[11,38,6,35]],[[0,38,7,0],[4,38,7,4,1065],[25,38,7,34]],[[0,38,8,0],[4,38,8,4,1066],[14,38,8,22]],[[0,38,10,0],[79,38,10,79]],[[0,38,11,0],[74,38,11,74]],[[0,38,12,0],[44,38,12,44]],[[0,38,13,0],[6,38,13,6,1067],[19,38,13,19],[24,38,13,24],[31,38,13,31],[36,38,13,36],[44,38,13,44]],[],[[0,38,15,7],[9,38,15,16,1062],[16,38,15,23,1068],[20,38,15,44]],[[4,38,16,2],[8,38,16,6,1064],[17,38,16,15,1068],[23,38,16,21]],[[8,38,17,4],[30,38,17,26]],[[8,38,18,4]],[[4,38,19,2]],[[4,38,20,2],[10,38,20,8,1069],[17,38,20,15,1068],[22,38,20,20,1069],[26,38,20,24]],[[4,38,21,2],[10,38,21,8,1070],[17,38,21,15,1068],[22,38,21,20,1070],[26,38,21,24]],[[4,38,22,2],[8,38,22,6,1070],[17,38,22,15],[25,38,22,23,1069],[34,38,22,32],[40,38,22,38]],[[8,38,23,4],[31,38,23,27]],[[8,38,24,4,1066],[19,38,24,15,1068],[24,38,24,20,1071],[28,38,24,24]],[[8,38,25,4],[75,38,25,71]],[[8,38,26,4],[81,38,26,77]],[[8,38,27,4],[32,38,27,28]],[[8,38,28,4,1072]],[[4,38,29,2],[11,38,29,9]],[[8,38,30,4],[60,38,30,56]],[[8,38,31,4,1069],[13,38,31,9,1070],[17,38,31,13],[20,38,31,16,1070]],[[8,38,32,4,1070],[13,38,32,9,1069],[17,38,32,13],[20,38,32,16,1069]],[[4,38,33,2]],[[4,38,35,2],[36,38,35,34]],[[4,38,36,2],[8,38,36,6,1064],[17,38,36,15],[23,38,36,21]],[[8,38,37,4],[34,38,37,30]],[[8,38,38,4,1068],[13,38,38,9,1069],[17,38,38,13],[20,38,38,16,1068]],[[8,38,39,4,1068],[13,38,39,9,1070],[17,38,39,13],[20,38,39,16,1068]],[[4,38,40,2],[11,38,40,9]],[[8,38,41,4],[39,38,41,35]],[[8,38,42,4],[14,38,42,10,1073],[21,38,42,17,1064],[26,38,42,22,1069],[30,38,42,26]],[[8,38,43,4,1068],[13,38,43,9,1069],[17,38,43,13],[20,38,43,16,1073]],[[8,38,44,4],[78,38,44,74]],[[8,38,45,4],[12,38,45,8,1073],[21,38,45,17],[27,38,45,23]],[[12,38,46,6,1073],[17,38,46,11,1070],[21,38,46,15],[24,38,46,18,1068]],[[8,38,47,4]],[[8,38,48,4,1068],[13,38,48,9,1070],[17,38,48,13],[20,38,48,16,1064]],[[8,38,49,4,1064],[13,38,49,9,1069],[17,38,49,13],[20,38,49,16,1068]],[[4,38,50,2]],[[4,38,51,2,1064],[11,38,51,9,1068]],[[0,38,52,0]],[[0,38,54,7],[9,38,54,16,1063],[23,38,54,30,1068],[27,38,54,51],[29,38,54,53,1074],[40,38,54,72]],[[4,38,55,2],[77,38,55,75]],[[4,38,56,2],[69,38,56,67]],[[4,38,57,2],[10,38,57,8,1075],[25,38,57,23,1068],[30,38,57,28,1071],[34,38,57,32]],[[4,38,58,2,1068],[9,38,58,7,1071],[13,38,58,11],[16,38,58,14,1074]],[[4,38,59,2],[8,38,59,6,1068],[13,38,59,11,1070],[17,38,59,15],[22,38,59,20],[28,38,59,26]],[[8,38,60,4],[64,38,60,60]],[[8,38,61,4]],[[4,38,62,2]],[[4,38,63,2],[32,38,63,30]],[[4,38,64,2,1066],[14,38,64,12,1066],[24,38,64,22,1075],[39,38,64,37,1074]],[[4,38,65,2,1072]],[[0,38,66,0]],[[0,38,68,7],[9,38,68,16,1061],[23,38,68,30,1076],[30,38,68,54]],[[4,38,69,2],[10,38,69,8,1070],[17,38,69,15,1076],[25,38,69,23,1070],[29,38,69,27]],[[4,38,70,2],[10,38,70,8,1069],[17,38,70,15,1076],[25,38,70,23,1069],[29,38,70,27]],[[4,38,71,2],[8,38,71,6,1070],[17,38,71,15],[25,38,71,23,1069],[34,38,71,32],[40,38,71,38]],[[8,38,72,4,1066],[19,38,72,15,1076],[27,38,72,23,1071],[31,38,72,27]],[[8,38,74,4,1076],[16,38,74,12,1070],[20,38,74,16],[23,38,74,19]],[[8,38,75,4,1076],[16,38,75,12,1069],[20,38,75,16],[23,38,75,19]],[[8,38,77,4],[31,38,77,27]],[[8,38,78,4],[12,38,78,8,1064],[21,38,78,17,1076],[30,38,78,26]],[[12,38,79,6],[30,38,79,24]],[[12,38,80,6],[16,38,80,10,1070],[25,38,80,19,1064],[31,38,80,25]],[[16,38,81,8],[42,38,81,34]],[[16,38,82,8,1064],[23,38,82,15]],[[12,38,83,6],[19,38,83,13]],[[16,38,84,8,1064],[23,38,84,15,1070]],[[16,38,85,8,1069],[21,38,85,13,1070],[25,38,85,17],[28,38,85,20,1070]],[[16,38,86,8,1070],[21,38,86,13,1069],[25,38,86,17],[28,38,86,20,1069]],[[12,38,87,6]],[[8,38,88,4],[15,38,88,11]],[[12,38,89,6,1069],[17,38,89,11,1070],[21,38,89,15],[24,38,89,18,1070]],[[12,38,90,6,1070],[17,38,90,11,1069],[21,38,90,15],[24,38,90,18,1069]],[[8,38,91,4]],[[4,38,92,2],[11,38,92,9]],[[4,38,93,4],[22,38,93,22]],[[4,38,94,2]],[[0,38,95,0]],[[0,38,97,0],[9,38,97,9,1072]],[[4,38,98,2],[8,38,98,6,1065],[30,38,98,28,1066],[41,38,98,39,1067],[53,38,98,51]],[[8,38,99,4]],[[4,38,100,2]],[[4,38,101,2,1065],[25,38,101,23]],[[4,38,102,2,1077],[27,38,102,25,1078]],[[0,38,103,0]],[[0,38,105,0],[9,38,105,9,1078]],[[4,38,106,2,1065],[25,38,106,23]],[[4,38,108,2],[74,38,108,72]],[[4,38,109,2],[68,38,109,66]],[[4,38,110,2],[69,38,110,67]],[[4,38,111,2],[10,38,111,8,1079],[29,38,111,27,1067],[42,38,111,40]],[[4,38,112,2],[10,38,112,9,1066],[20,38,112,19,1079],[40,38,112,39,1064],[49,38,112,48],[54,38,112,54]],[[8,38,113,4],[14,38,113,10,1073],[21,38,113,17,1064],[26,38,113,22,1069],[30,38,113,26]],[[8,38,114,4],[78,38,114,74]],[[8,38,115,4],[12,38,115,8,1073],[21,38,115,17],[27,38,115,23]],[[12,38,116,6],[79,38,116,73]],[[12,38,117,6],[23,38,117,17]],[[12,38,118,6,1080],[13,38,118,6,1080],[16,38,118,6,1080],[26,38,118,6,1080],[40,38,118,20],[42,38,118,21,1073]],[[8,38,119,4]],[[4,38,120,2]],[[0,38,121,0]],[[0,38,123,0],[6,38,123,6,1077],[31,38,124,2],[38,38,124,9,1081],[62,38,124,33],[75,38,125,6,1081],[97,38,126,6],[98,38,126,7,1082],[103,38,126,26,1083],[114,38,126,37,1082],[118,38,126,41]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,39,123,13,1084],[12,39,123,21],[14,39,123,21]],[[15,39,123,13,1084]],[],[[4,39,129,16,1085],[18,39,129,30],[20,39,129,30]],[[15,39,129,16,1085]],[],[[4,39,384,16,1086],[22,39,384,34],[24,39,384,34]],[[15,39,384,16,1086]],[],[[4,39,403,16,1087],[18,39,403,30],[20,39,403,30]],[[15,39,403,16,1087]],[],[[4,39,212,16,1088],[19,39,212,31],[21,39,212,31]],[[15,39,212,16,1088]],[],[[4,39,235,16,1089],[18,39,235,30],[20,39,235,30]],[[15,39,235,16,1089]],[],[[4,39,337,16,1090],[17,39,337,29],[19,39,337,29]],[[15,39,337,16,1090]],[],[[4,39,446,16,1091],[21,39,446,33],[23,39,446,33]],[[15,39,446,16,1091]],[],[],[[21,39,1,53]],[[0,39,123,7],[6,39,123,13,1084],[17,39,123,24],[18,39,123,25]],[[0,39,125,0],[79,39,125,79]],[[0,39,126,0],[71,39,126,71]],[[0,39,127,0],[6,39,127,6,1092],[21,39,127,21],[22,39,127,22]],[[0,39,129,7],[9,39,129,16,1085]],[[4,39,130,2],[10,39,130,8,1093],[21,39,130,32]],[[8,39,131,4,1094],[16,39,131,12]],[[8,39,132,4,1095],[13,39,132,9]],[[8,39,133,4,1096],[15,39,133,11]],[[8,39,134,4,1097],[13,39,134,9]],[[8,39,136,4],[29,39,136,25]],[[8,39,137,4,1098],[14,39,137,10]],[[8,39,138,4,1099],[14,39,138,10]],[[8,39,139,4,1100],[14,39,139,10]],[[4,39,140,2]],[[4,39,141,2],[11,39,141,9,1093]],[[0,39,142,0]],[[0,39,144,0],[9,39,144,9,1101],[25,39,145,2,1093],[33,39,145,23],[35,39,146,2,1102],[39,39,146,16],[41,39,147,2,1103],[55,39,147,25]],[[4,39,149,2],[77,39,149,75]],[[4,39,150,2],[47,39,150,45]],[[4,39,151,2],[6,39,151,4]],[[4,39,152,2],[79,39,152,77]],[[4,39,153,2],[78,39,153,76]],[[4,39,154,2],[38,39,154,36]],[[4,39,155,2],[8,39,155,6,1104],[16,39,155,14,1093]],[[4,39,156,2],[8,39,156,6,1105],[24,39,156,39,1102]],[[4,39,157,2],[8,39,157,6,1095],[14,39,157,28]],[[4,39,158,2],[10,39,158,9],[15,39,158,15]],[[8,39,159,4],[14,39,159,10,1106],[28,39,159,24,1095]],[[8,39,160,4],[12,39,160,8,1105],[30,39,160,26],[36,39,160,32]],[[12,39,161,6,1095],[18,39,161,12,1105],[32,39,161,26,1096],[37,39,161,31]],[[12,39,162,6,1105],[28,39,162,22,1105],[42,39,162,36,1094],[48,39,162,42]],[[8,39,163,4],[15,39,163,11],[19,39,163,15,1103],[37,39,163,33,1106],[53,39,163,49,1092],[67,39,163,63]],[[12,39,164,6],[81,39,164,75]],[[12,39,165,6],[72,39,165,66]],[[12,39,167,6],[86,39,167,80]],[[12,39,168,6],[82,39,168,76]],[[12,39,169,6],[27,39,169,21]],[[12,39,170,6],[16,39,170,10,1104],[22,39,170,16,1096],[27,39,170,21],[32,39,170,26],[38,39,170,32]],[[16,39,171,8],[23,39,171,15,1104]],[[12,39,172,6]],[[12,39,174,6],[47,39,174,41]],[[12,39,175,6,1095],[18,39,175,12,1092]],[[8,39,176,4],[15,39,176,11]],[[12,39,178,6]],[[8,39,179,4]],[[8,39,181,4],[12,39,181,8,1097],[18,39,181,14,1104],[24,39,181,20,1097],[27,39,181,23]],[[8,39,182,4],[12,39,182,8,1097],[20,39,182,16],[26,39,182,22]],[[12,39,183,6],[18,39,183,12,1107],[34,39,183,28,1097],[38,39,183,32,1108],[41,39,183,35],[42,39,183,36,1095]],[[12,39,184,6],[16,39,184,10,1107],[34,39,184,28,1109],[45,39,184,39]],[[16,39,185,8],[45,39,185,37]],[[16,39,186,8,1104],[24,39,186,16,1107]],[[16,39,187,8]],[[12,39,188,6]],[[8,39,189,4],[15,39,189,11]],[[12,39,190,6,1097],[18,39,190,12],[22,39,190,16,1110]],[[12,39,191,6,1104],[18,39,191,12,1097],[21,39,191,15],[24,39,191,18,1097]],[[8,39,192,4]],[[8,39,193,4],[63,39,193,59]],[[8,39,194,4],[14,39,194,10,1111],[25,39,194,34]],[[12,39,195,6,1094],[20,39,195,14,1104]],[[12,39,196,6,1095]],[[12,39,197,6,1096],[19,39,197,13]],[[12,39,198,6,1097],[17,39,198,11]],[[12,39,200,6],[33,39,200,27]],[[12,39,201,6,1098],[18,39,201,12]],[[12,39,202,6,1099],[18,39,202,12]],[[12,39,203,6,1100],[18,39,203,12]],[[8,39,204,4]],[[8,39,205,4,1097],[12,39,205,8,1112],[15,39,205,11],[16,39,205,12,1095],[21,39,205,17,1111]],[[8,39,206,4,1104],[16,39,206,12,1111]],[[4,39,207,2]],[[4,39,209,2],[11,39,209,9,1104]],[[0,39,210,0]],[[0,39,212,7],[9,39,212,16,1088],[25,39,213,2,1113],[28,39,213,13],[30,39,214,2,1114],[49,39,214,29],[51,39,215,2,1115],[60,39,215,24],[62,39,216,2,1102],[66,39,216,16],[68,39,217,2,1103],[82,39,217,25]],[[4,39,219,2],[10,39,219,8,1104],[18,39,219,16,1116],[43,39,220,4,1113],[48,39,221,4,1114],[69,39,222,4,1115],[80,39,223,4,1102],[86,39,224,4,1103],[102,39,225,4]],[[4,39,227,2],[8,39,227,6,1104],[18,39,227,16],[26,39,227,24,1104],[32,39,227,30,1096],[37,39,227,35],[42,39,227,40],[48,39,227,46]],[[8,39,228,4],[15,39,228,11]],[[4,39,229,2]],[[4,39,230,2],[70,39,230,68]],[[4,39,231,2,1117],[5,39,231,2,1117],[8,39,231,2,1117],[13,39,231,2,1117],[19,39,231,8],[21,39,231,9,1104]],[[4,39,232,2],[11,39,232,9,1104],[17,39,232,15,1096],[22,39,232,20]],[[0,39,233,0]],[[0,39,235,7],[9,39,235,16,1089],[24,39,236,2,1113],[27,39,236,13],[29,39,237,2,1114],[48,39,237,29],[50,39,238,2,1096],[55,39,238,17]],[[4,39,240,2],[11,39,240,9,1096],[17,39,240,15,1118],[24,39,240,22],[28,39,240,26,1113],[35,39,240,33,1096],[41,39,240,39,1119],[48,39,240,46],[51,39,240,49,1114]],[[0,39,241,0]],[[0,39,243,0],[9,39,243,9,1120],[29,39,244,2,1113],[32,39,244,13],[34,39,245,2,1114],[53,39,245,29],[55,39,246,2,1104],[60,39,246,20]],[[4,39,248,2],[81,39,248,79]],[[4,39,249,2],[81,39,249,79]],[[4,39,251,2],[8,39,251,6,1104],[14,39,251,12,1096],[19,39,251,17],[24,39,251,22],[30,39,251,28]],[[8,39,252,4],[64,39,252,60]],[[8,39,253,4],[15,39,253,11,1104]],[[4,39,254,2]],[[4,39,256,2],[10,39,256,8,1096],[18,39,256,16,1104],[24,39,256,22,1096],[29,39,256,27]],[[4,39,257,2],[8,39,257,6,1089],[23,39,257,21,1113],[28,39,257,26,1114],[49,39,257,47,1096],[57,39,257,55]],[[8,39,258,4],[83,39,258,79]],[[8,39,259,4],[52,39,259,48]],[[8,39,260,4,1087],[23,39,260,19,1104]],[[8,39,261,4],[15,39,261,11]],[[4,39,262,2]],[[4,39,264,2],[52,39,264,50]],[[4,39,265,2],[11,39,265,9,1104]],[[0,39,266,0]],[[0,39,268,0],[9,39,268,9,1116],[34,39,269,2,1113],[37,39,269,13],[39,39,270,2,1114],[58,39,270,29],[60,39,271,2,1104],[65,39,271,20],[67,39,272,2,1102],[71,39,272,23],[73,39,273,2,1103],[87,39,273,25],[89,39,274,2,1106],[100,39,274,29]],[[4,39,276,2],[79,39,276,77]],[[4,39,277,2],[77,39,277,75]],[[4,39,278,2],[76,39,278,74]],[[4,39,279,2],[36,39,279,34]],[[4,39,280,2],[6,39,280,4]],[[4,39,281,2],[56,39,281,54]],[[4,39,282,2],[8,39,282,6,1095]],[[4,39,283,2],[8,39,283,6,1105]],[[4,39,284,2],[8,39,284,6,1102],[17,39,284,15],[23,39,284,21]],[[8,39,285,4,1095],[14,39,285,10,1102],[19,39,285,15,1096],[24,39,285,20]],[[8,39,286,4,1105],[24,39,286,20,1102],[29,39,286,25,1094],[35,39,286,31]],[[4,39,287,2],[11,39,287,9],[15,39,287,13,1103],[33,39,287,31,1106],[49,39,287,47,1092],[63,39,287,61]],[[8,39,288,4],[77,39,288,73]],[[8,39,289,4],[34,39,289,30]],[[8,39,290,4,1095],[14,39,290,10,1092]],[[8,39,291,4,1105],[24,39,291,20]],[[4,39,292,2],[11,39,292,9]],[[8,39,293,4],[62,39,293,58]],[[8,39,295,4],[78,39,295,74]],[[8,39,296,4],[81,39,296,77]],[[8,39,297,4],[75,39,297,71]],[[8,39,298,4],[81,39,298,77]],[[8,39,299,4],[53,39,299,49]],[[8,39,301,4],[15,39,301,11,1120],[35,39,301,31,1113],[40,39,301,36,1114],[61,39,301,57,1104]],[[4,39,302,2]],[[4,39,303,2],[10,39,303,8,1097],[16,39,303,14,1104],[22,39,303,20,1097],[25,39,303,23]],[[4,39,304,2],[8,39,304,6,1097],[16,39,304,14],[22,39,304,20]],[[8,39,305,4],[14,39,305,10,1107],[30,39,305,26,1097],[34,39,305,30,1108],[37,39,305,33],[38,39,305,34,1095]],[[8,39,306,4],[12,39,306,8,1107],[30,39,306,26,1109],[41,39,306,37]],[[12,39,307,6],[65,39,307,59]],[[12,39,308,6],[18,39,308,12,1121],[27,39,308,21,1116],[52,39,309,8,1113],[57,39,310,8,1114],[78,39,311,8,1107],[93,39,312,8,1105],[108,39,313,8,1103],[124,39,314,8,1095]],[[12,39,316,6],[16,39,316,10,1121],[27,39,316,21],[33,39,316,27]],[[16,39,317,8],[23,39,317,15,1121]],[[12,39,318,6]],[[8,39,319,4]],[[8,39,320,4],[68,39,320,64]],[[8,39,321,4],[14,39,321,10,1122],[30,39,321,26,1097],[34,39,321,30,1108],[37,39,321,33],[38,39,321,34,1084]],[[8,39,322,4],[12,39,322,8,1122],[30,39,322,26,1109],[41,39,322,37]],[[12,39,323,6],[61,39,323,55]],[[12,39,324,6],[19,39,324,13,1116],[44,39,325,8,1113],[49,39,326,8,1114],[70,39,327,8,1122],[85,39,328,8,1105],[100,39,329,8,1103],[116,39,330,8,1095]],[[8,39,332,4]],[[4,39,333,2]],[[4,39,334,2],[11,39,334,9]],[[0,39,335,0]],[[0,39,337,7],[9,39,337,16,1090],[23,39,338,2,1093],[31,39,338,23],[33,39,339,2,1102],[37,39,339,16],[39,39,340,2,1096],[44,39,340,10],[46,39,341,2,1103],[60,39,341,25]],[[4,39,343,2],[75,39,343,73]],[[4,39,344,2],[78,39,344,76]],[[4,39,345,2],[65,39,345,63]],[[4,39,346,2],[10,39,346,8,1104],[18,39,346,16,1101],[34,39,346,32,1093],[44,39,346,42,1102],[50,39,346,48,1103]],[[4,39,347,2,1123],[21,39,347,19,1104],[28,39,347,26,1096]],[[4,39,349,2],[70,39,349,68]],[[4,39,350,2,1117],[5,39,350,2,1117],[8,39,350,2,1117],[13,39,350,2,1117],[19,39,350,8],[21,39,350,9,1104]],[[4,39,351,2,1124],[5,39,351,2,1124],[8,39,351,2,1124],[13,39,351,2,1124],[26,39,351,15],[28,39,351,16,1104],[35,39,351,23,1096],[41,39,351,29,1100],[45,39,351,33]],[[0,39,352,0]],[[0,39,354,0],[9,39,354,9,1123],[26,39,354,26,1104],[31,39,354,48],[33,39,354,50,1096],[38,39,354,65]],[[4,39,355,2],[8,39,355,6,1104],[14,39,355,12,1096],[19,39,355,17],[24,39,355,22],[30,39,355,28]],[[8,39,356,4],[81,39,356,77]],[[8,39,357,4],[76,39,357,72]],[[8,39,358,4],[81,39,358,77]],[[8,39,359,4,1125],[16,39,359,12,1104],[22,39,359,18,1096],[27,39,359,23]],[[8,39,360,4,1104],[14,39,360,10,1096],[19,39,360,15],[22,39,360,18]],[[4,39,361,2]],[[4,39,363,2],[67,39,363,65]],[[4,39,364,2],[47,39,364,45]],[[4,39,365,2],[10,39,365,8,1126],[21,39,365,19,1096],[27,39,365,25,1127],[30,39,365,28]],[[4,39,367,2,1104],[10,39,367,8,1096],[15,39,367,13],[18,39,367,16,1096]],[[4,39,368,2,1096],[10,39,368,8,1127],[13,39,368,11],[16,39,368,14,1104]],[[4,39,370,2,1124],[5,39,370,2,1124],[8,39,370,2,1124],[13,39,370,2,1124],[26,39,370,15],[28,39,370,16,1104],[35,39,370,23,1096],[41,39,370,29,1100],[45,39,370,33]],[[4,39,372,2],[8,39,372,6,1126],[21,39,372,19],[29,39,372,27,1126],[42,39,372,40,1104],[51,39,372,49,1126],[60,39,372,58,1096],[65,39,372,63],[70,39,372,68,1096],[77,39,372,75]],[[8,39,373,4],[78,39,373,74]],[[8,39,374,4],[78,39,374,74]],[[8,39,375,4],[28,39,375,24]],[[8,39,376,4],[10,39,376,6]],[[8,39,377,4],[79,39,377,75]],[[8,39,378,4],[66,39,378,62]],[[8,39,379,4],[57,39,379,53]],[[8,39,380,4,1087],[23,39,380,19,1126]],[[4,39,381,2]],[[0,39,382,0]],[[0,39,384,7],[9,39,384,16,1086],[28,39,384,35,1096],[33,39,384,50]],[[4,39,385,2],[10,39,385,8,1104],[18,39,385,16,1096],[24,39,385,22,1127],[27,39,385,25]],[[4,39,386,2],[8,39,386,6,1104],[18,39,386,16],[24,39,386,22]],[[8,39,387,4],[49,39,387,45]],[[8,39,388,4]],[[4,39,389,2]],[[4,39,391,2,1125],[12,39,391,10,1096]],[[4,39,392,2,1087],[19,39,392,17,1104]],[[0,39,393,0]],[[0,39,395,0],[9,39,395,9,1125],[17,39,395,17,1096],[22,39,395,32]],[[4,39,396,2],[70,39,396,68]],[[4,39,397,2],[76,39,397,74]],[[4,39,398,2],[75,39,398,73]],[[4,39,399,2],[57,39,399,55]],[[4,39,400,2,1096],[10,39,400,8,1127],[13,39,400,11],[16,39,400,14]],[[0,39,401,0]],[[0,39,403,7],[9,39,403,16,1087],[24,39,403,31,1104],[29,39,403,53]],[[4,39,404,2],[39,39,404,37]],[[4,39,405,2,1104],[10,39,405,8,1096],[15,39,405,13],[18,39,405,16]],[[4,39,407,2,1128],[5,39,407,2,1128],[8,39,407,2,1128],[13,39,407,2,1128],[26,39,407,15],[28,39,407,16,1104]],[[4,39,409,2],[49,39,409,47]],[[4,39,410,2],[10,39,410,8,1097],[16,39,410,14,1104],[22,39,410,20,1097],[25,39,410,23]],[[4,39,411,2],[8,39,411,6,1097],[16,39,411,14],[22,39,411,20]],[[8,39,412,4],[75,39,412,71]],[[8,39,413,4],[74,39,413,70]],[[8,39,414,4],[67,39,414,63]],[[8,39,415,4],[12,39,415,8,1094],[21,39,415,17,1104],[27,39,415,23,1094],[33,39,415,29]],[[8,39,416,4],[12,39,416,8,1095],[18,39,416,14,1104],[24,39,416,20,1095],[27,39,416,23]],[[8,39,417,4],[14,39,417,11,1094],[25,39,417,22],[30,39,417,28]],[[12,39,418,6],[18,39,418,12,1129],[30,39,418,24,1094],[37,39,418,31,1097],[40,39,418,34]],[[12,39,419,6],[16,39,419,10,1129],[30,39,419,24],[36,39,419,30]],[[16,39,420,8,1129],[26,39,420,18,1130],[32,39,420,24],[33,39,420,25,1095]],[[16,39,421,8],[20,39,421,12,1129],[30,39,421,22,1100],[34,39,421,26],[39,39,421,31],[42,39,421,34]],[[20,39,422,10],[72,39,422,62]],[[20,39,423,10,1094],[27,39,423,17,1097],[30,39,423,20],[33,39,423,23]],[[20,39,424,10],[24,39,424,14,1094],[31,39,424,21,1096],[36,39,424,26],[41,39,424,31],[47,39,424,37]],[[24,39,425,12],[89,39,425,77]],[[24,39,426,12],[78,39,426,66]],[[24,39,427,12,1095],[30,39,427,18,1094],[37,39,427,25,1095],[40,39,427,28]],[[24,39,428,12,1094],[33,39,428,21,1094],[40,39,428,28,1094],[46,39,428,34]],[[24,39,429,12]],[[20,39,430,10]],[[16,39,431,8]],[[12,39,432,6]],[[12,39,434,6]],[[8,39,435,4]],[[4,39,436,2],[11,39,436,9]],[[8,39,437,4],[72,39,437,68]],[[8,39,438,4],[65,39,438,61]],[[8,39,439,4],[14,39,439,10,1131],[34,39,439,30,1097],[38,39,439,34,1108],[41,39,439,37],[42,39,439,38,1092]],[[8,39,440,4],[12,39,440,8,1131],[34,39,440,30,1109],[47,39,440,43,1131],[65,39,440,61,1096],[70,39,440,66],[75,39,440,71],[81,39,440,77]],[[12,39,441,6,1123],[29,39,441,23,1104],[36,39,441,30,1131],[54,39,441,48,1096],[59,39,441,53]],[[8,39,442,4]],[[4,39,443,2]],[[0,39,444,0]],[[0,39,446,7],[9,39,446,16,1091],[27,39,447,2,1096],[32,39,447,10],[34,39,448,2,1100],[38,39,448,14]],[[4,39,450,2],[10,39,450,8,1104],[18,39,450,16,1096],[24,39,450,22,1127],[27,39,450,25]],[[4,39,451,2],[8,39,451,6,1104],[18,39,451,16],[24,39,451,22]],[[8,39,452,4],[49,39,452,45]],[[8,39,453,4]],[[4,39,454,2]],[[4,39,455,2],[81,39,455,79]],[[4,39,456,2],[80,39,456,78]],[[4,39,457,2],[15,39,457,13]],[[4,39,458,2,1096],[10,39,458,8,1100],[14,39,458,12],[17,39,458,15,1100]],[[4,39,459,2,1124],[5,39,459,2,1124],[8,39,459,2,1124],[13,39,459,2,1124],[26,39,459,15],[28,39,459,16,1104],[35,39,459,23,1100]],[[0,39,460,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,40,119,16,1132],[24,40,119,36],[26,40,119,36]],[[15,40,119,16,1132]],[],[[4,40,263,16,1133],[40,40,263,52],[42,40,263,52]],[[15,40,263,16,1133]],[],[[4,40,130,16,1134],[26,40,130,38],[28,40,130,38]],[[15,40,130,16,1134]],[],[[4,40,158,16,1135],[28,40,158,40],[30,40,158,40]],[[15,40,158,16,1135]],[],[[4,40,141,16,1136],[24,40,141,36],[26,40,141,36]],[[15,40,141,16,1136]],[],[[4,40,97,16,1137],[29,40,97,41],[31,40,97,41]],[[15,40,97,16,1137]],[],[[4,40,78,16,1138],[20,40,78,32],[22,40,78,32]],[[15,40,78,16,1138]],[],[[4,40,201,16,1139],[32,40,201,44],[34,40,201,44]],[[15,40,201,16,1139]],[],[],[[23,40,0,30]],[[26,40,7,44]],[[38,40,8,33]],[[0,40,78,7],[9,40,78,16,1138],[26,40,79,2,1140],[34,40,79,30],[36,40,80,2,1141],[42,40,80,26],[44,40,81,2,1142],[51,40,81,35]],[[4,40,83,2],[44,40,83,42]],[[4,40,84,2],[10,40,84,8,1143],[21,40,84,29]],[[8,40,85,4,1144],[15,40,85,11,1140]],[[8,40,86,4,1145],[16,40,86,12]],[[12,40,87,6,1144],[19,40,87,13,1141]],[[12,40,88,6,1145],[20,40,88,14]],[[16,40,89,8,1144],[23,40,89,15,1142]],[[16,40,90,8,1145],[24,40,90,16]],[[12,40,91,6]],[[8,40,92,4]],[[4,40,93,2]],[[4,40,94,2],[11,40,94,9,1143]],[[0,40,95,0]],[[0,40,97,7],[9,40,97,16,1137],[35,40,98,2,1140],[43,40,98,30],[45,40,99,2,1141],[51,40,99,26],[53,40,100,2,1142],[60,40,100,35],[62,40,101,2,1146],[80,40,101,29]],[[4,40,103,2],[79,40,103,77]],[[4,40,104,2],[61,40,104,59]],[[4,40,105,2],[44,40,105,42]],[[4,40,106,2],[10,40,106,8,1143],[21,40,106,29]],[[8,40,107,4,1144],[15,40,107,11,1140]],[[8,40,108,4,1145],[16,40,108,12]],[[12,40,109,6,1144],[19,40,109,13,1141]],[[12,40,110,6,1145],[20,40,110,14]],[[16,40,111,8,1144],[23,40,111,15,1146],[44,40,111,36,1142],[54,40,111,46,1147],[64,40,111,46,1147],[72,40,111,54]],[[16,40,112,8,1145],[24,40,112,16]],[[12,40,113,6]],[[8,40,114,4]],[[4,40,115,2]],[[4,40,116,2],[11,40,116,9,1143]],[[0,40,117,0]],[[0,40,119,7],[9,40,119,16,1132],[30,40,120,2,1148],[40,40,120,43],[42,40,121,2,1149],[50,40,121,18]],[[4,40,123,2],[10,40,123,8,1150],[25,40,123,33]],[[8,40,124,4,1144],[15,40,124,11,1149]],[[8,40,125,4,1145],[16,40,125,12,1148]],[[4,40,126,2]],[[4,40,127,2],[11,40,127,9,1150]],[[0,40,128,0]],[[0,40,130,7],[9,40,130,16,1134],[32,40,131,2,1151],[42,40,131,20],[44,40,132,2,1143],[52,40,132,41]],[[4,40,134,2],[10,40,134,8,1152],[27,40,134,35]],[[8,40,135,4,1144],[15,40,135,11,1151]],[[8,40,136,4,1145],[16,40,136,12,1143]],[[4,40,137,2]],[[4,40,138,2],[11,40,138,9,1152]],[[0,40,139,0]],[[0,40,141,7],[9,40,141,16,1136],[30,40,142,2,1151],[40,40,142,20],[42,40,143,2,1153],[56,40,143,34],[58,40,144,2,1143],[66,40,144,41]],[[4,40,146,2],[82,40,146,80]],[[4,40,147,2],[47,40,147,45]],[[4,40,148,2],[10,40,148,8,1154],[25,40,148,33]],[[8,40,149,4,1144],[15,40,149,11,1151]],[[8,40,150,4,1145],[16,40,150,12]],[[12,40,151,6,1144],[19,40,151,13,1153]],[[12,40,152,6,1145],[20,40,152,14,1143]],[[8,40,153,4]],[[4,40,154,2]],[[4,40,155,2],[11,40,155,9,1154]],[[0,40,156,0]],[[0,40,158,7],[9,40,158,16,1135],[34,40,159,2,1155],[48,40,159,24],[50,40,160,2,1153],[64,40,160,34],[66,40,161,2,1143],[74,40,161,41]],[[4,40,163,2],[79,40,163,77]],[[4,40,164,2],[74,40,164,72]],[[4,40,165,2],[78,40,165,76]],[[4,40,166,2],[14,40,166,12]],[[4,40,167,2],[6,40,167,4]],[[4,40,168,2],[79,40,168,77]],[[4,40,169,2],[80,40,169,78]],[[4,40,170,2],[79,40,170,77]],[[4,40,171,2],[78,40,171,76]],[[4,40,172,2],[22,40,172,20]],[[4,40,173,2],[6,40,173,4]],[[4,40,174,2],[71,40,174,69]],[[4,40,175,2],[77,40,175,75]],[[4,40,176,2],[75,40,176,73]],[[4,40,177,2],[31,40,177,29]],[[4,40,178,2],[6,40,178,4]],[[4,40,179,2],[78,40,179,76]],[[4,40,180,2],[79,40,180,77]],[[4,40,181,2],[75,40,181,73]],[[4,40,182,2],[23,40,182,21]],[[4,40,184,2],[79,40,184,77]],[[4,40,185,2],[72,40,185,70]],[[4,40,186,2],[73,40,186,71]],[[4,40,187,2],[75,40,187,73]],[[4,40,188,2],[10,40,188,8,1154],[25,40,188,33]],[[8,40,189,4],[79,40,189,75]],[[8,40,190,4],[83,40,190,79]],[[8,40,191,4],[54,40,191,50]],[[8,40,192,4,1144],[15,40,192,11,1155],[32,40,192,28,1156],[54,40,192,28,1156],[70,40,192,44]],[[8,40,193,4,1145],[16,40,193,12]],[[12,40,194,6,1144],[19,40,194,13,1153]],[[12,40,195,6,1145],[20,40,195,14,1143]],[[8,40,196,4]],[[4,40,197,2]],[[4,40,198,2],[11,40,198,9,1154]],[[0,40,199,0]],[[0,40,201,7],[9,40,201,16,1139],[38,40,202,2,1157],[51,40,202,30],[53,40,203,2,1158],[57,40,203,17]],[[4,40,205,2],[80,40,205,78]],[[4,40,206,2],[78,40,206,76]],[[4,40,207,2],[78,40,207,76]],[[4,40,208,2],[19,40,208,17]],[[4,40,209,2],[6,40,209,4]],[[4,40,210,2],[80,40,210,78]],[[4,40,211,2],[76,40,211,74]],[[4,40,212,2],[80,40,212,78]],[[4,40,213,2],[78,40,213,76]],[[4,40,214,2],[67,40,214,65]],[[4,40,215,2],[6,40,215,4]],[[4,40,216,2],[76,40,216,74]],[[4,40,217,2],[74,40,217,72]],[[4,40,218,2],[55,40,218,53]],[[4,40,219,2],[6,40,219,4]],[[4,40,220,2],[77,40,220,75]],[[4,40,221,2],[38,40,221,36]],[[4,40,222,2],[6,40,222,4]],[[4,40,223,2],[79,40,223,77]],[[4,40,224,2],[79,40,224,77]],[[4,40,225,2],[72,40,225,70]],[[4,40,226,2],[10,40,226,8,1159],[29,40,226,27,1158],[34,40,226,32,1143],[42,40,226,40]],[[4,40,228,2],[79,40,228,77]],[[4,40,229,2],[74,40,229,72]],[[4,40,230,2],[76,40,230,74]],[[4,40,231,2],[8,40,231,6,1158],[13,40,231,11,1160],[19,40,231,17],[21,40,231,19]],[[8,40,232,4],[79,40,232,75]],[[8,40,233,4],[79,40,233,75]],[[8,40,234,4],[51,40,234,47]],[[8,40,235,4],[14,40,235,10,1161],[39,40,236,6,1157],[57,40,236,24,1162],[64,40,236,24,1162],[77,40,236,37],[78,40,236,38,1163],[82,40,236,42],[86,40,237,6,1157],[104,40,237,24,1162],[111,40,237,24,1162],[124,40,237,37],[125,40,237,38,1164],[135,40,237,48]],[[8,40,239,4],[12,40,239,8],[13,40,239,9,1161],[37,40,239,33]],[[12,40,240,6],[85,40,240,79]],[[12,40,241,6],[77,40,241,71]],[[12,40,242,6],[29,40,242,23]],[[12,40,243,6],[14,40,243,8]],[[12,40,244,6],[55,40,244,49]],[[12,40,245,6],[68,40,245,62]],[[12,40,246,6],[18,40,246,12,1165],[41,40,246,36,1159],[58,40,246,70,1145],[64,40,246,76]],[[12,40,247,6],[18,40,247,12,1166],[39,40,247,33,1165],[60,40,247,54,1145],[66,40,247,60]],[[12,40,248,6],[18,40,248,12,1167],[36,40,248,40]],[[16,40,249,8,1144],[23,40,249,15,1159],[40,40,249,32,1144],[45,40,249,37]],[[16,40,250,8,1145],[24,40,250,16]],[[20,40,251,10,1144],[27,40,251,17,1147],[37,40,251,17,1147],[45,40,251,25]],[[20,40,252,10,1145],[28,40,252,18,1166]],[[16,40,253,8]],[[12,40,254,6]],[[12,40,255,6],[19,40,255,13,1167]],[[8,40,256,4]],[[4,40,257,2]],[[4,40,259,2],[80,40,259,78]],[[4,40,260,2],[11,40,260,9,1159]],[[0,40,261,0]],[[0,40,263,7],[9,40,263,16,1133],[46,40,264,2,1159],[62,40,264,32],[64,40,265,2,1168],[73,40,265,29]],[[4,40,267,2],[47,40,267,45]],[[4,40,268,2],[61,40,268,59]],[[4,40,269,2],[10,40,269,8,1165],[33,40,269,31,1159],[50,40,269,48,1145],[56,40,269,54]],[[4,40,270,2],[10,40,270,8,1169],[27,40,270,35]],[[8,40,271,4,1144],[15,40,271,11,1159],[32,40,271,28,1144],[37,40,271,33]],[[8,40,272,4,1145],[16,40,272,12]],[[12,40,273,6,1144],[19,40,273,13,1168]],[[12,40,274,6,1145],[20,40,274,14,1165],[41,40,274,35,1145],[47,40,274,41]],[[8,40,275,4]],[[4,40,276,2]],[[4,40,277,2],[11,40,277,9,1169]],[[0,40,278,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,41,0,0],[59,41,0,59]],[],[],[],[[31,41,19,16,1170],[49,41,19,16,1170]],[],[],[[15,41,19,16,1170]],[],[],[[0,41,19,7],[9,41,19,16,1170],[24,41,20,2,1171],[36,41,20,22],[38,41,21,2,1172],[45,41,21,24]],[[4,41,23,2],[10,41,23,8,1173],[24,41,23,22],[28,41,23,26,1174],[32,41,23,30,1171]],[[4,41,24,2],[10,41,24,8,1175],[21,41,24,19]],[[8,41,25,4,1176],[18,41,25,14,1173],[30,41,25,26,1176],[38,41,25,34]],[[8,41,26,4,1177],[16,41,26,12,1173],[28,41,26,24,1177],[34,41,26,30]],[[8,41,27,4,1172],[17,41,27,13,1172]],[[4,41,28,2]],[[4,41,29,2],[11,41,29,9,1175]],[[0,41,30,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,42,278,16,1178],[22,42,278,34],[24,42,278,34]],[[15,42,278,16,1178]],[],[[4,42,327,16,1179],[23,42,327,35],[25,42,327,35]],[[15,42,327,16,1179]],[],[[4,42,452,16,1180],[20,42,452,32],[22,42,452,32]],[[15,42,452,16,1180]],[],[[4,42,288,16,1181],[26,42,288,38],[28,42,288,38]],[[15,42,288,16,1181]],[],[[4,42,239,16,1182],[24,42,239,36],[26,42,239,36]],[[15,42,239,16,1182]],[],[[4,42,210,16,1183],[29,42,210,41],[31,42,210,41]],[[15,42,210,16,1183]],[],[],[[32,42,5,35]],[[31,42,6,29]],[[23,42,27,7]],[[26,42,28,67]],[[26,42,30,31]],[[23,42,35,7]],[[25,42,40,7]],[[0,42,43,0],[6,42,43,6,1184],[26,42,44,2],[33,42,44,9,1185],[52,42,44,28],[65,42,45,6,1185],[82,42,46,6],[83,42,46,7,1186],[88,42,47,8,1187],[96,42,47,16,1188],[103,42,47,23],[106,42,48,11,1189],[110,42,48,15],[111,42,48,16,1186],[115,42,49,11,1190],[120,42,49,16],[121,42,49,17],[122,42,49,18,1191],[130,42,50,12,1192],[141,42,50,23]],[[12,42,51,14],[18,42,51,20,1191]],[[8,42,52,12]],[[0,42,186,0],[6,42,186,6,1193],[17,42,186,38],[19,42,186,40]],[[0,42,188,0],[4,42,188,4,1194],[25,42,188,25]],[[0,42,190,0],[4,42,190,4,1195],[20,42,190,20]],[[0,42,191,0],[4,42,191,4,1196],[27,42,191,27]],[[0,42,193,0],[78,42,193,78]],[[0,42,194,0],[74,42,194,74]],[[0,42,195,0],[79,42,195,79]],[[0,42,196,0],[4,42,196,4,1197],[30,42,196,51]],[[0,42,198,0],[67,42,198,67]],[[0,42,199,0],[6,42,199,6,1198],[33,42,199,33]],[[0,42,201,0],[72,42,201,72]],[[0,42,202,0],[55,42,202,55]],[[0,42,203,0],[4,42,203,4,1199],[40,42,204,2]],[[0,42,210,7],[9,42,210,16,1183]],[[4,42,211,2],[71,42,211,69]],[[4,42,212,2],[27,42,212,25]],[[4,42,213,2],[8,42,213,6,1199],[46,42,213,44],[52,42,213,50]],[[8,42,214,4,1200],[21,42,214,17,1199]],[[4,42,215,2]],[[4,42,217,2],[55,42,217,53]],[[4,42,218,2,1199],[40,42,218,38,1192],[51,42,218,49]],[[8,42,219,4,1199],[44,42,219,40]],[[8,42,220,4],[70,42,220,66]],[[8,42,221,4,1201]],[[4,42,222,2],[7,42,222,5,1198]],[[0,42,223,0]],[[0,42,239,7],[9,42,239,16,1182],[30,42,240,2,1202],[33,42,240,20],[35,42,241,2,1203],[55,42,241,41],[57,42,242,2,1204],[70,42,242,42],[72,42,243,2,1205],[80,42,243,28],[82,42,244,2,1206],[94,42,244,35]],[[4,42,246,2],[32,42,246,30]],[[4,42,247,2],[10,42,247,8,1207],[17,42,247,29]],[[8,42,248,4,1202]],[[8,42,249,4,1203]],[[8,42,250,4,1208],[22,42,250,18,1209],[23,42,250,18,1209],[26,42,250,18,1209],[33,42,250,18,1209],[55,42,250,40]],[[8,42,251,4,1205]],[[8,42,252,4,1210],[13,42,252,9],[15,42,252,9]],[[8,42,253,4,1211],[27,42,253,23]],[[8,42,254,4,1212],[34,42,254,30]],[[8,42,255,4,1204]],[[8,42,256,4,1213],[16,42,256,12,1195]],[[8,42,257,4,1214],[20,42,257,16]],[[8,42,258,4,1206]],[[8,42,259,4,1215],[20,42,259,16],[21,42,259,17]],[[4,42,260,2]],[[4,42,262,2,1216],[33,42,262,31,1207]],[[4,42,264,2,1217],[13,42,264,11,1193],[23,42,264,21,1207]],[[4,42,266,2],[51,42,266,49]],[[4,42,267,2],[6,42,267,4]],[[4,42,268,2],[77,42,268,75]],[[4,42,269,2],[77,42,269,75]],[[4,42,270,2],[79,42,270,77]],[[4,42,271,2],[79,42,271,77]],[[4,42,272,2],[25,42,272,23]],[[4,42,273,2,1201]],[[4,42,275,2],[11,42,275,9,1207]],[[0,42,276,0]],[[0,42,278,7],[9,42,278,16,1178],[28,42,278,35,1207],[32,42,278,53]],[[4,42,279,2],[78,42,279,76]],[[4,42,280,2],[28,42,280,26]],[[4,42,281,2],[6,42,281,4]],[[4,42,282,2],[79,42,282,77]],[[4,42,283,2],[76,42,283,74]],[[4,42,284,2,1207],[9,42,284,7,1214],[19,42,284,17],[22,42,284,20]],[[4,42,285,2,1218],[15,42,285,13,1193],[25,42,285,23,1207]],[[0,42,286,0]],[[0,42,288,7],[9,42,288,16,1181],[32,42,289,2,1207],[36,42,289,20],[38,42,290,2,1203],[58,42,290,41],[60,42,291,2,1204],[73,42,291,42],[75,42,292,2,1205],[83,42,292,28]],[[4,42,294,2],[76,42,294,74]],[[4,42,295,2],[78,42,295,76]],[[4,42,296,2],[55,42,296,53]],[[4,42,297,2],[6,42,297,4]],[[4,42,298,2],[74,42,298,72]],[[4,42,299,2],[25,42,299,23]],[[4,42,301,2],[62,42,301,60]],[[4,42,302,2,1207],[9,42,302,7,1214],[19,42,302,17],[22,42,302,20]],[[4,42,303,2,1207],[9,42,303,7,1210],[14,42,303,12],[17,42,303,12]],[[4,42,305,2],[75,42,305,73]],[[4,42,306,2],[61,42,306,59]],[[4,42,307,2,1207],[9,42,307,7,1213],[15,42,307,13],[18,42,307,16,1195]],[[4,42,308,2,1207],[9,42,308,7,1205],[17,42,308,15],[20,42,309,4],[20,42,310,4],[82,42,310,66],[83,42,309,67]],[[4,42,311,4,1207],[13,42,311,13,1197],[39,42,311,39,1219],[46,42,311,39,1219],[62,42,311,55],[63,42,311,56,1220],[69,42,311,62],[72,42,311,65,1205]],[[4,42,313,2,1207],[9,42,313,7,1203],[29,42,313,27],[32,42,313,30,1203]],[[4,42,314,2,1207],[9,42,314,7,1204],[22,42,314,20],[25,42,314,23,1204]],[[4,42,316,2,1216],[33,42,316,31,1207]],[[4,42,318,2],[8,42,318,6,1207],[13,42,318,11,1215],[23,42,318,21],[28,42,318,26],[29,42,318,27],[32,42,318,30]],[[8,42,319,4],[44,42,319,40]],[[8,42,320,4,1221],[19,42,320,15,1193],[29,42,320,25,1207]],[[4,42,321,2],[11,42,321,9]],[[8,42,322,4,1217],[17,42,322,13,1193],[27,42,322,23,1207]],[[4,42,323,2]],[[4,42,324,2,1201]],[[0,42,325,0]],[[0,42,327,7],[9,42,327,16,1179],[29,42,328,2,1207],[33,42,328,20],[35,42,329,2,1222],[42,42,329,24],[44,42,330,2,1223],[48,42,330,25]],[[4,42,332,2],[75,42,332,73]],[[4,42,333,2],[75,42,333,73]],[[4,42,334,2],[79,42,334,77]],[[4,42,335,2],[75,42,335,73]],[[4,42,336,2],[31,42,336,29]],[[4,42,337,2],[10,42,337,8,1224],[32,42,337,30,1209],[33,42,337,30,1209],[36,42,337,30,1209],[43,42,337,30,1209],[65,42,337,52]],[[4,42,338,2],[11,42,339,4,1207],[16,42,339,9,1208],[28,42,339,21],[33,42,339,26,1224],[56,42,340,4,1207],[61,42,340,9,1203],[81,42,340,29],[86,42,340,34,1223],[94,42,341,4,1207],[99,42,341,9,1202],[102,42,341,12],[103,42,341,13,1222],[110,42,341,20],[115,42,341,25,1222]],[[0,42,343,0]],[[0,42,345,0],[9,42,345,9,1216],[38,42,345,38,1207],[42,42,345,56]],[[4,42,346,2],[79,42,346,77]],[[4,42,347,2],[75,42,347,73]],[[4,42,348,2],[8,42,349,4,1207],[13,42,349,9,1205],[21,42,349,17],[26,42,349,22,1219],[33,42,349,22,1219],[49,42,349,38],[50,42,349,39,1220],[56,42,349,45],[60,42,350,4,1207],[69,42,350,13,1197],[94,42,351,4]],[[8,42,352,4],[12,42,352,8,1197],[40,42,352,36],[46,42,352,42]],[[12,42,353,6],[75,42,353,69]],[[12,42,354,6],[16,42,354,10,1197],[40,42,354,34,1205],[48,42,354,42],[53,42,354,47,1219],[60,42,354,47,1219],[76,42,354,63],[77,42,354,64,1225],[87,42,354,74],[89,42,354,76]],[[16,42,355,8,1197],[40,42,355,32,1205],[48,42,355,40],[51,42,355,43,1219],[58,42,355,43,1219],[74,42,355,59],[75,42,355,60,1226],[82,42,355,67]],[[16,42,356,8,1221],[27,42,356,19,1193],[37,42,356,29,1197]],[[12,42,357,6]],[[8,42,358,4]],[[8,42,359,4,1197],[34,42,359,30,1207]],[[4,42,360,2]],[[0,42,361,0]],[[0,42,363,0],[9,42,363,9,1201]],[[4,42,364,2],[8,42,364,6,1196],[30,42,364,28]],[[8,42,365,4],[56,42,365,52]],[[8,42,366,4]],[[4,42,367,2]],[[4,42,368,2,1196],[27,42,368,25]],[[4,42,369,2,1184],[22,42,369,20,1227]],[[0,42,370,0]],[[0,42,372,0]],[],[],[],[],[],[],[],[[1,42,380,1],[4,42,381,0],[13,42,381,9,1228],[33,42,381,29,1207],[37,42,381,47]],[[4,42,382,2],[61,42,382,59]],[[4,42,383,2],[8,42,383,6,1199],[46,42,383,44],[52,42,383,50]],[[8,42,384,4],[81,42,384,77]],[[8,42,385,4],[83,42,385,79]],[[8,42,386,4],[30,42,386,26]],[[8,42,387,4],[15,42,387,11]],[[4,42,388,2]],[[4,42,390,2],[77,42,390,75]],[[4,42,391,2],[76,42,391,74]],[[4,42,392,2],[79,42,392,77]],[[4,42,393,2],[26,42,393,24]],[[4,42,395,2],[79,42,395,77]],[[4,42,397,2],[8,42,397,6,1207],[13,42,397,11,1205],[21,42,397,19],[26,42,397,24,1219],[33,42,397,24,1219],[49,42,397,40],[50,42,397,41,1220],[56,42,397,47],[58,42,397,49]],[[8,42,398,4],[81,42,398,77]],[[8,42,399,4],[10,42,399,6]],[[8,42,400,4],[78,42,400,74]],[[8,42,401,4],[45,42,401,41]],[[8,42,402,4],[10,42,402,6]],[[8,42,403,4],[84,42,403,80]],[[8,42,404,4],[82,42,404,78]],[[8,42,405,4],[73,42,405,69]],[[8,42,406,4],[15,42,406,11,1194],[36,42,406,32]],[[4,42,407,2]],[[4,42,409,2],[68,42,409,66]],[[4,42,410,2],[11,42,410,9,1194],[32,42,410,30]],[[0,42,411,0]],[[0,42,413,0],[9,42,413,9,1229],[30,42,414,2,1230],[45,42,414,59]],[[4,42,416,2],[74,42,416,72]],[[4,42,417,2],[78,42,417,76]],[[4,42,418,2],[39,42,418,37]],[[4,42,419,2],[6,42,419,4]],[[4,42,420,2],[76,42,420,74]],[[4,42,421,2],[79,42,421,77]],[[4,42,422,2],[77,42,422,75]],[[4,42,423,2],[79,42,423,77]],[[4,42,424,2],[54,42,424,52]],[[4,42,425,2,1194]],[[4,42,426,2],[11,42,426,9,1230],[27,42,426,25,1189],[31,42,426,29],[32,42,426,30],[33,42,426,31,1231]],[[8,42,427,4],[12,42,427,8,1231],[23,42,427,19],[29,42,427,25]],[[12,42,428,6],[77,42,428,71]],[[12,42,429,6],[63,42,429,57]],[[12,42,430,6,1232]],[[12,42,431,6],[19,42,431,13]],[[8,42,432,4]],[[8,42,433,4],[77,42,433,73]],[[8,42,434,4,1231],[15,42,434,11,1233],[21,42,434,17],[22,42,434,18,1189],[26,42,434,22],[27,42,434,23,1232]],[[8,42,435,4],[15,42,435,11,1231],[22,42,435,18,1234],[27,42,435,23]],[[4,42,436,2]],[[0,42,437,0]],[[0,42,439,0],[9,42,439,9,1232]],[[4,42,440,2,1194]],[[4,42,442,2],[73,42,442,71]],[[4,42,443,2],[24,42,443,22]],[[4,42,444,2,1201]],[[0,42,445,0]],[[0,42,452,7],[9,42,452,16,1180],[26,42,452,33,1207],[30,42,452,51]],[[4,42,453,2],[77,42,453,75]],[[4,42,454,2],[8,42,455,4],[8,42,456,4,1207],[13,42,456,9,1214],[23,42,456,19],[27,42,457,4],[42,42,455,38],[66,42,457,43]],[[4,42,458,4,1207],[9,42,458,9,1215],[19,42,458,19],[24,42,458,24],[25,42,458,25],[28,42,459,4]],[[8,42,460,4]],[[4,42,461,2]],[[4,42,462,2],[38,42,462,36]],[[4,42,463,2,1217],[13,42,463,11,1193],[23,42,463,21,1207]],[[4,42,464,2,1201]],[[0,42,465,0]],[[0,42,467,0],[9,42,467,9,1227]],[[4,42,468,2,1196],[27,42,468,25]],[[4,42,470,2],[78,42,470,76]],[[4,42,471,2],[80,42,471,78]],[[4,42,472,2],[60,42,472,58]],[[4,42,473,2],[10,42,473,8,1235],[16,42,473,14,1236],[21,42,473,19,1235],[24,42,473,22]],[[4,42,475,2],[68,42,475,66]],[[4,42,476,2],[8,42,476,6,1207],[15,42,476,13,1237],[24,42,476,22,1193]],[[4,42,477,2],[10,42,477,9,1207],[19,42,477,18],[27,42,477,26,1228],[47,42,477,46,1207],[53,42,477,53]],[[8,42,478,4,1207],[13,42,478,9,1208],[25,42,478,21],[28,42,478,24,1209],[29,42,478,24,1209],[32,42,478,24,1209],[39,42,478,24,1209],[61,42,478,46]],[[8,42,480,4],[14,42,480,10,1238],[27,42,480,23,1239],[37,42,480,33,1235],[42,42,480,38,1207]],[[8,42,482,4],[82,42,482,78]],[[8,42,483,4],[39,42,483,35]],[[8,42,484,4],[14,42,484,10,1211],[34,42,484,30,1207],[39,42,484,35,1211],[56,42,484,52]],[[8,42,485,4,1207],[13,42,485,9,1211],[30,42,485,26],[33,42,485,29]],[[8,42,486,4,1207],[13,42,486,9,1212],[37,42,486,33],[40,42,486,36]],[[8,42,488,4],[15,42,488,12,1238]],[[12,42,489,6],[17,42,489,6]],[[16,42,490,8],[84,42,490,76]],[[16,42,491,8],[70,42,491,62]],[[16,42,492,8]],[[12,42,493,6],[17,42,493,6]],[[16,42,494,8],[81,42,494,73]],[[16,42,495,8],[76,42,495,68]],[[16,42,496,8,1240],[24,42,496,16,1193]],[[16,42,497,8],[44,42,497,36]],[[16,42,498,8,1207],[23,42,498,15,1237],[32,42,498,24,1193]],[[16,42,499,8]],[[12,42,500,6],[17,42,500,6]],[[16,42,501,8],[20,42,501,12,1207],[25,42,501,17,1210],[30,42,501,22],[35,42,501,22],[38,42,501,52]],[[20,42,502,10],[82,42,502,72]],[[20,42,503,10],[36,42,503,26]],[[20,42,504,10,1207],[25,42,504,15,1210],[30,42,504,20],[33,42,504,20]],[[20,42,505,10,1221],[31,42,505,21,1193],[41,42,505,31,1207]],[[16,42,506,8],[23,42,506,15],[27,42,506,19,1211],[46,42,506,38]],[[20,42,507,10],[87,42,507,77]],[[20,42,508,10],[46,42,508,36]],[[20,42,509,10,1207],[25,42,509,15,1205],[33,42,509,23],[36,42,509,26,1219],[43,42,509,26,1219],[59,42,509,42],[60,42,509,43,1225],[70,42,509,53]],[[20,42,510,10,1221],[31,42,510,21,1193],[41,42,510,31,1207]],[[16,42,511,8],[23,42,511,15]],[[20,42,512,10],[75,42,512,65]],[[20,42,513,10,1240],[28,42,513,18,1193]],[[16,42,514,8]],[[16,42,515,8,1207],[23,42,515,15,1237],[32,42,515,24,1193]],[[16,42,516,8]],[[12,42,517,6]],[[16,42,518,8,1238]],[[8,42,519,4]],[[4,42,520,2]],[[0,42,521,0]],[[0,42,523,0]],[],[],[],[],[],[],[],[],[[1,42,532,1],[4,42,533,0],[13,42,533,9,1241],[24,42,533,20,1207],[28,42,533,38]],[[4,42,534,2],[8,42,534,6,1207],[13,42,534,11,1205],[21,42,534,19],[26,42,534,24,1219],[33,42,534,24,1219],[49,42,534,40],[50,42,534,41,1225],[60,42,534,51],[62,42,534,53]],[[8,42,535,4],[15,42,535,11]],[[4,42,536,2]],[[4,42,537,2,1207],[9,42,537,7,1211],[26,42,537,24],[29,42,537,27]],[[4,42,538,2],[11,42,538,9]],[[0,42,539,0]],[[0,42,541,0],[9,42,541,9,1239],[19,42,541,19,1235],[22,42,541,30],[24,42,541,32,1207],[28,42,541,50]],[[4,42,542,2],[10,42,542,8,1202],[16,42,542,14,1207],[21,42,542,19,1202],[24,42,542,22]],[[4,42,543,2],[10,42,543,8,1242],[18,42,543,16,1243],[19,42,543,16,1243],[22,42,543,16,1243],[29,42,543,16,1243],[56,42,543,43],[58,42,543,44,1235],[63,42,543,49,1207],[69,42,543,55,1202]],[[4,42,544,2],[10,42,544,8,1238],[23,42,544,21,1244],[41,42,544,39,1235],[46,42,544,44,1207],[52,42,544,50,1242]],[[4,42,546,2],[8,42,546,6,1238],[23,42,546,6,1238],[28,42,546,58,1202],[32,42,546,62,1245],[38,42,546,68],[43,42,546,73],[47,42,546,77]],[[8,42,547,4],[79,42,547,75]],[[8,42,548,4],[84,42,548,80]],[[8,42,549,4],[80,42,549,76]],[[8,42,550,4],[10,42,550,6]],[[8,42,551,4],[80,42,551,76]],[[8,42,552,4],[22,42,552,18]],[[8,42,553,4],[10,42,553,6]],[[8,42,554,4],[84,42,554,80]],[[8,42,555,4],[75,42,555,71]],[[8,42,556,4],[79,42,556,75]],[[8,42,557,4],[67,42,557,63]],[[8,42,558,4],[14,42,558,10,1246],[20,42,558,16],[24,42,558,20,1247],[28,42,558,24,1202],[32,42,558,28,1248],[40,42,558,36],[42,42,558,38,1249],[51,42,558,47,1250],[57,42,558,53]],[[8,42,559,4],[14,42,559,10,1251],[33,42,559,29,1252],[34,42,559,29,1252],[37,42,559,29,1252],[47,42,559,29,1252],[61,42,559,43],[63,42,559,44,1246],[67,42,559,48,1253],[71,42,559,52],[73,42,559,54,1202],[77,42,559,58,1222],[84,42,559,65]],[[8,42,560,4],[14,42,560,10,1254],[35,42,560,31,1243],[36,42,560,31,1243],[39,42,560,31,1243],[46,42,560,31,1243],[73,42,560,58],[75,42,561,6,1235],[80,42,562,6,1207],[86,42,563,6,1251]],[[8,42,565,4],[15,42,565,12,1254],[34,42,565,31,1255],[40,42,565,37]],[[12,42,566,6],[17,42,566,11,1256],[24,42,566,11,1256],[35,42,566,22],[36,42,566,23,1257],[41,42,566,28]],[[16,42,566,30]],[[20,42,567,8],[24,42,567,12,1241],[35,42,567,23,1207],[42,42,567,30]],[[24,42,568,10,1254],[43,42,568,29,1255],[49,42,568,35],[52,42,568,38,1256],[59,42,568,38,1256],[70,42,568,49],[71,42,568,50,1258],[78,42,568,57]],[[24,42,569,10,1229],[45,42,570,12,1259],[46,42,570,12,1259],[49,42,570,12,1259],[56,42,570,12,1259],[77,42,570,33],[79,42,570,34,1254],[99,42,570,54,1207],[105,42,570,60,1251]],[[20,42,572,8]],[[20,42,573,8]],[[16,42,574,6]],[[12,42,575,6],[17,42,575,11,1256],[24,42,575,11,1256],[35,42,575,22],[36,42,575,23,1258],[43,42,575,30]],[[12,42,576,6],[17,42,576,11,1256],[24,42,576,11,1256],[35,42,576,22],[36,42,576,23,1260],[45,42,576,32]],[[12,42,577,6],[17,42,577,11,1256],[24,42,577,11,1256],[35,42,577,22],[36,42,577,23,1261],[44,42,577,31]],[[16,42,577,33]],[[20,42,581,8]],[[16,42,582,6]],[[12,42,583,6]],[[16,42,584,8,1254]],[[8,42,585,4]],[[4,42,586,2]],[[4,42,588,2],[11,42,588,9,1238]],[[0,42,589,0]],[[0,42,591,0],[9,42,591,9,1244],[27,42,592,2,1235],[30,42,592,13],[32,42,593,2,1207],[36,42,593,20],[38,42,594,2,1242],[43,42,594,24]],[[4,42,596,2],[11,42,596,10,1242],[17,42,596,16,1255],[23,42,596,22]],[[8,42,597,4],[13,42,597,9,1256],[20,42,597,9,1256],[31,42,597,20],[32,42,597,21,1257],[37,42,597,26]],[[12,42,597,28]],[[16,42,598,6],[87,42,598,77]],[[16,42,599,6],[86,42,599,76]],[[16,42,600,6],[40,42,600,30]],[[16,42,602,6],[88,42,602,78]],[[16,42,603,6],[87,42,603,77]],[[16,42,604,6],[36,42,604,26]],[[16,42,605,6],[18,42,605,8]],[[16,42,606,6],[56,42,606,46]],[[16,42,607,6],[65,42,607,55]],[[16,42,608,6],[70,42,608,60]],[[16,42,609,6],[88,42,609,78]],[[16,42,610,6],[18,42,610,8]],[[16,42,611,6],[52,42,611,42]],[[16,42,612,6,1229],[37,42,612,27,1259],[38,42,612,27,1259],[41,42,612,27,1259],[48,42,612,27,1259],[69,42,612,48],[71,42,612,49,1242],[78,42,612,56,1207],[84,42,612,62,1207],[89,42,612,67,1202],[92,42,612,70]],[[16,42,614,6],[89,42,614,79]],[[16,42,615,6],[88,42,615,78]],[[16,42,616,6],[90,42,616,80]],[[16,42,617,6],[35,42,617,25]],[[16,42,618,6],[90,42,618,80]],[[16,42,619,6],[36,42,619,26]],[[16,42,620,6,1242],[22,42,620,12,1262],[29,42,620,19],[32,42,620,22,1235],[38,42,620,28],[43,42,620,33]],[[16,42,622,6],[86,42,622,76]],[[16,42,623,6,1242],[22,42,623,12,1255],[28,42,623,18],[31,42,623,21,1256],[38,42,623,21,1256],[49,42,623,32],[50,42,623,33,1258],[57,42,623,40]],[[12,42,625,6],[60,42,625,54]],[[12,42,626,4]],[[8,42,627,4],[13,42,627,9,1256],[20,42,627,9,1256],[31,42,627,20],[32,42,627,21,1258],[39,42,627,28]],[[12,42,627,30]],[[16,42,628,6],[89,42,628,79]],[[16,42,629,6],[87,42,629,77]],[[16,42,630,6],[60,42,630,50]],[[16,42,631,6],[22,42,631,12,1263],[37,42,631,27,1242],[43,42,631,33,1263],[55,42,631,45]],[[16,42,632,6],[20,42,632,10,1263],[37,42,632,27],[43,42,632,33]],[[20,42,633,8,1242],[26,42,633,14,1263],[38,42,633,26],[41,42,633,29],[45,42,633,33,1264],[49,42,633,37]],[[24,42,633,38,1207]],[[21,42,633,43]],[[16,42,634,6],[23,42,634,13]],[[20,42,635,8,1263],[33,42,635,21,1265],[36,42,635,24],[37,42,635,25,1207]],[[16,42,636,6]],[[16,42,637,6],[23,42,637,6]],[[12,42,638,4]],[[8,42,639,4],[13,42,639,9,1256],[20,42,639,9,1256],[31,42,639,20],[32,42,639,21,1261],[40,42,639,29]],[[12,42,639,31]],[[16,42,640,6],[61,42,640,51]],[[16,42,641,6],[23,42,641,6]],[[12,42,642,4]],[[8,42,643,4],[13,42,643,9,1256],[20,42,643,9,1256],[31,42,643,20],[32,42,643,21,1260],[41,42,643,30]],[[12,42,643,32]],[[16,42,644,6],[20,42,644,10,1207],[25,42,644,15,1210],[30,42,644,20],[35,42,644,20],[38,42,644,49]],[[20,42,645,8],[90,42,645,78]],[[20,42,646,8],[27,42,646,8]],[[16,42,647,6]],[[16,42,648,6],[56,42,648,46]],[[16,42,649,6],[20,42,649,10],[21,42,649,11,1228],[41,42,649,31,1207],[48,42,649,38]],[[20,42,650,8],[78,42,650,66]],[[20,42,651,8],[27,42,651,8]],[[16,42,652,6]],[[16,42,653,6],[22,42,653,12,1223],[29,42,653,19,1242],[35,42,653,25,1223],[39,42,653,29]],[[16,42,655,6],[85,42,655,75]],[[16,42,656,6],[111,42,656,101]],[[16,42,657,6],[103,42,657,93]],[[16,42,658,6],[63,42,658,53]],[[16,42,659,6],[22,42,659,12,1204],[38,42,660,8,1207],[43,42,660,13,1204],[56,42,660,26],[61,42,660,31,1266],[68,42,660,31,1266],[81,42,660,44],[82,42,660,45,1267],[85,42,660,48],[88,42,661,12,1242],[94,42,661,18,1268],[106,42,661,30],[109,42,662,14,1266],[116,42,662,14,1266],[129,42,662,27],[130,42,662,28,1267],[133,42,662,31],[136,42,663,14,1266],[143,42,663,14,1266],[156,42,663,27],[157,42,663,28,1269],[172,42,663,43],[175,42,664,12,1207],[180,42,664,17,1204],[193,42,664,30]],[[16,42,666,6],[23,42,666,14,1204]],[[20,42,667,8],[25,42,667,13,1266],[32,42,667,13,1266],[45,42,667,26],[46,42,667,27,1267],[49,42,667,30]],[[24,42,667,32]],[[28,42,668,10],[89,42,668,71]],[[28,42,669,10],[86,42,669,68]],[[28,42,670,10],[96,42,670,78]],[[28,42,671,10],[87,42,671,69]],[[28,42,672,10],[30,42,672,12]],[[28,42,673,10],[91,42,673,73]],[[28,42,674,10],[77,42,674,59]],[[28,42,675,10,1270],[43,42,675,25,1235],[48,42,675,30,1207],[54,42,675,36,1242]],[[28,42,676,10],[34,42,676,16,1238],[47,42,676,29,1271],[83,42,677,12,1235],[88,42,678,12,1207],[94,42,679,12,1242],[101,42,680,12,1207],[106,42,680,17,1203],[126,42,680,37],[128,42,681,12,1223]],[[28,42,683,10],[32,42,683,14,1238],[47,42,683,14,1238],[50,42,683,64]],[[32,42,684,12],[67,42,684,47]],[[32,42,685,12],[39,42,685,12]],[[28,42,686,10]],[[28,42,687,10],[34,42,687,16,1212],[61,42,687,43,1207],[66,42,687,48,1212],[90,42,687,72]],[[28,42,688,10],[32,42,688,14,1212],[61,42,688,43],[67,42,688,49]],[[32,42,689,12],[95,42,689,75]],[[32,42,690,12],[98,42,690,78]],[[32,42,691,12],[38,42,691,18,1272],[55,42,691,35],[59,42,691,39,1273]],[[32,42,695,12,1274],[48,42,696,14,1235],[53,42,697,14,1207],[59,42,698,14,1242],[66,42,699,14,1272],[82,42,700,14,1266],[89,42,700,14,1266],[102,42,700,27],[103,42,700,28,1275],[113,42,700,38]],[[32,42,702,12],[38,42,702,18,1276],[52,42,702,32,1277],[74,42,703,14,1235],[79,42,704,14,1207],[85,42,705,14,1242],[92,42,706,14,1223],[98,42,707,14,1212],[124,42,708,14,1272]],[[32,42,710,12],[36,42,710,16,1278],[58,42,710,38,1272],[73,42,710,53,1279],[77,42,710,57],[80,42,710,60]],[[32,42,711,12],[36,42,711,16,1278],[57,42,711,37]],[[36,42,712,14],[101,42,712,79]],[[36,42,713,14],[50,42,713,28]],[[36,42,714,14,1229],[57,42,715,16,1280],[58,42,715,16,1280],[61,42,715,16,1280],[68,42,715,16,1280],[109,42,715,57],[111,42,716,18,1207],[117,42,717,18,1242],[124,42,718,18,1266],[131,42,718,18,1266],[144,42,718,31],[145,42,718,32,1275],[155,42,718,42],[157,42,719,18,1276],[170,42,720,18,1272]],[[32,42,723,12]],[[28,42,724,10]],[[28,42,725,10],[35,42,725,10]],[[24,42,726,8]],[[20,42,727,8],[25,42,727,13,1266],[32,42,727,13,1266],[45,42,727,26],[46,42,727,27,1281],[50,42,727,31]],[[20,42,728,8],[25,42,728,13,1266],[32,42,728,13,1266],[45,42,728,26],[46,42,728,27,1275],[56,42,728,37]],[[20,42,729,8],[25,42,729,13,1266],[32,42,729,13,1266],[45,42,729,26],[46,42,729,27,1269],[61,42,729,42]],[[24,42,729,44]],[[28,42,730,10],[89,42,730,71]],[[28,42,731,10],[97,42,731,79]],[[28,42,732,10],[97,42,732,79]],[[28,42,733,10],[98,42,733,80]],[[28,42,734,10],[96,42,734,78]],[[28,42,735,10],[96,42,735,78]],[[28,42,736,10],[47,42,736,29]],[[28,42,737,10],[34,42,737,16,1272],[51,42,737,33],[55,42,737,37,1273]],[[28,42,741,10,1274],[44,42,741,26,1235],[49,42,741,31,1207],[55,42,741,37,1242],[62,42,741,44,1272],[78,42,741,60,1204]],[[28,42,742,10],[34,42,742,16,1282],[55,42,742,37,1283],[83,42,743,12,1235],[88,42,744,12,1207],[94,42,745,12,1242],[101,42,746,12,1207],[106,42,746,17,1203],[126,42,746,37],[128,42,747,12,1223],[134,42,748,12,1272],[150,42,749,12,1204]],[[28,42,751,10],[32,42,751,14,1278],[54,42,751,36,1272],[69,42,751,51,1279],[73,42,751,55],[76,42,751,58]],[[28,42,752,10],[32,42,752,14,1278],[53,42,752,35]],[[32,42,753,12,1229],[53,42,754,14,1280],[54,42,754,14,1280],[57,42,754,14,1280],[64,42,754,14,1280],[105,42,754,55],[107,42,755,16,1207],[113,42,756,16,1242],[120,42,757,16,1204],[135,42,758,16,1282],[155,42,759,16,1272]],[[28,42,762,10]],[[28,42,763,10],[35,42,763,10]],[[24,42,764,8]],[[20,42,765,8]],[[24,42,766,10,1204]],[[16,42,767,6]],[[16,42,768,6]],[[12,42,769,4]],[[8,42,770,4]],[[12,42,770,13]],[[16,42,771,6,1242]],[[12,42,772,4]],[[4,42,773,2]],[[4,42,774,2],[11,42,774,2]],[[0,42,775,0]],[[0,42,777,0],[9,42,777,9,1270],[24,42,778,2,1235],[27,42,778,13],[29,42,779,2,1207],[33,42,779,20],[35,42,780,2,1242],[40,42,780,33]],[[4,42,782,2],[74,42,782,72]],[[4,42,783,2],[77,42,783,75]],[[4,42,784,2],[64,42,784,62]],[[4,42,785,2,1284],[26,42,786,4,1235],[31,42,787,4,1207],[37,42,788,4,1242],[44,42,789,4,1285],[45,42,789,4,1285],[48,42,789,4,1285],[55,42,789,4,1285],[84,42,789,33],[86,42,790,6,1235],[91,42,791,6,1266],[98,42,791,6,1266],[111,42,791,19],[112,42,791,20,1267],[115,42,791,23],[117,42,792,6,1242],[124,42,793,6,1242],[130,42,793,12,1286],[138,42,793,20],[141,42,795,4,1207],[146,42,795,9,1202],[149,42,795,12],[151,42,796,4,1242],[157,42,796,10,1286],[165,42,796,18]],[[0,42,798,0]],[[0,42,800,0],[9,42,800,9,1274],[25,42,801,2,1235],[28,42,801,13],[30,42,802,2,1207],[34,42,802,20],[36,42,803,2,1242],[41,42,803,33],[43,42,804,2,1272],[57,42,804,66],[59,42,805,2,1204],[72,42,808,35]],[[4,42,810,2,1287],[39,42,811,4,1235],[44,42,812,4,1207],[50,42,813,4,1242],[57,42,814,4,1242],[63,42,814,10,1286],[71,42,814,18],[73,42,815,4],[80,42,816,4,1272],[96,42,817,4],[96,42,818,4],[118,42,818,26],[160,42,817,68]],[[4,42,819,4,1204],[22,42,819,22,1266],[29,42,819,22,1266],[42,42,819,35],[43,42,819,36,1269],[58,42,819,51],[61,42,820,8,1266],[68,42,820,8,1266],[81,42,820,21],[82,42,820,22,1281],[86,42,820,26],[89,42,821,8,1204]],[[0,42,823,0]],[[0,42,825,0],[57,42,825,57]],[[0,42,827,0],[9,42,827,9,1271],[45,42,828,2,1235],[48,42,828,13],[50,42,829,2,1207],[54,42,829,20],[56,42,830,2,1242],[61,42,830,33],[63,42,831,2,1288],[70,42,831,28],[72,42,832,2,1289],[79,42,832,20]],[[4,42,834,2],[81,42,834,79]],[[4,42,835,2],[81,42,835,79]],[[4,42,836,2],[78,42,836,76]],[[4,42,837,2],[78,42,837,76]],[[4,42,838,2],[71,42,838,69]],[[4,42,839,2],[56,42,839,54]],[[4,42,840,2],[6,42,840,4]],[[4,42,841,2],[79,42,841,77]],[[4,42,842,2],[66,42,842,64]],[[4,42,843,2],[40,42,843,38]],[[4,42,845,2],[43,42,845,41]],[[4,42,846,2],[10,42,846,8,1290],[20,42,846,18,1285],[21,42,846,18,1285],[24,42,846,18,1285],[31,42,846,18,1285],[60,42,846,47],[62,42,847,4,1235],[67,42,848,4,1207],[72,42,848,9,1204],[85,42,848,22],[87,42,849,4,1242],[94,42,850,4,1289]],[[4,42,852,2,1284],[26,42,852,24,1235],[31,42,852,29,1207],[37,42,852,35,1242],[44,42,852,42,1290],[53,42,852,51,1207],[58,42,852,56,1202],[61,42,852,59],[63,42,852,61,1289]],[[4,42,854,2],[37,42,854,35]],[[4,42,855,2],[10,42,855,8,1291],[28,42,855,26,1288],[35,42,855,33],[36,42,855,34],[38,42,855,36]],[[4,42,856,2],[10,42,856,8,1292],[28,42,856,26,1289],[36,42,856,34,1293],[41,42,856,39]],[[4,42,857,2],[8,42,857,6,1292],[28,42,857,26],[34,42,857,32]],[[8,42,858,4],[12,42,858,9],[18,42,858,15,1294],[38,42,858,35,1292],[54,42,858,52]],[[12,42,859,6],[16,42,859,10],[17,42,859,11,1228],[37,42,859,31,1207],[44,42,859,38]],[[16,42,860,8],[74,42,860,66]],[[16,42,861,8],[23,42,861,8]],[[12,42,862,6]],[[12,42,863,6],[18,42,863,12,1295],[33,42,863,27,1292],[48,42,863,42],[49,42,863,43,1294],[66,42,863,60]],[[12,42,864,6],[18,42,864,12,1296],[40,42,864,34,1295],[53,42,864,47,1290],[60,42,864,54]],[[12,42,865,6],[18,42,865,12,1297],[33,42,866,8,1291],[48,42,866,23],[49,42,866,24,1294],[66,42,866,41]],[[12,42,867,6],[18,42,867,12,1298],[40,42,868,8,1297],[54,42,868,22],[55,42,868,23],[57,42,868,25]],[[12,42,869,6],[16,42,869,10,1299]],[[12,42,870,6],[16,42,871,8,1298],[40,42,871,32,1300],[53,42,872,8,1301],[90,42,873,10,1242],[97,42,874,10,1296],[118,42,875,10,1298],[140,42,877,8]],[[16,42,878,8],[64,42,878,56]],[[16,42,879,8,1299],[34,42,879,26,1271],[70,42,880,10,1235],[75,42,881,10,1207],[81,42,882,10,1242],[88,42,883,10,1297],[102,42,884,10,1295]],[[12,42,886,6],[19,42,886,13]],[[16,42,887,8],[67,42,887,59]],[[16,42,888,8],[39,42,888,31]],[[16,42,889,8,1299],[34,42,889,26,1302],[67,42,890,10,1235],[72,42,891,10,1207],[78,42,892,10,1242],[85,42,893,10,1295]],[[12,42,895,6]],[[12,42,896,6],[16,42,896,10,1299],[36,42,896,10,1299],[39,42,896,65]],[[16,42,897,8],[51,42,897,43]],[[16,42,898,8],[23,42,898,8]],[[12,42,899,6]],[[8,42,900,4]],[[4,42,901,2]],[[4,42,903,2],[11,42,903,2]],[[0,42,904,0]],[[0,42,906,0],[9,42,906,9,1302],[42,42,907,2,1235],[45,42,907,13],[47,42,908,2,1207],[51,42,908,20],[53,42,909,2,1242],[58,42,909,33],[60,42,910,2,1223],[64,42,910,17]],[[4,42,912,2],[81,42,912,79]],[[4,42,913,2],[72,42,913,70]],[[4,42,914,2],[80,42,914,78]],[[4,42,915,2],[73,42,915,71]],[[4,42,916,2],[69,42,916,67]],[[4,42,917,2],[8,42,917,6,1223],[13,42,917,11,1303],[31,42,917,29],[33,42,917,31]],[[8,42,918,4],[83,42,918,79]],[[8,42,919,4],[82,42,919,78]],[[8,42,920,4],[83,42,920,79]],[[8,42,921,4],[80,42,921,76]],[[8,42,922,4],[81,42,922,77]],[[8,42,923,4],[83,42,923,79]],[[8,42,924,4],[82,42,924,78]],[[8,42,925,4],[34,42,925,30]],[[8,42,926,4],[10,42,926,6]],[[8,42,927,4],[72,42,927,68]],[[8,42,928,4],[81,42,928,77]],[[8,42,929,4],[77,42,929,73]],[[8,42,930,4],[83,42,930,79]],[[8,42,931,4],[72,42,931,68]],[[8,42,932,4],[25,42,932,21]],[[8,42,933,4],[10,42,933,6]],[[8,42,934,4],[84,42,934,80]],[[8,42,935,4],[78,42,935,74]],[[8,42,936,4],[48,42,936,44]],[[8,42,937,4],[12,42,937,8,1207],[17,42,937,13,1212],[41,42,937,37],[46,42,937,42],[52,42,937,48]],[[12,42,938,6,1207],[17,42,938,11,1212],[41,42,938,35],[44,42,938,38],[48,42,938,42,1264],[52,42,938,46]],[[16,42,938,47,1223],[21,42,938,52,1304],[31,42,938,62]],[[13,42,938,63]],[[8,42,939,4],[15,42,939,11]],[[12,42,940,6,1207],[17,42,940,11,1212],[41,42,940,35],[42,42,940,36,1265],[45,42,940,39],[46,42,940,40,1223],[51,42,940,45,1304],[61,42,940,55]],[[8,42,941,4]],[[8,42,942,4],[72,42,942,68]],[[8,42,943,4],[15,42,943,4]],[[4,42,944,2]],[[4,42,946,2],[79,42,946,77]],[[4,42,947,2],[10,42,947,8,1290],[20,42,947,18,1285],[21,42,947,18,1285],[24,42,947,18,1285],[31,42,947,18,1285],[60,42,947,47],[62,42,948,4,1235],[67,42,949,4,1207],[72,42,949,9,1204],[85,42,949,22],[87,42,950,4,1242],[94,42,951,4,1223]],[[4,42,953,2,1284],[26,42,953,24,1235],[31,42,953,29,1207],[37,42,953,35,1242],[44,42,953,42,1290],[53,42,953,51,1207],[58,42,953,56,1202],[61,42,953,59],[63,42,953,61,1223]],[[4,42,954,2],[8,42,954,6,1223],[13,42,954,11,1293],[18,42,954,16],[23,42,954,21],[29,42,954,27]],[[8,42,955,4],[12,42,955,8],[13,42,955,9,1228],[33,42,955,29,1207],[40,42,955,36]],[[12,42,956,6],[70,42,956,64]],[[12,42,957,6],[19,42,957,6]],[[8,42,958,4]],[[8,42,959,4],[41,42,959,37]],[[8,42,960,4],[12,42,960,9],[18,42,960,15,1294],[38,42,960,35,1223],[43,42,960,40,1293],[48,42,960,45],[49,42,960,47]],[[12,42,961,6],[18,42,961,12,1305],[30,42,961,24,1223],[35,42,961,29,1293],[40,42,961,34],[41,42,961,35,1294],[58,42,961,52]],[[12,42,962,6],[18,42,962,12,1299],[36,42,962,30,1302],[69,42,963,8,1235],[74,42,964,8,1207],[80,42,965,8,1242],[87,42,966,8,1305]],[[12,42,968,6],[16,42,968,10,1299],[36,42,968,10,1299],[39,42,968,65]],[[16,42,969,8],[51,42,969,43]],[[16,42,970,8],[23,42,970,8]],[[12,42,971,6]],[[8,42,972,4]],[[4,42,973,2]],[[4,42,974,2],[67,42,974,65]],[[4,42,975,2],[11,42,975,2]],[[0,42,976,0]],[[0,42,978,0],[9,42,978,9,1283],[37,42,979,2,1235],[40,42,979,13],[42,42,980,2,1207],[46,42,980,20],[48,42,981,2,1242],[53,42,981,33],[55,42,982,2,1288],[62,42,982,28],[64,42,983,2,1289],[71,42,983,20],[73,42,984,2,1272],[87,42,984,66],[89,42,985,2,1204],[102,42,988,35]],[[4,42,990,2],[70,42,990,68]],[[4,42,991,2],[75,42,991,73]],[[4,42,992,2],[80,42,992,78]],[[4,42,993,2],[30,42,993,28]],[[4,42,994,2],[75,42,994,73]],[[4,42,995,2],[74,42,995,72]],[[4,42,996,2],[77,42,996,75]],[[4,42,997,2],[79,42,997,77]],[[4,42,998,2],[29,42,998,27]],[[4,42,999,2],[10,42,999,8,1291],[28,42,999,26,1288],[35,42,999,33],[36,42,999,34],[38,42,999,36]],[[4,42,1000,2],[10,42,1000,8,1292],[28,42,1000,26,1289],[36,42,1000,34,1293],[41,42,1000,39]],[[4,42,1001,2],[8,42,1001,6,1306],[30,42,1001,63],[31,42,1001,64]],[[4,42,1002,2],[8,42,1002,6,1292],[28,42,1002,26],[34,42,1002,32]],[[8,42,1003,4],[12,42,1003,9],[18,42,1003,15,1294],[38,42,1003,35,1292],[54,42,1003,52]],[[12,42,1004,6],[18,42,1004,12,1295],[33,42,1004,27,1292],[48,42,1004,42],[49,42,1004,43,1294],[66,42,1004,60]],[[12,42,1005,6],[18,42,1005,12,1296],[40,42,1005,34,1295],[53,42,1005,47,1290],[60,42,1005,54]],[[12,42,1006,6],[18,42,1006,12,1297],[33,42,1007,8,1291],[48,42,1007,23],[49,42,1007,24,1294],[66,42,1007,41]],[[12,42,1008,6],[18,42,1008,12,1298],[40,42,1009,8,1297],[54,42,1009,22],[55,42,1009,23],[57,42,1009,25]],[[12,42,1010,6],[16,42,1011,8,1298],[40,42,1011,32,1300],[53,42,1012,8,1301],[90,42,1013,10,1242],[97,42,1014,10,1296],[118,42,1015,10,1298],[140,42,1017,8]],[[16,42,1018,8],[86,42,1018,78]],[[16,42,1019,8],[22,42,1019,14,1307],[41,42,1019,33,1283],[69,42,1020,10,1235],[74,42,1021,10,1207],[80,42,1022,10,1242],[87,42,1023,10,1297],[101,42,1024,10,1295],[115,42,1025,10,1272],[131,42,1026,10,1204]],[[16,42,1028,8,1306],[35,42,1028,27],[36,42,1028,28,1294],[53,42,1028,45],[56,42,1028,48,1307]],[[12,42,1029,6],[19,42,1029,13]],[[16,42,1030,8],[82,42,1030,74]],[[16,42,1031,8],[82,42,1031,74]],[[16,42,1032,8],[35,42,1032,27]],[[16,42,1033,8],[23,42,1033,16,1204]],[[20,42,1034,10],[25,42,1034,15,1266],[32,42,1034,15,1266],[45,42,1034,28],[46,42,1034,29,1269],[61,42,1034,44]],[[24,42,1034,46]],[[28,42,1035,12],[91,42,1035,75]],[[28,42,1036,12],[96,42,1036,80]],[[28,42,1037,12],[95,42,1037,79]],[[28,42,1038,12],[40,42,1038,24]],[[28,42,1039,12],[30,42,1039,14]],[[28,42,1040,12],[87,42,1040,71]],[[28,42,1041,12],[91,42,1041,75]],[[28,42,1042,12],[30,42,1042,14]],[[28,42,1043,12],[91,42,1043,75]],[[28,42,1044,12],[90,42,1044,74]],[[28,42,1045,12],[94,42,1045,78]],[[28,42,1046,12],[55,42,1046,39]],[[28,42,1047,12],[34,42,1047,18,1308],[62,42,1048,14,1295],[75,42,1048,27,1309],[93,42,1048,45],[98,42,1049,14,1310],[114,42,1049,14,1310],[132,42,1049,32],[133,42,1049,33,1311],[160,42,1049,60]],[[28,42,1050,12],[34,42,1050,18,1307],[53,42,1050,37,1308],[81,42,1051,16,1312],[125,42,1052,18,1235],[130,42,1053,18,1207],[136,42,1054,18,1242],[143,42,1055,18,1295],[157,42,1056,18],[163,42,1057,18,1272],[181,42,1060,16,1313],[182,42,1060,16,1313],[185,42,1060,16,1313],[192,42,1060,16,1313],[227,42,1060,51],[229,42,1060,52,1295]],[[28,42,1061,12,1306],[47,42,1061,31],[48,42,1061,32,1294],[65,42,1061,49],[68,42,1061,52,1307]],[[28,42,1062,12]],[[24,42,1063,10]],[[20,42,1064,10],[25,42,1064,15,1266],[32,42,1064,15,1266],[45,42,1064,28],[46,42,1064,29,1275],[56,42,1064,39]],[[24,42,1064,41]],[[28,42,1065,12],[96,42,1065,80]],[[28,42,1066,12],[61,42,1066,45]],[[28,42,1067,12],[34,42,1067,18,1307],[53,42,1067,37,1287],[88,42,1068,14,1235],[93,42,1069,14,1207],[99,42,1070,14,1242],[106,42,1071,14,1295],[120,42,1072,14],[127,42,1073,14,1272],[143,42,1074,14,1204]],[[28,42,1076,12,1306],[47,42,1076,31],[48,42,1076,32,1294],[65,42,1076,49],[68,42,1076,52,1307]],[[28,42,1077,12]],[[24,42,1078,10]],[[20,42,1079,10],[25,42,1079,15,1266],[32,42,1079,15,1266],[45,42,1079,28],[46,42,1079,29,1281],[50,42,1079,33]],[[24,42,1079,35]],[[28,42,1080,12],[94,42,1080,78]],[[28,42,1081,12],[92,42,1081,76]],[[28,42,1082,12],[88,42,1082,72]],[[28,42,1083,12],[89,42,1083,73]],[[28,42,1084,12],[47,42,1084,31]],[[28,42,1085,12],[30,42,1085,14]],[[28,42,1086,12],[93,42,1086,77]],[[28,42,1087,12],[86,42,1087,70]],[[28,42,1088,12],[93,42,1088,77]],[[28,42,1089,12],[80,42,1089,64]],[[28,42,1090,12],[50,42,1090,34]],[[28,42,1091,12],[30,42,1091,14]],[[28,42,1092,12],[95,42,1092,79]],[[28,42,1093,12],[94,42,1093,78]],[[28,42,1094,12],[95,42,1094,79]],[[28,42,1095,12],[90,42,1095,74]],[[28,42,1096,12],[58,42,1096,42]],[[28,42,1097,12],[34,42,1097,18,1307],[53,42,1097,37,1287],[88,42,1098,14,1235],[93,42,1099,14,1207],[99,42,1100,14,1242],[106,42,1101,14,1295],[120,42,1102,14],[127,42,1103,14,1272],[143,42,1104,14,1204]],[[28,42,1106,12,1306],[47,42,1106,31],[48,42,1106,32,1294],[65,42,1106,49],[68,42,1106,52,1307]],[[28,42,1107,12]],[[24,42,1108,10]],[[20,42,1109,10]],[[24,42,1110,12,1204]],[[16,42,1111,8]],[[12,42,1112,6]],[[8,42,1113,4]],[[4,42,1114,2]],[[4,42,1115,2],[10,42,1115,8,1276],[24,42,1115,41]],[[8,42,1116,4,1289],[16,42,1116,12,1290],[23,42,1116,19]],[[8,42,1117,4,1306]],[[8,42,1118,4]],[[8,42,1119,4]],[[8,42,1120,4,1289],[16,42,1120,12,1314],[28,42,1120,24]],[[5,42,1121,3]],[[4,42,1122,2],[11,42,1122,9,1276]],[[0,42,1123,0]],[[0,42,1125,0],[9,42,1125,9,1312],[53,42,1126,2,1235],[56,42,1126,13],[58,42,1127,2,1207],[62,42,1127,20],[64,42,1128,2,1242],[69,42,1128,33],[71,42,1129,2,1223],[75,42,1129,17],[77,42,1130,2,1315],[97,42,1130,65],[99,42,1131,2,1272],[113,42,1131,66]],[[4,42,1133,2],[81,42,1133,79]],[[4,42,1134,2],[76,42,1134,74]],[[4,42,1135,2],[74,42,1135,72]],[[4,42,1136,2],[80,42,1136,78]],[[4,42,1137,2],[71,42,1137,69]],[[4,42,1138,2],[80,42,1138,78]],[[4,42,1139,2],[76,42,1139,74]],[[4,42,1140,2],[63,42,1140,61]],[[4,42,1142,2],[75,42,1142,73]],[[4,42,1143,2],[24,42,1143,22]],[[4,42,1144,2],[8,42,1144,6,1316],[24,42,1145,4,1315],[49,42,1145,29],[56,42,1145,36],[81,42,1145,61]],[[4,42,1147,2],[10,42,1147,8,1290],[20,42,1147,18,1285],[21,42,1147,18,1285],[24,42,1147,18,1285],[31,42,1147,18,1285],[60,42,1147,47],[62,42,1148,4,1235],[67,42,1149,4,1207],[72,42,1149,9,1204],[85,42,1149,22],[87,42,1150,4,1242],[94,42,1151,4,1223]],[[4,42,1153,2],[11,42,1153,10,1290],[19,42,1153,18,1255],[25,42,1153,24]],[[8,42,1154,4],[13,42,1154,9,1256],[20,42,1154,9,1256],[31,42,1154,20],[32,42,1154,21,1257],[37,42,1154,26]],[[12,42,1154,28]],[[16,42,1155,6],[87,42,1155,77]],[[16,42,1156,6],[43,42,1156,33]],[[16,42,1157,6],[89,42,1157,79]],[[16,42,1158,6],[87,42,1158,77]],[[16,42,1159,6],[88,42,1159,78]],[[16,42,1160,6],[89,42,1160,79]],[[16,42,1161,6],[64,42,1161,54]],[[16,42,1163,6],[65,42,1163,55]],[[16,42,1164,6,1272],[31,42,1164,21,1317],[34,42,1164,24],[35,42,1165,8,1223],[40,42,1165,13,1304],[50,42,1165,23],[52,42,1166,8,1318],[53,42,1166,8,1318],[56,42,1166,8,1318],[63,42,1166,8,1318],[86,42,1166,31],[88,42,1167,10,1290],[97,42,1168,10],[97,42,1169,10],[169,42,1168,82],[170,42,1169,83]],[[16,42,1170,10],[83,42,1170,77]],[[16,42,1171,10,1266],[23,42,1171,10,1266],[36,42,1171,23],[37,42,1171,24,1269],[52,42,1171,39]],[[16,42,1174,6],[20,42,1174,10,1315],[45,42,1174,35],[56,42,1174,46]],[[20,42,1175,8,1316],[36,42,1175,24,1315],[59,42,1175,47]],[[16,42,1176,6],[23,42,1176,13]],[[16,42,1177,8],[83,42,1177,75]],[[16,42,1178,8],[38,42,1178,30]],[[16,42,1179,6]],[[16,42,1180,6]],[[12,42,1181,4]],[[8,42,1182,4],[13,42,1182,9,1256],[20,42,1182,9,1256],[31,42,1182,20],[32,42,1182,21,1260],[41,42,1182,30]],[[12,42,1182,32]],[[16,42,1183,6],[49,42,1183,39]],[[16,42,1184,6],[22,42,1184,12,1319],[50,42,1185,8,1223],[55,42,1185,13,1309],[73,42,1185,31],[78,42,1185,36,1310],[94,42,1185,36,1310],[112,42,1185,54],[113,42,1185,55,1320],[138,42,1185,80]],[[16,42,1186,6],[20,42,1186,10,1319],[47,42,1186,37]],[[20,42,1187,8],[88,42,1187,76]],[[20,42,1188,8],[90,42,1188,78]],[[20,42,1189,8],[45,42,1189,33]],[[20,42,1190,8],[27,42,1190,15,1313],[28,42,1190,15,1313],[31,42,1190,15,1313],[38,42,1190,15,1313],[73,42,1190,50],[75,42,1190,51,1223]],[[16,42,1191,6]],[[16,42,1198,6]],[[12,42,1199,4]],[[8,42,1200,4],[13,42,1200,9,1256],[20,42,1200,9,1256],[31,42,1200,20],[32,42,1200,21,1258],[39,42,1200,28]],[[12,42,1200,30]],[[16,42,1203,6]],[[12,42,1204,4]],[[8,42,1205,4],[13,42,1205,9,1256],[20,42,1205,9,1256],[31,42,1205,20],[32,42,1205,21,1261],[40,42,1205,29]],[[12,42,1205,31]],[[16,42,1208,6]],[[12,42,1209,4]],[[8,42,1210,4]],[[12,42,1211,6,1290]],[[4,42,1212,2]],[[4,42,1213,2],[10,42,1213,8,1306],[32,42,1213,65],[33,42,1213,66]],[[4,42,1214,2],[8,42,1214,6,1223],[13,42,1214,11,1293],[18,42,1214,16],[23,42,1214,21],[29,42,1214,27]],[[8,42,1215,4],[12,42,1215,9],[18,42,1215,15,1294],[38,42,1215,35,1223],[43,42,1215,40,1293],[48,42,1215,45],[49,42,1215,47]],[[12,42,1216,6],[18,42,1216,12,1305],[30,42,1216,24,1223],[35,42,1216,29,1293],[40,42,1216,34],[41,42,1216,35,1294],[58,42,1216,52]],[[12,42,1217,6,1306],[31,42,1217,25],[32,42,1217,26,1294],[49,42,1217,43],[52,42,1218,8,1312],[96,42,1219,10,1235],[101,42,1220,10,1207],[107,42,1221,10,1242],[114,42,1222,10,1305],[125,42,1223,10,1315],[147,42,1224,10,1272]],[[8,42,1226,4]],[[4,42,1227,2]],[[4,42,1228,2],[10,42,1228,8,1276],[24,42,1228,41]],[[8,42,1229,4,1223],[13,42,1229,9,1290],[20,42,1229,16]],[[8,42,1230,4,1306]],[[8,42,1231,4]],[[8,42,1232,4,1316]],[[8,42,1233,4,1223],[13,42,1233,9,1314],[25,42,1233,21]],[[5,42,1234,3]],[[4,42,1235,2],[11,42,1235,9,1276]],[[0,42,1236,0]],[[0,42,1238,0],[9,42,1238,9,1287],[44,42,1239,2,1235],[47,42,1239,13],[49,42,1240,2,1207],[53,42,1240,20],[55,42,1241,2,1242],[60,42,1241,33],[62,42,1242,2,1223],[66,42,1242,17],[68,42,1243,2,1321],[92,42,1243,35],[94,42,1244,2,1272],[108,42,1244,66],[110,42,1245,2,1204],[123,42,1245,62]],[[4,42,1247,2],[81,42,1247,79]],[[4,42,1248,2],[80,42,1248,78]],[[4,42,1249,2],[59,42,1249,57]],[[4,42,1250,2],[6,42,1250,4]],[[4,42,1251,2],[75,42,1251,73]],[[4,42,1252,2],[78,42,1252,76]],[[4,42,1253,2],[76,42,1253,74]],[[4,42,1254,2],[22,42,1254,20]],[[4,42,1255,2],[10,42,1255,8,1290],[20,42,1255,18,1285],[21,42,1255,18,1285],[24,42,1255,18,1285],[31,42,1255,18,1285],[60,42,1255,47],[62,42,1256,4,1235],[67,42,1258,4],[67,42,1257,4],[105,42,1258,42],[141,42,1257,78]],[[4,42,1259,4],[95,42,1259,95]],[[4,42,1260,4],[95,42,1260,95]],[[4,42,1261,4],[42,42,1261,42]],[[4,42,1262,4,1204],[19,42,1263,4,1242],[26,42,1264,4,1223]],[[4,42,1267,2],[8,42,1267,6,1322],[25,42,1267,56]],[[4,42,1269,2],[11,42,1269,10,1290],[19,42,1269,18,1255],[25,42,1269,24]],[[8,42,1270,4],[13,42,1270,9,1256],[20,42,1270,9,1256],[31,42,1270,20],[32,42,1270,21,1257],[37,42,1270,26]],[[12,42,1270,28]],[[16,42,1271,6],[73,42,1271,63]],[[16,42,1272,6,1322],[33,42,1272,23,1318],[34,42,1272,23,1318],[37,42,1272,23,1318],[44,42,1272,23,1318],[67,42,1272,46],[69,42,1272,47,1290],[78,42,1272,56,1204]],[[16,42,1273,6]],[[12,42,1274,4]],[[8,42,1275,4],[13,42,1275,9,1256],[20,42,1275,9,1256],[31,42,1275,20],[32,42,1275,21,1260],[41,42,1275,30]],[[12,42,1275,32]],[[16,42,1276,6],[49,42,1276,39]],[[16,42,1277,6],[20,42,1278,8,1290],[28,42,1278,16,1323],[37,42,1278,25],[41,42,1279,8,1324],[42,42,1279,8,1324],[45,42,1279,8,1324],[52,42,1279,8,1324],[89,42,1279,45],[91,42,1280,10,1290],[99,42,1280,18,1204],[112,42,1280,31],[114,42,1281,10,1204],[130,42,1283,8]],[[20,42,1284,8],[137,42,1284,125]],[[20,42,1285,8],[62,42,1285,50]],[[20,42,1286,8],[88,42,1286,76]],[[20,42,1287,8],[115,42,1287,103]],[[20,42,1288,8],[117,42,1288,105]],[[20,42,1289,8,1322],[37,42,1289,25,1325],[65,42,1290,10,1235],[70,42,1291,10,1242],[77,42,1292,10,1223],[83,42,1293,10,1204]],[[16,42,1295,6]],[[16,42,1296,6]],[[12,42,1297,4]],[[8,42,1298,4],[13,42,1298,9,1256],[20,42,1298,9,1256],[31,42,1298,20],[32,42,1298,21,1258],[39,42,1298,28]],[[8,42,1299,4],[13,42,1299,9,1256],[20,42,1299,9,1256],[31,42,1299,20],[32,42,1299,21,1261],[40,42,1299,29]],[[12,42,1299,31]],[[16,42,1300,6],[89,42,1300,79]],[[16,42,1301,6],[96,42,1301,86]],[[16,42,1302,6],[20,42,1303,8,1324],[21,42,1303,8,1324],[24,42,1303,8,1324],[31,42,1303,8,1324],[68,42,1303,45],[70,42,1304,10,1290],[78,42,1304,18,1204],[91,42,1304,31],[93,42,1305,10,1204],[109,42,1307,8]],[[20,42,1308,8,1322],[37,42,1308,25,1325],[65,42,1309,10,1235],[70,42,1310,10,1242],[77,42,1311,10,1223],[83,42,1312,10,1204]],[[16,42,1314,6]],[[16,42,1315,6]],[[12,42,1316,4]],[[8,42,1317,4]],[[12,42,1318,6,1290]],[[4,42,1319,2]],[[4,42,1320,2],[10,42,1320,8,1306],[32,42,1320,65],[33,42,1320,66]],[[4,42,1321,2],[8,42,1321,6,1223],[13,42,1321,11,1293],[18,42,1321,16],[23,42,1321,21],[29,42,1321,27]],[[8,42,1322,4],[12,42,1322,9],[18,42,1322,15,1294],[38,42,1322,35,1223],[43,42,1322,40,1293],[48,42,1322,45],[49,42,1322,47]],[[12,42,1323,6],[18,42,1323,12,1305],[30,42,1323,24,1223],[35,42,1323,29,1293],[40,42,1323,34],[41,42,1323,35,1294],[58,42,1323,52]],[[12,42,1324,6,1306],[31,42,1324,25],[32,42,1324,26,1294],[49,42,1324,43],[52,42,1325,8,1287],[87,42,1326,10,1235],[92,42,1327,10,1207],[98,42,1328,10,1242],[105,42,1329,10,1305],[116,42,1330,10,1321],[144,42,1330,38,1322],[163,42,1330,57],[169,42,1331,10,1272],[185,42,1332,10,1204]],[[8,42,1334,4]],[[4,42,1335,2]],[[4,42,1337,2],[8,42,1337,6,1322],[27,42,1337,25],[33,42,1337,31]],[[8,42,1338,4],[51,42,1338,47]],[[8,42,1339,4,1272],[23,42,1339,19,1317],[26,42,1339,22],[27,42,1339,23,1223],[32,42,1339,28,1304],[42,42,1339,38],[44,42,1339,40,1322]],[[4,42,1340,2]],[[4,42,1342,2],[82,42,1342,80]],[[4,42,1343,2],[10,42,1343,8,1316],[26,42,1344,4],[27,42,1344,5,1321],[55,42,1344,33,1322],[74,42,1344,52],[81,42,1344,59],[93,42,1344,71]],[[4,42,1346,2],[10,42,1346,8,1276],[24,42,1346,41]],[[8,42,1347,4,1223],[13,42,1347,9,1290],[20,42,1347,16]],[[8,42,1348,4,1306]],[[8,42,1349,4]],[[8,42,1350,4,1316]],[[8,42,1351,4,1223],[13,42,1351,9,1314],[25,42,1351,21]],[[5,42,1352,3]],[[4,42,1353,2],[11,42,1353,9,1276]],[[0,42,1354,0]],[[0,42,1356,0],[9,42,1356,9,1277],[31,42,1357,2,1235],[34,42,1357,13],[36,42,1358,2,1207],[40,42,1358,20],[42,42,1359,2,1242],[47,42,1359,33],[49,42,1360,2,1223],[53,42,1360,17],[55,42,1361,2,1212],[79,42,1361,50],[81,42,1362,2,1272],[95,42,1362,66]],[[4,42,1364,2],[78,42,1364,76]],[[4,42,1365,2],[76,42,1365,74]],[[4,42,1366,2],[79,42,1366,77]],[[4,42,1367,2],[59,42,1367,57]],[[4,42,1368,2],[6,42,1368,4]],[[4,42,1369,2],[58,42,1369,56]],[[4,42,1370,2],[8,42,1370,6,1212],[33,42,1370,31,1326],[36,42,1370,34],[37,42,1370,35,1223],[42,42,1370,40,1304],[52,42,1370,50],[55,42,1370,53]],[[8,42,1371,4],[49,42,1371,45]],[[8,42,1372,4],[15,42,1372,11,1287],[50,42,1373,6,1235],[55,42,1374,6,1207],[61,42,1375,6,1242],[68,42,1376,6,1223],[74,42,1377,6],[81,42,1378,6,1272],[97,42,1379,6,1266],[104,42,1379,6,1266],[117,42,1379,19],[118,42,1379,20,1275],[128,42,1379,30]],[[4,42,1381,2]],[[4,42,1382,2],[8,42,1382,6,1306],[30,42,1382,63],[31,42,1382,64]],[[4,42,1383,2],[10,42,1383,8,1293],[18,42,1383,16,1223],[23,42,1383,21,1293],[28,42,1383,26]],[[4,42,1384,2],[8,42,1384,6,1293],[18,42,1384,16],[24,42,1384,22]],[[8,42,1385,4],[12,42,1385,9],[18,42,1385,15,1294],[38,42,1385,35,1293],[44,42,1385,42]],[[12,42,1386,6],[18,42,1386,12,1305],[30,42,1386,24,1293],[35,42,1386,29],[36,42,1386,30,1294],[53,42,1386,47]],[[12,42,1387,6,1306],[31,42,1387,25],[32,42,1387,26,1294],[49,42,1387,43],[52,42,1387,46,1277],[74,42,1388,8,1235],[79,42,1389,8,1207],[85,42,1390,8,1242],[92,42,1391,8,1305],[103,42,1392,8,1212],[129,42,1393,8,1272]],[[8,42,1395,4]],[[4,42,1396,2]],[[4,42,1398,2],[77,42,1398,75]],[[4,42,1399,2],[10,42,1399,8,1276],[24,42,1399,41]],[[8,42,1400,4,1223],[13,42,1400,9,1290],[20,42,1400,16]],[[8,42,1401,4,1306]],[[8,42,1402,4]],[[8,42,1403,4]],[[5,42,1404,3]],[[4,42,1405,2],[11,42,1405,9,1276]],[[0,42,1406,0]],[[0,42,1408,0],[9,42,1408,9,1284],[31,42,1409,2,1235],[34,42,1409,13],[36,42,1410,2,1207],[40,42,1410,20],[42,42,1411,2,1242],[47,42,1411,33],[49,42,1412,2,1290],[56,42,1412,28],[58,42,1413,2,1327],[66,42,1413,25],[68,42,1414,2,1223],[72,42,1414,17]],[[4,42,1416,2],[11,42,1416,10,1290],[19,42,1416,18,1255],[25,42,1416,24]],[[8,42,1417,4],[13,42,1417,9,1256],[20,42,1417,9,1256],[31,42,1417,20],[32,42,1417,21,1257],[37,42,1417,26]],[[12,42,1418,6],[82,42,1418,76]],[[12,42,1419,6,1229],[33,42,1420,8,1328],[34,42,1420,8,1328],[37,42,1420,8,1328],[44,42,1420,8,1328],[67,42,1420,31],[69,42,1421,10,1242],[76,42,1422,10,1318],[77,42,1422,10,1318],[80,42,1422,10,1318],[87,42,1422,10,1318],[110,42,1422,33],[112,42,1422,34,1290],[121,42,1422,43,1266],[128,42,1422,43,1266],[141,42,1422,56],[142,42,1422,57,1267],[145,42,1422,60],[148,42,1423,10,1327],[158,42,1424,10,1223]],[[12,42,1427,6]],[[8,42,1428,4],[13,42,1428,9,1256],[20,42,1428,9,1256],[31,42,1428,20],[32,42,1428,21,1258],[39,42,1428,28]],[[12,42,1428,30]],[[16,42,1429,6],[83,42,1429,73]],[[16,42,1430,6],[63,42,1430,53]],[[16,42,1431,6],[23,42,1431,14,1290],[31,42,1431,22,1204],[44,42,1431,35]],[[20,42,1432,8],[25,42,1432,13,1266],[32,42,1432,13,1266],[45,42,1432,26],[46,42,1432,27,1267],[49,42,1432,30]],[[20,42,1433,8],[25,42,1433,13,1266],[32,42,1433,13,1266],[45,42,1433,26],[46,42,1433,27,1275],[56,42,1433,37]],[[20,42,1434,8],[25,42,1434,13,1266],[32,42,1434,13,1266],[45,42,1434,26],[46,42,1434,27,1281],[50,42,1434,31]],[[24,42,1436,10]],[[20,42,1437,8],[25,42,1437,13,1266],[32,42,1437,13,1266],[45,42,1437,26],[46,42,1437,27,1269],[61,42,1437,42]],[[24,42,1438,10],[84,42,1438,70]],[[24,42,1439,10],[92,42,1439,78]],[[24,42,1440,10],[90,42,1440,76]],[[24,42,1441,10],[89,42,1441,75]],[[24,42,1442,10],[47,42,1442,33]],[[24,42,1443,10],[28,42,1443,14,1241],[39,42,1443,25,1207],[46,42,1443,32]],[[28,42,1444,12],[94,42,1444,78]],[[28,42,1445,12],[80,42,1445,64]],[[28,42,1446,12,1329],[55,42,1446,39,1235],[60,42,1446,44,1242],[67,42,1446,51,1327],[77,42,1446,61,1223]],[[24,42,1447,10]],[[24,42,1448,10]],[[20,42,1449,8]],[[24,42,1450,10,1290],[32,42,1450,18,1204],[45,42,1450,31]],[[16,42,1451,6]],[[16,42,1452,6]],[[12,42,1453,4]],[[8,42,1454,4],[13,42,1454,9,1256],[20,42,1454,9,1256],[31,42,1454,20],[32,42,1454,21,1261],[40,42,1454,29]],[[12,42,1454,31]],[[16,42,1455,6],[84,42,1455,74]],[[16,42,1456,6],[83,42,1456,73]],[[16,42,1457,6],[23,42,1457,14,1290],[31,42,1457,22,1204],[44,42,1457,35]],[[20,42,1458,8],[25,42,1458,13,1266],[32,42,1458,13,1266],[45,42,1458,26],[46,42,1458,27,1267],[49,42,1458,30]],[[20,42,1459,8],[25,42,1459,13,1266],[32,42,1459,13,1266],[45,42,1459,26],[46,42,1459,27,1275],[56,42,1459,37]],[[20,42,1460,8],[25,42,1460,13,1266],[32,42,1460,13,1266],[45,42,1460,26],[46,42,1460,27,1281],[50,42,1460,31]],[[24,42,1463,10]],[[20,42,1464,8],[25,42,1464,13,1266],[32,42,1464,13,1266],[45,42,1464,26],[46,42,1464,27,1269],[61,42,1464,42]],[[24,42,1465,10],[89,42,1465,75]],[[24,42,1466,10],[92,42,1466,78]],[[24,42,1467,10],[93,42,1467,79]],[[24,42,1468,10],[84,42,1468,70]],[[24,42,1469,10],[44,42,1469,30]],[[24,42,1470,10],[26,42,1470,12]],[[24,42,1471,10],[94,42,1471,80]],[[24,42,1472,10],[92,42,1472,78]],[[24,42,1473,10],[84,42,1473,70]],[[24,42,1474,10,1329],[51,42,1474,37,1235],[56,42,1474,42,1242],[63,42,1474,49,1327],[73,42,1474,59,1223]],[[24,42,1475,10]],[[20,42,1476,8]],[[24,42,1477,10,1290],[32,42,1477,18,1204],[45,42,1477,31]],[[16,42,1478,6]],[[16,42,1479,6]],[[12,42,1480,4]],[[8,42,1481,4],[13,42,1481,9,1256],[20,42,1481,9,1256],[31,42,1481,20],[32,42,1481,21,1260],[41,42,1481,30]],[[12,42,1483,6]],[[8,42,1484,4]],[[12,42,1485,6,1290]],[[4,42,1486,2]],[[0,42,1488,2],[75,42,1488,77]],[[0,42,1489,2],[75,42,1489,77]],[[0,42,1490,2],[57,42,1490,59]],[[0,42,1491,0]],[[0,42,1493,0],[9,42,1493,9,1329],[36,42,1494,2,1235],[39,42,1494,13],[41,42,1495,2,1242],[46,42,1495,33],[48,42,1496,2,1327],[56,42,1496,25],[58,42,1497,2,1223],[62,42,1497,17]],[[4,42,1499,2],[10,42,1499,8,1330],[32,42,1499,30,1331],[33,42,1499,30,1331],[36,42,1499,30,1331],[43,42,1499,30,1331],[79,42,1499,66],[81,42,1500,4,1235],[86,42,1501,4,1266],[93,42,1501,4,1266],[106,42,1501,17],[107,42,1501,18,1267],[110,42,1501,21],[112,42,1502,4,1242],[119,42,1503,4,1223]],[[4,42,1505,2],[11,42,1505,10,1330],[31,42,1505,30,1255],[37,42,1505,36]],[[8,42,1506,4],[13,42,1506,9,1256],[20,42,1506,9,1256],[31,42,1506,20],[32,42,1506,21,1257],[37,42,1506,26]],[[12,42,1507,6],[77,42,1507,71]],[[12,42,1508,6],[31,42,1508,25]],[[12,42,1509,6,1332],[38,42,1510,8,1229],[59,42,1511,10,1328],[60,42,1511,10,1328],[63,42,1511,10,1328],[70,42,1511,10,1328],[93,42,1511,33],[95,42,1512,12,1242],[102,42,1513,12,1318],[103,42,1513,12,1318],[106,42,1513,12,1318],[113,42,1513,12,1318],[136,42,1513,35],[138,42,1513,36,1330],[159,42,1513,57,1266],[166,42,1513,57,1266],[179,42,1513,70],[180,42,1513,71,1267],[183,42,1513,74],[186,42,1514,12,1327],[196,42,1515,12,1223],[204,42,1518,8,1333],[205,42,1518,8,1333],[208,42,1518,8,1333],[218,42,1518,8,1333],[246,42,1518,36],[248,42,1518,37,1266],[255,42,1518,37,1266],[268,42,1518,50],[269,42,1518,51,1267],[272,42,1518,54],[274,42,1518,56,1223]],[[12,42,1520,6]],[[8,42,1521,4],[13,42,1521,9,1256],[20,42,1521,9,1256],[31,42,1521,20],[32,42,1521,21,1258],[39,42,1521,28]],[[12,42,1523,6]],[[8,42,1524,4],[13,42,1524,9,1256],[20,42,1524,9,1256],[31,42,1524,20],[32,42,1524,21,1260],[41,42,1524,30]],[[8,42,1525,4],[13,42,1525,9,1256],[20,42,1525,9,1256],[31,42,1525,20],[32,42,1525,21,1261],[40,42,1525,29]],[[12,42,1529,6]],[[8,42,1530,4]],[[12,42,1531,6,1330]],[[4,42,1532,2]],[[0,42,1533,0]],[[0,42,1535,0],[9,42,1535,9,1325],[37,42,1536,2,1235],[40,42,1536,13],[42,42,1537,2,1242],[47,42,1537,33],[49,42,1538,2,1223],[53,42,1538,17],[55,42,1539,2,1204],[68,42,1539,62]],[[4,42,1541,2],[10,42,1541,8,1330],[32,42,1541,30,1331],[33,42,1541,30,1331],[36,42,1541,30,1331],[43,42,1541,30,1331],[79,42,1541,66],[81,42,1542,4,1235],[86,42,1543,4,1204],[101,42,1544,4,1242],[108,42,1545,4,1223]],[[4,42,1547,2],[8,42,1547,6,1330],[28,42,1547,26,1255],[34,42,1547,32],[39,42,1547,37,1256],[46,42,1547,37,1256],[57,42,1547,48],[58,42,1547,49,1257],[63,42,1547,54],[65,42,1547,56]],[[8,42,1548,4],[90,42,1548,86]],[[8,42,1549,4],[82,42,1549,78]],[[8,42,1550,4],[81,42,1550,77]],[[8,42,1551,4],[77,42,1551,73]],[[8,42,1552,4],[22,42,1552,18]],[[8,42,1553,4],[14,42,1553,10,1334],[31,42,1553,27,1318],[32,42,1553,27,1318],[35,42,1553,27,1318],[42,42,1553,27,1318],[65,42,1553,50],[67,42,1554,6,1330],[88,42,1555,6,1204]],[[8,42,1557,4,1332],[34,42,1558,6,1335],[35,42,1558,6,1335],[38,42,1558,6,1335],[45,42,1558,6,1335],[69,42,1558,30],[71,42,1558,31,1334],[88,42,1559,6,1333],[89,42,1559,6,1333],[92,42,1559,6,1333],[102,42,1559,6,1333],[130,42,1559,34],[132,42,1559,35,1204],[147,42,1559,50,1223]],[[8,42,1561,4],[15,42,1561,11,1334]],[[4,42,1562,2],[11,42,1562,9]],[[8,42,1563,4],[54,42,1563,50]],[[8,42,1564,4],[14,42,1564,10,1336],[44,42,1564,40,1330]],[[8,42,1565,4],[12,42,1566,6,1324],[13,42,1566,6,1324],[16,42,1566,6,1324],[23,42,1566,6,1324],[60,42,1566,43],[62,42,1567,8,1336],[90,42,1567,36,1204],[103,42,1567,49],[105,42,1568,8,1204],[121,42,1570,6]],[[12,42,1571,6],[84,42,1571,78]],[[12,42,1572,6],[53,42,1572,47]],[[12,42,1573,6],[18,42,1573,12,1337],[33,42,1573,27,1338],[34,42,1573,27,1338],[37,42,1573,27,1338],[44,42,1573,27,1338],[82,42,1573,65],[84,42,1574,8,1204],[99,42,1575,8,1242],[106,42,1576,8,1223]],[[12,42,1578,6],[18,42,1578,12,1334],[35,42,1578,29,1318],[36,42,1578,29,1318],[39,42,1578,29,1318],[46,42,1578,29,1318],[69,42,1578,52],[71,42,1579,8,1337],[85,42,1580,8,1204]],[[12,42,1582,6,1332],[38,42,1583,8,1335],[39,42,1583,8,1335],[42,42,1583,8,1335],[49,42,1583,8,1335],[73,42,1583,32],[75,42,1583,33,1334],[92,42,1584,8,1333],[93,42,1584,8,1333],[96,42,1584,8,1333],[106,42,1584,8,1333],[134,42,1584,36],[136,42,1584,37,1204],[151,42,1584,52,1223]],[[12,42,1586,6],[19,42,1586,13,1334]],[[8,42,1587,4]],[[8,42,1588,4],[15,42,1588,12,1336],[43,42,1588,40,1255],[49,42,1588,46]],[[12,42,1589,6],[17,42,1589,11,1256],[24,42,1589,11,1256],[35,42,1589,22],[36,42,1589,23,1258],[43,42,1589,30]],[[16,42,1590,8],[86,42,1590,78]],[[16,42,1591,8],[23,42,1591,15]],[[12,42,1592,6],[17,42,1592,11,1256],[24,42,1592,11,1256],[35,42,1592,22],[36,42,1592,23,1260],[45,42,1592,32]],[[12,42,1593,6],[17,42,1593,11,1256],[24,42,1593,11,1256],[35,42,1593,22],[36,42,1593,23,1261],[44,42,1593,31]],[[16,42,1594,8],[88,42,1594,80]],[[16,42,1595,8],[87,42,1595,79]],[[16,42,1596,8],[46,42,1596,38]],[[16,42,1597,8],[23,42,1597,15]],[[12,42,1598,6]],[[16,42,1599,8,1336]],[[16,42,1600,8],[23,42,1600,15]],[[8,42,1601,4]],[[4,42,1602,2]],[[0,42,1603,0]],[[0,42,1605,0],[6,42,1605,6,1339],[13,42,1605,13],[18,42,1605,20]],[[0,42,1607,0],[9,42,1607,9,1332],[35,42,1608,2,1340],[42,42,1608,53],[44,42,1609,2,1341],[52,42,1609,27]],[[4,42,1611,2],[74,42,1611,72]],[[4,42,1612,2,1340],[12,42,1612,10,1189],[16,42,1612,14],[17,42,1612,15],[18,42,1612,16,1342]],[[8,42,1613,4],[12,42,1613,8,1342],[26,42,1613,22],[32,42,1613,28]],[[12,42,1614,6],[85,42,1614,79]],[[12,42,1615,6,1343],[13,42,1615,6,1343],[16,42,1615,6,1343],[23,42,1615,6,1343],[41,42,1615,24],[43,42,1615,25,1236],[48,42,1615,30,1235],[51,42,1615,33],[55,42,1615,37,1341],[65,42,1615,47,1342]],[[8,42,1616,4]],[[4,42,1617,2],[7,42,1617,5,1339]],[[0,42,1618,0]],[[0,42,1620,0],[9,42,1620,9,1301],[46,42,1621,2,1242],[51,42,1621,33],[53,42,1622,2,1344],[67,42,1622,25],[69,42,1623,2,1345],[82,42,1623,24]],[[4,42,1625,2],[8,42,1625,6,1345],[26,42,1625,24,1346],[35,42,1625,24,1346],[51,42,1625,40],[53,42,1625,42]],[[8,42,1626,4],[82,42,1626,78]],[[8,42,1627,4],[77,42,1627,73]],[[8,42,1628,4],[81,42,1628,77]],[[8,42,1629,4],[82,42,1629,78]],[[8,42,1630,4],[69,42,1630,65]],[[8,42,1631,4],[67,42,1631,63]],[[8,42,1632,4],[82,42,1632,78]],[[8,42,1633,4],[78,42,1633,74]],[[8,42,1634,4],[83,42,1634,79]],[[8,42,1635,4],[77,42,1635,73]],[[8,42,1636,4],[15,42,1637,6,1344],[34,42,1638,6,1347],[35,42,1638,6,1347],[38,42,1638,6,1347],[47,42,1638,6,1347],[75,42,1638,34],[77,42,1639,8,1346],[86,42,1639,8,1346],[102,42,1639,24],[104,42,1640,8,1348],[111,42,1640,15,1349],[122,42,1640,26],[123,42,1640,27],[127,42,1640,31,1350],[143,42,1640,47,1242],[149,42,1640,53,1351],[163,42,1640,67]],[[4,42,1643,2]],[[4,42,1644,2],[75,42,1644,73]],[[4,42,1645,2],[11,42,1645,9,1352],[12,42,1645,9,1352],[15,42,1645,9,1352],[30,42,1645,9,1352],[42,42,1645,21],[44,42,1645,22,1345],[59,42,1645,37,1344]],[[0,42,1646,0]],[[0,42,1648,0],[80,42,1648,80]],[[0,42,1649,0],[78,42,1649,78]],[[0,42,1650,0],[77,42,1650,77]],[[0,42,1651,0],[69,42,1651,69]],[[0,42,1652,0],[80,42,1652,80]],[[0,42,1654,0],[9,42,1654,9,1353],[30,42,1654,30,1354],[31,42,1654,45],[33,42,1654,47,1355],[34,42,1654,62]],[[4,42,1655,2],[81,42,1655,79]],[[4,42,1656,2],[76,42,1656,74]],[[4,42,1657,2],[14,42,1657,12]],[[4,42,1659,2],[74,42,1659,72]],[[4,42,1660,2],[10,42,1660,8,1356],[25,42,1660,23,1355],[27,42,1660,25,1205],[35,42,1660,33],[38,42,1660,36,1354],[40,42,1660,38,1205],[48,42,1660,46]],[[4,42,1661,2],[8,42,1661,6,1356],[25,42,1661,23],[28,42,1661,26]],[[8,42,1662,4],[15,42,1662,11,1356]],[[4,42,1663,2]],[[4,42,1665,2],[80,42,1665,78]],[[4,42,1666,2],[80,42,1666,78]],[[4,42,1667,2],[10,42,1667,8,1357],[22,42,1667,20,1355],[24,42,1667,22,1210],[29,42,1667,27],[32,42,1667,30,1354],[34,42,1667,32,1210],[39,42,1667,37]],[[4,42,1668,2],[8,42,1668,6,1357],[22,42,1668,20],[25,42,1668,23]],[[8,42,1669,4],[15,42,1669,11,1357]],[[4,42,1670,2]],[[4,42,1672,2],[78,42,1672,76]],[[4,42,1673,2],[78,42,1673,76]],[[4,42,1674,2],[11,42,1674,9,1355],[13,42,1674,11,1213],[19,42,1674,17],[22,42,1674,20,1354],[24,42,1674,22,1213],[30,42,1674,28]],[[0,42,1675,0]],[[0,42,1677,0],[9,42,1677,9,1217],[18,42,1677,18,1358],[22,42,1677,43],[24,42,1677,45,1359],[28,42,1677,63]],[[4,42,1678,2],[10,42,1678,8,1360],[18,42,1678,16,1358],[23,42,1678,21,1361],[29,42,1678,27]],[[4,42,1679,2,1358],[9,42,1679,7,1362],[13,42,1679,11],[14,42,1679,12,1359]],[[4,42,1680,2,1359],[9,42,1680,7,1215],[19,42,1680,17],[22,42,1680,20,1360]],[[4,42,1681,2,1363],[15,42,1681,13,1358],[21,42,1681,19,1359],[27,42,1681,25,1360]],[[0,42,1682,0]],[[0,42,1684,0],[9,42,1684,9,1237],[18,42,1684,18,1358],[22,42,1684,43]],[[4,42,1685,2],[11,42,1685,9,1358],[16,42,1685,14,1361],[22,42,1685,20],[27,42,1685,25],[31,42,1685,29],[38,42,1685,36,1358],[42,42,1685,40],[43,42,1685,41],[45,42,1685,43]],[[0,42,1686,0]],[[0,42,1688,0],[9,42,1688,9,1240],[17,42,1688,17,1358],[21,42,1688,42]],[[4,42,1689,2],[8,42,1689,6,1358],[13,42,1689,11,1361],[19,42,1689,17],[24,42,1689,22],[27,42,1689,25]],[[8,42,1690,4],[15,42,1690,11]],[[4,42,1691,2]],[[4,42,1692,2],[10,42,1692,8,1364],[18,42,1692,16,1358],[22,42,1692,20],[23,42,1692,21],[25,42,1692,23]],[[4,42,1693,2,1364],[10,42,1693,8,1215],[20,42,1693,18],[23,42,1693,21],[24,42,1693,22]],[[4,42,1694,2],[10,42,1694,8,1365],[17,42,1694,15,1358],[22,42,1694,20,1366],[25,42,1694,23]],[[4,42,1695,2],[8,42,1695,6,1365],[17,42,1695,15,1364],[24,42,1695,22]],[[8,42,1696,4,1358],[12,42,1696,8],[13,42,1696,9],[15,42,1696,11],[18,42,1696,14,1365]],[[8,42,1697,4,1365],[13,42,1697,9,1215],[23,42,1697,19],[26,42,1697,22]],[[8,42,1698,4,1367],[21,42,1698,17,1358],[27,42,1698,23,1365],[33,42,1698,29]],[[4,42,1699,2]],[[4,42,1700,2],[11,42,1700,9,1364]],[[0,42,1701,0]],[[0,42,1703,0],[9,42,1703,9,1218],[20,42,1703,20,1358],[24,42,1703,45],[26,42,1703,47,1359],[30,42,1703,65]],[[4,42,1704,2],[10,42,1704,8,1360],[18,42,1704,16,1359],[23,42,1704,21,1215],[33,42,1704,31]],[[4,42,1705,2],[8,42,1705,6,1360],[18,42,1705,16],[19,42,1705,17],[22,42,1705,20]],[[8,42,1706,4,1359],[13,42,1706,9,1215],[23,42,1706,19],[26,42,1706,22],[27,42,1706,23]],[[8,42,1707,4],[12,42,1707,8,1358],[17,42,1707,13,1361],[23,42,1707,19],[28,42,1707,24],[31,42,1707,27]],[[12,42,1708,6],[18,42,1708,12,1365],[25,42,1708,19,1358],[30,42,1708,24,1366],[33,42,1708,27]],[[12,42,1709,6],[16,42,1709,10,1365],[25,42,1709,19,1359],[31,42,1709,25]],[[16,42,1710,8,1358],[20,42,1710,12],[21,42,1710,13,1360],[27,42,1710,19],[30,42,1710,22,1365]],[[16,42,1711,8,1365],[21,42,1711,13,1215],[31,42,1711,23],[34,42,1711,26,1360]],[[16,42,1712,8,1367],[29,42,1712,21,1358],[35,42,1712,27,1365],[41,42,1712,33,1360]],[[12,42,1713,6]],[[8,42,1714,4]],[[4,42,1715,2]],[[0,42,1716,0]],[[0,42,1718,0],[9,42,1718,9,1221],[20,42,1718,20,1358],[24,42,1718,45],[26,42,1718,47,1359],[30,42,1718,65]],[[4,42,1719,2],[10,42,1719,8,1360],[18,42,1719,16,1359],[23,42,1719,21,1215],[33,42,1719,31]],[[4,42,1720,2],[8,42,1720,6,1360],[18,42,1720,16],[19,42,1720,17],[22,42,1720,20]],[[8,42,1721,4],[12,42,1721,8,1360],[22,42,1721,18],[25,42,1721,21]],[[12,42,1722,6,1367],[25,42,1722,19,1358],[31,42,1722,25,1359],[37,42,1722,31]],[[8,42,1723,4],[15,42,1723,11]],[[12,42,1724,6],[18,42,1724,12,1368],[32,42,1724,27,1360],[40,42,1724,35],[46,42,1724,42]],[[12,42,1725,6],[18,42,1725,12,1369],[27,42,1725,21,1358],[31,42,1725,25],[32,42,1725,26,1368],[44,42,1725,38]],[[12,42,1726,6],[16,42,1726,10,1353],[37,42,1726,31,1369],[45,42,1726,39,1359],[53,42,1726,47],[56,42,1726,50]],[[16,42,1727,8],[49,42,1727,41]],[[16,42,1728,8,1363],[27,42,1728,19,1358],[33,42,1728,25,1359],[39,42,1728,31,1360]],[[12,42,1729,6],[19,42,1729,13]],[[16,42,1730,8],[63,42,1730,55]],[[16,42,1731,8,1367],[29,42,1731,21,1358],[35,42,1731,27,1359],[41,42,1731,33,1360]],[[12,42,1732,6]],[[8,42,1733,4]],[[4,42,1734,2]],[[0,42,1735,0]],[[0,42,1737,0],[9,42,1737,9,1363],[20,42,1738,2,1358],[24,42,1738,27],[26,42,1739,2,1359],[30,42,1739,20],[32,42,1740,2,1370],[33,42,1740,11]],[[4,42,1742,2],[8,42,1742,6,1360],[16,42,1742,14,1370]],[[4,42,1743,2],[10,42,1743,9,1360],[18,42,1743,17],[20,42,1743,20]],[[8,42,1744,4],[14,42,1744,10,1368],[28,42,1744,25,1360],[36,42,1744,33],[42,42,1744,40]],[[8,42,1745,4],[14,42,1745,10,1369],[23,42,1745,19,1358],[27,42,1745,23],[28,42,1745,24,1368],[40,42,1745,36]],[[8,42,1746,4],[12,42,1746,8,1353],[33,42,1746,29,1369],[41,42,1746,37,1359],[49,42,1746,45],[52,42,1746,48]],[[12,42,1747,6],[52,42,1747,46]],[[12,42,1748,6,1358],[16,42,1748,10],[17,42,1748,11,1368],[29,42,1748,23],[32,42,1748,26,1359]],[[12,42,1749,6,1359],[17,42,1749,11,1215],[27,42,1749,21],[30,42,1749,24,1368]],[[12,42,1750,6,1358],[16,42,1750,10],[17,42,1750,11,1360],[23,42,1750,17],[26,42,1750,20,1369]],[[12,42,1751,6,1369],[19,42,1751,13,1215],[29,42,1751,23],[32,42,1751,26,1360]],[[12,42,1753,6,1360],[20,42,1753,14,1368]],[[8,42,1754,4],[15,42,1754,11]],[[12,42,1755,6],[43,42,1755,37]],[[12,42,1756,6]],[[8,42,1757,4]],[[4,42,1758,2]],[[0,42,1759,0]],[[0,42,1761,0],[9,42,1761,9,1367],[22,42,1762,2,1358],[26,42,1762,27],[28,42,1763,2,1359],[32,42,1763,20],[34,42,1764,2,1370],[35,42,1764,11]],[[4,42,1766,2],[8,42,1766,6,1360],[16,42,1766,14,1370]],[[4,42,1767,2],[10,42,1767,8,1361],[19,42,1767,17,1358],[24,42,1767,22,1361],[30,42,1767,28]],[[4,42,1768,2],[10,42,1768,8,1371],[23,42,1768,21,1361],[34,42,1768,32]],[[4,42,1769,2],[10,42,1769,9,1360],[18,42,1769,17,1371],[29,42,1769,29]],[[8,42,1770,4],[14,42,1770,10,1372],[26,42,1770,23,1360],[27,42,1770,23,1360],[35,42,1770,31],[36,42,1770,31],[40,42,1770,36],[44,42,1770,40]],[[8,42,1771,4],[14,42,1771,10,1373],[21,42,1771,17,1358],[25,42,1771,21],[26,42,1771,22,1372],[36,42,1771,32]],[[8,42,1772,4],[14,42,1772,10,1374],[27,42,1772,23,1372],[39,42,1772,35]],[[8,42,1773,4],[14,42,1773,10,1375],[22,42,1773,18,1358],[26,42,1773,22],[27,42,1773,23,1374],[38,42,1773,34]],[[8,42,1775,4],[80,42,1775,76]],[[8,42,1776,4],[12,42,1776,8,1353],[33,42,1776,29,1373],[39,42,1776,35,1359],[47,42,1776,43],[50,42,1776,46]],[[12,42,1777,6],[16,42,1777,10,1374],[29,42,1777,23,1361],[39,42,1777,33,1353],[60,42,1777,54,1375],[67,42,1777,61,1373],[75,42,1777,69],[78,42,1777,72]],[[16,42,1778,8,1358],[20,42,1778,12],[21,42,1778,13,1360],[27,42,1778,19],[30,42,1778,22,1375]],[[16,42,1779,8,1375],[22,42,1779,14,1215],[32,42,1779,24],[35,42,1779,27,1360]],[[16,42,1780,8,1358],[20,42,1780,12],[21,42,1780,13,1374],[32,42,1780,24],[35,42,1780,27,1359]],[[16,42,1781,8,1359],[21,42,1781,13,1215],[31,42,1781,23],[34,42,1781,26,1374]],[[16,42,1783,8,1360],[24,42,1783,16,1374]],[[12,42,1784,6],[19,42,1784,13]],[[16,42,1785,8,1358],[20,42,1785,12],[21,42,1785,13,1360],[27,42,1785,19],[30,42,1785,22,1373]],[[16,42,1786,8,1373],[21,42,1786,13,1215],[31,42,1786,23],[34,42,1786,26,1360]],[[16,42,1787,8,1358],[20,42,1787,12],[21,42,1787,13,1372],[31,42,1787,23],[34,42,1787,26,1359]],[[16,42,1788,8,1359],[21,42,1788,13,1215],[31,42,1788,23],[34,42,1788,26,1372]],[[16,42,1790,8,1360],[24,42,1790,16,1372]],[[12,42,1791,6]],[[8,42,1792,4],[15,42,1792,11],[19,42,1792,15,1374],[32,42,1792,28,1361],[42,42,1792,38,1353],[63,42,1792,59,1375],[70,42,1792,66,1359],[78,42,1792,74],[81,42,1792,77]],[[12,42,1793,6,1358],[16,42,1793,10],[17,42,1793,11,1360],[23,42,1793,17],[26,42,1793,20,1375]],[[12,42,1794,6,1375],[18,42,1794,12,1215],[28,42,1794,22],[31,42,1794,25,1360]],[[12,42,1795,6,1358],[16,42,1795,10],[17,42,1795,11,1374],[28,42,1795,22],[31,42,1795,25,1359]],[[12,42,1796,6,1359],[17,42,1796,11,1215],[27,42,1796,21],[30,42,1796,24,1374]],[[12,42,1798,6,1360],[20,42,1798,14,1374]],[[8,42,1799,4],[15,42,1799,11]],[[12,42,1800,6],[46,42,1800,40]],[[12,42,1801,6]],[[8,42,1802,4]],[[4,42,1803,2]],[[0,42,1804,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,43,8,31,1379],[8,43,8,39,1380],[11,43,8,42],[12,43,8,43,1381],[40,43,8,71]],[],[],[],[],[[31,43,7,13,1376],[61,43,7,13,1376]],[],[],[[15,43,7,13,1376]],[],[],[[37,43,0,36]],[[27,43,1,26]],[[0,43,7,7],[6,43,7,13,1376],[35,43,7,42],[36,43,7,43,1377]],[[4,43,8,2],[8,43,8,6],[9,43,8,7,1377],[14,43,8,12,1378],[24,43,8,22],[25,43,8,23],[75,43,8,73]],[[8,43,9,4],[15,43,9,11,1377]],[[4,43,10,2]],[[4,43,12,2],[10,43,12,8],[12,43,12,10,1382],[20,43,12,18],[22,43,12,20,1383],[27,43,12,25],[29,43,12,27,1384],[33,43,12,31],[35,43,12,33],[38,43,12,36,1385],[39,43,12,36,1385],[42,43,12,36,1385],[53,43,12,36,1385],[62,43,12,45],[64,43,12,46,1377]],[[4,43,13,2],[8,43,13,6,1379],[16,43,13,14,1380],[19,43,13,17],[20,43,13,18,1386],[41,43,13,39],[43,43,13,41]],[],[[4,43,23,2],[11,43,23,9],[14,43,23,12,1388],[15,43,23,12,1388],[18,43,23,12,1388],[39,43,23,12,1388],[58,43,23,31],[60,43,23,32,1382],[72,43,23,44,1383],[80,43,23,52,1384],[86,43,23,58]],[[0,43,24,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,44,3,18,1392],[8,44,3,26,1393],[11,44,3,29],[12,44,3,30,1394],[34,44,3,52]],[],[],[],[],[[31,44,5,16,1390],[46,44,5,16,1390]],[],[],[[15,44,5,16,1390]],[],[],[[31,44,0,30]],[[40,44,1,43]],[[0,44,3,0],[6,44,3,6,1391],[57,44,3,67]],[[0,44,5,7],[9,44,5,16,1390],[21,44,5,28,1395],[25,44,5,40],[27,44,5,42,1396],[35,44,5,60]],[[4,44,6,2],[11,44,6,9,1397],[12,44,6,9,1397],[15,44,6,9,1397],[39,44,6,9,1397],[65,44,6,35],[67,44,7,4,1392],[75,44,7,12,1393],[78,44,7,15],[79,44,7,16,1398],[105,44,8,8,1395],[109,44,7,46],[113,44,7,50],[114,44,7,51,1396],[131,44,9,8,1399],[132,44,9,8,1399],[135,44,9,8,1399],[150,44,9,8,1399],[163,44,9,21],[165,44,9,22,1395],[171,44,9,28,1391]],[[0,44,11,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,45,32,6,1414],[8,45,32,14,1415],[11,45,32,17],[12,45,32,18,1416],[20,45,32,26],[25,45,32,31]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,45,14,16,1400],[21,45,14,33],[23,45,14,33]],[[15,45,14,16,1400]],[],[[4,45,3,16,1401],[17,45,3,29],[19,45,3,29]],[[15,45,3,16,1401]],[],[],[[23,45,0,22]],[[29,45,1,28]],[[0,45,3,7],[9,45,3,16,1401],[23,45,3,30,1402],[26,45,3,38]],[[4,45,4,2],[11,45,4,9,1402],[15,45,4,13,1403],[21,45,4,19],[26,45,4,24,1404],[33,45,4,31,1405],[41,45,4,39],[42,45,4,40,1403],[48,45,4,46]],[[0,45,5,0]],[[0,45,14,7],[9,45,14,16,1400],[27,45,14,34,1406],[31,45,14,46]],[[4,45,15,2],[54,45,15,52]],[[4,45,16,2],[8,45,16,6,1407],[9,45,16,6,1407],[12,45,16,6,1407],[19,45,16,6,1407],[24,45,16,11],[26,45,16,12,1404],[33,45,16,19,1408],[42,45,16,28],[43,45,16,29,1409],[52,45,16,38],[55,45,16,41]],[[8,45,17,4],[15,45,17,11]],[[4,45,18,2]],[[4,45,20,2],[8,45,20,6,1402]],[[4,45,21,2],[8,45,21,6]],[[8,45,22,4,1402],[14,45,22,10],[18,45,22,14,1410],[22,45,22,18,1411],[23,45,22,18,1411],[26,45,22,18,1411],[39,45,22,18,1411],[50,45,22,29],[52,45,22,30,1406],[59,45,22,37,1404],[66,45,22,44,1405],[74,45,22,52],[75,45,22,53,1406],[79,45,22,57]],[[4,45,23,2],[6,45,23,4],[13,45,23,11,1412],[16,45,23,14]],[[8,45,24,4],[83,45,24,79]],[[8,45,25,4],[58,45,25,54]],[[8,45,26,4],[14,45,26,10],[21,45,26,10],[35,45,28,5],[36,45,26,10],[40,45,26,14,1413],[46,45,27,6],[47,45,27,7],[64,45,27,24],[66,45,27,26,1406],[71,45,27,31],[113,45,27,73],[114,45,27,74],[117,45,26,10],[138,45,26,10]],[[19,45,26,10]],[[24,45,26,10]],[[26,45,26,10]],[[8,45,28,4]],[[4,45,29,2]],[[4,45,31,2],[75,45,31,73]],[[4,45,32,2],[44,45,32,46]],[[8,45,33,4],[15,45,33,11]],[[4,45,34,2]],[],[],[[0,45,42,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,46,235,6,1472],[8,46,235,14,1473],[11,46,235,17],[12,46,235,18,1474],[20,46,235,26],[25,46,235,31]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,46,64,13,1417],[20,46,64,29],[22,46,64,29]],[[15,46,64,13,1417]],[],[[4,46,61,13,1418],[23,46,61,32],[25,46,61,32]],[[15,46,61,13,1418]],[],[[4,46,184,16,1419],[21,46,184,33],[23,46,184,33]],[[15,46,184,16,1419]],[],[[4,46,146,16,1420],[21,46,146,33],[23,46,146,33]],[[15,46,146,16,1420]],[],[[4,46,234,16,1421],[27,46,234,39],[29,46,234,39]],[[15,46,234,16,1421]],[],[[4,46,256,16,1422],[22,46,256,34],[24,46,256,34]],[[15,46,256,16,1422]],[],[[4,46,329,16,1423],[20,46,329,32],[22,46,329,32]],[[15,46,329,16,1423]],[],[[4,46,70,16,1424],[31,46,70,43],[33,46,70,43]],[[15,46,70,16,1424]],[],[[4,46,79,16,1425],[35,46,79,47],[37,46,79,47]],[[15,46,79,16,1425]],[],[[4,46,209,16,1426],[31,46,209,43],[33,46,209,43]],[[15,46,209,16,1426]],[],[],[[23,46,6,7]],[[26,46,7,31]],[[27,46,14,7]],[[23,46,15,32]],[[0,46,56,0],[73,46,56,73]],[[0,46,57,0],[60,46,57,60]],[[0,46,58,0],[4,46,58,4,1427],[34,46,58,55]],[[0,46,61,7],[6,46,61,13,1418],[28,46,61,35]],[[4,46,61,37,1428],[13,46,61,46]],[[0,46,61,51]],[[0,46,64,7],[6,46,64,13,1417],[25,46,64,32]],[[4,46,64,34,1428],[13,46,64,43]],[[0,46,64,49]],[[0,46,70,7],[9,46,70,16,1424],[37,46,70,44,1429],[41,46,70,69]],[[4,46,71,2,1430],[5,46,71,2,1430],[8,46,71,2,1430],[15,46,71,2,1430],[30,46,71,17],[32,46,71,18]],[[8,46,72,4,1427],[37,46,72,33,1431],[61,46,72,57,1417]],[[8,46,73,4,1429],[14,46,73,10,1431],[38,46,73,34,1418]],[[8,46,74,4,1427],[38,46,74,34,1429]],[[4,46,75,2]],[[0,46,76,0]],[[0,46,79,7],[9,46,79,16,1425],[41,46,79,48,1429],[45,46,79,66]],[[4,46,80,2],[8,46,80,6,1427],[40,46,80,38,1429],[46,46,80,44]],[[8,46,81,4,1427],[38,46,81,34]],[[4,46,82,2]],[[0,46,83,0]],[[0,46,85,0],[75,46,85,75]],[[0,46,86,0],[67,46,86,67]],[[0,46,87,0],[6,46,87,6,1432],[21,46,90,2],[28,46,90,9,1433],[40,46,90,21],[53,46,90,34],[57,46,90,38,1433],[69,46,90,50],[73,46,90,54,1434]],[[0,46,92,0],[77,46,92,77]],[[0,46,93,0],[76,46,93,76]],[[0,46,94,0],[74,46,94,74]],[[0,46,95,0],[17,46,95,17]],[[0,46,96,0],[6,46,96,6,1435],[31,46,96,58],[35,46,96,62,1436]],[[0,46,98,0],[74,46,98,74]],[[0,46,99,0],[6,46,99,6,1437],[17,46,100,2],[24,46,100,9,1438],[49,46,100,34],[62,46,101,6],[66,46,101,10,1438],[87,46,101,31,1439],[104,46,101,48]],[[4,46,102,8,1440],[16,46,102,20]],[[0,46,103,6],[5,46,104,6]],[[0,46,106,0],[9,46,106,9,1441],[27,46,106,27,1442],[34,46,106,43],[36,46,106,45,1443],[44,46,106,75]],[[4,46,107,2],[10,46,107,8,1444],[29,46,107,27,1432],[42,46,107,40,1445],[45,46,107,43],[46,46,107,44,1442]],[[4,46,108,2],[8,46,108,6,1444],[29,46,108,27,1446],[40,46,108,38]],[[8,46,109,4],[82,46,109,78]],[[8,46,110,4],[83,46,110,79]],[[8,46,111,4],[55,46,111,51]],[[8,46,112,4,1426],[36,46,112,32,1442]],[[4,46,113,2]],[[4,46,114,2],[67,46,114,65]],[[4,46,115,2,1432],[17,46,115,15,1447],[20,46,115,18],[21,46,115,19,1442],[30,46,115,28,1443]],[[4,46,116,2],[8,46,116,6,1437],[21,46,116,19],[27,46,116,25]],[[8,46,117,4,1437],[17,46,117,13,1448],[24,46,117,20],[25,46,117,21,1442]],[[4,46,118,2]],[[0,46,119,0]],[[0,46,121,0],[9,46,121,9,1449],[31,46,121,31,1450],[35,46,121,43]],[[4,46,122,2],[8,46,122,6],[15,46,122,13,1451],[26,46,122,24],[39,46,122,37]],[[8,46,123,4],[14,46,123,10],[16,46,123,12,1452],[33,46,123,29],[35,46,123,31],[38,46,124,6,1453],[46,46,124,14]],[[8,46,126,4],[12,46,126,8]],[[12,46,127,6],[19,46,127,13,1452],[37,46,127,31,1450]],[[8,46,128,4],[10,46,128,6],[17,46,128,12]],[[12,46,129,6],[79,46,129,73]],[[12,46,130,6],[72,46,130,66]],[[12,46,131,6],[86,46,131,80]],[[12,46,132,6],[84,46,132,78]],[[12,46,133,6],[44,46,133,38]],[[12,46,134,6],[18,46,134,12,1454],[34,46,135,8],[41,46,135,15,1455],[57,46,135,31],[70,46,135,44,1455],[84,46,135,58,1456],[92,46,135,66,1457],[97,46,135,71]],[[12,46,136,6,1454],[26,46,137,8],[27,46,137,9],[44,46,137,26],[46,46,137,28,1450],[51,46,137,33],[93,46,137,75],[94,46,137,76]],[[12,46,139,6],[19,46,139,13]],[[8,46,140,4]],[[4,46,141,2],[11,46,141,9]],[[8,46,142,4],[15,46,142,11]],[[4,46,143,2]],[[0,46,144,0]],[[0,46,146,7],[9,46,146,16,1420],[27,46,147,2,1442],[34,46,147,22],[36,46,148,2,1450],[40,46,148,14],[42,46,149,2,1458],[48,46,149,27],[50,46,150,2,1459],[63,46,150,42],[65,46,151,2,1460],[80,46,151,26],[82,46,152,2,1431],[105,46,152,65]],[[4,46,154,2],[8,46,154,6,1460],[25,46,154,23]],[[8,46,155,4],[14,46,155,10,1461],[28,46,155,24,1449],[50,46,155,46,1450]],[[8,46,156,4],[12,46,156,8,1461],[28,46,156,24],[34,46,156,30]],[[12,46,157,6],[18,46,157,12,1443],[29,46,157,49]],[[16,46,158,8,1458]],[[16,46,159,8,1459]],[[16,46,160,8,1462],[27,46,160,19]],[[16,46,161,8,1463],[30,46,161,22]],[[16,46,162,8,1464],[30,46,162,22,1461],[42,46,162,34,1450],[46,46,162,38]],[[16,46,163,8,1431]],[[12,46,164,6]],[[12,46,165,6],[78,46,165,72]],[[12,46,166,6],[61,46,166,55]],[[12,46,167,6,1441],[30,46,167,24,1442],[39,46,167,33,1443]],[[12,46,168,6],[19,46,168,13,1443]],[[8,46,169,4]],[[4,46,170,2]],[[4,46,171,2],[77,46,171,75]],[[4,46,172,2],[55,46,172,53]],[[4,46,173,2],[10,46,173,8,1443],[21,46,173,48]],[[8,46,174,4,1458]],[[8,46,175,4,1459]],[[8,46,176,4,1462],[19,46,176,15]],[[8,46,177,4,1463],[22,46,177,18]],[[8,46,178,4,1464],[22,46,178,18]],[[8,46,179,4,1431]],[[4,46,180,2]],[[4,46,181,2],[11,46,181,9,1443]],[[0,46,182,0]],[[0,46,184,7],[9,46,184,16,1419],[27,46,185,2,1442],[34,46,185,26],[36,46,186,2,1450],[40,46,186,14],[42,46,187,2,1458],[48,46,187,27],[50,46,188,2,1459],[63,46,188,42]],[[4,46,190,2],[10,46,190,8,1461],[24,46,190,22,1449],[46,46,190,44,1450]],[[4,46,191,2],[8,46,191,6,1461],[24,46,191,22],[30,46,191,28]],[[8,46,192,4],[63,46,192,59]],[[8,46,193,4],[83,46,193,79]],[[8,46,194,4],[84,46,194,80]],[[8,46,195,4],[72,46,195,68]],[[8,46,196,4]],[[4,46,197,2]],[[4,46,198,2],[10,46,198,8,1443],[21,46,198,33]],[[8,46,199,4,1458]],[[8,46,200,4,1459]],[[8,46,201,4,1462],[19,46,201,15]],[[8,46,202,4,1463],[22,46,202,18]],[[8,46,203,4,1464],[22,46,203,18,1461],[34,46,203,30,1450],[38,46,203,34]],[[8,46,204,4,1431],[33,46,204,29]],[[4,46,205,2]],[[4,46,206,2,1441],[22,46,206,20,1442],[31,46,206,29,1443]],[[0,46,207,0]],[[0,46,209,7],[9,46,209,16,1426],[37,46,209,44,1442],[44,46,209,60]],[[4,46,210,2],[10,46,210,8,1443],[21,46,210,19,1432],[34,46,210,32,1445],[37,46,210,35],[38,46,210,36,1442]],[[4,46,211,2],[8,46,211,6,1443],[21,46,211,19,1446],[32,46,211,30]],[[8,46,212,4,1432],[21,46,212,17,1465],[27,46,212,23],[28,46,212,24,1442]],[[8,46,213,4,1435],[31,46,213,27,1465],[37,46,213,33],[38,46,213,34,1443]],[[8,46,214,4],[14,46,214,10,1463],[29,46,214,25,1443],[38,46,214,34,1463],[50,46,214,46]],[[8,46,215,4],[12,46,215,8,1463],[29,46,215,25],[35,46,215,31]],[[12,46,216,6,1466],[13,46,216,6,1466],[16,46,216,6,1466],[27,46,216,6,1466],[45,46,216,24],[47,46,216,25,1463]],[[8,46,217,4]],[[4,46,218,2]],[[4,46,219,2],[8,46,219,6,1437],[21,46,219,19],[27,46,219,25]],[[8,46,220,4,1437],[17,46,220,13,1467],[26,46,220,22],[27,46,220,23,1442]],[[4,46,221,2]],[[0,46,222,0]],[[0,46,224,0],[9,46,224,9,1439],[25,46,224,25,1468],[32,46,224,66]],[[4,46,225,2],[9,46,225,7],[15,46,225,13,1469],[24,46,225,22,1468],[32,46,225,31]],[[8,46,226,4],[74,46,226,70]],[[8,46,227,4],[81,46,227,77]],[[8,46,228,4],[46,46,228,42]],[[8,46,229,4],[14,46,229,10,1462],[26,46,229,22,1469],[32,46,229,28,1470],[49,46,229,45],[52,46,229,48]],[[8,46,230,4,1421],[32,46,230,28,1469],[38,46,230,34,1471],[44,46,230,40],[46,46,230,63,1462]],[[4,46,231,2]],[[0,46,232,0]],[[0,46,234,7],[9,46,234,16,1421],[33,46,234,40,1442],[40,46,234,56],[42,46,234,58,1462],[51,46,234,76]],[[4,46,235,2],[44,46,235,45]],[[8,46,236,4],[77,46,236,73]],[[8,46,237,4],[66,46,237,62]],[[8,46,238,4],[46,46,238,42]],[[8,46,239,4]],[[4,46,240,2]],[],[],[[4,46,242,2],[10,46,242,8,1443],[21,46,242,19,1432],[34,46,242,32,1445],[37,46,242,35],[38,46,242,36,1442]],[[0,46,254,0]],[[0,46,256,7],[9,46,256,16,1422],[28,46,257,2,1442],[35,46,257,42],[37,46,258,2,1479],[70,46,258,44]],[[4,46,260,2],[10,46,260,8,1443],[21,46,260,19,1432],[34,46,260,32,1445],[37,46,260,35],[38,46,260,36,1442]],[[4,46,261,2],[8,46,261,6,1443],[21,46,261,19,1446],[32,46,261,30]],[[8,46,262,4]],[[4,46,263,2]],[[4,46,264,2],[45,46,264,43]],[[4,46,265,2],[8,46,265,6,1443],[21,46,265,19,1446],[32,46,265,30]],[[8,46,266,4],[12,46,267,6,1472],[20,46,267,14,1473],[23,46,267,17],[24,46,267,18,1480],[47,46,267,41],[51,46,268,6,1479],[86,46,269,6]],[],[[8,46,273,4,1476],[31,46,273,27,1443],[41,46,273,37,1477],[48,46,273,37,1477],[64,46,273,53],[65,46,273,54,1483],[71,46,273,60]],[[4,46,274,2]],[[0,46,275,0]],[[0,46,277,0],[9,46,277,9,1476],[32,46,278,2,1443],[40,46,278,32],[42,46,279,2,1484],[50,46,279,62]],[[4,46,281,2],[76,46,281,74]],[[4,46,282,2],[8,46,282,6],[15,46,282,13,1451],[26,46,282,24],[39,46,282,37]],[[8,46,283,4],[14,46,283,10,1485],[37,46,283,33,1443],[46,46,283,42,1463],[58,46,283,54]],[[8,46,285,4],[12,46,285,8],[13,46,285,9,1443],[22,46,285,18,1462],[31,46,285,27],[33,46,285,29]],[[12,46,286,6],[86,46,286,80]],[[12,46,287,6],[27,46,287,21]],[[12,46,288,6],[16,46,288,10,1485],[41,46,288,35],[47,46,288,41]],[[16,46,289,8,1466],[17,46,289,8,1466],[20,46,289,8,1466],[31,46,289,8,1466],[49,46,289,26],[51,46,289,27,1485]],[[12,46,290,6]],[[12,46,291,6],[84,46,291,78]],[[12,46,292,6],[88,46,292,82]],[[12,46,293,6],[80,46,293,74]],[[12,46,294,6],[64,46,294,58]],[[12,46,295,6]],[[8,46,296,4]],[[8,46,298,4],[14,46,298,10],[16,46,298,12,1486],[40,46,298,36],[42,46,298,38],[45,46,299,6,1453],[53,46,299,14]],[[8,46,301,4],[14,46,301,10,1487],[31,46,301,27,1486]],[[8,46,302,4],[12,46,302,8,1487],[31,46,302,27],[37,46,302,33]],[[12,46,303,6],[18,46,303,12,1488],[41,46,303,35,1487],[56,46,303,50,1489],[60,46,303,54]],[[12,46,304,6],[16,46,304,10,1485],[41,46,304,35],[47,46,304,41]],[[16,46,305,8],[44,46,305,36]],[[16,46,306,8],[22,46,306,14,1490],[32,46,306,24,1487],[47,46,306,39,1490],[54,46,306,46]],[[16,46,307,8],[22,46,307,14,1491],[33,46,307,25,1492],[34,46,307,25,1492],[37,46,307,25,1492],[47,46,307,25,1492],[61,46,307,39],[63,46,307,40,1443],[72,46,307,49,1464],[84,46,307,61],[86,46,307,63,1490]],[[16,46,308,8,1443],[25,46,308,17,1463],[37,46,308,29],[40,46,308,32,1493],[41,46,308,32,1493],[44,46,308,32,1493],[55,46,308,32,1493],[75,46,308,59],[77,46,309,10,1491],[87,46,310,10,1488],[109,46,311,10,1443],[118,46,311,19,1459],[131,46,311,32],[133,46,312,10,1484],[143,46,313,10]],[[12,46,315,6],[19,46,315,13]],[[16,46,316,8],[85,46,316,77]],[[16,46,317,8],[89,46,317,81]],[[16,46,318,8,1494],[17,46,318,8,1494],[20,46,318,8,1494],[31,46,318,8,1494],[53,46,318,30],[55,46,319,10,1485],[77,46,320,10,1488],[99,46,321,10,1443],[108,46,321,19,1459],[121,46,321,32],[123,46,322,10,1484]],[[12,46,324,6]],[[8,46,325,4]],[[4,46,326,2]],[[0,46,327,0]],[[0,46,329,7],[9,46,329,16,1423],[26,46,330,2,1490],[33,46,330,24],[35,46,331,2,1489],[39,46,331,25]],[[4,46,333,2],[80,46,333,78]],[[4,46,334,2],[81,46,334,79]],[[4,46,335,2],[59,46,335,57]],[[4,46,336,2],[6,46,336,4]],[[4,46,337,2],[77,46,337,75]],[[4,46,338,2],[73,46,338,71]],[[4,46,339,2],[26,46,339,24]],[[4,46,340,2],[9,46,340,7],[15,46,340,13,1443],[27,46,340,25,1435],[50,46,340,49]],[[8,46,341,4],[14,46,341,10,1495],[21,46,341,17,1443],[30,46,341,26,1463],[42,46,341,38]],[[8,46,342,4],[12,46,342,8,1495],[21,46,342,17],[29,46,342,25],[30,46,342,26,1496],[31,46,342,26,1496],[34,46,342,26,1496],[45,46,342,26,1496],[64,46,342,45],[66,46,342,46,1495],[72,46,342,52,1490],[81,46,342,61,1489],[88,46,342,68]],[[12,46,345,6]],[[8,46,346,4]],[[8,46,347,4],[78,46,347,74]],[[8,46,348,4],[19,46,348,15]],[[8,46,349,4],[12,46,349,8,1495],[21,46,349,17],[27,46,349,23]],[[12,46,350,6,1466],[13,46,350,6,1466],[16,46,350,6,1466],[27,46,350,6,1466],[45,46,350,24],[47,46,350,25,1495]],[[8,46,351,4]],[[8,46,352,4],[14,46,352,10,1491],[25,46,352,21,1492],[26,46,352,21,1492],[29,46,352,21,1492],[39,46,352,21,1492],[53,46,352,35],[55,46,352,36,1443],[64,46,352,45,1464],[76,46,352,57],[78,46,352,59,1490]],[[8,46,353,4,1443],[17,46,353,13,1463],[29,46,353,25],[32,46,353,28,1493],[33,46,353,28,1493],[36,46,353,28,1493],[47,46,353,28,1493],[67,46,353,55],[69,46,354,6,1491],[79,46,355,6,1489],[85,46,356,6,1443],[94,46,356,15,1459],[107,46,356,28],[109,46,357,6,1477],[116,46,357,6,1477],[132,46,357,22],[133,46,357,23,1478],[140,46,357,30],[142,46,358,6]],[[4,46,360,2]],[[0,46,361,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,47,271,2,1522],[8,47,271,10,1523],[11,47,271,13],[12,47,271,14,1524],[20,47,271,22]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,47,175,18,1497],[15,47,175,29],[17,47,175,29]],[[15,47,175,18,1497]],[],[[4,47,2292,16,1498],[41,47,2292,53],[43,47,2292,53]],[[15,47,2292,16,1498]],[],[[4,47,1268,16,1499],[39,47,1268,51],[41,47,1268,51]],[[15,47,1268,16,1499]],[],[[4,47,816,16,1500],[35,47,816,47],[37,47,816,47]],[[15,47,816,16,1500]],[],[[4,47,1289,22,1501],[25,47,1289,43],[27,47,1289,43]],[[15,47,1289,22,1501]],[],[[4,47,1565,22,1502],[27,47,1565,45],[29,47,1565,45]],[[15,47,1565,22,1502]],[],[[4,47,1682,22,1503],[45,47,1682,63],[47,47,1682,63]],[[15,47,1682,22,1503]],[],[[4,47,295,16,1504],[26,47,295,38],[28,47,295,38]],[[15,47,295,16,1504]],[],[[4,47,96,16,1505],[18,47,96,30],[20,47,96,30]],[[15,47,96,16,1505]],[],[[4,47,741,16,1506],[42,47,741,54],[44,47,741,54]],[[15,47,741,16,1506]],[],[[4,47,364,16,1507],[29,47,364,41],[31,47,364,41]],[[15,47,364,16,1507]],[],[[4,47,691,16,1508],[40,47,691,52],[42,47,691,52]],[[15,47,691,16,1508]],[],[[4,47,449,16,1509],[31,47,449,43],[33,47,449,43]],[[15,47,449,16,1509]],[],[[4,47,668,16,1510],[33,47,668,45],[35,47,668,45]],[[15,47,668,16,1510]],[],[[4,47,383,16,1511],[23,47,383,35],[25,47,383,35]],[[15,47,383,16,1511]],[],[[4,47,402,16,1512],[25,47,402,37],[27,47,402,37]],[[15,47,402,16,1512]],[],[[4,47,493,16,1513],[36,47,493,48],[38,47,493,48]],[[15,47,493,16,1513]],[],[[4,47,305,16,1514],[25,47,305,37],[27,47,305,37]],[[15,47,305,16,1514]],[],[[4,47,838,16,1515],[27,47,838,39],[29,47,838,39]],[[15,47,838,16,1515]],[],[[4,47,761,16,1516],[22,47,761,34],[24,47,761,34]],[[15,47,761,16,1516]],[],[[4,47,430,16,1517],[28,47,430,40],[30,47,430,40]],[[15,47,430,16,1517]],[],[],[[32,47,10,35]],[[34,47,20,7]],[[37,47,26,7]],[[27,47,33,7]],[[26,47,47,7]],[[28,47,48,30]],[[35,47,49,34]],[[26,47,52,59]],[[29,47,59,7]],[[26,47,69,7]],[[38,47,77,7]],[[35,47,85,7]],[[33,47,86,36]],[[23,47,87,33]],[[25,47,88,33]],[[23,47,89,30]],[[38,47,90,43]],[[0,47,96,7],[9,47,96,16,1505],[24,47,96,31,1518],[40,47,96,55]],[[4,47,97,2],[11,47,97,9,1519],[16,47,97,14,1520],[19,47,97,17],[20,47,97,18,1518],[38,47,97,36],[44,47,97,42]],[[0,47,98,0]],[[0,47,175,7],[4,47,175,18,1497],[18,47,175,18,1497],[29,47,175,18,1497],[32,47,175,18,1497],[41,47,175,18,1497],[52,47,175,18,1497]],[],[],[],[],[[11,47,175,18,1497]],[],[[0,47,270,0],[6,47,270,6,1521],[79,47,271,27],[95,47,272,2,1522],[103,47,272,10,1523],[106,47,272,13],[107,47,272,14,1525],[127,47,272,34],[140,47,272,39]],[[0,47,274,0],[6,47,274,6,1526],[32,47,274,51]],[[4,47,275,2]],[[4,47,276,2],[5,47,276,3]],[[4,47,277,2]],[[4,47,278,2]],[[1,47,279,1]],[[0,47,281,0],[4,47,281,4,1527],[20,47,281,47,1528],[21,47,281,47,1528],[24,47,281,47,1528],[34,47,281,47,1528],[48,47,281,61]],[[0,47,282,0],[4,47,282,4,1529],[22,47,282,51,1528],[23,47,282,51,1528],[26,47,282,51,1528],[36,47,282,51,1528],[50,47,282,65]],[[0,47,284,0],[76,47,284,76]],[[0,47,285,0],[78,47,285,78]],[[0,47,286,0],[68,47,286,68]],[[0,47,287,0],[78,47,287,78]],[[0,47,288,0],[75,47,288,75]],[[0,47,289,0],[28,47,289,28]],[[0,47,290,0],[4,47,290,4,1530],[28,47,290,54]],[[0,47,292,0],[58,47,292,58]],[[0,47,293,0],[4,47,293,4,1531],[26,47,293,26]],[[0,47,295,7],[9,47,295,16,1504]],[[4,47,296,2],[11,47,296,9,1531]],[[0,47,297,0]],[[0,47,305,7],[9,47,305,16,1514],[31,47,306,2,1532],[38,47,306,24],[40,47,307,2,1533],[44,47,307,25]],[[4,47,309,2],[80,47,309,78]],[[4,47,310,2],[78,47,310,76]],[[4,47,311,2],[75,47,311,73]],[[4,47,312,2],[75,47,312,73]],[[4,47,313,2],[77,47,313,75]],[[4,47,314,2],[45,47,314,43]],[[4,47,315,2,1531]],[[4,47,317,2],[77,47,317,75]],[[4,47,318,2,1534],[5,47,318,2,1534],[8,47,318,2,1534],[19,47,318,2,1534],[44,47,318,27]],[[4,47,320,2],[76,47,320,74]],[[4,47,321,2,1535],[5,47,321,2,1535],[8,47,321,2,1535],[15,47,321,2,1535],[31,47,321,18],[33,47,321,19,1532],[42,47,321,28,1533]],[[4,47,323,2],[73,47,323,71]],[[4,47,324,2],[75,47,324,73]],[[4,47,325,2],[17,47,325,15]],[[4,47,326,2,1507],[30,47,326,28,1532],[39,47,326,37,1533]],[[0,47,327,0]],[[0,47,329,0],[9,47,329,9,1536],[36,47,329,36,1537],[40,47,329,54]],[[4,47,330,2],[79,47,330,77]],[[4,47,331,2],[78,47,331,76]],[[4,47,332,2],[79,47,332,77]],[[4,47,333,2],[79,47,333,77]],[[4,47,334,2],[44,47,334,42]],[[4,47,335,2],[8,47,335,6,1537],[13,47,335,11,1538],[25,47,335,23],[30,47,335,28],[36,47,335,34]],[[8,47,336,4],[12,47,336,8,1530],[38,47,336,34],[44,47,336,40]],[[12,47,337,6,1530],[36,47,337,30],[40,47,337,34,1539],[44,47,337,38]],[[16,47,337,39,1537]],[[13,47,337,44]],[[8,47,338,4],[15,47,338,11]],[[12,47,339,6,1530],[34,47,339,28,1540],[37,47,339,31],[38,47,339,32,1537]],[[8,47,340,4]],[[4,47,341,2]],[[0,47,342,0]],[[0,47,344,0],[9,47,344,9,1541],[36,47,344,36,1537],[40,47,344,54]],[[4,47,345,2],[10,47,345,8,1538],[25,47,345,23,1537],[30,47,345,28,1538],[42,47,345,40]],[[4,47,346,2],[8,47,346,6,1538],[25,47,346,23],[31,47,346,29]],[[8,47,347,4],[84,47,347,80]],[[8,47,348,4],[21,47,348,17]],[[8,47,349,4,1537],[13,47,349,9,1538],[25,47,349,21],[28,47,349,24]],[[8,47,351,4],[71,47,351,67]],[[8,47,352,4],[12,47,352,8]],[[12,47,353,6,1538]],[[8,47,354,4],[10,47,354,6],[17,47,354,13,1542],[24,47,354,20]],[[12,47,355,6],[16,47,355,10],[23,47,355,17,1543],[39,47,355,33],[51,47,355,45]],[[16,47,356,8,1543],[28,47,356,20,1542]],[[12,47,357,6],[19,47,357,13]],[[16,47,358,8,1544],[24,47,358,16,1542],[29,47,358,21],[30,47,358,22,1542]],[[12,47,359,6]],[[8,47,360,4]],[[4,47,361,2]],[[0,47,362,0]],[[0,47,364,7],[9,47,364,16,1507],[35,47,365,2,1532],[42,47,365,24],[44,47,366,2,1533],[48,47,366,25]],[[4,47,368,2],[80,47,368,78]],[[4,47,369,2],[77,47,369,75]],[[4,47,370,2],[73,47,370,71]],[[4,47,371,2],[26,47,371,24]],[[4,47,372,2],[8,47,372,6,1530],[34,47,372,32],[40,47,372,38]],[[8,47,373,4],[14,47,373,10,1545],[22,47,373,18,1530]],[[8,47,374,4,1530],[32,47,374,28]],[[8,47,375,4],[13,47,375,9],[19,47,375,15,1537],[27,47,375,23,1545],[33,47,375,30]],[[12,47,376,6],[16,47,376,10,1546],[17,47,376,10,1546],[20,47,376,10,1546],[31,47,376,10,1546],[50,47,376,29],[52,47,376,30,1537],[58,47,376,36,1532],[67,47,376,45,1533],[74,47,376,52]],[[16,47,377,8,1541],[43,47,377,35,1537]],[[12,47,378,6]],[[8,47,379,4]],[[4,47,380,2]],[[0,47,381,0]],[[0,47,383,7],[9,47,383,16,1511],[29,47,384,2,1547],[32,47,384,13],[34,47,385,2,1548],[37,47,385,20]],[[4,47,387,2],[10,47,387,8,1549],[21,47,387,34,1550],[22,47,387,34,1550],[25,47,387,34,1550],[35,47,387,34,1550],[51,47,387,50],[53,47,388,4,1548],[57,47,388,8,1551],[65,47,388,16],[67,47,389,4,1548],[71,47,389,8,1552],[77,47,389,14],[79,47,390,4,1548],[83,47,390,8,1532],[90,47,390,15]],[[4,47,392,2],[10,47,392,8,1553],[27,47,392,25]],[[4,47,393,2],[11,47,393,9,1554],[12,47,393,9,1554],[15,47,393,9,1554],[25,47,393,9,1554],[40,47,393,24],[42,47,394,4,1547],[47,47,395,4,1504],[73,47,396,4,1527],[88,47,397,4,1549],[98,47,398,4,1553]],[[0,47,400,0]],[[0,47,402,7],[9,47,402,16,1512],[31,47,403,2,1547],[34,47,403,13],[36,47,404,2,1549],[44,47,404,27]],[[4,47,406,2],[10,47,406,8,1553],[27,47,406,25]],[[4,47,407,2],[11,47,407,9,1554],[12,47,407,9,1554],[15,47,407,9,1554],[25,47,407,9,1554],[40,47,407,24],[42,47,408,4,1547],[47,47,409,4,1504],[73,47,410,4,1529],[90,47,411,4,1549],[100,47,412,4,1553]],[[0,47,414,0]],[[0,47,416,0],[9,47,416,9,1555],[43,47,417,2,1547],[46,47,417,13],[48,47,418,2,1549],[56,47,418,27]],[[4,47,420,2],[10,47,420,8,1553],[27,47,420,25]],[[4,47,421,2],[11,47,421,9,1554],[12,47,421,9,1554],[15,47,421,9,1554],[25,47,421,9,1554],[40,47,421,24],[42,47,422,4,1547],[47,47,423,4,1504],[73,47,424,4,1529],[90,47,425,4,1549],[100,47,426,4,1553]],[[0,47,428,0]],[[0,47,430,7],[9,47,430,16,1517],[34,47,431,2,1556],[46,47,431,40]],[[4,47,433,2],[75,47,433,73]],[[4,47,434,2],[80,47,434,78]],[[4,47,435,2],[8,47,435,6,1557],[31,47,435,29,1556],[44,47,435,42,1558],[51,47,435,49]],[[4,47,436,2],[8,47,436,6,1557],[33,47,436,31],[39,47,436,37]],[[8,47,437,4,1557],[31,47,437,27,1556],[44,47,437,40,1558],[51,47,437,47],[54,47,438,6,1559],[55,47,438,6,1559],[58,47,438,6,1559],[80,47,438,6,1559],[106,47,438,32]],[[4,47,439,2],[11,47,439,9]],[[4,47,440,4],[43,47,440,43]],[[4,47,441,2]],[[4,47,442,2],[11,47,442,9,1557],[32,47,442,30,1558],[39,47,442,37]],[[0,47,443,0]],[[0,47,449,7],[9,47,449,16,1509],[37,47,450,2,1547],[40,47,450,13],[42,47,451,2,1537],[46,47,451,20],[48,47,452,2,1548],[51,47,452,20]],[[4,47,454,2,1536],[31,47,454,29,1537]],[[4,47,456,2],[10,47,456,8,1560],[26,47,456,24,1511],[46,47,456,44,1547],[51,47,456,49,1548]],[[4,47,457,2],[8,47,457,6,1560],[26,47,457,24],[32,47,457,30]],[[8,47,458,4],[15,47,458,11,1560]],[[4,47,459,2]],[[4,47,460,2],[54,47,460,52]],[[4,47,461,2],[10,47,461,8,1556],[25,47,461,47]],[[8,47,462,4,1561],[22,47,462,18]],[[8,47,463,4,1562],[14,47,463,10],[16,47,463,10]],[[8,47,464,4,1563],[22,47,464,18]],[[8,47,465,4,1533],[14,47,465,10]],[[8,47,466,4,1564],[18,47,466,14]],[[8,47,467,4],[82,47,467,78]],[[8,47,468,4],[82,47,468,78]],[[8,47,469,4],[27,47,469,23]],[[8,47,470,4,1565],[28,47,470,24]],[[8,47,471,4],[66,47,471,62]],[[8,47,472,4,1566],[22,47,472,18]],[[8,47,473,4,1567],[24,47,473,20]],[[8,47,475,4],[29,47,475,25]],[[8,47,476,4,1568],[13,47,476,9]],[[8,47,477,4,1569],[14,47,477,10]],[[8,47,478,4],[84,47,478,80]],[[8,47,479,4],[49,47,479,45]],[[8,47,480,4,1570],[17,47,480,13,1571]],[[8,47,481,4,1572],[17,47,481,13,1504]],[[4,47,482,2]],[[4,47,483,2],[10,47,483,8,1549],[21,47,483,34,1550],[22,47,483,34,1550],[25,47,483,34,1550],[35,47,483,34,1550],[51,47,483,50],[53,47,484,4,1548],[57,47,484,8,1551],[65,47,484,16],[67,47,485,4,1548],[71,47,485,8,1552],[77,47,485,14],[79,47,486,4,1548],[83,47,486,8,1532],[90,47,486,15]],[[4,47,488,2],[10,47,488,8,1553],[27,47,488,25]],[[4,47,489,2,1573],[5,47,489,2,1573],[8,47,489,2,1573],[18,47,489,2,1573],[31,47,489,15],[33,47,489,16,1527],[48,47,489,31,1549],[58,47,489,41,1556],[72,47,489,55,1553]],[[4,47,490,2],[11,47,490,9,1556]],[[0,47,491,0]],[[0,47,493,7],[9,47,493,16,1513],[42,47,494,2,1547],[45,47,494,13],[47,47,495,2,1574],[59,47,495,19],[61,47,496,2,1532],[68,47,496,24]],[[4,47,498,2],[77,47,498,75]],[[4,47,499,2],[72,47,499,70]],[[4,47,500,2],[82,47,500,80]],[[4,47,501,2],[59,47,501,57]],[[4,47,502,2],[6,47,502,4]],[[4,47,503,2],[74,47,503,72]],[[4,47,504,2],[79,47,504,77]],[[4,47,505,2],[6,47,505,4]],[[4,47,506,2],[76,47,506,74]],[[4,47,507,2],[76,47,507,74]],[[4,47,508,2],[73,47,508,71]],[[4,47,509,2],[80,47,509,78]],[[4,47,510,2],[79,47,510,77]],[[4,47,511,2],[76,47,511,74]],[[4,47,512,2],[78,47,512,76]],[[4,47,513,2],[38,47,513,36]],[[4,47,515,2],[80,47,515,78]],[[4,47,516,2],[78,47,516,76]],[[4,47,517,2],[78,47,517,76]],[[4,47,518,2],[75,47,518,73]],[[4,47,519,2],[80,47,519,78]],[[4,47,520,2],[43,47,520,41]],[[4,47,521,2],[10,47,521,8,1575],[28,47,521,26,1574],[41,47,521,39,1552],[47,47,521,45]],[[4,47,522,2],[8,47,522,6,1575],[28,47,522,26],[32,47,522,30]],[[8,47,523,4],[80,47,523,76]],[[8,47,524,4],[59,47,524,55]],[[8,47,525,4],[15,47,525,11]],[[4,47,526,2]],[[4,47,527,2],[10,47,527,8,1576],[35,47,527,33],[39,47,527,37,1577],[43,47,527,41,1574]],[[4,47,528,2,1576],[27,47,528,25,1552],[33,47,528,31],[36,47,528,34]],[[4,47,529,2],[10,47,529,8,1578],[36,47,529,34,1511],[56,47,530,4,1547],[61,47,531,4,1579],[62,47,531,4,1579],[65,47,531,4,1579],[75,47,531,4,1579],[89,47,531,28],[91,47,531,29,1576],[114,47,531,52,1580],[118,47,531,56],[120,47,531,58,1532]],[[4,47,534,2],[8,47,535,4,1578],[36,47,535,32],[44,47,536,4,1578],[68,47,536,28,1562],[74,47,536,34],[79,47,536,34],[82,47,537,4]],[[8,47,538,4],[81,47,538,77]],[[8,47,539,4],[47,47,539,43]],[[8,47,540,4],[15,47,540,11]],[[4,47,541,2]],[[4,47,543,2],[79,47,543,77]],[[4,47,545,2],[73,47,545,71]],[[4,47,546,2],[70,47,546,68]],[[4,47,547,2],[73,47,547,71]],[[4,47,548,2],[72,47,548,70]],[[4,47,549,2],[35,47,549,33]],[[4,47,550,2],[10,47,550,8,1581],[51,47,550,49],[55,47,550,53,1577],[59,47,551,4,1578],[83,47,551,28,1561],[95,47,551,40],[97,47,552,4,1574],[110,47,552,17,1582],[116,47,552,23]],[[4,47,554,2],[10,47,554,8,1583],[38,47,555,4,1581],[77,47,555,43,1552],[83,47,555,49],[88,47,555,54],[93,47,557,8,1581],[132,47,557,47,1552],[138,47,557,53],[141,47,558,8,1575]],[[4,47,560,2],[71,47,560,69]],[[4,47,561,2],[72,47,561,70]],[[4,47,562,2],[76,47,562,74]],[[4,47,563,2],[77,47,563,75]],[[4,47,564,2],[35,47,564,33]],[[4,47,565,2],[10,47,565,8,1584],[37,47,566,4,1578],[61,47,566,28,1567],[75,47,566,42],[80,47,566,47],[85,47,568,8,1578],[109,47,568,32,1567],[123,47,568,46],[126,47,569,8,1575]],[[4,47,571,2],[10,47,571,8,1585],[26,47,571,24],[30,47,571,28,1577],[34,47,572,4,1578],[58,47,572,28,1561],[70,47,572,40],[72,47,573,4,1586],[81,47,573,13,1582],[87,47,573,19]],[[4,47,575,2,1585],[18,47,575,16,1552],[24,47,575,22],[27,47,575,25,1583]],[[4,47,576,2],[10,47,576,8,1587],[35,47,576,33,1588],[36,47,576,33,1588],[39,47,576,33,1588],[58,47,576,33,1588],[75,47,576,50],[77,47,576,51,1585]],[[4,47,578,2],[10,47,578,8,1589],[32,47,578,30,1590],[58,47,579,4,1578],[82,47,579,28,1533],[86,47,579,32],[88,47,580,4,1584]],[[4,47,582,2],[10,47,582,8,1591],[35,47,582,33,1590],[61,47,583,4,1578],[85,47,583,28,1564],[93,47,583,36],[95,47,584,4,1584]],[[4,47,587,2],[75,47,587,73]],[[4,47,588,2],[25,47,588,23]],[[4,47,589,2],[10,47,589,8,1592],[28,47,589,52]],[[8,47,590,4,1561],[22,47,590,18,1587]],[[8,47,592,4,1562],[14,47,592,10],[16,47,592,10]],[[8,47,593,4],[59,47,593,55]],[[8,47,594,4,1563],[22,47,594,18]],[[8,47,595,4,1533],[14,47,595,10,1589]],[[8,47,596,4,1564],[18,47,596,14,1591]],[[8,47,597,4,1565],[28,47,597,24,1578],[52,47,597,48,1565],[70,47,597,66]],[[8,47,598,4,1566],[22,47,598,18,1578],[46,47,598,42,1566],[58,47,598,54]],[[8,47,600,4],[66,47,600,62]],[[8,47,601,4,1567],[24,47,601,20,1584]],[[8,47,603,4],[29,47,603,25]],[[8,47,604,4,1568],[13,47,604,9]],[[8,47,605,4,1569],[14,47,605,10]],[[8,47,606,4,1570],[17,47,606,13,1578],[41,47,606,37,1570],[48,47,606,44]],[[8,47,607,4,1572],[17,47,607,13,1578],[41,47,607,37,1572],[48,47,607,44]],[[4,47,608,2]],[[4,47,610,2],[72,47,610,70]],[[4,47,611,2],[68,47,611,66]],[[4,47,612,2],[11,47,612,9,1592]],[[0,47,613,0]],[[0,47,615,0],[9,47,615,9,1590],[35,47,616,2,1533],[39,47,616,17],[41,47,617,2,1593],[58,47,617,37]],[[4,47,619,2],[76,47,619,74]],[[4,47,620,2],[71,47,620,69]],[[4,47,622,2],[8,47,622,6,1594],[22,47,622,54]],[[4,47,623,2],[10,47,623,8,1595],[26,47,623,24,1533],[31,47,623,29,1596],[36,47,623,34]],[[4,47,624,2],[8,47,624,6,1595],[26,47,624,24],[32,47,624,30]],[[8,47,625,4,1594],[22,47,625,18],[23,47,625,19]],[[8,47,626,4],[12,47,626,9],[18,47,626,15,1597],[38,47,626,35,1595],[52,47,626,50]],[[12,47,627,6],[18,47,627,12,1598],[30,47,627,24,1595],[43,47,627,37],[44,47,627,38,1597],[61,47,627,55]],[[12,47,628,6,1594],[23,47,628,17],[24,47,628,18,1597],[41,47,628,35],[44,47,628,38,1590],[70,47,629,8,1598],[81,47,630,8,1593]],[[8,47,632,4]],[[4,47,633,2]],[[4,47,635,2],[66,47,635,64]],[[4,47,636,2],[8,47,636,6,1533],[13,47,636,11,1599],[19,47,636,17],[21,47,636,19]],[[8,47,637,4],[15,47,637,11]],[[12,47,638,6,1600],[24,47,638,18,1533],[29,47,638,23,1600],[39,47,638,33]],[[12,47,639,6,1601],[21,47,639,15,1533],[26,47,639,20,1601],[33,47,639,27]],[[12,47,640,6,1549],[22,47,640,16,1602],[23,47,640,16,1602],[26,47,640,16,1602],[36,47,640,16,1602],[72,47,640,52],[74,47,641,8,1533],[79,47,641,13,1549],[87,47,641,21],[89,47,642,8,1593]],[[12,47,644,6,1599],[20,47,644,14]],[[12,47,645,6,1596],[19,47,645,13,1594]],[[12,47,646,6,1603],[26,47,646,20,1533],[31,47,646,25,1603],[43,47,646,37]],[[12,47,647,6,1604],[32,47,647,26,1533],[37,47,647,31,1604],[55,47,647,49]],[[12,47,648,6,1605],[32,47,648,26,1533],[37,47,648,31,1605],[55,47,648,49]],[[8,47,649,4]],[[4,47,650,2]],[[4,47,652,2],[11,47,652,9]],[[8,47,653,4,1600],[20,47,653,16,1533],[25,47,653,21,1600],[35,47,653,31]],[[8,47,654,4,1601],[17,47,654,13,1533],[22,47,654,18,1601],[29,47,654,25]],[[8,47,655,4,1549],[18,47,655,14,1533],[23,47,655,19,1549],[31,47,655,27]],[[8,47,656,4,1599],[16,47,656,12]],[[8,47,657,4,1596],[15,47,657,11,1594]],[[8,47,658,4,1603],[22,47,658,18,1533],[27,47,658,23,1603],[39,47,658,35]],[[8,47,659,4,1604],[28,47,659,24,1533],[33,47,659,29,1604],[51,47,659,47]],[[8,47,660,4,1605],[28,47,660,24,1533],[33,47,660,29,1605],[51,47,660,47]],[[4,47,661,2]],[[0,47,662,0]],[[0,47,668,7],[9,47,668,16,1510],[39,47,669,2,1547],[42,47,669,13],[44,47,670,2,1606],[57,47,670,30],[59,47,671,2,1607],[64,47,671,33],[66,47,672,2,1533],[70,47,672,17]],[[4,47,674,2],[10,47,674,8,1560],[26,47,674,24,1512],[48,47,674,46,1547],[53,47,674,51,1533],[58,47,674,56,1549],[66,47,674,64]],[[4,47,675,2],[8,47,675,6,1560],[26,47,675,24],[32,47,675,30]],[[8,47,676,4],[15,47,676,11,1560]],[[4,47,677,2]],[[4,47,678,2],[54,47,678,52]],[[4,47,679,2],[10,47,679,8,1608],[31,47,679,29,1609],[32,47,679,29,1609],[35,47,679,29,1609],[45,47,679,29,1609],[73,47,679,57],[75,47,679,58,1606],[90,47,679,73,1533]],[[4,47,680,2],[10,47,680,8,1556],[25,47,680,23,1500],[57,47,680,55,1607],[63,47,680,61,1570],[70,47,680,68]],[[4,47,681,2],[10,47,681,8,1553],[27,47,681,25]],[[4,47,682,2,1573],[5,47,682,2,1573],[8,47,682,2,1573],[18,47,682,2,1573],[31,47,682,15],[33,47,683,4,1529],[50,47,684,4,1608],[70,47,685,4,1556],[84,47,686,4,1553]],[[4,47,688,2],[11,47,688,9,1556]],[[0,47,689,0]],[[0,47,691,7],[9,47,691,16,1508],[46,47,692,2,1547],[49,47,692,13],[51,47,693,2,1606],[64,47,693,30],[66,47,694,2,1607],[71,47,694,33],[73,47,695,2,1533],[77,47,695,17]],[[4,47,697,2],[77,47,697,75]],[[4,47,698,2],[82,47,698,80]],[[4,47,699,2],[80,47,699,78]],[[4,47,700,2],[79,47,700,77]],[[4,47,701,2],[77,47,701,75]],[[4,47,702,2],[30,47,702,28]],[[4,47,703,2],[6,47,703,4]],[[4,47,704,2],[80,47,704,78]],[[4,47,705,2],[80,47,705,78]],[[4,47,706,2],[78,47,706,76]],[[4,47,707,2],[82,47,707,80]],[[4,47,708,2],[77,47,708,75]],[[4,47,709,2],[6,47,709,4]],[[4,47,710,2],[78,47,710,76]],[[4,47,711,2],[80,47,711,78]],[[4,47,712,2],[77,47,712,75]],[[4,47,713,2],[80,47,713,78]],[[4,47,714,2],[72,47,714,70]],[[4,47,715,2],[20,47,715,18]],[[4,47,717,2],[78,47,717,76]],[[4,47,718,2],[76,47,718,74]],[[4,47,719,2],[78,47,719,76]],[[4,47,720,2],[78,47,720,76]],[[4,47,721,2],[81,47,721,79]],[[4,47,722,2],[78,47,722,76]],[[4,47,723,2],[45,47,723,43]],[[4,47,724,2],[10,47,724,8,1560],[26,47,724,24,1555],[60,47,724,58,1547],[65,47,724,63,1533],[70,47,724,68,1549],[78,47,724,76]],[[4,47,725,2],[8,47,725,6,1560],[26,47,725,24],[32,47,725,30]],[[8,47,726,4],[15,47,726,11,1560]],[[4,47,727,2]],[[4,47,728,2],[54,47,728,52]],[[4,47,729,2],[10,47,729,8,1608],[31,47,729,29,1609],[32,47,729,29,1609],[35,47,729,29,1609],[45,47,729,29,1609],[73,47,729,57],[75,47,729,58,1606],[90,47,729,73,1533]],[[4,47,730,2],[10,47,730,8,1556],[25,47,730,23,1500],[57,47,730,55,1607],[63,47,730,61,1570],[70,47,730,68]],[[4,47,731,2],[10,47,731,8,1553],[27,47,731,25]],[[4,47,732,2,1573],[5,47,732,2,1573],[8,47,732,2,1573],[18,47,732,2,1573],[31,47,732,15],[33,47,733,4,1529],[50,47,734,4,1608],[70,47,735,4,1556],[84,47,736,4,1553]],[[4,47,738,2],[11,47,738,9,1556]],[[0,47,739,0]],[[0,47,741,7],[9,47,741,16,1506],[48,47,742,2,1606],[61,47,742,30],[63,47,743,2,1607],[68,47,743,33],[70,47,744,2,1533],[74,47,744,17]],[[4,47,746,2],[80,47,746,78]],[[4,47,747,2],[74,47,747,72]],[[4,47,748,2],[38,47,748,36]],[[4,47,749,2],[10,47,749,8,1608],[31,47,749,29,1609],[32,47,749,29,1609],[35,47,749,29,1609],[45,47,749,29,1609],[73,47,749,57],[75,47,749,58,1606],[90,47,749,73,1533]],[[4,47,750,2],[10,47,750,8,1556],[25,47,750,23,1500],[57,47,750,55,1607],[63,47,750,61,1570],[70,47,750,68]],[[4,47,751,2],[10,47,751,8,1553],[27,47,751,25]],[[4,47,752,2,1573],[5,47,752,2,1573],[8,47,752,2,1573],[18,47,752,2,1573],[31,47,752,15],[33,47,753,4,1529],[50,47,754,4,1608],[70,47,755,4,1556],[84,47,756,4,1553]],[[4,47,758,2],[11,47,758,9,1556]],[[0,47,759,0]],[[0,47,761,7],[9,47,761,16,1516],[28,47,762,2,1547],[31,47,762,13],[33,47,763,2,1549],[41,47,763,27],[43,47,764,2,1610],[57,47,764,35]],[[4,47,766,2],[80,47,766,78]],[[4,47,767,2],[81,47,767,79]],[[4,47,768,2],[29,47,768,27]],[[4,47,769,2],[81,47,769,79]],[[4,47,770,2],[81,47,770,79]],[[4,47,771,2],[69,47,771,67]],[[4,47,773,2],[8,47,773,6,1611],[9,47,773,6,1611],[12,47,773,6,1611],[22,47,773,6,1611],[36,47,773,20],[38,47,773,21,1547],[43,47,773,26,1504],[69,47,773,52,1610],[86,47,773,69]],[[8,47,774,4],[53,47,774,49]],[[8,47,775,4],[15,47,775,11]],[[4,47,776,2]],[[4,47,778,2],[10,47,778,8,1560],[26,47,778,24,1512],[48,47,778,46,1547],[53,47,778,51,1549]],[[4,47,779,2],[8,47,779,6,1560],[26,47,779,24],[32,47,779,30]],[[8,47,780,4],[92,47,780,88]],[[8,47,781,4],[66,47,781,62]],[[8,47,782,4],[36,47,782,32]],[[8,47,783,4],[12,47,786,6],[12,47,784,6],[12,47,785,6],[89,47,784,83],[92,47,785,86]],[[8,47,786,7,1610],[23,47,786,22,1606],[36,47,786,35],[41,47,786,40,1560],[55,47,786,54,1606],[68,47,786,67],[72,47,787,8],[73,47,787,9,1498],[111,47,788,10,1560],[125,47,788,24,1606],[138,47,788,37],[140,47,789,10,1610],[155,47,789,25,1606],[168,47,789,38],[173,47,791,6],[229,47,791,62]],[[8,47,792,6],[101,47,792,99]],[[8,47,793,7],[9,47,793,8,1560],[23,47,793,22,1612],[32,47,793,31],[36,47,793,35,1610],[51,47,793,50,1612],[60,47,793,59],[62,47,794,6]],[[12,47,795,6],[86,47,795,80]],[[12,47,796,6],[84,47,796,78]],[[12,47,797,6],[86,47,797,80]],[[12,47,798,6],[86,47,798,80]],[[12,47,799,6],[33,47,799,27]],[[12,47,800,6],[18,47,800,12,1613],[34,47,800,55,1610]],[[12,47,801,6,1613],[26,47,801,20,1562],[32,47,801,26],[35,47,801,26]],[[12,47,802,6,1613],[26,47,802,20,1614],[33,47,802,27],[36,47,802,30]],[[12,47,803,6,1613],[26,47,803,20,1615],[29,47,803,23],[32,47,803,26]],[[12,47,804,6],[19,47,804,13]],[[8,47,805,4]],[[8,47,807,4],[51,47,807,47]],[[8,47,808,4,1616],[9,47,808,4,1616],[12,47,808,4,1616],[22,47,808,4,1616],[40,47,808,22],[42,47,808,23,1560]],[[4,47,809,2]],[[4,47,811,2],[10,47,811,8,1553],[27,47,811,25]],[[4,47,812,2,1573],[5,47,812,2,1573],[8,47,812,2,1573],[18,47,812,2,1573],[31,47,812,15],[33,47,812,16,1529],[50,47,812,33,1549],[60,47,812,43,1610],[76,47,812,59,1553]],[[4,47,813,2],[11,47,813,9,1610]],[[0,47,814,0]],[[0,47,816,7],[9,47,816,16,1500],[41,47,817,2,1570],[48,47,817,17]],[[4,47,819,2],[10,47,819,8,1617],[23,47,819,45]],[[8,47,820,4,1562],[14,47,820,10],[16,47,820,10]],[[8,47,821,4],[83,47,821,79]],[[8,47,822,4],[46,47,822,42]],[[8,47,823,4,1606],[23,47,823,19,1618],[30,47,823,19,1618],[43,47,823,32],[44,47,823,33,1619],[47,47,823,36]],[[8,47,824,4,1615],[13,47,824,9]],[[8,47,825,4,1614],[17,47,825,13]],[[8,47,826,4,1612],[19,47,826,15]],[[8,47,827,4,1558],[17,47,827,13]],[[8,47,829,4],[29,47,829,25]],[[8,47,830,4,1568],[13,47,830,9]],[[8,47,831,4,1569],[14,47,831,10]],[[8,47,832,4,1570]],[[8,47,833,4,1572],[17,47,833,13]],[[4,47,834,2]],[[4,47,835,2],[11,47,835,9,1617]],[[0,47,836,0]],[[0,47,838,7],[9,47,838,16,1515],[33,47,839,2,1617],[43,47,839,36],[45,47,840,2,1606],[58,47,840,30]],[[4,47,842,2],[10,47,842,8,1556],[25,47,842,49,1617]],[[4,47,843,2,1556],[17,47,843,15,1562],[23,47,843,21],[26,47,843,21]],[[4,47,844,2,1556],[17,47,844,15,1606],[30,47,844,28],[33,47,844,31,1606]],[[4,47,846,2],[8,47,846,6,1606],[26,47,846,24,1618],[33,47,846,24,1618],[46,47,846,37],[47,47,846,38,1620],[51,47,846,42],[53,47,846,44]],[[8,47,847,4],[82,47,847,78]],[[8,47,848,4],[79,47,848,75]],[[8,47,849,4],[68,47,849,64]],[[8,47,850,4,1556],[21,47,850,17,1612],[30,47,850,26],[33,47,850,29]],[[4,47,851,2]],[[4,47,853,2],[81,47,853,79]],[[4,47,854,2],[76,47,854,74]],[[4,47,855,2],[81,47,855,79]],[[4,47,856,2],[74,47,856,72]],[[4,47,857,2],[45,47,857,43]],[[4,47,858,2,1556],[17,47,858,15,1572],[24,47,858,22],[27,47,858,25,1504]],[[4,47,859,2],[11,47,859,9,1556]],[[0,47,860,0]],[[0,47,862,0],[9,47,862,9,1621],[26,47,862,26,1622],[31,47,864,1]],[[4,47,865,2],[10,47,865,8,1563],[25,47,865,23,1622],[31,47,865,29,1563],[43,47,865,41]],[[4,47,866,2],[8,47,866,6,1563],[25,47,866,23],[31,47,866,29]],[[8,47,867,4],[13,47,867,9],[19,47,867,15,1537],[27,47,867,23,1563],[40,47,867,37]],[[12,47,868,6,1623],[13,47,868,6,1623],[16,47,868,6,1623],[27,47,868,6,1623],[43,47,868,22],[45,47,868,23,1537]],[[8,47,869,4]],[[8,47,870,4,1622],[14,47,870,10,1563],[26,47,870,22],[29,47,870,25]],[[4,47,871,2]],[[0,47,872,0]],[[0,47,874,0],[9,47,874,9,1624],[32,47,875,2,1622],[37,47,875,24],[39,47,876,2,1533],[43,47,876,17],[45,47,877,2,1625],[61,47,877,32],[63,47,878,2,1570],[70,47,878,17],[72,47,879,2,1565],[90,47,879,29],[92,47,880,2,1561],[104,47,880,22],[106,47,881,2,1567],[120,47,881,34],[122,47,882,2,1566],[134,47,882,23]],[[4,47,884,2],[81,47,884,79]],[[4,47,885,2],[75,47,885,73]],[[4,47,886,2],[77,47,886,75]],[[4,47,887,2],[18,47,887,16]],[[4,47,888,2],[10,47,888,8,1564],[21,47,888,30]],[[8,47,889,4,1600],[20,47,889,16,1626],[42,47,889,16,1626],[58,47,889,32]],[[8,47,890,4,1601],[17,47,890,13,1626],[39,47,890,13,1626],[55,47,890,29]],[[8,47,891,4,1549],[18,47,891,14,1625]],[[8,47,892,4],[81,47,892,77]],[[8,47,893,4],[82,47,893,78]],[[8,47,894,4],[83,47,894,79]],[[8,47,895,4,1599],[16,47,895,12]],[[8,47,896,4,1596],[15,47,896,11]],[[8,47,897,4,1603],[22,47,897,18]],[[8,47,898,4,1604],[28,47,898,24,1627],[44,47,898,24,1627],[62,47,898,42],[63,47,898,43,1628],[90,47,898,70]],[[8,47,899,4,1605],[28,47,899,24]],[[4,47,900,2]],[[4,47,901,2],[10,47,901,8,1629],[27,47,901,51,1622]],[[4,47,902,2,1629],[19,47,902,17,1562],[25,47,902,23],[28,47,902,23]],[[4,47,903,2,1629],[19,47,903,17,1533],[23,47,903,21],[26,47,903,24,1533]],[[4,47,904,2,1629],[19,47,904,17,1564],[27,47,904,25],[30,47,904,28,1564]],[[4,47,905,2,1629],[19,47,905,17,1570],[26,47,905,24],[29,47,905,27,1570]],[[4,47,906,2,1629],[19,47,906,17,1565],[37,47,906,35],[40,47,906,38,1565]],[[4,47,907,2,1629],[19,47,907,17,1561],[31,47,907,29],[34,47,907,32,1561]],[[4,47,908,2,1629],[19,47,908,17,1567],[33,47,908,31],[36,47,908,34,1567]],[[4,47,909,2,1629],[19,47,909,17,1566],[31,47,909,29],[34,47,909,32,1566]],[[4,47,910,2,1621],[21,47,910,19,1622]],[[4,47,911,2],[11,47,911,9,1629]],[[0,47,912,0]],[[0,47,914,0],[9,47,914,9,1630],[34,47,915,2,1631],[51,47,915,45],[53,47,916,2,1615],[56,47,916,22],[58,47,917,2,1614],[65,47,917,57],[67,47,918,2,1570],[74,47,918,17],[76,47,919,2,1612],[85,47,919,20]],[[4,47,921,2],[10,47,921,8,1629],[27,47,921,53,1631]],[[4,47,922,2,1629],[19,47,922,17,1562],[25,47,922,23],[28,47,922,23]],[[4,47,923,2,1629],[19,47,923,17,1615],[22,47,923,20],[25,47,923,23,1615]],[[4,47,924,2,1629],[19,47,924,17,1614],[26,47,924,24],[29,47,924,27,1614]],[[4,47,925,2,1629],[19,47,925,17,1570],[26,47,925,24],[29,47,925,27,1570]],[[4,47,926,2,1629],[19,47,926,17,1612],[28,47,926,26],[31,47,926,29,1612]],[[4,47,927,2],[61,47,927,59]],[[4,47,928,2],[8,47,928,6,1631],[26,47,928,24,1558],[33,47,928,31],[38,47,928,36],[44,47,928,42]],[[8,47,929,4,1631],[26,47,929,22,1558],[33,47,929,29],[34,47,929,30,1632],[41,47,929,37],[42,47,929,38,1629]],[[8,47,930,4],[51,47,930,47]],[[8,47,931,4,1629],[23,47,931,19,1558],[30,47,931,26],[33,47,931,29]],[[4,47,932,2]],[[4,47,933,2],[11,47,933,9,1629]],[[0,47,934,0]],[[0,47,936,0],[9,47,936,9,1633],[31,47,937,2,1622],[36,47,937,31],[38,47,938,2,1570],[45,47,938,17]],[[4,47,940,2],[10,47,940,8,1613],[26,47,940,49,1622]],[[4,47,941,2,1613],[18,47,941,16,1562],[24,47,941,22],[27,47,941,22]],[[4,47,942,2,1613],[18,47,942,16,1570],[25,47,942,23],[28,47,942,26,1570]],[[4,47,943,2,1621],[21,47,943,19,1622]],[[0,47,944,0]],[[0,47,946,0],[9,47,946,9,1634],[33,47,947,2,1622],[38,47,947,33],[40,47,948,2,1570],[47,47,948,17]],[[4,47,950,2],[10,47,950,8,1613],[26,47,950,51,1622]],[[4,47,951,2,1613],[18,47,951,16,1562],[24,47,951,22],[27,47,951,22]],[[4,47,952,2,1613],[18,47,952,16,1570],[25,47,952,23],[28,47,952,26,1570]],[[4,47,953,2],[8,47,953,6,1622],[14,47,953,12,1558],[21,47,953,19],[26,47,953,24],[32,47,953,30]],[[8,47,954,4],[82,47,954,78]],[[8,47,955,4],[57,47,955,53]],[[8,47,956,4,1622],[14,47,956,10,1558],[21,47,956,17],[22,47,956,18,1632],[29,47,956,25],[30,47,956,26]],[[8,47,957,4,1622],[14,47,957,10,1558],[21,47,957,17],[24,47,957,20]],[[4,47,958,2]],[[0,47,959,0]],[[0,47,965,0],[9,47,965,9,1635],[44,47,966,2,1636],[52,47,966,28],[54,47,967,2,1637],[70,47,967,26],[72,47,968,2,1567],[86,47,968,34],[88,47,969,2,1638],[91,47,969,27]],[[4,47,971,2],[42,47,971,40]],[[4,47,972,2],[10,47,972,8,1639],[26,47,972,24,1637],[43,47,972,41,1640],[48,47,972,46],[49,47,972,47],[54,47,972,52,1641],[60,47,972,58],[61,47,972,59],[62,47,972,60,1642],[66,47,972,66,1642],[72,47,972,72]],[[4,47,973,2],[10,47,973,8,1643],[18,47,973,16]],[[4,47,974,2],[10,47,974,8,1644],[24,47,974,22,1645],[46,47,974,22,1645],[70,47,974,46]],[[4,47,975,2],[11,47,975,9,1646],[42,47,976,4,1636],[51,47,976,13,1533],[55,47,976,17],[57,47,977,4,1644],[70,47,978,4],[76,47,979,4,1645],[98,47,979,4,1645],[122,47,979,28],[124,47,980,4,1639],[139,47,981,4,1643],[146,47,982,4,1567],[162,47,983,4,1638]],[[0,47,985,0]],[[0,47,987,0],[9,47,987,9,1646],[40,47,988,2,1647],[48,47,988,24],[50,47,989,2,1601],[57,47,989,35],[59,47,990,2,1648],[74,47,990,48],[76,47,991,2,1600],[86,47,991,31],[88,47,992,2,1639],[101,47,992,30],[103,47,993,2,1649],[121,47,993,28],[123,47,994,2,1567],[137,47,994,34],[139,47,995,2,1638],[142,47,995,27]],[[4,47,997,2],[77,47,997,75]],[[4,47,998,2],[82,47,998,80]],[[4,47,999,2],[80,47,999,78]],[[4,47,1000,2],[78,47,1000,76]],[[4,47,1001,2],[43,47,1001,41]],[[4,47,1003,2],[8,47,1003,6,1596],[16,47,1003,64]],[[4,47,1004,2],[8,47,1004,6,1599]],[[4,47,1005,2],[8,47,1005,6,1549]],[[4,47,1006,2],[10,47,1006,8,1650],[26,47,1006,24,1647],[35,47,1006,33,1596],[40,47,1006,38]],[[4,47,1007,2],[8,47,1007,6,1650],[26,47,1007,24],[32,47,1007,30]],[[8,47,1008,4,1599],[17,47,1008,13]],[[8,47,1009,4,1549],[19,47,1009,15,1651],[20,47,1009,15,1651],[23,47,1009,15,1651],[33,47,1009,15,1651],[55,47,1009,37],[57,47,1009,38,1600],[69,47,1009,50,1648]],[[8,47,1011,4,1596],[16,47,1011,12],[17,47,1011,13]],[[8,47,1012,4],[12,47,1012,9],[16,47,1012,13,1597],[36,47,1012,33,1650],[50,47,1012,48]],[[12,47,1013,6],[18,47,1013,12,1652],[34,47,1013,28,1650],[47,47,1013,41],[48,47,1013,42,1597],[65,47,1013,59]],[[12,47,1014,6],[18,47,1014,12,1653],[35,47,1014,29,1652],[49,47,1014,43,1654],[53,47,1014,47]],[[12,47,1015,6],[18,47,1015,12,1655],[35,47,1015,29,1652],[49,47,1015,43,1656],[58,47,1015,52]],[[12,47,1016,6],[18,47,1016,12,1657],[44,47,1016,38,1652],[58,47,1016,52,1658],[66,47,1016,60]],[[12,47,1018,6],[16,47,1018,10,1659]],[[12,47,1019,6],[16,47,1019,10,1660]],[[12,47,1020,6],[16,47,1020,10,1661]],[[12,47,1021,6],[16,47,1021,10,1655],[35,47,1021,29],[41,47,1021,35]],[[16,47,1022,8],[82,47,1022,74]],[[16,47,1023,8],[22,47,1023,14,1662],[40,47,1023,32,1663],[41,47,1023,32,1663],[44,47,1023,32,1663],[57,47,1023,32,1663],[85,47,1023,60],[87,47,1024,10,1655],[103,47,1025,10,1639],[118,47,1026,10,1649]],[[16,47,1029,8],[86,47,1029,78]],[[16,47,1030,8],[87,47,1030,79]],[[16,47,1031,8],[87,47,1031,79]],[[16,47,1032,8],[75,47,1032,67]],[[16,47,1034,8],[80,47,1034,72]],[[16,47,1035,8],[87,47,1035,79]],[[16,47,1036,8],[86,47,1036,78]],[[16,47,1037,8],[75,47,1037,67]],[[16,47,1038,8],[32,47,1038,24]],[[16,47,1039,8],[22,47,1039,14,1664],[38,47,1040,10],[38,47,1041,10],[68,47,1041,40],[100,47,1040,72]],[[16,47,1042,10,1657],[44,47,1042,38],[51,47,1043,14,1657],[77,47,1045,14,1665],[78,47,1045,14,1665],[81,47,1045,14,1665],[94,47,1045,14,1665],[120,47,1045,40],[122,47,1046,16,1662],[139,47,1047,16]],[[16,47,1050,8,1661],[39,47,1050,31,1666],[40,47,1050,31,1666],[43,47,1050,31,1666],[53,47,1050,31,1666],[73,47,1050,51],[75,47,1051,10,1648],[92,47,1052,10,1664]],[[16,47,1054,8,1660],[31,47,1054,23]],[[20,47,1054,24,1653]],[[20,47,1054,40,1664]],[[20,47,1054,55,1655]],[[17,47,1054,70]],[[16,47,1055,8,1659],[39,47,1055,31]],[[12,47,1056,6],[19,47,1056,13]],[[16,47,1057,8],[87,47,1057,79]],[[16,47,1058,8],[30,47,1058,22]],[[16,47,1059,8,1661],[39,47,1059,31,1648]],[[16,47,1060,8,1660],[31,47,1060,23,1653]],[[16,47,1061,8,1659],[39,47,1061,31,1667],[40,47,1061,31,1667],[43,47,1061,31,1667],[56,47,1061,31,1667],[84,47,1061,59],[86,47,1061,60,1653]],[[12,47,1062,6]],[[12,47,1064,6],[84,47,1064,78]],[[12,47,1065,6],[74,47,1065,68]],[[12,47,1066,6],[18,47,1066,12,1668],[44,47,1066,38,1659],[67,47,1067,10,1649],[88,47,1067,31],[92,47,1068,10,1649]],[[12,47,1070,6],[18,47,1070,12,1669],[40,47,1070,34,1670],[41,47,1070,34,1670],[44,47,1070,34,1670],[66,47,1070,34,1670],[93,47,1070,61],[95,47,1070,62,1660]],[[12,47,1071,6],[18,47,1071,12,1671],[36,47,1071,30,1672],[37,47,1071,30,1672],[40,47,1071,30,1672],[62,47,1071,30,1672],[89,47,1071,57],[91,47,1072,8,1600],[103,47,1073,8,1597],[121,47,1074,8,1669]],[[12,47,1076,6,1596],[17,47,1076,11],[18,47,1076,12,1597],[35,47,1076,29],[38,47,1076,32,1646],[69,47,1077,8,1652],[84,47,1078,8,1660],[98,47,1079,8,1661],[120,47,1080,8,1671],[137,47,1081,8,1639],[152,47,1082,8,1668],[177,47,1083,8,1567],[193,47,1084,8,1638]],[[8,47,1086,4]],[[4,47,1087,2],[11,47,1087,9]],[[8,47,1088,4],[12,47,1088,8,1600],[23,47,1088,19,1673],[31,47,1088,27],[32,47,1088,28,1674],[41,47,1088,28,1674],[57,47,1088,44],[60,47,1088,47]],[[12,47,1089,6],[38,47,1089,32]],[[12,47,1090,6,1599],[21,47,1090,15]],[[12,47,1091,6,1549],[23,47,1091,17,1675],[24,47,1091,17,1675],[27,47,1091,17,1675],[37,47,1091,17,1675],[57,47,1091,37],[59,47,1092,8,1600],[71,47,1093,8,1567],[87,47,1094,8,1648]],[[12,47,1096,6],[85,47,1096,79]],[[12,47,1097,6],[80,47,1097,74]],[[12,47,1098,6],[83,47,1098,77]],[[12,47,1099,6],[75,47,1099,69]],[[12,47,1100,6],[67,47,1100,61]],[[12,47,1101,6],[57,47,1101,51]],[[12,47,1102,6],[16,47,1102,10,1638],[20,47,1102,14,1625],[36,47,1102,30],[41,47,1102,35],[47,47,1102,41]],[[16,47,1103,8,1638],[20,47,1103,12,1625],[36,47,1103,28],[39,47,1103,31,1676],[40,47,1103,31,1676],[43,47,1103,31,1676],[53,47,1103,31,1676],[77,47,1103,55],[79,47,1104,10,1600],[91,47,1105,10,1567],[107,47,1106,10,1648]],[[12,47,1108,6]],[[8,47,1109,4],[15,47,1109,11]],[[12,47,1110,6],[40,47,1110,34]],[[12,47,1111,6,1599],[21,47,1111,15]],[[12,47,1112,6,1549],[23,47,1112,17,1651],[24,47,1112,17,1651],[27,47,1112,17,1651],[37,47,1112,17,1651],[59,47,1112,39],[61,47,1112,40,1600],[73,47,1112,52,1648]],[[8,47,1113,4]],[[4,47,1114,2]],[[4,47,1116,2],[11,47,1116,9]],[[8,47,1117,4,1600]],[[8,47,1118,4,1601]],[[8,47,1119,4,1549]],[[8,47,1120,4],[82,47,1120,78]],[[8,47,1121,4],[83,47,1121,79]],[[8,47,1122,4],[81,47,1122,77]],[[8,47,1123,4],[83,47,1123,79]],[[8,47,1124,4],[83,47,1124,79]],[[8,47,1125,4],[45,47,1125,41]],[[8,47,1126,4,1599],[16,47,1126,12,1599]],[[8,47,1127,4,1596]],[[8,47,1128,4,1603],[22,47,1128,18,1647],[31,47,1128,27,1603],[43,47,1128,39]],[[8,47,1129,4],[81,47,1129,77]],[[8,47,1130,4],[66,47,1130,62]],[[8,47,1131,4,1604],[28,47,1131,24,1627],[44,47,1131,24,1627],[62,47,1131,42],[63,47,1131,43,1677],[88,47,1131,68]],[[8,47,1132,4,1605],[28,47,1132,24,1647],[37,47,1132,33,1605],[55,47,1132,51]],[[4,47,1133,2]],[[0,47,1134,0]],[[0,47,1136,0],[9,47,1136,9,1678],[49,47,1137,2,1679],[66,47,1137,38],[68,47,1138,2,1567],[82,47,1138,34],[84,47,1139,2,1638],[87,47,1139,27]],[[4,47,1141,2],[11,47,1141,9,1680],[47,47,1142,4,1679],[66,47,1143,4,1645],[88,47,1143,4,1645],[112,47,1143,28],[114,47,1144,4],[120,47,1145,4,1567],[136,47,1146,4,1638]],[[0,47,1148,0]],[[0,47,1150,0],[9,47,1150,9,1680],[45,47,1151,2,1679],[62,47,1151,38],[64,47,1152,2,1600],[74,47,1152,31],[76,47,1153,2,1681],[97,47,1153,54],[99,47,1154,2,1567],[113,47,1154,34],[115,47,1155,2,1638],[118,47,1155,27]],[[4,47,1157,2],[10,47,1157,8,1682],[28,47,1157,26,1679],[45,47,1157,43],[46,47,1157,44],[48,47,1157,46]],[[4,47,1159,2],[8,47,1159,6,1601]],[[4,47,1160,2],[8,47,1160,6,1648]],[[4,47,1161,2],[8,47,1161,6,1599]],[[4,47,1162,2],[8,47,1162,6,1549]],[[4,47,1163,2],[8,47,1163,6,1683],[14,47,1163,12,1684],[21,47,1163,19],[22,47,1163,20,1682],[40,47,1163,38]],[[8,47,1164,4,1599],[17,47,1164,13]],[[8,47,1165,4],[14,47,1165,10,1685],[30,47,1165,26,1682],[45,47,1165,41],[46,47,1165,42],[48,47,1165,44]],[[8,47,1166,4,1648],[26,47,1166,22,1666],[27,47,1166,22,1666],[30,47,1166,22,1666],[40,47,1166,22,1666],[60,47,1166,42],[62,47,1166,43,1681],[85,47,1166,66,1685]],[[8,47,1167,4,1549],[19,47,1167,15,1651],[20,47,1167,15,1651],[23,47,1167,15,1651],[33,47,1167,15,1651],[55,47,1167,37],[57,47,1167,38,1600],[69,47,1167,50,1648]],[[8,47,1168,4,1601],[18,47,1168,14,1682]],[[4,47,1169,2],[11,47,1169,9]],[[8,47,1170,4],[79,47,1170,75]],[[8,47,1171,4],[22,47,1171,18]],[[8,47,1172,4,1648],[26,47,1172,22,1681]],[[8,47,1173,4],[12,47,1173,8,1600],[23,47,1173,19,1673],[31,47,1173,27],[32,47,1173,28,1674],[41,47,1173,28,1674],[57,47,1173,44],[60,47,1173,47]],[[12,47,1174,6],[38,47,1174,32]],[[12,47,1175,6,1599],[21,47,1175,15]],[[12,47,1177,6],[85,47,1177,79]],[[12,47,1178,6],[84,47,1178,78]],[[12,47,1179,6],[87,47,1179,81]],[[12,47,1180,6],[38,47,1180,32]],[[12,47,1181,6],[14,47,1181,8]],[[12,47,1182,6],[73,47,1182,67]],[[12,47,1183,6],[14,47,1183,8]],[[12,47,1184,6],[85,47,1184,79]],[[12,47,1185,6],[83,47,1185,77]],[[12,47,1186,6,1601],[22,47,1186,16,1674],[31,47,1186,16,1674],[47,47,1186,32]],[[12,47,1187,6,1549],[23,47,1187,17,1675],[24,47,1187,17,1675],[27,47,1187,17,1675],[37,47,1187,17,1675],[57,47,1187,37],[59,47,1188,8,1600],[71,47,1189,8,1567],[87,47,1190,8,1648]],[[12,47,1192,6],[85,47,1192,79]],[[12,47,1193,6],[80,47,1193,74]],[[12,47,1194,6],[83,47,1194,77]],[[12,47,1195,6],[75,47,1195,69]],[[12,47,1196,6],[67,47,1196,61]],[[12,47,1197,6],[57,47,1197,51]],[[12,47,1198,6],[16,47,1198,10,1638],[20,47,1198,14,1625],[36,47,1198,30],[41,47,1198,35],[47,47,1198,41]],[[16,47,1199,8,1638],[20,47,1199,12,1625],[36,47,1199,28],[39,47,1199,31,1676],[40,47,1199,31,1676],[43,47,1199,31,1676],[53,47,1199,31,1676],[77,47,1199,55],[79,47,1200,10,1600],[91,47,1201,10,1567],[107,47,1202,10,1648]],[[12,47,1204,6]],[[8,47,1205,4],[15,47,1205,11]],[[12,47,1206,6],[40,47,1206,34]],[[12,47,1207,6,1599],[21,47,1207,15]],[[12,47,1208,6,1601],[22,47,1208,16,1682]],[[12,47,1209,6,1549],[23,47,1209,17,1651],[24,47,1209,17,1651],[27,47,1209,17,1651],[37,47,1209,17,1651],[59,47,1209,39],[61,47,1209,40,1600],[73,47,1209,52,1648]],[[8,47,1210,4]],[[4,47,1211,2]],[[4,47,1213,2],[8,47,1213,6,1596],[16,47,1213,64]],[[4,47,1215,2],[10,47,1215,8,1686],[27,47,1215,25,1679],[44,47,1215,42],[45,47,1215,43],[47,47,1215,45]],[[4,47,1216,2],[8,47,1216,7],[12,47,1216,11,1597],[32,47,1216,31,1686],[47,47,1216,47]],[[8,47,1217,4],[14,47,1217,10,1687],[33,47,1217,29,1686],[47,47,1217,43],[48,47,1217,44,1597],[65,47,1217,61]],[[8,47,1218,4],[14,47,1218,10,1660],[29,47,1218,25,1687],[45,47,1218,41],[46,47,1218,42],[48,47,1218,44]],[[8,47,1219,4],[82,47,1219,78]],[[8,47,1220,4],[79,47,1220,75]],[[8,47,1221,4],[48,47,1221,44]],[[8,47,1222,4],[14,47,1222,10,1669],[36,47,1222,32,1670],[37,47,1222,32,1670],[40,47,1222,32,1670],[62,47,1222,32,1670],[89,47,1222,59],[91,47,1222,60,1660]],[[8,47,1223,4],[14,47,1223,10,1671],[32,47,1223,28,1672],[33,47,1223,28,1672],[36,47,1223,28,1672],[58,47,1223,28,1672],[85,47,1223,55],[87,47,1224,6,1600],[99,47,1225,6,1597],[117,47,1226,6,1669]],[[8,47,1228,4],[14,47,1228,10,1598],[26,47,1228,22,1680],[62,47,1229,6,1687],[80,47,1230,6,1671],[97,47,1231,6,1648],[114,47,1232,6,1567],[130,47,1233,6,1638]],[[8,47,1235,4],[12,47,1235,8,1596],[22,47,1235,18],[28,47,1235,24]],[[12,47,1236,6,1596],[20,47,1236,14]],[[16,47,1237,8],[17,47,1237,9,1597],[34,47,1237,26],[36,47,1237,28,1598]],[[12,47,1238,6]],[[8,47,1239,4],[15,47,1239,11]],[[12,47,1240,6,1596],[17,47,1240,11],[18,47,1240,12,1597],[35,47,1240,29],[38,47,1240,32,1598]],[[8,47,1241,4]],[[4,47,1242,2]],[[4,47,1244,2],[11,47,1244,9]],[[8,47,1245,4,1600]],[[8,47,1246,4,1601]],[[8,47,1247,4,1549]],[[8,47,1248,4],[82,47,1248,78]],[[8,47,1249,4],[83,47,1249,79]],[[8,47,1250,4],[81,47,1250,77]],[[8,47,1251,4],[83,47,1251,79]],[[8,47,1252,4],[83,47,1252,79]],[[8,47,1253,4],[45,47,1253,41]],[[8,47,1254,4,1599],[16,47,1254,12,1599]],[[8,47,1255,4,1596]],[[8,47,1256,4,1603],[22,47,1256,18,1679],[39,47,1256,35],[40,47,1256,36],[42,47,1256,38],[47,47,1256,43]],[[8,47,1257,4,1604],[28,47,1258,6,1679],[45,47,1258,23],[46,47,1258,24],[48,47,1258,26],[53,47,1258,31,1688],[65,47,1259,10,1679],[82,47,1259,27],[83,47,1259,28],[85,47,1259,30],[88,47,1260,10,1627],[104,47,1260,10,1627],[122,47,1260,28],[123,47,1260,29,1628],[150,47,1260,56]],[[8,47,1262,4],[79,47,1262,75]],[[8,47,1263,4],[53,47,1263,49]],[[8,47,1264,4,1605],[28,47,1264,24]],[[4,47,1265,2]],[[0,47,1266,0]],[[0,47,1268,7],[9,47,1268,16,1499],[45,47,1269,2,1689],[54,47,1269,22]],[[4,47,1271,2],[10,47,1271,8,1686],[27,47,1271,60],[28,47,1271,61]],[[4,47,1272,2],[8,47,1272,6,1689],[18,47,1272,16,1596],[23,47,1272,21],[28,47,1272,26],[34,47,1272,32]],[[8,47,1273,4],[12,47,1273,9],[18,47,1273,15,1597],[38,47,1273,35,1689],[48,47,1273,45,1596],[53,47,1273,50],[54,47,1273,52]],[[12,47,1274,6,1686],[26,47,1274,20],[27,47,1274,21,1597],[44,47,1274,38],[47,47,1274,41,1499],[83,47,1275,8,1689],[93,47,1275,18,1596],[98,47,1275,23],[99,47,1275,24,1597],[116,47,1275,41]],[[8,47,1277,4]],[[4,47,1278,2]],[[4,47,1279,2],[10,47,1279,8,1679],[30,47,1279,47]],[[8,47,1280,4,1689],[18,47,1280,14,1601],[25,47,1280,21]],[[8,47,1281,4,1686]],[[8,47,1282,4]],[[8,47,1283,4]],[[8,47,1284,4,1689],[18,47,1284,14,1603],[30,47,1284,26]],[[5,47,1285,3]],[[4,47,1286,2],[11,47,1286,9,1679]],[[0,47,1287,0]],[[0,47,1289,7],[15,47,1289,22,1501],[37,47,1290,2,1622],[42,47,1290,31],[44,47,1291,2,1537],[48,47,1291,20],[50,47,1292,2,1548],[53,47,1292,20]],[[4,47,1294,2],[81,47,1294,79]],[[4,47,1295,2],[81,47,1295,79]],[[4,47,1296,2],[76,47,1296,74]],[[4,47,1297,2],[18,47,1297,16]],[[4,47,1298,2],[10,47,1298,8,1551],[21,47,1298,19,1548],[25,47,1298,23,1551],[33,47,1298,31]],[[4,47,1299,2],[10,47,1299,8,1552],[19,47,1299,17,1548],[23,47,1299,21,1552],[29,47,1299,27]],[[4,47,1300,2],[10,47,1300,8,1532],[20,47,1300,18,1548],[24,47,1300,22,1532],[31,47,1300,29]],[[4,47,1301,2],[10,47,1301,8,1690],[24,47,1301,22]],[[4,47,1303,2],[10,47,1303,8,1691],[20,47,1303,34]],[[8,47,1304,4],[9,47,1304,5,1692],[27,47,1304,5,1692],[37,47,1304,15],[38,47,1304,16],[40,47,1304,18]],[[8,47,1305,4],[9,47,1305,5,1693],[27,47,1305,5,1693],[54,47,1305,32],[55,47,1305,33],[57,47,1305,35]],[[8,47,1306,4],[9,47,1306,5,1694],[27,47,1306,5,1694],[62,47,1306,40],[63,47,1306,41],[65,47,1306,43,1690]],[[4,47,1307,2]],[[4,47,1308,2],[8,47,1308,6,1532],[20,47,1308,18],[26,47,1308,24]],[[8,47,1309,4,1691],[15,47,1309,11],[16,47,1309,12,1695],[34,47,1309,12,1695],[42,47,1309,20],[43,47,1309,21],[46,47,1309,24,1532]],[[4,47,1310,2]],[[4,47,1312,2],[8,47,1312,6]],[[8,47,1313,4],[14,47,1313,10,1696],[20,47,1313,16],[24,47,1313,20,1577],[28,47,1313,24,1551],[39,47,1313,35,1552],[47,47,1313,43,1586],[56,47,1313,52,1582],[62,47,1313,58]],[[8,47,1314,4],[12,47,1314,8,1697]],[[8,47,1315,4],[12,47,1315,8,1698]],[[8,47,1316,4],[12,47,1316,8,1521],[32,47,1316,28]],[],[[13,47,1373,11]],[[12,47,1374,6],[81,47,1374,75]],[[12,47,1375,6],[86,47,1375,80]],[[12,47,1376,6],[78,47,1376,72]],[[12,47,1377,6],[44,47,1377,38]],[[12,47,1378,6,1697],[23,47,1378,17],[29,47,1378,23,1704],[51,47,1378,45,1696],[56,47,1378,50,1691]],[[12,47,1379,6,1698],[32,47,1380,8,1697],[45,47,1380,21],[53,47,1380,29,1697],[62,47,1380,38,1703],[72,47,1380,48],[75,47,1380,51],[79,47,1380,55,1577],[83,47,1380,59,1697],[92,47,1380,68,1696],[95,47,1380,71],[99,47,1380,75,1696]],[[8,47,1381,4]],[[8,47,1383,4],[12,47,1384,6],[13,47,1384,7,1697],[25,47,1385,6],[26,47,1385,7,1697],[35,47,1385,16,1706],[37,47,1385,18],[41,47,1386,6],[112,47,1386,77]],[[8,47,1387,6],[81,47,1387,79]],[[8,47,1388,6],[60,47,1388,58]],[[8,47,1389,6,1697],[17,47,1389,15,1562],[23,47,1389,21],[28,47,1389,26],[35,47,1390,6],[36,47,1390,7,1697],[45,47,1390,16,1707],[49,47,1390,20],[51,47,1391,6]],[[12,47,1392,6],[84,47,1392,78]],[[12,47,1393,6],[67,47,1393,61]],[[12,47,1394,6,1633],[34,47,1394,28,1622],[41,47,1394,35,1702],[46,47,1394,40,1547],[49,47,1394,43],[54,47,1394,48],[59,47,1394,53]],[[12,47,1395,6],[19,47,1395,13]],[[8,47,1396,4]],[[8,47,1398,4],[74,47,1398,70]],[[8,47,1399,4],[80,47,1399,76]],[[8,47,1400,4],[81,47,1400,77]],[[8,47,1401,4],[80,47,1401,76]],[[8,47,1402,4],[84,47,1402,80]],[[8,47,1403,4],[81,47,1403,77]],[[8,47,1404,4],[10,47,1404,6]],[[8,47,1405,4],[83,47,1405,79]],[[8,47,1406,4],[83,47,1406,79]],[[8,47,1407,4],[84,47,1407,80]],[[8,47,1408,4],[82,47,1408,78]],[[8,47,1409,4],[83,47,1409,79]],[[8,47,1410,4],[36,47,1410,32]],[[8,47,1411,4],[14,47,1411,10,1561],[29,47,1411,25,1588],[30,47,1411,25,1588],[33,47,1411,25,1588],[52,47,1411,25,1588],[69,47,1411,42],[71,47,1411,43,1698]],[[8,47,1413,4],[74,47,1413,70]],[[8,47,1414,4],[14,47,1414,10,1708],[27,47,1414,23,1697],[36,47,1414,32,1691],[43,47,1414,39],[44,47,1414,40,1709],[47,47,1414,43],[48,47,1414,44]],[[8,47,1415,4],[14,47,1415,10,1565],[35,47,1416,6,1708],[50,47,1416,21],[58,47,1416,29,1708],[69,47,1416,40,1710],[77,47,1416,48],[78,47,1416,49,1695],[96,47,1416,49,1695],[104,47,1416,57]],[[8,47,1418,4],[52,47,1418,48]],[[8,47,1419,4],[14,47,1419,10,1711],[23,47,1419,19,1559],[24,47,1419,19,1559],[27,47,1419,19,1559],[49,47,1419,19,1559],[75,47,1419,45]],[[8,47,1421,4],[82,47,1421,78]],[[8,47,1422,4],[81,47,1422,77]],[[8,47,1423,4],[37,47,1423,33]],[[8,47,1424,4],[14,47,1424,10,1712],[34,47,1425,6,1697],[43,47,1425,15,1691],[50,47,1425,22],[51,47,1425,23,1709],[54,47,1425,26],[55,47,1425,27,1713],[73,47,1425,27,1713],[97,47,1425,51],[103,47,1425,57],[110,47,1426,6],[183,47,1426,79]],[[8,47,1427,6],[80,47,1427,78]],[[8,47,1428,6],[51,47,1428,49]],[[8,47,1429,6,1521]],[[8,47,1431,4],[12,47,1431,8,1712],[31,47,1431,27]],[[12,47,1432,6],[18,47,1432,12,1714],[35,47,1432,29,1715],[64,47,1433,8,1697],[73,47,1433,17,1707],[77,47,1433,21],[79,47,1434,8,1711],[86,47,1434,15,1632],[93,47,1434,22],[95,47,1435,8],[104,47,1435,17,1716],[125,47,1435,38,1569],[129,47,1435,42]],[[16,47,1436,10,1717],[17,47,1436,10,1717],[20,47,1436,10,1717],[30,47,1436,10,1717],[47,47,1436,27],[49,47,1436,28,1622],[56,47,1436,35,1569]],[[12,47,1437,8]],[[12,47,1439,6],[18,47,1439,12,1718],[31,47,1439,25],[37,47,1439,31,1719],[38,47,1439,31,1719],[41,47,1439,31,1719],[62,47,1439,31,1719],[90,47,1439,59],[92,47,1440,8,1714],[108,47,1441,8,1691]],[[12,47,1443,6],[16,47,1443,10,1718],[27,47,1443,21,1720],[34,47,1443,28],[39,47,1443,33,1721],[40,47,1443,33,1721],[43,47,1443,33,1721],[55,47,1443,33,1721],[68,47,1443,46],[73,47,1443,50]],[[16,47,1444,8],[85,47,1444,77]],[[16,47,1445,8],[83,47,1445,75]],[[16,47,1446,8],[90,47,1446,82]],[[16,47,1447,8],[86,47,1447,78]],[[16,47,1448,8],[45,47,1448,37]],[[16,47,1449,8],[81,47,1449,73]],[[16,47,1450,8,1633],[38,47,1450,30,1622],[45,47,1450,37,1702],[50,47,1450,42,1547],[53,47,1450,45],[58,47,1450,50],[63,47,1450,55]],[[16,47,1451,8],[23,47,1451,15]],[[12,47,1452,6]],[[12,47,1454,6],[81,47,1454,75]],[[12,47,1455,6],[75,47,1455,69]],[[12,47,1456,6],[29,47,1456,23]],[[12,47,1457,6],[18,47,1457,12,1637],[37,47,1457,31,1722],[38,47,1457,31,1722],[41,47,1457,31,1722],[54,47,1457,31,1722],[73,47,1457,50],[75,47,1457,51,1697]],[[12,47,1458,6],[18,47,1458,12,1567],[35,47,1458,29,1723],[36,47,1458,29,1723],[39,47,1458,29,1723],[52,47,1458,29,1723],[69,47,1458,46],[71,47,1458,47,1697]],[[12,47,1460,6],[81,47,1460,75]],[[12,47,1461,6],[28,47,1461,22]],[[12,47,1462,6],[14,47,1462,8]],[[12,47,1463,6],[77,47,1463,71]],[[12,47,1464,6],[36,47,1464,30]],[[12,47,1465,6],[18,47,1465,12,1638],[24,47,1465,40]],[[16,47,1465,42,1625],[34,47,1465,60]],[[12,47,1465,65]],[[12,47,1466,6],[18,47,1466,12,1689],[30,47,1466,24,1635],[65,47,1467,8,1718],[77,47,1468,8,1637],[95,47,1469,8,1567],[111,47,1470,8,1638]],[[12,47,1472,6],[18,47,1472,12,1625],[37,47,1472,31,1638],[41,47,1472,35,1625],[57,47,1472,51]],[[12,47,1473,6],[16,47,1473,10,1625],[37,47,1473,31],[43,47,1473,37]],[[16,47,1474,8,1633],[38,47,1474,30,1622],[45,47,1474,37,1702],[50,47,1474,42,1547],[53,47,1474,45],[58,47,1474,50],[63,47,1474,55]],[[16,47,1475,8],[23,47,1475,15]],[[12,47,1476,6]],[[12,47,1478,6],[18,47,1478,12,1724],[32,47,1478,26,1505],[47,47,1478,41,1718],[58,47,1478,52,1725],[67,47,1478,61]],[[12,47,1479,6,1624],[35,47,1480,8,1622],[42,47,1481,8,1689],[53,47,1482,8,1625],[71,47,1483,8,1702],[76,47,1483,13,1547],[79,47,1483,16],[84,47,1483,21,1724],[97,47,1484,8,1565],[117,47,1485,8,1561],[131,47,1486,8,1567],[147,47,1487,8,1712]],[[8,47,1489,4],[15,47,1489,11]],[[12,47,1490,6],[76,47,1490,70]],[[12,47,1491,6],[76,47,1491,70]],[[12,47,1492,6],[82,47,1492,76]],[[12,47,1493,6],[69,47,1493,63]],[[12,47,1494,6],[35,47,1494,29]],[[12,47,1495,6],[18,47,1495,12,1714],[35,47,1495,29,1715],[64,47,1496,8,1697],[73,47,1496,17,1707],[77,47,1496,21],[79,47,1497,8,1711],[86,47,1497,15,1632],[93,47,1497,22],[95,47,1498,8],[104,47,1498,17,1716],[125,47,1498,38,1569],[129,47,1498,42]],[[16,47,1499,10,1717],[17,47,1499,10,1717],[20,47,1499,10,1717],[30,47,1499,10,1717],[47,47,1499,27],[49,47,1499,28,1622],[56,47,1499,35,1569]],[[12,47,1500,8]],[[12,47,1502,6],[18,47,1502,12,1718],[31,47,1503,8],[37,47,1503,14,1719],[38,47,1503,14,1719],[41,47,1503,14,1719],[62,47,1503,14,1719],[90,47,1503,42],[92,47,1504,10,1714],[108,47,1505,10,1691]],[[12,47,1507,6],[16,47,1507,10,1718],[27,47,1507,21,1726],[28,47,1507,22],[33,47,1507,27,1721],[34,47,1507,27,1721],[37,47,1507,27,1721],[49,47,1507,27,1721],[62,47,1507,40],[67,47,1507,44]],[[16,47,1508,8],[85,47,1508,77]],[[16,47,1509,8],[83,47,1509,75]],[[16,47,1510,8],[90,47,1510,82]],[[16,47,1511,8],[86,47,1511,78]],[[16,47,1512,8],[45,47,1512,37]],[[16,47,1513,8],[81,47,1513,73]],[[16,47,1514,8,1633],[38,47,1514,30,1622],[45,47,1514,37,1702],[50,47,1514,42,1547],[53,47,1514,45],[58,47,1514,50],[63,47,1514,55]],[[16,47,1515,8],[23,47,1515,15]],[[12,47,1516,6]],[[12,47,1518,6,1727],[46,47,1519,8,1702],[51,47,1519,13,1547],[54,47,1519,16],[58,47,1520,8,1537],[64,47,1521,8],[64,47,1522,8],[143,47,1521,87],[149,47,1522,93]],[[12,47,1523,8,1618],[19,47,1523,8,1618],[32,47,1523,21],[33,47,1523,22,1728],[48,47,1523,37],[50,47,1524,8,1697],[60,47,1525,8,1718],[72,47,1526,8,1622],[79,47,1527,8,1565],[99,47,1528,8,1561],[113,47,1529,8,1712]],[[8,47,1531,4]],[[8,47,1533,4],[12,47,1533,8],[13,47,1533,9,1565],[33,47,1533,29]],[[12,47,1534,6],[85,47,1534,79]],[[12,47,1535,6],[84,47,1535,78]],[[12,47,1536,6],[73,47,1536,67]],[[12,47,1537,6],[43,47,1537,37]],[[12,47,1539,6],[82,47,1539,76]],[[12,47,1540,6],[82,47,1540,76]],[[12,47,1541,6],[66,47,1541,60]],[[12,47,1542,6],[79,47,1542,73]],[[12,47,1543,6],[80,47,1543,74]],[[12,47,1544,6],[27,47,1544,21]],[[12,47,1545,6],[18,47,1545,12,1729],[38,47,1545,47,1730],[39,47,1545,47,1730],[42,47,1545,47,1730],[52,47,1545,47,1730],[77,47,1545,72],[79,47,1546,8,1551],[89,47,1547,8,1552],[97,47,1548,8,1532],[106,47,1549,8,1565]],[[12,47,1551,6],[18,47,1551,12,1553],[35,47,1551,29]],[[12,47,1552,6,1573],[13,47,1552,6,1573],[16,47,1552,6,1573],[26,47,1552,6,1573],[39,47,1552,19],[41,47,1552,20,1527],[56,47,1552,35,1729],[75,47,1552,54,1622],[82,47,1552,61,1553]],[[8,47,1553,4]],[[8,47,1554,4],[80,47,1554,76]],[[8,47,1555,4],[80,47,1555,76]],[[8,47,1556,4],[15,47,1556,11]],[[12,47,1556,13,1731],[19,47,1556,20]],[[12,47,1556,26,1711],[20,47,1556,34,1711],[27,47,1556,41,1558],[34,47,1556,48]],[[8,47,1556,49]],[[4,47,1557,2],[6,47,1557,4],[13,47,1557,11,1542],[20,47,1557,18]],[[8,47,1558,4],[79,47,1558,75]],[[8,47,1559,4],[33,47,1559,29]],[[8,47,1560,4,1633],[30,47,1560,26,1622],[37,47,1560,33,1702],[42,47,1560,38,1547],[45,47,1560,41],[50,47,1560,46],[55,47,1560,51]],[[8,47,1561,4],[15,47,1561,11]],[[4,47,1562,2]],[[0,47,1563,0]],[[0,47,1565,7],[15,47,1565,22,1502],[39,47,1566,2,1607],[44,47,1566,33],[46,47,1567,2,1631],[63,47,1567,45],[65,47,1568,2,1732],[73,47,1568,25],[75,47,1569,2,1533],[79,47,1569,17]],[[4,47,1571,2],[81,47,1571,79]],[[4,47,1572,2],[81,47,1572,79]],[[4,47,1573,2],[76,47,1573,74]],[[4,47,1574,2],[18,47,1574,16]],[[4,47,1575,2],[6,47,1575,4]],[[4,47,1576,2],[78,47,1576,76]],[[4,47,1577,2],[21,47,1577,19]],[[4,47,1579,2],[80,47,1579,78]],[[4,47,1580,2],[81,47,1580,79]],[[4,47,1581,2],[81,47,1581,79]],[[4,47,1582,2],[71,47,1582,69]],[[4,47,1583,2],[10,47,1583,8,1696],[16,47,1583,14],[20,47,1583,18,1577],[24,47,1583,22,1607],[30,47,1583,28,1561],[42,47,1583,40],[44,47,1583,42,1586],[53,47,1583,51,1582],[59,47,1583,57]],[[4,47,1584,2],[10,47,1584,8,1532],[20,47,1584,18,1732],[29,47,1584,27,1532],[36,47,1584,34]],[[4,47,1586,2],[10,47,1586,8,1600],[23,47,1586,21,1533],[28,47,1586,26,1600],[38,47,1586,36]],[[4,47,1587,2],[10,47,1587,8,1733],[33,47,1588,4,1600],[48,47,1588,19,1645],[70,47,1588,19,1645],[94,47,1588,43],[97,47,1590,8],[97,47,1591,8],[162,47,1590,73],[165,47,1591,76]],[[4,47,1592,8],[73,47,1592,77]],[[4,47,1593,8],[68,47,1593,72]],[[4,47,1594,8],[73,47,1594,77]],[[4,47,1595,9],[16,47,1596,8,1600]],[[4,47,1598,2],[10,47,1598,8,1691],[20,47,1598,34]],[[8,47,1599,4],[9,47,1599,5,1692],[27,47,1599,5,1692],[37,47,1599,15],[38,47,1599,16],[40,47,1599,18]],[[8,47,1600,4],[9,47,1600,5,1693],[27,47,1600,5,1693],[54,47,1600,32],[55,47,1600,33],[57,47,1600,35]],[[8,47,1601,4],[9,47,1601,5,1694],[27,47,1601,5,1694],[62,47,1601,40],[63,47,1601,41],[65,47,1601,43,1733]],[[4,47,1602,2]],[[4,47,1603,2],[8,47,1603,6,1532],[20,47,1603,18],[26,47,1603,24]],[[8,47,1604,4,1691],[15,47,1604,11],[16,47,1604,12,1695],[34,47,1604,12,1695],[42,47,1604,20],[43,47,1604,21],[46,47,1604,24,1532]],[[4,47,1605,2]],[[4,47,1607,2],[10,47,1607,8,1734],[23,47,1607,21,1521],[61,47,1609,6,1705],[87,47,1610,6,1696],[99,47,1609,44,1696],[104,47,1609,49,1733]],[[4,47,1611,2],[8,47,1611,6]],[[8,47,1612,4],[14,47,1612,10,1697],[25,47,1612,21],[31,47,1612,27,1704],[53,47,1612,49,1734],[65,47,1612,61,1691]],[[8,47,1613,4],[12,47,1614,6],[13,47,1614,7,1697],[25,47,1615,6],[26,47,1615,7,1697],[35,47,1615,16,1706],[37,47,1615,18],[41,47,1616,6,1697],[50,47,1616,15,1562],[56,47,1616,21],[61,47,1616,26],[68,47,1616,33],[81,47,1616,46]],[[8,47,1617,6],[82,47,1617,80]],[[8,47,1618,6],[81,47,1618,79]],[[8,47,1619,6],[76,47,1619,74]],[[8,47,1620,6],[79,47,1620,77]],[[8,47,1621,6],[34,47,1621,32]],[[8,47,1622,7,1697],[17,47,1622,16,1691],[24,47,1622,23],[25,47,1622,24,1709],[28,47,1622,27],[29,47,1622,28,1713],[47,47,1622,28,1713],[71,47,1622,52],[77,47,1622,58],[84,47,1623,8],[154,47,1623,78]],[[8,47,1624,8],[73,47,1624,73]],[[8,47,1625,8],[61,47,1625,61]],[[8,47,1626,8],[9,47,1626,9,1521],[31,47,1627,6],[32,47,1627,7,1697],[41,47,1627,16,1707],[45,47,1627,20],[47,47,1628,6]],[[12,47,1629,6],[84,47,1629,78]],[[12,47,1630,6],[67,47,1630,61]],[[12,47,1631,6,1634],[36,47,1631,30,1631],[55,47,1631,49,1702],[60,47,1631,54,1547],[63,47,1631,57],[68,47,1631,62],[73,47,1631,67]],[[12,47,1632,6],[19,47,1632,13]],[[8,47,1633,4]],[[8,47,1635,4],[52,47,1635,48]],[[8,47,1636,4],[14,47,1636,10,1711],[23,47,1636,19,1559],[24,47,1636,19,1559],[27,47,1636,19,1559],[49,47,1636,19,1559],[75,47,1636,45]],[[8,47,1638,4],[83,47,1638,79]],[[8,47,1639,4],[68,47,1639,64]],[[8,47,1640,4],[14,47,1640,10,1714],[31,47,1640,27,1715],[60,47,1641,6,1697],[69,47,1641,15,1707],[73,47,1641,19],[75,47,1642,6,1711],[82,47,1642,13,1632],[89,47,1642,20],[91,47,1643,6],[100,47,1643,15,1716],[121,47,1643,36,1569],[125,47,1643,40]],[[12,47,1644,8,1717],[13,47,1644,8,1717],[16,47,1644,8,1717],[26,47,1644,8,1717],[43,47,1644,25],[45,47,1644,26,1631],[64,47,1644,45,1569]],[[8,47,1645,6]],[[8,47,1647,4],[14,47,1647,10,1718],[27,47,1647,23],[33,47,1647,30,1719],[34,47,1647,30,1719],[37,47,1647,30,1719],[58,47,1647,30,1719],[86,47,1647,58],[88,47,1648,6,1714],[104,47,1649,6,1691]],[[8,47,1651,4],[12,47,1651,8,1718],[23,47,1651,19,1720],[30,47,1651,26],[35,47,1651,31,1721],[36,47,1651,31,1721],[39,47,1651,31,1721],[51,47,1651,31,1721],[64,47,1651,44],[69,47,1651,48]],[[12,47,1652,6],[81,47,1652,75]],[[12,47,1653,6],[79,47,1653,73]],[[12,47,1654,6],[86,47,1654,80]],[[12,47,1655,6],[82,47,1655,76]],[[12,47,1656,6],[41,47,1656,35]],[[12,47,1657,6,1634],[36,47,1657,30,1631],[55,47,1657,49,1702],[60,47,1657,54,1547],[63,47,1657,57],[68,47,1657,62],[73,47,1657,67]],[[12,47,1658,6],[19,47,1658,13]],[[8,47,1659,4]],[[8,47,1660,4],[15,47,1660,11]],[[12,47,1661,6,1731],[19,47,1661,13,1630],[44,47,1662,8,1631],[63,47,1663,8,1718],[74,47,1663,19,1615],[77,47,1663,22],[79,47,1664,8,1718],[90,47,1664,19,1614],[97,47,1664,26],[99,47,1666,8],[99,47,1665,8],[140,47,1666,49],[169,47,1665,78]],[[12,47,1667,8,1607],[18,47,1667,14,1570],[25,47,1667,21],[27,47,1668,8,1718],[38,47,1668,19,1612],[47,47,1668,28]],[[12,47,1670,6],[84,47,1670,78]],[[12,47,1671,6],[84,47,1671,78]],[[12,47,1672,6,1711],[20,47,1672,14,1711],[27,47,1672,21,1558],[34,47,1672,28]],[[8,47,1673,4]],[[4,47,1674,2],[6,47,1674,4],[13,47,1674,11,1542],[20,47,1674,18]],[[8,47,1675,4],[79,47,1675,75]],[[8,47,1676,4],[33,47,1676,29]],[[8,47,1677,4,1634],[32,47,1677,28,1631],[51,47,1677,47,1702],[56,47,1677,52,1547],[59,47,1677,55],[64,47,1677,60],[69,47,1677,65]],[[8,47,1678,4],[15,47,1678,11]],[[4,47,1679,2]],[[0,47,1680,0]],[[0,47,1682,7],[15,47,1682,22,1503],[57,47,1683,2,1537],[61,47,1683,20],[63,47,1684,2,1607],[68,47,1684,33],[70,47,1685,2,1606],[83,47,1688,24],[85,47,1689,2,1735],[103,47,1689,39],[105,47,1690,2,1736],[119,47,1690,66]],[[4,47,1692,2],[10,47,1692,8,1548],[16,47,1692,14,1537],[21,47,1692,19,1548],[24,47,1692,22]],[[4,47,1693,2],[10,47,1693,8,1696],[16,47,1693,14],[20,47,1693,18,1577],[24,47,1693,22,1607],[30,47,1693,28,1561],[42,47,1693,40],[44,47,1693,42,1586],[53,47,1693,51,1582],[59,47,1693,57]],[[4,47,1694,2],[10,47,1694,8,1532],[20,47,1694,18,1548],[24,47,1694,22,1532],[31,47,1694,29]],[[4,47,1696,2],[8,47,1697,4,1736],[23,47,1697,19,1569],[27,47,1697,23],[32,47,1697,28],[37,47,1698,4,1736],[52,47,1698,19,1737],[55,47,1698,22],[56,47,1698,23,1607],[62,47,1698,29,1564],[70,47,1698,37],[71,47,1698,38,1600],[81,47,1698,48],[84,47,1699,4]],[[8,47,1700,4],[69,47,1700,65]],[[8,47,1701,4],[37,47,1701,33]],[[8,47,1702,4,1735],[29,47,1702,25,1526]],[[4,47,1703,2]],[[4,47,1705,2],[10,47,1705,8,1691],[20,47,1705,34]],[[8,47,1706,4],[9,47,1706,5,1692],[27,47,1706,5,1692],[37,47,1706,15],[38,47,1706,16],[40,47,1706,18]],[[8,47,1707,4],[9,47,1707,5,1738],[27,47,1707,5,1738],[56,47,1707,34],[57,47,1707,35],[59,47,1708,6,1739],[60,47,1708,6,1739],[63,47,1708,6,1739],[82,47,1708,6,1739],[116,47,1708,40],[118,47,1708,41,1735]],[[4,47,1709,2]],[[4,47,1710,2],[8,47,1710,6,1532],[20,47,1710,18],[26,47,1710,24]],[[8,47,1711,4,1691],[15,47,1711,11],[16,47,1711,12,1695],[34,47,1711,12,1695],[42,47,1711,20],[43,47,1711,21],[46,47,1711,24,1532]],[[4,47,1712,2]],[[4,47,1713,2],[11,47,1713,10,1606]],[[8,47,1714,4],[13,47,1714,9,1618],[20,47,1714,9,1618],[33,47,1714,22],[34,47,1714,23,1620],[38,47,1714,27]],[[12,47,1714,29]],[[16,47,1718,6]],[[12,47,1719,4]],[[8,47,1720,4],[13,47,1720,9,1618],[20,47,1720,9,1618],[33,47,1720,22],[34,47,1720,23,1740],[44,47,1720,33]],[[12,47,1720,35]],[[16,47,1721,6,1691],[23,47,1721,13],[24,47,1721,14,1693],[42,47,1721,14,1693],[69,47,1721,41],[70,47,1721,42],[73,47,1721,45]],[[16,47,1722,6]],[[12,47,1723,4]],[[8,47,1724,4],[13,47,1724,9,1618],[20,47,1724,9,1618],[33,47,1724,22],[34,47,1724,23,1728],[49,47,1724,38]],[[12,47,1724,40]],[[16,47,1725,6,1691],[23,47,1725,13],[24,47,1725,14,1693],[42,47,1725,14,1693],[69,47,1725,41],[70,47,1725,42],[73,47,1725,45]],[[16,47,1726,6]],[[12,47,1727,4]],[[8,47,1728,4]],[[12,47,1728,13]],[[16,47,1729,6,1606]],[[12,47,1730,4]],[[4,47,1731,2]],[[4,47,1733,2],[8,47,1733,6]],[[8,47,1734,4],[14,47,1734,10,1697],[25,47,1734,21],[31,47,1734,27,1704],[53,47,1734,49,1696],[58,47,1734,54,1691]],[[8,47,1735,4],[12,47,1735,8],[13,47,1735,9,1697],[25,47,1735,21],[26,47,1735,22,1697],[35,47,1735,31,1706],[37,47,1735,33],[41,47,1735,37],[42,47,1735,38,1697],[51,47,1735,47,1707],[55,47,1735,51],[57,47,1735,53]],[[12,47,1736,6],[84,47,1736,78]],[[12,47,1737,6],[67,47,1737,61]],[[12,47,1738,6,1741],[47,47,1738,41,1736],[63,47,1738,57,1702],[68,47,1738,62,1547],[71,47,1738,65],[76,47,1738,70],[81,47,1738,75]],[[12,47,1739,6],[19,47,1739,13]],[[8,47,1740,4]],[[8,47,1742,4],[14,47,1742,10,1567],[31,47,1742,27,1723],[32,47,1742,27,1723],[35,47,1742,27,1723],[48,47,1742,27,1723],[65,47,1742,44],[67,47,1742,45,1697]],[[8,47,1743,4],[12,47,1743,8,1567],[31,47,1743,27,1607],[37,47,1743,33,1567],[51,47,1743,47],[53,47,1743,49]],[[12,47,1744,6],[77,47,1744,71]],[[12,47,1745,6],[85,47,1745,79]],[[12,47,1746,6],[82,47,1746,76]],[[12,47,1747,6],[29,47,1747,23]],[[12,47,1748,6],[85,47,1748,79]],[[12,47,1749,6],[83,47,1749,77]],[[12,47,1750,6],[57,47,1750,51]],[[12,47,1751,6,1741],[47,47,1751,41,1736],[63,47,1751,57,1702],[68,47,1751,62,1547],[71,47,1751,65],[76,47,1751,70],[81,47,1751,75]],[[12,47,1752,6],[19,47,1752,13]],[[8,47,1753,4]],[[8,47,1755,4],[52,47,1755,48]],[[8,47,1756,4],[14,47,1756,10,1711],[23,47,1756,19,1559],[24,47,1756,19,1559],[27,47,1756,19,1559],[49,47,1756,19,1559],[75,47,1756,45]],[[8,47,1758,4],[12,47,1758,8,1742],[31,47,1758,69]],[[8,47,1759,4],[14,47,1759,10,1714],[31,47,1759,27,1715],[60,47,1760,6,1697],[69,47,1760,15,1707],[73,47,1760,19],[75,47,1761,6,1711],[82,47,1761,13,1632],[89,47,1761,20],[91,47,1762,6],[100,47,1762,15,1716],[121,47,1762,36,1743],[144,47,1762,59]],[[12,47,1763,8],[79,47,1763,75]],[[12,47,1764,8],[77,47,1764,73]],[[12,47,1765,8],[54,47,1765,50]],[[12,47,1766,8],[16,47,1766,12,1742],[37,47,1766,33],[43,47,1766,39]],[[16,47,1767,10],[74,47,1767,68]],[[16,47,1768,10],[33,47,1768,27]],[[16,47,1769,10]],[[12,47,1770,8]],[[12,47,1771,8],[18,47,1771,14,1744],[32,47,1771,28,1743],[58,47,1771,54,1742],[75,47,1771,71,1745],[81,47,1771,77]],[[12,47,1772,8],[17,47,1772,13],[23,47,1772,19,1622],[32,47,1772,28,1742],[49,47,1772,46]],[[16,47,1773,10,1717],[17,47,1773,10,1717],[20,47,1773,10,1717],[30,47,1773,10,1717],[47,47,1773,27],[49,47,1773,28,1622],[56,47,1773,35,1744]],[[12,47,1774,8]],[[8,47,1775,6]],[[8,47,1777,4],[14,47,1777,10,1718],[27,47,1777,23],[33,47,1777,30,1719],[34,47,1777,30,1719],[37,47,1777,30,1719],[58,47,1777,30,1719],[86,47,1777,58],[88,47,1778,6,1714],[104,47,1779,6,1691]],[[8,47,1782,4],[14,47,1782,10,1746],[34,47,1783,6,1606],[52,47,1783,24,1618],[59,47,1783,24,1618],[72,47,1783,37],[73,47,1783,38,1740],[83,47,1783,48],[86,47,1785,10,1718],[97,47,1785,21,1747],[99,47,1785,23],[101,47,1785,25],[102,47,1785,26],[104,47,1785,28],[109,47,1785,33],[116,47,1787,10],[116,47,1788,10],[213,47,1787,107]],[[8,47,1790,4],[81,47,1790,77]],[[8,47,1791,4],[84,47,1791,80]],[[8,47,1792,4],[44,47,1792,40]],[[8,47,1793,4,1742],[27,47,1793,23,1748],[63,47,1794,6,1702],[68,47,1794,11,1547],[71,47,1794,14],[75,47,1795,6,1537],[81,47,1796,6,1606],[96,47,1797,6,1697],[106,47,1798,6,1718],[118,47,1799,6,1746],[137,47,1800,6,1607],[144,47,1801,6,1736]],[[8,47,1804,4],[80,47,1804,76]],[[8,47,1805,4],[80,47,1805,76]],[[8,47,1806,4],[15,47,1806,11]],[[12,47,1806,13,1731],[19,47,1806,20]],[[12,47,1806,26,1711],[20,47,1806,34,1711],[27,47,1806,41,1558],[34,47,1806,48]],[[8,47,1806,49]],[[4,47,1807,2],[6,47,1807,4],[13,47,1807,11,1542],[20,47,1807,18]],[[8,47,1808,4,1741],[43,47,1808,39,1736],[59,47,1808,55,1702],[64,47,1808,60,1547],[67,47,1808,63],[72,47,1808,68],[77,47,1808,73]],[[8,47,1809,4],[15,47,1809,11]],[[4,47,1810,2]],[[0,47,1811,0]],[[0,47,1813,0],[9,47,1813,9,1727],[43,47,1814,2,1547],[46,47,1814,13],[48,47,1815,2,1537],[52,47,1815,20],[54,47,1816,2,1606],[67,47,1819,24],[69,47,1820,2,1697],[77,47,1820,49],[79,47,1821,2,1718],[89,47,1821,38],[91,47,1822,2,1622],[96,47,1822,31],[98,47,1823,2,1565],[116,47,1823,29],[118,47,1824,2,1561],[130,47,1824,22],[132,47,1825,2,1712],[149,47,1825,28]],[[4,47,1827,2],[81,47,1827,79]],[[4,47,1828,2],[66,47,1828,64]],[[4,47,1829,2],[10,47,1829,8,1567],[27,47,1829,25,1723],[28,47,1829,25,1723],[31,47,1829,25,1723],[44,47,1829,25,1723],[61,47,1829,42],[63,47,1829,43,1697]],[[4,47,1831,2],[10,47,1831,8,1749],[39,47,1831,37,1750],[40,47,1831,37,1750],[43,47,1831,37,1750],[62,47,1831,37,1750],[81,47,1831,56],[83,47,1831,57,1718],[94,47,1831,68,1751],[95,47,1831,69]],[[4,47,1832,2],[8,47,1833,4],[8,47,1834,4],[26,47,1834,22],[75,47,1833,71]],[[4,47,1835,4],[11,47,1835,11,1749],[42,47,1835,42],[54,47,1836,4,1749],[81,47,1836,31,1745],[87,47,1836,37],[92,47,1836,42],[95,47,1837,4]],[[8,47,1838,4,1633],[30,47,1838,26,1622],[37,47,1838,33,1547],[43,47,1838,39],[48,47,1838,44]],[[8,47,1839,4]],[[4,47,1840,2]],[[4,47,1841,2],[10,47,1841,8,1752],[23,47,1841,21,1749],[49,47,1841,47],[50,47,1841,48],[52,47,1841,50]],[[4,47,1842,2],[8,47,1842,6],[9,47,1842,7,1752],[20,47,1842,18,1753],[32,47,1842,30],[34,47,1842,32]],[[8,47,1843,4],[38,47,1843,34]],[[8,47,1844,4,1633],[30,47,1844,26,1622],[37,47,1844,33,1547],[43,47,1844,39],[48,47,1844,44]],[[8,47,1845,4]],[[4,47,1846,2]],[[4,47,1848,2],[10,47,1848,8,1679],[30,47,1848,28,1752],[41,47,1848,39,1533],[45,47,1848,43]],[[4,47,1849,2],[69,47,1849,67]],[[4,47,1850,2],[52,47,1850,50]],[[4,47,1851,2],[10,47,1851,8,1518],[29,47,1852,4],[36,47,1852,11,1718],[47,47,1852,22,1747],[49,47,1852,24],[51,47,1852,26],[52,47,1852,27],[54,47,1852,29],[59,47,1852,34],[70,47,1853,8,1718],[81,47,1853,19,1747],[83,47,1853,21],[84,47,1853,22],[86,47,1853,24],[89,47,1854,8,1754],[98,47,1854,17,1697],[107,47,1854,26,1691],[114,47,1854,33],[115,47,1854,34,1709],[118,47,1854,37],[119,47,1854,38,1755],[137,47,1854,38,1755],[166,47,1854,67],[171,47,1854,72],[175,47,1854,76]],[[4,47,1855,2],[10,47,1855,8,1724],[24,47,1855,22],[25,47,1855,23,1756],[31,47,1855,29,1518],[51,47,1856,6,1505],[66,47,1856,21,1518],[86,47,1857,6,1757],[103,47,1857,6,1757],[122,47,1857,25]],[[4,47,1859,2],[81,47,1859,79]],[[4,47,1860,2],[76,47,1860,74]],[[4,47,1861,2],[82,47,1861,80]],[[4,47,1862,2],[41,47,1862,39]],[[4,47,1863,2],[10,47,1863,8,1746],[30,47,1864,4,1697],[39,47,1864,13,1691],[46,47,1864,20],[47,47,1864,21,1709],[50,47,1864,24],[51,47,1864,25,1713],[69,47,1864,25,1713],[93,47,1864,49],[99,47,1864,55]],[[4,47,1866,2],[73,47,1866,71]],[[4,47,1867,2],[20,47,1867,18]],[[4,47,1868,2],[6,47,1868,4]],[[4,47,1869,2],[69,47,1869,67]],[[4,47,1870,2],[28,47,1870,26]],[[4,47,1871,2],[10,47,1871,8,1638],[16,47,1871,36]],[[8,47,1871,38,1625],[26,47,1871,56]],[[4,47,1871,61]],[[4,47,1872,2],[10,47,1872,8,1689],[22,47,1872,20,1678],[62,47,1873,4,1679],[81,47,1874,4,1567],[97,47,1875,4,1638]],[[4,47,1877,2],[10,47,1877,8,1625],[29,47,1877,27,1638],[33,47,1877,31,1625],[49,47,1877,47]],[[4,47,1878,2],[8,47,1878,6,1625],[29,47,1878,27],[35,47,1878,33]],[[8,47,1879,4,1633],[30,47,1879,26,1622],[37,47,1879,33,1547],[43,47,1879,39],[48,47,1879,44]],[[8,47,1880,4]],[[4,47,1881,2]],[[4,47,1883,2],[10,47,1883,8,1629],[27,47,1883,25,1624],[50,47,1884,4,1622],[57,47,1885,4,1689],[68,47,1886,4,1625],[86,47,1887,4,1547],[92,47,1887,10,1724],[105,47,1888,4,1565],[125,47,1889,4,1561],[139,47,1890,4,1567],[155,47,1891,4,1712]],[[4,47,1894,2],[79,47,1894,77]],[[4,47,1895,2],[73,47,1895,71]],[[4,47,1896,2],[6,47,1896,4]],[[4,47,1897,2],[78,47,1897,76]],[[4,47,1898,2],[78,47,1898,76]],[[4,47,1899,2],[80,47,1899,78]],[[4,47,1900,2],[77,47,1900,75]],[[4,47,1901,2],[78,47,1901,76]],[[4,47,1902,2],[79,47,1902,77]],[[4,47,1903,2,1748],[40,47,1904,4,1547],[45,47,1905,4,1537],[51,47,1906,4,1606],[66,47,1907,4,1697],[76,47,1908,4,1718],[88,47,1909,4,1746],[107,47,1910,4,1629],[123,47,1911,4]],[[0,47,1913,0]],[[0,47,1915,0],[9,47,1915,9,1741],[44,47,1916,2,1758],[51,47,1916,52],[53,47,1917,2,1570],[60,47,1917,17]],[[4,47,1919,2],[10,47,1919,8,1742],[29,47,1919,27],[31,47,1919,29]],[[4,47,1920,2],[9,47,1920,7],[15,47,1920,13,1622],[24,47,1920,22,1758],[32,47,1920,30,1759],[38,47,1920,36],[41,47,1920,40]],[[8,47,1921,4],[12,47,1921,8,1622],[18,47,1921,14,1562],[24,47,1921,20],[29,47,1921,20],[32,47,1921,46]],[[12,47,1922,6,1634],[36,47,1922,30,1622],[43,47,1922,37,1570]],[[8,47,1923,4],[15,47,1923,11],[19,47,1923,15,1622],[25,47,1923,21,1562],[31,47,1923,27],[36,47,1923,27],[39,47,1923,55]],[[12,47,1924,6,1742],[29,47,1924,23,1760],[33,47,1924,27],[34,47,1924,28,1622]],[[8,47,1925,4]],[[4,47,1926,2]],[[4,47,1927,2],[11,47,1927,9,1742]],[[0,47,1928,0]],[[0,47,1930,0],[9,47,1930,9,1748],[45,47,1931,2,1547],[48,47,1931,13],[50,47,1932,2,1537],[54,47,1932,20],[56,47,1933,2,1606],[69,47,1936,24],[71,47,1937,2,1697],[79,47,1937,49],[81,47,1938,2,1718],[91,47,1938,38],[93,47,1939,2,1746],[110,47,1939,28],[112,47,1940,2,1607],[117,47,1940,33],[119,47,1941,2,1736],[133,47,1941,73]],[[4,47,1943,2],[8,47,1943,6,1718],[19,47,1943,17,1726],[20,47,1943,18],[25,47,1943,23,1721],[26,47,1943,23,1721],[29,47,1943,23,1721],[41,47,1943,23,1721],[54,47,1943,36],[59,47,1943,40]],[[8,47,1944,4],[77,47,1944,73]],[[8,47,1945,4],[75,47,1945,71]],[[8,47,1946,4],[82,47,1946,78]],[[8,47,1947,4],[78,47,1947,74]],[[8,47,1948,4],[37,47,1948,33]],[[8,47,1949,4],[12,47,1949,8,1736],[31,47,1949,27],[37,47,1949,33]],[[12,47,1950,6,1741],[47,47,1950,41,1736],[63,47,1950,57,1547],[69,47,1950,63],[74,47,1950,68]],[[8,47,1951,4]],[[8,47,1952,4],[15,47,1952,11]],[[4,47,1953,2]],[[4,47,1955,2],[10,47,1955,8,1761],[24,47,1955,22,1750],[25,47,1955,22,1750],[28,47,1955,22,1750],[47,47,1955,22,1750],[66,47,1955,41],[68,47,1955,42,1718],[79,47,1955,53,1751],[80,47,1955,54]],[[4,47,1956,2],[8,47,1956,6],[15,47,1956,13,1761],[31,47,1956,29],[41,47,1956,39]],[[8,47,1957,4],[80,47,1957,76]],[[8,47,1958,4],[84,47,1958,80]],[[8,47,1959,4],[15,47,1959,11]],[[4,47,1960,2]],[[4,47,1962,2],[69,47,1962,67]],[[4,47,1963,2],[52,47,1963,50]],[[4,47,1964,2],[10,47,1964,8,1518],[29,47,1965,4],[36,47,1965,11,1718],[47,47,1965,22,1747],[49,47,1965,24],[51,47,1965,26],[52,47,1965,27],[54,47,1965,29],[59,47,1965,34],[70,47,1966,8,1718],[81,47,1966,19,1747],[83,47,1966,21],[84,47,1966,22],[86,47,1966,24],[89,47,1967,8,1754],[98,47,1967,17,1697],[107,47,1967,26,1691],[114,47,1967,33],[115,47,1967,34,1709],[118,47,1967,37],[119,47,1967,38,1755],[137,47,1967,38,1755],[166,47,1967,67],[171,47,1967,72],[175,47,1967,76]],[[4,47,1968,2],[10,47,1968,8,1724],[24,47,1968,22],[25,47,1968,23,1756],[31,47,1968,29,1518],[51,47,1969,6,1505],[66,47,1969,21,1518],[86,47,1970,6,1757],[103,47,1970,6,1757],[122,47,1970,25]],[[4,47,1971,2],[10,47,1971,8,1570],[20,47,1971,18,1547],[26,47,1971,24,1724]],[[4,47,1973,2],[9,47,1973,7],[15,47,1973,13,1752],[29,47,1973,27,1761],[41,47,1973,40]],[[8,47,1974,4],[14,47,1974,10,1762],[25,47,1974,21,1752],[36,47,1974,32,1762],[44,47,1974,40]],[[8,47,1975,4],[12,47,1975,8,1762],[25,47,1975,21],[31,47,1975,27]],[[12,47,1976,6],[83,47,1976,77]],[[12,47,1977,6],[80,47,1977,74]],[[12,47,1978,6],[14,47,1978,8]],[[12,47,1979,6],[82,47,1979,76]],[[12,47,1980,6],[57,47,1980,51]],[[12,47,1981,6],[14,47,1981,8]],[[12,47,1982,6],[73,47,1982,67]],[[12,47,1983,6],[18,47,1983,12,1690],[32,47,1983,26,1752],[43,47,1983,37,1690],[54,47,1983,48]],[[12,47,1984,6],[16,47,1984,10,1533],[23,47,1984,17,1607],[29,47,1984,23,1533],[33,47,1984,27]],[[12,47,1985,6],[16,47,1985,11],[20,47,1985,15,1763],[24,47,1985,19],[27,47,1985,22,1763],[31,47,1985,26,1690],[43,47,1985,38,1745],[49,47,1985,44],[51,47,1985,46,1763],[56,47,1985,51],[58,47,1985,54]],[[16,47,1986,8],[22,47,1986,14,1597],[41,47,1986,41,1690],[52,47,1986,52],[53,47,1986,53,1763],[55,47,1986,55]],[[16,47,1987,8],[20,47,1987,12,1533],[26,47,1987,18,1596],[33,47,1987,25],[34,47,1987,26,1597],[51,47,1987,43],[56,47,1987,48,1688],[67,47,1987,59]],[[20,47,1988,10,1533],[27,47,1988,17,1533],[32,47,1988,22,1596],[37,47,1988,27],[38,47,1988,28,1597],[55,47,1988,45]],[[16,47,1989,8],[23,47,1989,15]],[[20,47,1990,10],[24,47,1990,14,1736],[43,47,1990,33],[49,47,1990,39]],[[24,47,1991,12,1741],[59,47,1991,47,1736],[75,47,1991,63,1547],[81,47,1991,69],[86,47,1991,74]],[[20,47,1992,10]],[[20,47,1993,10],[27,47,1993,17]],[[16,47,1994,8]],[[12,47,1995,6]],[[12,47,1997,6,1764],[35,47,1998,8,1547],[40,47,1999,8,1537],[46,47,2000,8,1606],[61,47,2001,8,1607],[68,47,2002,8,1533],[74,47,2003,8,1570],[83,47,2004,8,1762],[93,47,2005,8,1746],[112,47,2006,8,1736]],[[8,47,2008,4]],[[8,47,2010,4],[14,47,2010,10,1765],[21,47,2010,17,1752],[32,47,2010,28,1765],[36,47,2010,32]],[[8,47,2011,4],[12,47,2011,8,1765],[21,47,2011,17],[27,47,2011,23]],[[12,47,2012,6,1766],[49,47,2013,8,1547],[54,47,2014,8,1606],[69,47,2015,8,1607],[76,47,2016,8,1765],[82,47,2017,8],[88,47,2018,8,1752],[99,47,2018,19,1767],[112,47,2018,32],[114,47,2019,8,1570],[123,47,2020,8,1607],[129,47,2020,14,1564],[137,47,2020,22],[139,47,2021,8,1736]],[[8,47,2023,4]],[[4,47,2024,2]],[[4,47,2025,2],[75,47,2025,73]],[[4,47,2026,2],[80,47,2026,78]],[[4,47,2027,2],[42,47,2027,40]],[[4,47,2028,2],[80,47,2028,78]],[[4,47,2029,2],[79,47,2029,77]],[[4,47,2030,2],[77,47,2030,75]],[[4,47,2031,2],[82,47,2031,80]],[[4,47,2032,2],[72,47,2032,70]],[[4,47,2033,2],[8,47,2033,6,1736],[27,47,2033,25],[33,47,2033,31]],[[8,47,2034,4],[14,47,2034,10,1742],[33,47,2034,29,1741],[68,47,2035,6,1736],[84,47,2036,6,1547],[90,47,2036,12],[95,47,2036,17]],[[8,47,2038,4],[15,47,2038,11,1742]],[[4,47,2039,2]],[[4,47,2040,2],[11,47,2040,9]],[[0,47,2041,0]],[[0,47,2043,0],[9,47,2043,9,1764],[32,47,2044,2,1547],[35,47,2044,13],[37,47,2045,2,1537],[41,47,2045,20],[43,47,2046,2,1606],[56,47,2049,24],[58,47,2050,2,1607],[63,47,2050,33],[65,47,2051,2,1533],[69,47,2051,17],[71,47,2052,2,1570],[78,47,2052,17],[80,47,2053,2,1762],[88,47,2053,29],[90,47,2054,2,1746],[107,47,2054,28],[109,47,2055,2,1768],[134,47,2058,10]],[[4,47,2060,2],[76,47,2060,74]],[[4,47,2061,2],[51,47,2061,49]],[[4,47,2062,2],[10,47,2062,8,1615],[16,47,2062,14,1762],[24,47,2062,22],[25,47,2062,23],[27,47,2062,25]],[[4,47,2063,2],[10,47,2063,8,1614],[20,47,2063,18,1762],[28,47,2063,26],[29,47,2063,27],[31,47,2063,29]],[[4,47,2064,2],[10,47,2064,8,1612],[22,47,2064,20,1615],[30,47,2064,28],[38,47,2064,36,1746]],[[4,47,2065,2,1766],[41,47,2066,4,1547],[46,47,2067,4,1606],[61,47,2068,4,1607],[68,47,2069,4,1615],[73,47,2070,4,1614],[82,47,2071,4,1612],[93,47,2072,4,1570],[102,47,2073,4,1533],[108,47,2074,4,1768]],[[4,47,2077,2],[55,47,2077,53]],[[4,47,2078,2],[10,47,2078,8,1596],[18,47,2078,16,1533],[23,47,2078,21,1596],[28,47,2078,26]],[[4,47,2079,2],[8,47,2079,6,1596],[18,47,2079,16],[24,47,2079,22]],[[8,47,2080,4],[14,47,2080,10,1769],[33,47,2080,29,1762],[41,47,2080,37],[42,47,2080,38],[44,47,2080,40]],[[8,47,2081,4],[12,47,2081,9],[18,47,2081,15,1597],[38,47,2081,35,1596],[44,47,2081,42]],[[12,47,2082,6],[18,47,2082,12,1598],[30,47,2082,24,1596],[35,47,2082,29],[36,47,2082,30,1597],[53,47,2082,47]],[[12,47,2083,6],[18,47,2083,12,1770],[34,47,2084,8,1769],[50,47,2084,24],[51,47,2084,25,1597],[68,47,2084,42]],[[12,47,2085,6],[16,47,2085,10,1770],[34,47,2085,28],[42,47,2085,36,1770],[60,47,2085,54,1688],[71,47,2085,65]],[[16,47,2086,8,1764],[39,47,2087,10,1547],[44,47,2088,10,1537],[50,47,2089,10,1606],[65,47,2090,10,1607],[72,47,2091,10,1598],[83,47,2092,10,1570],[92,47,2093,10,1770],[107,47,2094,10,1746],[126,47,2095,10,1768]],[[12,47,2097,6]],[[8,47,2098,4]],[[4,47,2099,2]],[[0,47,2100,0]],[[0,47,2102,0],[9,47,2102,9,1766],[46,47,2103,2,1547],[49,47,2103,13],[51,47,2104,2,1606],[64,47,2107,24],[66,47,2108,2,1607],[71,47,2108,33],[73,47,2109,2,1615],[76,47,2109,22],[78,47,2110,2,1614],[85,47,2110,57],[87,47,2111,2,1612],[96,47,2111,20],[98,47,2112,2,1570],[105,47,2112,17],[107,47,2113,2,1533],[111,47,2113,17],[113,47,2114,2,1768],[138,47,2117,10]],[[4,47,2119,2],[78,47,2119,76]],[[4,47,2120,2],[80,47,2120,78]],[[4,47,2121,2],[67,47,2121,65]],[[4,47,2122,2],[10,47,2122,8,1771],[23,47,2123,4,1768],[53,47,2123,34],[60,47,2124,8,1768],[86,47,2124,34,1709],[89,47,2124,37],[90,47,2124,38,1533],[95,47,2124,43,1600],[105,47,2124,53],[109,47,2125,8,1688]],[[4,47,2126,2],[8,47,2126,6,1771],[23,47,2126,21,1688],[34,47,2126,32]],[[8,47,2127,4,1630],[33,47,2127,29,1771],[45,47,2127,41,1615],[50,47,2127,46,1614],[59,47,2127,55,1570],[68,47,2127,64,1612]],[[4,47,2128,2],[11,47,2128,9]],[[8,47,2129,4],[66,47,2129,62]],[[8,47,2130,4],[14,47,2130,10,1772],[33,47,2130,29,1510],[63,47,2131,6,1547],[68,47,2132,6,1606],[83,47,2133,6,1607],[90,47,2134,6,1533]],[[8,47,2136,4],[12,47,2136,8,1772],[29,47,2136,25,1562],[35,47,2136,31],[40,47,2136,31],[43,47,2136,55]],[[12,47,2137,6],[64,47,2137,58]],[[12,47,2138,6],[18,47,2138,12,1773],[29,47,2138,23,1772]],[[12,47,2139,6,1630],[37,47,2140,8,1515],[61,47,2140,32,1773],[71,47,2140,42,1606],[87,47,2141,8,1615],[92,47,2142,8,1614],[101,47,2143,8,1570],[110,47,2144,8,1612]],[[8,47,2146,4],[15,47,2146,11]],[[12,47,2147,6],[77,47,2147,71]],[[12,47,2148,6],[59,47,2148,53]],[[12,47,2149,6],[18,47,2149,12,1773],[29,47,2149,23,1630],[54,47,2150,8,1515],[78,47,2151,10,1500],[110,47,2151,42,1570],[120,47,2152,10,1606],[136,47,2154,8,1615],[141,47,2155,8,1614],[150,47,2156,8,1570],[159,47,2157,8,1612]],[[12,47,2159,6,1516],[31,47,2160,8,1547],[36,47,2161,8,1609],[37,47,2161,8,1609],[40,47,2161,8,1609],[50,47,2161,8,1609],[78,47,2161,36],[80,47,2161,37,1606],[95,47,2161,52,1533],[102,47,2162,8,1773]],[[8,47,2164,4]],[[4,47,2165,2]],[[0,47,2166,0]],[[0,47,2168,0],[15,47,2168,15,1704],[37,47,2169,2,1696],[40,47,2169,10],[42,47,2170,2,1691],[49,47,2170,25]],[[4,47,2172,2],[10,47,2172,8,1774],[26,47,2172,24]],[[4,47,2173,2],[81,47,2173,79]],[[4,47,2174,2],[81,47,2174,79]],[[4,47,2175,2],[56,47,2175,54]],[[4,47,2176,2],[55,47,2176,53]],[[4,47,2177,2],[10,47,2177,8,1775],[36,47,2177,34]],[[4,47,2178,2],[10,47,2178,8,1697],[21,47,2178,19],[27,47,2178,25,1776],[28,47,2178,25,1776],[31,47,2178,25,1776],[52,47,2178,25,1776],[63,47,2178,36],[65,47,2179,4,1696],[70,47,2180,4,1691],[79,47,2181,4,1774],[94,47,2182,4,1775]],[[4,47,2184,2],[8,47,2184,6],[9,47,2184,7,1697],[18,47,2184,16,1706],[20,47,2184,18],[22,47,2184,20]],[[8,47,2185,4],[15,47,2185,11]],[[4,47,2186,2]],[[4,47,2188,2],[29,47,2188,27]],[[4,47,2189,2],[8,47,2189,6,1521],[43,47,2189,26]],[[4,47,2190,4],[78,47,2190,78]],[[4,47,2191,4],[79,47,2191,79]],[[4,47,2192,4],[79,47,2192,79]],[[4,47,2193,4],[58,47,2193,58]],[[4,47,2194,2],[11,47,2194,9]],[[8,47,2195,4],[14,47,2195,10,1777],[28,47,2195,24,1697],[37,47,2195,33,1691],[44,47,2195,40],[45,47,2195,41,1709],[48,47,2195,44],[49,47,2195,45]],[[8,47,2196,4],[14,47,2196,10,1778],[33,47,2197,6,1777],[48,47,2197,21,1777],[60,47,2197,33,1779],[70,47,2197,43],[71,47,2197,44,1780],[89,47,2197,44,1780],[112,47,2197,67]],[[8,47,2198,4],[12,47,2198,8],[13,47,2198,9,1778],[31,47,2198,27]],[[12,47,2199,6],[19,47,2199,13]],[[8,47,2200,4]],[[4,47,2201,2]],[[4,47,2202,2],[11,47,2202,9,1697]],[[0,47,2203,0]],[[0,47,2205,0],[9,47,2205,9,1715],[38,47,2206,2,1781],[58,47,2206,50],[60,47,2207,2,1782],[73,47,2207,27],[75,47,2208,2,1716],[95,47,2208,46]],[[4,47,2210,2],[78,47,2210,76]],[[4,47,2211,2],[80,47,2211,78]],[[4,47,2212,2],[75,47,2212,73]],[[4,47,2213,2],[78,47,2213,76]],[[4,47,2214,2],[66,47,2214,64]],[[4,47,2215,2],[47,47,2215,45]],[[4,47,2216,2],[6,47,2216,4]],[[4,47,2217,2],[79,47,2217,77]],[[4,47,2218,2],[78,47,2218,76]],[[4,47,2219,2],[82,47,2219,80]],[[4,47,2220,2],[35,47,2220,33]],[[4,47,2221,2],[6,47,2221,4]],[[4,47,2222,2],[82,47,2222,80]],[[4,47,2223,2],[37,47,2223,35]],[[4,47,2224,2],[8,47,2224,6,1783],[26,47,2224,24]],[[4,47,2225,2],[10,47,2225,8,1784],[19,47,2225,17,1781],[40,47,2225,38,1785],[49,47,2225,47]],[[4,47,2226,2],[11,47,2226,9],[15,47,2226,13,1786],[30,47,2226,28]],[[8,47,2227,4],[14,47,2227,10,1787],[20,47,2227,15,1788],[30,47,2227,25]],[[12,47,2228,6],[18,47,2228,13],[23,47,2228,19]],[[16,47,2229,8],[22,47,2229,14],[24,47,2229,16,1789],[28,47,2229,20],[30,47,2229,22,1731],[35,47,2229,27],[37,47,2229,29],[40,47,2229,32],[46,47,2229,38,1784],[53,47,2229,45,1790],[57,47,2229,49]],[[16,47,2230,8],[20,47,2230,12],[21,47,2230,13,1789],[27,47,2230,19]],[[20,47,2231,10],[87,47,2231,77]],[[20,47,2232,10],[39,47,2232,29]],[[20,47,2233,10,1788],[31,47,2233,21,1791],[38,47,2233,28],[39,47,2233,29,1731]],[[20,47,2235,10],[83,47,2235,73]],[[20,47,2236,10],[86,47,2236,76]],[[20,47,2237,10],[89,47,2237,79]],[[20,47,2238,10],[65,47,2238,55]],[[20,47,2239,10,1783],[39,47,2239,29,1731],[45,47,2239,35,1792],[55,47,2239,45]],[[20,47,2240,10,1716],[41,47,2240,31,1783]],[[20,47,2241,10]],[[16,47,2242,8]],[[16,47,2243,8],[85,47,2243,77]],[[16,47,2244,8],[70,47,2244,62]],[[16,47,2245,8,1782]],[[16,47,2246,8]],[[12,47,2247,6]],[[8,47,2248,4]],[[4,47,2249,2]],[[0,47,2250,0]],[[0,47,2252,0],[9,47,2252,9,1705],[47,47,2253,2,1696],[50,47,2253,10],[52,47,2254,2,1690],[63,47,2254,32]],[[4,47,2256,2],[8,47,2256,6,1521],[28,47,2256,26]],[],[[4,47,2268,2],[11,47,2268,9,1696]],[[0,47,2269,0]],[[0,47,2292,7],[9,47,2292,16,1498],[47,47,2293,2,1798],[62,47,2293,32],[64,47,2294,2,1799],[75,47,2294,28]],[[4,47,2296,2],[11,47,2296,9,1798],[29,47,2296,27,1799]],[[0,47,2297,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,48,575,16,1800],[32,48,575,44],[34,48,575,44]],[[15,48,575,16,1800]],[],[[4,48,69,16,1801],[12,48,69,24],[14,48,69,24]],[[15,48,69,16,1801]],[],[[4,48,205,16,1802],[25,48,205,37],[27,48,205,37]],[[15,48,205,16,1802]],[],[],[[37,48,11,36]],[[32,48,18,7]],[[35,48,19,34]],[[23,48,28,7]],[[26,48,29,31]],[[25,48,30,45]],[[23,48,31,36]],[[0,48,69,7],[9,48,69,16,1801],[18,48,70,2,1803],[21,48,70,10],[23,48,71,2,1804],[33,48,71,17],[35,48,72,2,1805],[51,48,72,36],[53,48,73,2,1806],[77,48,73,45],[79,48,74,2,1807],[86,48,74,24],[88,48,75,2,1808],[103,48,75,34],[105,48,76,2,1809],[117,48,76,23],[119,48,77,2,1810],[131,48,77,55]],[[4,48,79,2],[10,48,79,8,1811],[16,48,79,14,1812],[21,48,79,19,1811],[24,48,79,22]],[[4,48,80,2],[10,48,80,8,1813],[17,48,80,15,1803],[21,48,80,19,1813],[25,48,80,23]],[[4,48,82,2],[81,48,82,79]],[[4,48,83,2],[80,48,83,78]],[[4,48,84,2],[82,48,84,80]],[[4,48,85,2],[16,48,85,14]],[[4,48,86,2],[6,48,86,4]],[[4,48,87,2],[80,48,87,78]],[[4,48,88,2],[80,48,88,78]],[[4,48,89,2],[79,48,89,77]],[[4,48,90,2],[22,48,90,20]],[[4,48,91,2],[6,48,91,4]],[[4,48,92,2],[81,48,92,79]],[[4,48,93,2],[82,48,93,80]],[[4,48,94,2],[80,48,94,78]],[[4,48,95,2],[31,48,95,29]],[[4,48,96,2],[6,48,96,4]],[[4,48,97,2],[78,48,97,76]],[[4,48,98,2],[79,48,98,77]],[[4,48,99,2],[51,48,99,49]],[[4,48,100,2],[10,48,100,8,1814],[33,48,100,31,1813],[42,48,100,40,1804],[53,48,100,51,1813],[57,48,100,55]],[[4,48,102,2],[10,48,102,8,1815],[21,48,102,19,1816],[22,48,102,19,1816],[25,48,102,19,1816],[35,48,102,19,1816],[49,48,102,33],[51,48,102,34,1813],[57,48,102,40,1807]],[[4,48,103,2],[10,48,103,8,1817],[18,48,103,16,1818],[19,48,103,16,1818],[22,48,103,16,1818],[29,48,103,16,1818],[48,48,103,35],[50,48,103,36,1811],[55,48,103,41,1815]],[[4,48,104,2],[8,48,104,6,1817],[18,48,104,16],[26,48,104,24,1817],[32,48,104,30,1819],[38,48,104,36],[43,48,104,41,1820],[50,48,104,41,1820],[61,48,104,52],[62,48,104,53,1821],[71,48,104,62],[73,48,104,64]],[[8,48,105,4],[39,48,105,35]],[[8,48,106,4],[14,48,106,10,1822],[25,48,106,21,1823],[53,48,106,49,1811],[58,48,106,54,1817],[65,48,106,61,1817],[71,48,106,67,1824],[75,48,106,71]],[[8,48,107,4],[14,48,107,10,1825],[42,48,107,38,1822],[51,48,107,47,1826],[68,48,107,64]],[[8,48,108,4],[14,48,108,10,1827],[33,48,108,29,1822],[42,48,108,38,1828],[50,48,108,46]],[[8,48,109,4],[14,48,109,10,1829],[29,48,109,25,1830],[55,48,109,51,1811],[60,48,109,56,1817]],[[8,48,110,4],[14,48,110,10,1831],[29,48,110,25,1829],[42,48,110,38,1832],[45,48,110,41]],[[8,48,111,4],[14,48,111,10,1833],[38,48,111,34,1829],[51,48,111,47,1834],[60,48,111,56]],[[8,48,112,4],[81,48,112,77]],[[8,48,113,4],[78,48,113,74]],[[8,48,114,4],[79,48,114,75]],[[8,48,115,4],[81,48,115,77]],[[8,48,116,4],[78,48,116,74]],[[8,48,117,4],[19,48,117,15]],[[8,48,118,4],[14,48,118,10,1835],[32,48,118,28,1817],[38,48,118,34,1836],[50,48,118,46],[53,48,118,49,1803],[57,48,118,53,1837],[61,48,118,57]],[[8,48,119,4],[14,48,119,10,1838],[31,48,119,27,1817],[37,48,119,33,1838],[51,48,119,47]],[[8,48,120,4],[15,48,120,11,1839],[48,48,121,6,1811],[53,48,122,6,1803],[58,48,123,6,1804],[70,48,124,6,1807],[79,48,125,6,1814],[101,48,126,6,1805],[119,48,127,6,1806],[145,48,128,6,1825],[172,48,129,6,1827],[190,48,130,6,1831],[204,48,131,6,1833],[227,48,132,6,1835],[244,48,133,6,1838],[260,48,134,6,1808],[277,48,135,6,1809]],[[4,48,137,2]],[[4,48,139,2],[73,48,139,71]],[[4,48,140,2],[44,48,140,42]],[[4,48,141,2],[6,48,141,4]],[[4,48,142,2],[78,48,142,76]],[[4,48,143,2],[80,48,143,78]],[[4,48,144,2],[54,48,144,52]],[[4,48,145,2],[6,48,145,4]],[[4,48,146,2],[79,48,146,77]],[[4,48,147,2],[70,48,147,68]],[[4,48,148,2],[8,48,148,6,1817],[18,48,148,16],[26,48,148,24,1817],[32,48,148,30,1819],[38,48,148,36],[43,48,148,41,1820],[50,48,148,41,1820],[61,48,148,52],[62,48,148,53,1840],[70,48,148,61],[72,48,148,63]],[[8,48,149,4],[14,48,149,10,1841],[32,48,149,28,1842],[33,48,149,28,1842],[36,48,149,28,1842],[43,48,149,28,1842],[75,48,149,60],[77,48,149,61,1811],[82,48,149,66,1803],[87,48,149,71,1807]],[[8,48,150,4],[12,48,150,8,1841],[32,48,150,28],[38,48,150,34]],[[12,48,151,6],[78,48,151,72]],[[12,48,152,6],[18,48,152,12,1822],[29,48,152,23,1823],[57,48,153,8,1811],[62,48,154,8,1841],[79,48,155,8,1841],[95,48,155,24,1824],[99,48,155,28]],[[12,48,157,6],[18,48,157,12,1825],[46,48,157,40,1822],[55,48,157,49,1826],[72,48,157,66]],[[12,48,158,6],[18,48,158,12,1827],[37,48,158,31,1822],[46,48,158,40,1828],[54,48,158,48]],[[12,48,159,6],[18,48,159,12,1829],[33,48,159,27,1830],[59,48,159,53,1811],[64,48,159,58,1841]],[[12,48,160,6],[18,48,160,12,1831],[33,48,160,27,1829],[46,48,160,40,1832],[49,48,160,43]],[[12,48,161,6],[18,48,161,12,1833],[42,48,161,36,1829],[55,48,161,49,1834],[64,48,161,58]],[[12,48,162,6],[18,48,162,12,1835],[36,48,162,30,1841],[52,48,162,46,1836],[64,48,162,58],[67,48,162,61,1803],[71,48,162,65,1837],[75,48,162,69]],[[12,48,163,6],[18,48,163,12,1843],[38,48,163,32,1841],[54,48,163,48,1838],[68,48,163,62]],[[12,48,164,6],[19,48,164,13,1839],[52,48,165,8,1811],[57,48,166,8,1803],[62,48,167,8,1804],[74,48,168,8,1807],[83,48,169,8,1814],[105,48,170,8,1805],[123,48,171,8,1806],[149,48,172,8,1825],[176,48,173,8,1827],[194,48,174,8,1831],[208,48,175,8,1833],[231,48,176,8,1835],[248,48,177,8,1843],[267,48,178,8,1808],[284,48,179,8,1809]],[[8,48,181,4]],[[4,48,182,2]],[[4,48,184,2],[64,48,184,62]],[[4,48,185,2],[8,48,185,6,1844],[29,48,185,27,1810],[42,48,185,40,1844],[60,48,185,58],[64,48,185,62],[66,48,185,64]],[[4,48,186,2],[8,48,186,6,1810],[21,48,186,19,1844],[39,48,186,37],[44,48,186,42,1845],[55,48,186,53]],[[8,48,187,4,1844],[29,48,187,25,1810],[42,48,187,38,1844],[60,48,187,56],[63,48,187,59],[65,48,187,61]],[[4,48,188,2]],[[4,48,189,2],[11,48,189,9]],[[8,48,190,4,1846],[13,48,190,9,1847],[20,48,190,9,1847],[39,48,190,28],[40,48,190,29,1848],[45,48,190,34]],[[8,48,191,4,1849],[14,48,191,10,1850],[48,48,192,6,1811],[53,48,193,6,1803],[58,48,194,6,1804],[70,48,195,6,1807],[79,48,196,6,1805],[97,48,197,6,1806],[123,48,198,6,1808],[140,48,199,6,1809],[154,48,200,6,1844]],[[4,48,202,2]],[[0,48,203,0]],[[0,48,205,7],[9,48,205,16,1802],[31,48,206,2,1811],[34,48,206,13],[36,48,207,2,1803],[39,48,207,10],[41,48,208,2,1836],[53,48,208,22],[55,48,209,2,1851],[69,48,209,32],[71,48,210,2,1804],[81,48,210,17],[83,48,211,2,1805],[99,48,211,36],[101,48,212,2,1806],[125,48,212,45],[127,48,213,2,1808],[142,48,213,34],[144,48,214,2,1807],[151,48,214,24],[153,48,215,2,1809],[165,48,215,23]],[[4,48,217,2],[80,48,217,78]],[[4,48,218,2],[54,48,218,52]],[[4,48,219,2],[10,48,219,8,1810],[25,48,219,54]],[[8,48,220,4,1852],[28,48,220,24]],[[8,48,221,4,1853],[29,48,221,25]],[[4,48,222,2]],[[4,48,223,2],[10,48,223,8,1814],[33,48,223,31,1803],[37,48,223,35,1813],[41,48,223,39],[46,48,223,44,1804],[57,48,223,55,1813],[61,48,223,59]],[[4,48,224,2],[10,48,224,8,1854],[17,48,224,15,1855],[18,48,224,15,1855],[21,48,224,15,1855],[37,48,224,15,1855],[55,48,224,33],[57,48,225,4,1811],[62,48,226,4,1804],[74,48,227,4,1805],[92,48,228,4,1806],[118,48,229,4,1851],[133,48,229,19,1824],[137,48,229,23],[139,48,230,4,1808],[156,48,231,4,1851],[171,48,231,19,1849],[175,48,231,23],[177,48,232,4,1851],[192,48,232,19,1856],[196,48,232,23],[198,48,233,4],[204,48,234,4],[210,48,235,4],[217,48,236,4,1814],[239,48,237,4,1810]],[[4,48,239,2],[8,48,239,6,1854],[17,48,239,15],[23,48,239,21]],[[8,48,240,4,1857],[9,48,240,4,1857],[12,48,240,4,1857],[28,48,240,4,1857],[48,48,240,24],[50,48,240,25,1854],[56,48,240,31,1803],[61,48,240,36,1807],[70,48,240,45,1808],[87,48,240,62,1810]],[[8,48,241,4],[15,48,241,11,1858],[38,48,242,6,1854],[44,48,243,6,1836],[58,48,244,6,1851],[73,48,244,21,1838],[87,48,244,35],[89,48,245,6,1810],[102,48,245,19,1852],[120,48,245,37],[122,48,246,6,1809],[136,48,247,6,1803],[140,48,247,10,1837],[144,48,247,14]],[[4,48,249,2]],[[4,48,250,2],[82,48,250,80]],[[4,48,251,2],[11,48,251,9]],[[8,48,252,4,1846],[13,48,252,9,1847],[20,48,252,9,1847],[39,48,252,28],[40,48,252,29,1859],[43,48,252,32]],[[8,48,253,4,1849],[14,48,253,10,1836]],[[4,48,254,2]],[[0,48,255,0]],[[0,48,257,0],[9,48,257,9,1839],[42,48,258,2,1811],[45,48,258,13],[47,48,259,2,1803],[50,48,259,10],[52,48,260,2,1804],[62,48,260,17],[64,48,261,2,1807],[71,48,261,24],[73,48,262,2,1814],[93,48,262,31],[95,48,263,2,1805],[111,48,263,36],[113,48,264,2,1806],[137,48,264,45],[139,48,265,2,1825],[164,48,265,46],[166,48,266,2,1827],[182,48,266,44],[184,48,267,2,1831],[196,48,267,31],[198,48,268,2,1833],[219,48,268,32],[221,48,269,2,1836],[233,48,269,22],[235,48,270,2,1838],[249,48,270,24],[251,48,271,2,1808],[266,48,271,34],[268,48,272,2,1809],[280,48,272,23]],[[4,48,274,2],[82,48,274,80]],[[4,48,275,2],[76,48,275,74]],[[4,48,276,2],[75,48,276,73]],[[4,48,277,2],[78,48,277,76]],[[4,48,278,2],[82,48,278,80]],[[4,48,279,2],[68,48,279,66]],[[4,48,280,2],[10,48,280,8,1810],[25,48,280,54]],[[8,48,281,4,1852],[28,48,281,24]],[[8,48,282,4,1853],[29,48,282,25]],[[4,48,283,2]],[[4,48,284,2],[10,48,284,8,1828],[21,48,284,19]],[[4,48,285,2],[10,48,285,8,1860],[21,48,285,19]],[[4,48,286,2],[10,48,286,8,1854],[17,48,286,15,1855],[18,48,286,15,1855],[21,48,286,15,1855],[37,48,286,15,1855],[55,48,286,33],[57,48,287,4,1811],[62,48,288,4,1804],[74,48,289,4,1805],[92,48,290,4,1806],[118,48,291,4,1825],[145,48,292,4,1808],[162,48,293,4,1828],[172,48,294,4,1860],[182,48,295,4,1827],[200,48,296,4,1831],[214,48,297,4,1833],[237,48,298,4,1814],[259,48,299,4,1810]],[[4,48,301,2],[8,48,301,6,1854],[17,48,301,15],[23,48,301,21]],[[8,48,302,4,1857],[9,48,302,4,1857],[12,48,302,4,1857],[28,48,302,4,1857],[48,48,302,24],[50,48,302,25,1854],[56,48,302,31,1803],[61,48,302,36,1807],[70,48,302,45,1808],[87,48,302,62,1810]],[[8,48,303,4],[15,48,303,11,1858],[38,48,304,6,1854],[44,48,305,6,1836],[58,48,306,6,1838],[74,48,307,6,1810],[87,48,307,19,1852],[105,48,307,37],[107,48,308,6,1809],[121,48,309,6,1803],[125,48,309,10,1837],[129,48,309,14]],[[4,48,311,2]],[[4,48,312,2],[82,48,312,80]],[[4,48,313,2],[11,48,313,9]],[[8,48,314,4,1846],[13,48,314,9,1847],[20,48,314,9,1847],[39,48,314,28],[40,48,314,29,1859],[43,48,314,32]],[[8,48,315,4,1849],[14,48,315,10,1836]],[[4,48,316,2]],[[0,48,317,0]],[[0,48,319,0],[9,48,319,9,1858],[32,48,320,2,1854],[36,48,320,22],[38,48,321,2,1836],[50,48,321,22],[52,48,322,2,1838],[66,48,322,24],[68,48,323,2,1852],[86,48,323,53],[88,48,324,2,1809],[100,48,324,23],[102,48,325,2,1837],[106,48,325,14]],[[4,48,327,2],[11,48,327,9]],[[8,48,328,4,1846],[13,48,328,9,1847],[20,48,328,9,1847],[39,48,328,28],[40,48,328,29,1861],[47,48,328,36]],[[8,48,329,4,1849],[14,48,329,10]],[[12,48,330,6,1826],[31,48,330,25,1854],[36,48,330,30,1817],[41,48,330,35]],[[12,48,331,6,1862],[23,48,331,17,1854],[28,48,331,22,1863],[32,48,331,26]],[[12,48,332,6,1836]],[[12,48,333,6,1838]],[[12,48,334,6,1852]],[[12,48,335,6,1809]],[[12,48,336,6,1837]],[[8,48,337,4]],[[4,48,338,2]],[[0,48,339,0]],[[0,48,341,0],[9,48,341,9,1823],[37,48,342,2,1811],[40,48,342,13],[42,48,343,2,1817],[47,48,343,33],[49,48,344,2,1824],[53,48,344,17]],[[4,48,346,2],[8,48,346,6,1864],[28,48,346,77],[29,48,346,78]],[[4,48,347,2],[8,48,347,6,1865],[25,48,349,6],[26,48,349,7]],[[4,48,350,2],[10,48,350,8,1866],[18,48,350,16,1824],[23,48,350,21,1866],[28,48,350,26]],[[4,48,351,2],[8,48,351,6,1866],[18,48,351,16],[24,48,351,22]],[[8,48,352,4],[12,48,352,9],[18,48,352,15,1867],[38,48,352,35,1866],[44,48,352,42]],[[12,48,353,6],[18,48,353,12,1868],[30,48,353,24,1866],[35,48,353,29],[36,48,353,30,1867],[53,48,353,47]],[[12,48,354,6],[18,48,354,12,1869],[32,48,354,26,1823],[60,48,354,54,1811],[65,48,354,59,1817],[72,48,354,66,1868]],[[12,48,355,6,1864],[29,48,355,23],[30,48,355,24,1867],[47,48,355,41],[50,48,355,44,1869],[62,48,355,56,1826],[79,48,355,73]],[[12,48,356,6,1865],[26,48,356,20],[27,48,356,21,1867],[44,48,356,38],[47,48,356,41,1869],[59,48,356,53,1828],[67,48,356,61]],[[8,48,357,4]],[[4,48,358,2]],[[4,48,360,2],[8,48,360,6,1832],[14,48,360,36]],[[4,48,361,2],[8,48,361,6,1870],[18,48,361,64]],[[4,48,362,2],[8,48,362,6,1834],[20,48,362,27]],[[4,48,364,2],[10,48,364,8,1871],[25,48,364,23,1872],[26,48,364,23,1872],[29,48,364,23,1872],[36,48,364,23,1872],[57,48,364,44],[59,48,364,45,1811],[64,48,364,50,1824],[69,48,364,55,1873],[77,48,364,63]],[[4,48,365,2],[8,48,365,6,1871],[25,48,365,23],[31,48,365,29]],[[8,48,366,4],[15,48,366,12,1871],[28,48,366,25,1819],[34,48,366,31]],[[12,48,367,6],[17,48,367,11,1820],[24,48,367,11,1820],[35,48,367,22],[36,48,367,23,1821],[45,48,367,32]],[[16,48,367,34]],[[20,48,368,8],[46,48,368,34]],[[20,48,369,8,1832],[26,48,369,14,1871],[39,48,369,27,1832],[42,48,369,30]],[[20,48,370,8,1870],[30,48,370,18,1871],[43,48,370,31,1870],[50,48,370,38]],[[20,48,371,8,1834],[32,48,371,20,1871],[45,48,371,33,1834],[54,48,371,42]],[[20,48,372,8]],[[16,48,373,6]],[[12,48,374,6],[17,48,374,11,1820],[24,48,374,11,1820],[35,48,374,22],[36,48,374,23,1874],[43,48,374,30]],[[16,48,374,32]],[[20,48,375,8],[89,48,375,77]],[[20,48,376,8],[84,48,376,72]],[[20,48,377,8],[81,48,377,69]],[[20,48,378,8],[26,48,378,14,1875],[53,48,378,41,1876],[54,48,378,41,1876],[57,48,378,41,1876],[64,48,378,41,1876],[88,48,378,65],[90,48,378,66,1871]],[[20,48,379,8,1832],[26,48,379,14,1875],[51,48,379,39,1877],[55,48,379,43],[56,48,379,44],[57,48,379,45,1878],[65,48,380,10,1878],[75,48,380,20],[82,48,380,27,1878],[88,48,380,33,1832],[91,48,380,36],[94,48,380,39]],[[20,48,382,8,1870],[30,48,382,18,1875],[55,48,382,43,1877],[59,48,382,47],[60,48,382,48],[61,48,382,49,1878],[69,48,383,10,1878],[79,48,383,20],[86,48,383,27,1878],[92,48,383,33,1870],[99,48,383,40],[102,48,383,43]],[[20,48,385,8],[88,48,385,76]],[[20,48,386,8],[91,48,386,79]],[[20,48,387,8],[89,48,387,77]],[[20,48,388,8],[85,48,388,73]],[[20,48,389,8],[35,48,389,23]],[[20,48,390,8],[22,48,390,10]],[[20,48,391,8],[85,48,391,73]],[[20,48,392,8],[90,48,392,78]],[[20,48,393,8],[92,48,393,80]],[[20,48,394,8],[41,48,394,29]],[[20,48,395,8,1834],[32,48,395,20,1871],[45,48,395,33,1834],[54,48,395,42]],[[20,48,396,8]],[[16,48,397,6]],[[12,48,398,6],[17,48,398,11,1820],[24,48,398,11,1820],[35,48,398,22],[36,48,398,23,1879],[41,48,398,28]],[[12,48,399,6],[17,48,399,11,1820],[24,48,399,11,1820],[35,48,399,22],[36,48,399,23,1840],[44,48,399,31]],[[16,48,400,8]],[[12,48,401,6]],[[16,48,402,8,1871]],[[8,48,403,4]],[[4,48,404,2]],[[4,48,406,2],[68,48,406,66]],[[4,48,407,2],[72,48,407,70]],[[4,48,408,2],[72,48,408,70]],[[4,48,409,2],[26,48,409,24]],[[4,48,410,2],[6,48,410,4]],[[4,48,411,2],[67,48,411,65]],[[4,48,412,2],[6,48,412,4]],[[4,48,413,2],[71,48,413,69]],[[4,48,414,2],[69,48,414,67]],[[4,48,415,2],[75,48,415,73]],[[4,48,416,2],[10,48,416,8,1880],[20,48,416,18,1881],[21,48,416,18,1881],[24,48,416,18,1881],[33,48,416,18,1881],[61,48,416,46],[63,48,417,4,1824],[68,48,417,9,1880],[75,48,417,16],[77,48,418,4,1882],[84,48,418,11,1883],[95,48,418,22],[96,48,418,23],[100,48,418,27,1884],[116,48,418,43,1817],[122,48,418,49,1838],[136,48,418,63]],[[4,48,421,2],[94,48,421,92]],[[4,48,422,2],[10,48,422,8,1885],[31,48,422,29]],[[4,48,424,2],[11,48,424,9]],[[8,48,425,4,1826],[27,48,425,23]],[[12,48,426,6,1880]],[[12,48,427,6,1864]],[[12,48,428,6]],[[12,48,429,6]],[[12,48,430,6,1824],[17,48,430,11,1886],[29,48,430,23]],[[9,48,431,5]],[[8,48,432,4,1828],[18,48,432,14]],[[12,48,432,15,1832]],[[12,48,432,20,1865]],[[12,48,432,36,1870]],[[12,48,432,45,1834]],[[12,48,432,56,1885]],[[9,48,432,75]],[[4,48,433,2]],[[0,48,434,0]],[[0,48,436,0],[9,48,436,9,1830],[35,48,437,2,1811],[38,48,437,13],[40,48,438,2,1817],[45,48,438,33]],[[4,48,440,2],[60,48,440,58]],[[4,48,441,2],[8,48,441,6,1832],[14,48,441,36]],[[4,48,442,2],[8,48,442,6,1834],[20,48,442,27]],[[4,48,443,2],[10,48,443,8,1871],[25,48,443,23,1872],[26,48,443,23,1872],[29,48,443,23,1872],[36,48,443,23,1872],[57,48,443,44],[59,48,443,45,1811],[64,48,443,50,1817],[70,48,443,56,1887],[78,48,443,64],[79,48,443,65,1873],[87,48,443,73]],[[4,48,444,2],[8,48,444,6,1871],[25,48,444,23],[31,48,444,29]],[[8,48,445,4],[15,48,445,12,1871],[28,48,445,25,1819],[34,48,445,31]],[[12,48,446,6],[17,48,446,11,1820],[24,48,446,11,1820],[35,48,446,22],[36,48,446,23,1821],[45,48,446,32]],[[16,48,446,34]],[[20,48,447,8,1832],[26,48,447,14,1871],[39,48,447,27,1832],[42,48,447,30]],[[20,48,448,8,1834],[32,48,448,20,1871],[45,48,448,33,1834],[54,48,448,42]],[[20,48,449,8]],[[16,48,450,6]],[[12,48,451,6],[17,48,451,11,1820],[24,48,451,11,1820],[35,48,451,22],[36,48,451,23,1874],[43,48,451,30]],[[16,48,451,32]],[[20,48,452,8],[26,48,452,14,1875],[53,48,452,41,1876],[54,48,452,41,1876],[57,48,452,41,1876],[64,48,452,41,1876],[88,48,452,65],[90,48,452,66,1871]],[[20,48,453,8,1832],[26,48,453,14,1875],[51,48,453,39,1877],[55,48,453,43],[56,48,453,44],[57,48,453,45,1878],[65,48,454,10,1878],[75,48,454,20],[82,48,454,27,1878],[88,48,454,33,1832],[91,48,454,36],[94,48,454,39]],[[20,48,456,8,1834],[32,48,456,20,1871],[45,48,456,33,1834],[54,48,456,42]],[[20,48,457,8]],[[16,48,458,6]],[[12,48,459,6],[17,48,459,11,1820],[24,48,459,11,1820],[35,48,459,22],[36,48,459,23,1879],[41,48,459,28]],[[12,48,460,6],[17,48,460,11,1820],[24,48,460,11,1820],[35,48,460,22],[36,48,460,23,1840],[44,48,460,31]],[[16,48,461,8]],[[12,48,462,6]],[[16,48,463,8,1871]],[[8,48,464,4]],[[4,48,465,2]],[[4,48,466,2],[11,48,466,9]],[[8,48,466,11,1832]],[[8,48,466,16,1834]],[[4,48,466,26]],[[0,48,467,0]],[[0,48,469,0],[79,48,469,79]],[[0,48,470,0],[75,48,470,75]],[[0,48,471,0],[78,48,471,78]],[[0,48,472,0],[76,48,472,76]],[[0,48,473,0],[16,48,473,16]],[[0,48,474,0],[6,48,474,6,1888],[41,48,474,60]],[[4,48,475,2]],[[4,48,476,2],[5,48,476,3]],[[4,48,477,2]],[[4,48,478,2]],[[1,48,479,1]],[[0,48,481,0],[15,48,481,15,1850],[49,48,482,2,1811],[52,48,482,13],[54,48,483,2,1803],[57,48,483,10],[59,48,484,2,1804],[69,48,484,17],[71,48,485,2,1807],[78,48,485,24],[80,48,486,2,1805],[96,48,486,36],[98,48,487,2,1806],[122,48,487,45],[124,48,488,2,1808],[139,48,488,34],[141,48,489,2,1809],[153,48,489,23],[155,48,490,2,1844],[173,48,490,36]],[[4,48,492,2],[80,48,492,78]],[[4,48,493,2],[74,48,493,72]],[[4,48,494,2],[80,48,494,78]],[[4,48,495,2],[78,48,495,76]],[[4,48,496,2],[65,48,496,63]],[[4,48,497,2],[6,48,497,4]],[[4,48,498,2],[74,48,498,72]],[[4,48,499,2],[80,48,499,78]],[[4,48,500,2],[79,48,500,77]],[[4,48,501,2],[70,48,501,68]],[[4,48,502,2],[75,48,502,73]],[[4,48,504,2],[8,48,504,6,1889]],[[4,48,505,2],[11,48,505,10,1808]],[[8,48,506,4],[13,48,506,9,1890],[29,48,506,9,1890],[44,48,506,24],[45,48,506,25,1891],[52,48,506,32]],[[8,48,507,4],[13,48,507,9,1890],[29,48,507,9,1890],[44,48,507,24],[45,48,507,25,1892],[61,48,507,41]],[[12,48,508,6,1889],[33,48,508,27,1806]],[[12,48,509,6]],[[8,48,510,4],[13,48,510,9,1890],[29,48,510,9,1890],[44,48,510,24],[45,48,510,25,1893],[54,48,510,34]],[[8,48,511,4],[13,48,511,9,1890],[29,48,511,9,1890],[44,48,511,24],[45,48,511,25,1894],[55,48,511,35]],[[8,48,512,4],[13,48,512,9,1890],[29,48,512,9,1890],[44,48,512,24],[45,48,512,25,1895],[55,48,512,35]],[[12,48,513,6,1889],[33,48,513,27,1888]],[[12,48,514,6]],[[8,48,515,4]],[[12,48,516,6,1808]],[[12,48,517,6,1889],[33,48,517,27,1806]],[[12,48,518,6]],[[4,48,519,2]],[[4,48,521,2],[10,48,521,8,1896],[44,48,521,42,1897],[45,48,521,42,1897],[48,48,521,42,1897],[69,48,521,42,1897],[88,48,521,61],[90,48,521,62,1803],[95,48,521,67]],[[8,48,522,4,1826],[27,48,522,23,1889]],[[8,48,523,4,1807]],[[4,48,524,2]],[[4,48,525,2],[10,48,525,8,1898],[19,48,525,17],[25,48,525,23,1896]],[[4,48,526,2],[8,48,526,6],[15,48,526,13,1898],[26,48,526,24],[36,48,526,34]],[[8,48,527,4],[37,48,527,33]],[[8,48,528,4],[14,48,528,10,1899],[23,48,528,19,1898]],[[8,48,529,4],[15,48,529,11]],[[12,48,530,6,1846],[17,48,530,11,1847],[24,48,530,11,1847],[43,48,530,30],[44,48,530,31,1859],[47,48,530,34]],[[12,48,531,6,1849],[18,48,531,12,1899]],[[8,48,532,4]],[[4,48,533,2]],[[4,48,535,2],[10,48,535,8],[12,48,536,4,1900],[22,48,536,14],[24,48,537,4,1836],[36,48,537,16],[38,48,538,4,1838],[52,48,538,18],[54,48,539,4,1901],[65,48,539,15,1902],[86,48,539,36],[88,48,540,3],[91,48,540,6,1898]],[[4,48,541,2],[8,48,541,6,1902],[34,48,541,32],[40,48,541,38]],[[8,48,542,4,1844],[27,48,542,23,1903],[31,48,542,27],[35,48,542,31,1902]],[[4,48,543,2]],[[4,48,545,2],[79,48,545,77]],[[4,48,546,2],[80,48,546,78]],[[4,48,547,2],[73,48,547,71]],[[4,48,548,2],[10,48,548,8,1851],[27,48,548,25,1800],[56,48,549,4,1806],[82,48,550,4,1900],[94,48,551,4,1838]],[[4,48,554,2],[11,48,554,9,1802],[33,48,555,4,1811],[38,48,556,4,1803],[43,48,557,4,1904],[44,48,557,4,1904],[47,48,557,4,1904],[66,48,557,4,1904],[83,48,557,21],[85,48,557,22,1836],[100,48,558,4,1851],[116,48,559,4,1804],[128,48,560,4,1805],[146,48,561,4,1806],[172,48,562,4,1808],[189,48,563,4,1807],[198,48,564,4,1809]],[[0,48,566,0]],[[0,48,575,7],[9,48,575,16,1800],[38,48,576,2,1905],[49,48,576,32],[51,48,577,2,1900],[61,48,577,41],[63,48,578,2,1838],[77,48,578,24]],[[4,48,580,2],[81,48,580,79]],[[4,48,581,2],[51,48,581,49]],[[4,48,582,2],[6,48,582,4]],[[4,48,583,2],[81,48,583,79]],[[4,48,584,2],[26,48,584,24]],[[4,48,585,2],[6,48,585,4]],[[4,48,586,2],[72,48,586,70]],[[4,48,587,2],[80,48,587,78]],[[4,48,588,2],[74,48,588,72]],[[4,48,589,2],[80,48,589,78]],[[4,48,590,2],[6,48,590,4]],[[4,48,591,2],[75,48,591,73]],[[4,48,592,2],[79,48,592,77]],[[4,48,593,2],[77,48,593,75]],[[4,48,594,2],[46,48,594,44]],[[4,48,596,2],[8,48,596,6,1906],[19,48,596,36,1905]],[[4,48,597,2],[8,48,597,6,1907],[19,48,597,43]],[[4,48,598,2],[8,48,598,6,1856],[15,48,598,30]],[[4,48,599,2],[9,48,599,7],[15,48,599,13],[17,48,600,4,1908],[28,48,600,15],[30,48,601,4,1824],[36,48,601,10,1909],[45,48,601,19],[47,48,602,4,1828],[57,48,602,14,1910],[66,48,602,23],[68,48,603,4,1856],[74,48,603,10,1911],[83,48,603,19],[85,48,604,3],[89,48,604,7,1900],[100,48,604,19]],[[8,48,605,4],[14,48,605,10,1898],[23,48,605,19,1912],[56,48,606,6,1906],[66,48,607,6,1907],[76,48,608,6,1909],[87,48,609,6,1910],[98,48,610,6,1908],[111,48,611,6]],[[8,48,613,4,1906],[19,48,613,15,1898],[26,48,613,22,1824],[30,48,613,26]],[[8,48,614,4,1907],[19,48,614,15,1898],[26,48,614,22,1849],[30,48,614,26]],[[8,48,615,4],[73,48,615,69]],[[8,48,616,4],[24,48,616,20]],[[8,48,617,4,1856],[15,48,617,11,1911]],[[4,48,618,2]],[[4,48,620,2],[11,48,620,9]],[[8,48,621,4,1824],[14,48,621,10,1906]],[[8,48,622,4,1849],[14,48,622,10,1907]],[[8,48,623,4,1838]],[[8,48,624,4,1856]],[[4,48,625,2]],[[0,48,626,0]],[[0,48,628,0],[9,48,628,9,1912],[42,48,629,2,1913],[57,48,629,36],[59,48,630,2,1907],[67,48,630,36],[69,48,631,2,1909],[78,48,631,30],[80,48,632,2,1910],[89,48,632,37],[91,48,633,2,1908],[102,48,633,32],[104,48,634,2,1914],[109,48,634,15]],[[4,48,636,2],[8,48,636,6,1914],[18,48,636,16,1908],[30,48,636,28,1915],[36,48,636,34],[38,48,636,36]],[[8,48,637,4],[65,48,637,61]],[[8,48,638,4],[15,48,638,11]],[[12,48,639,6,1824],[18,48,639,12,1909]],[[12,48,640,6,1849],[18,48,640,12,1910]],[[8,48,641,4]],[[4,48,642,2]],[[4,48,644,2],[74,48,644,72]],[[4,48,645,2],[49,48,645,47]],[[4,48,646,2],[6,48,646,4]],[[4,48,647,2],[65,48,647,63]],[[4,48,648,2],[6,48,648,4]],[[4,48,649,2],[78,48,649,76]],[[4,48,650,2],[6,48,650,4]],[[4,48,651,2],[78,48,651,76]],[[4,48,652,2],[82,48,652,80]],[[4,48,653,2],[65,48,653,63]],[[4,48,654,2],[10,48,654,8,1916],[36,48,654,42,1908],[47,48,654,53],[48,48,654,54,1914],[54,48,654,60]],[[4,48,655,2],[83,48,655,81]],[[4,48,657,2],[10,48,657,8,1917],[29,48,657,27,1913],[44,48,657,42],[45,48,657,43],[47,48,657,45]],[[4,48,658,2],[10,48,658,8,1918],[33,48,658,31,1907],[46,48,658,44],[53,48,658,51,1907],[61,48,658,59],[62,48,658,60],[64,48,658,62],[67,48,658,65]],[[4,48,659,2],[10,48,659,8,1919],[28,48,659,61],[29,48,659,62]],[[4,48,660,2],[10,48,660,8,1920],[32,48,660,72],[33,48,660,73]],[[4,48,661,2],[8,48,661,7],[14,48,661,13,1867],[34,48,661,33,1917],[51,48,661,51]],[[8,48,662,4],[14,48,662,10,1921],[37,48,662,33,1917],[53,48,662,49],[54,48,662,50,1867],[71,48,662,67]],[[8,48,663,4],[14,48,663,10,1922],[34,48,664,6,1918],[59,48,664,31],[66,48,665,11,1918],[86,48,665,31],[87,48,665,32,1867],[104,48,665,49],[108,48,665,53],[115,48,666,10]],[[8,48,667,4],[12,48,667,8,1867],[33,48,667,29,1916],[58,48,667,54]],[[12,48,668,6],[18,48,668,12,1898],[27,48,668,21,1912],[60,48,669,8,1921],[82,48,670,8,1922],[101,48,671,8,1909],[112,48,672,8,1910],[123,48,673,8,1908],[136,48,674,8],[136,48,675,8],[167,48,675,39],[195,48,674,67]],[[12,48,676,8,1914],[20,48,676,16]],[[12,48,679,6,1919],[27,48,679,21],[28,48,679,22,1867],[45,48,679,39],[48,48,679,42,1898],[55,48,679,49,1824],[59,48,679,53]],[[12,48,680,6,1920],[31,48,680,25],[32,48,680,26,1867],[49,48,680,43],[52,48,680,46,1898],[59,48,680,53,1849],[63,48,680,57]],[[8,48,681,4],[15,48,681,11]],[[12,48,682,6],[67,48,682,61]],[[12,48,683,6,1919],[27,48,683,21],[28,48,683,22,1867],[45,48,683,39],[48,48,683,42,1921]],[[12,48,684,6,1920],[31,48,684,25],[32,48,684,26,1867],[49,48,684,43],[52,48,684,46,1922]],[[8,48,685,4]],[[4,48,686,2]],[[4,48,688,2],[8,48,688,6,1923]],[[4,48,689,2],[8,48,689,6,1924]],[[4,48,690,2],[48,48,690,46]],[[4,48,692,2],[69,48,692,67]],[[4,48,693,2],[78,48,693,76]],[[4,48,694,2],[73,48,694,71]],[[4,48,695,2],[22,48,695,20]],[[4,48,696,2,1923],[17,48,696,15]],[[8,48,696,16,1913],[23,48,696,31],[24,48,696,32],[26,48,696,34]],[[8,48,696,36,1919]],[[5,48,696,52]],[[4,48,697,2],[8,48,697,6],[13,48,697,11,1913],[30,48,697,28]],[[8,48,698,4,1923],[18,48,698,14],[19,48,698,15],[21,48,698,17],[24,48,698,20,1913],[39,48,698,35],[40,48,698,36],[42,48,698,38]],[[4,48,699,2]],[[4,48,700,2],[8,48,700,6],[13,48,700,11,1913],[30,48,700,28]],[[8,48,701,4,1923],[18,48,701,14],[19,48,701,15],[21,48,701,17],[24,48,701,20,1913],[39,48,701,35],[40,48,701,36],[42,48,701,38]],[[4,48,702,2]],[[4,48,703,2],[8,48,703,6],[13,48,703,11,1913],[30,48,703,28]],[[8,48,704,4,1923],[18,48,704,14],[19,48,704,15],[21,48,704,17],[24,48,704,20,1913],[39,48,704,35],[40,48,704,36],[42,48,704,38]],[[4,48,705,2]],[[4,48,707,2],[40,48,707,38]],[[4,48,708,2],[10,48,708,8,1925],[35,48,708,33]],[[4,48,709,2,1924],[21,48,709,19]],[[8,48,710,4]],[[8,48,711,4,1920]],[[8,48,712,4]],[[8,48,713,4,1925]],[[8,48,714,4]],[[5,48,715,3]],[[4,48,717,2],[11,48,717,9]],[[8,48,718,4,1824],[14,48,718,10,1923]],[[8,48,719,4,1849],[14,48,719,10,1924]],[[4,48,720,2]],[[0,48,721,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,49,24,9,1933],[8,49,24,17,1934],[11,49,24,20],[12,49,24,21,1935],[50,49,24,59]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,49,23,13,1926],[24,49,23,33],[26,49,23,33]],[[15,49,23,13,1926]],[],[[4,49,26,13,1927],[23,49,26,32],[25,49,26,32]],[[15,49,26,13,1927]],[],[[4,49,44,16,1928],[29,49,44,41],[31,49,44,41]],[[15,49,44,16,1928]],[],[[4,49,30,16,1929],[21,49,30,33],[23,49,30,33]],[[15,49,30,16,1929]],[],[[4,49,70,16,1930],[26,49,70,38],[28,49,70,38]],[[15,49,70,16,1930]],[],[[4,49,138,16,1931],[19,49,138,31],[21,49,138,31]],[[15,49,138,16,1931]],[],[],[[35,49,4,34]],[[31,49,11,30]],[[28,49,16,7]],[[23,49,17,36]],[[23,49,18,31]],[[32,49,19,32]],[[0,49,23,7],[6,49,23,13,1926],[29,49,24,2,1932],[77,49,24,63]],[[0,49,26,7],[6,49,26,13,1927],[28,49,26,35,1936],[29,49,26,35,1936],[32,49,26,35,1936],[39,49,26,35,1936],[53,49,26,49],[55,49,27,2,1932],[62,49,27,9,1933],[70,49,27,17,1934],[73,49,27,20],[74,49,27,21,1937],[111,49,27,58]],[[0,49,30,7],[9,49,30,16,1929],[27,49,31,2,1938],[32,49,31,29],[34,49,32,2,1939],[41,49,32,18],[43,49,33,2,1940],[46,49,33,13],[48,49,34,2,1941],[59,49,34,22]],[[4,49,36,2,1939],[12,49,36,10,1942],[25,49,36,23],[28,49,36,26]],[[4,49,37,2,1939],[12,49,37,10,1943],[24,49,37,22],[27,49,37,25,1940]],[[4,49,38,2,1939],[12,49,38,10,1941],[23,49,38,21],[26,49,38,24,1941]],[[4,49,39,2,1939],[12,49,39,10,1944],[30,49,39,28],[33,49,39,31,1945]],[[4,49,41,2],[11,49,41,9,1946],[12,49,41,9,1946],[15,49,41,9,1946],[30,49,41,9,1946],[43,49,41,22],[45,49,41,23,1938],[52,49,41,30,1939]],[[0,49,42,0]],[[0,49,44,7],[9,49,44,16,1928],[35,49,45,2,1947],[52,49,45,38]],[[4,49,47,2],[10,49,47,8,1948],[21,49,47,40],[23,49,47,42]],[[4,49,48,2],[10,49,48,8],[11,49,48,9,1949],[20,49,48,18,1950],[35,49,48,33],[38,49,48,36,1947]],[[4,49,50,2],[8,49,50,6,1951],[15,49,50,13,1952],[19,49,50,17],[20,49,50,18,1950],[36,49,50,34,1953],[42,49,50,40],[47,49,50,45],[50,49,50,48]],[[8,49,51,4],[15,49,51,11]],[[12,49,51,12]],[[16,49,51,13,1949]],[[13,49,51,21]],[[9,49,51,22]],[[4,49,52,2]],[[4,49,54,2],[9,49,54,7],[15,49,54,13],[16,49,54,14,1954],[34,49,54,32,1955],[48,49,54,46],[52,49,54,50,1951],[59,49,54,57,1956],[66,49,54,64],[67,49,55,4,1950],[83,49,56,5]],[[8,49,57,4],[13,49,57,9],[19,49,57,15,1957],[35,49,57,31,1928],[61,49,57,57,1955],[76,49,57,73]],[[12,49,58,6],[79,49,58,73]],[[12,49,59,6],[16,49,59,10,1949],[28,49,59,22],[32,49,59,26]],[[16,49,60,8,1948],[25,49,60,17,1958],[29,49,60,21],[30,49,60,22]],[[20,49,60,23,1954]],[[23,49,60,44,1957]],[[17,49,60,57]],[[12,49,61,6],[19,49,61,13]],[[16,49,62,8,1948],[25,49,62,17,1958],[29,49,62,21],[30,49,62,22]],[[20,49,62,23,1949]],[[20,49,62,32,1954]],[[23,49,62,53,1957]],[[17,49,62,66]],[[12,49,63,6]],[[8,49,64,4]],[[4,49,65,2]],[[4,49,67,2],[11,49,67,9,1948]],[[0,49,68,0]],[[0,49,70,7],[9,49,70,16,1930],[32,49,71,2,1940],[35,49,71,10],[37,49,72,2,1938],[42,49,72,29],[44,49,73,2,1939],[51,49,73,18],[53,49,74,2,1941],[64,49,74,22],[66,49,75,2,1959],[72,49,75,26]],[[4,49,77,2],[11,49,77,10,1959],[18,49,77,17,1960],[21,49,77,20]],[[8,49,78,4],[13,49,78,9,1961],[20,49,78,9,1961],[39,49,78,28],[40,49,78,29,1962],[43,49,78,32]],[[12,49,78,34]],[[16,49,79,6],[45,49,79,35]],[[16,49,80,6],[22,49,80,12,1963],[31,49,80,21,1959],[38,49,80,28,1964],[42,49,80,32]],[[16,49,81,6],[23,49,81,13,1929],[41,49,81,31,1938],[48,49,81,38,1939],[57,49,81,47,1963],[65,49,81,55,1941]],[[12,49,82,4]],[[8,49,83,4],[13,49,83,9,1961],[20,49,83,9,1961],[39,49,83,28],[40,49,83,29,1965],[47,49,83,36]],[[12,49,83,38]],[[16,49,84,6],[41,49,84,31]],[[16,49,85,6,1939],[24,49,85,14,1966],[29,49,85,19],[32,49,85,22,1959],[39,49,85,29,1964],[43,49,85,33],[44,49,85,34,1967],[53,49,85,43]],[[16,49,86,6,1939],[24,49,86,14,1968],[35,49,86,25],[38,49,86,28,1959],[45,49,86,35,1964],[49,49,86,39],[50,49,86,40,1969],[67,49,86,57]],[[16,49,87,6,1939],[24,49,87,14,1970],[38,49,87,28],[41,49,87,31,1959],[48,49,87,38,1964],[52,49,87,42],[53,49,87,43,1970],[67,49,87,57]],[[16,49,88,6,1939],[24,49,88,14,1943],[36,49,88,26],[39,49,88,29,1959],[46,49,88,36,1964],[50,49,88,40],[51,49,88,41,1943],[63,49,88,53]],[[16,49,89,6],[89,49,89,79]],[[16,49,90,6],[87,49,90,77]],[[16,49,91,6],[88,49,91,78]],[[16,49,92,6],[83,49,92,73]],[[16,49,93,6],[87,49,93,77]],[[16,49,94,6],[50,49,94,40]],[[16,49,95,6,1939],[24,49,95,14,1944],[42,49,95,32],[45,49,95,35,1959],[52,49,95,42,1964],[56,49,95,46],[57,49,95,47,1944],[75,49,95,65],[79,49,95,69,1945]],[[16,49,96,6,1939],[24,49,96,14,1971],[36,49,96,26],[39,49,96,29,1959],[46,49,96,36,1964],[50,49,96,40],[51,49,96,41,1971],[63,49,96,53]],[[16,49,97,6,1939],[24,49,97,14,1972],[36,49,97,26],[39,49,97,29,1959],[46,49,97,36,1964],[50,49,97,40],[51,49,97,41,1973],[55,49,97,45]],[[16,49,99,6],[78,49,99,68]],[[16,49,100,6],[22,49,100,12,1974],[31,49,100,21],[35,49,100,25,1975],[39,49,100,29,1938],[45,49,100,35,1943],[57,49,100,47],[59,49,100,49,1940]],[[16,49,101,6],[22,49,101,12,1976],[39,49,103,8],[39,49,102,8],[77,49,103,46],[101,49,102,70]],[[16,49,104,8,1940],[20,49,104,12,1977],[28,49,104,20],[33,49,104,25,1974],[40,49,104,32,1977],[48,49,104,40],[52,49,105,8,1940],[56,49,105,12,1978],[62,49,105,18],[67,49,105,23,1974],[74,49,105,30,1978],[80,49,105,36],[84,49,106,8,1940],[88,49,106,12,1973],[92,49,106,16],[97,49,106,21,1974],[104,49,106,28,1973],[108,49,106,32]],[[16,49,107,6],[20,49,107,10,1976],[36,49,107,26]],[[20,49,108,8],[68,49,108,56]],[[20,49,109,8,1939],[28,49,109,16,1976],[42,49,109,30],[45,49,109,33]],[[20,49,110,8,1939],[28,49,110,16,1971],[40,49,110,28],[43,49,110,31,1959],[50,49,110,38,1964],[54,49,110,42],[55,49,110,43,1971],[67,49,110,55]],[[20,49,111,8,1939],[28,49,111,16,1972],[40,49,111,28],[43,49,111,31,1940],[47,49,111,35,1973],[51,49,111,39]],[[20,49,112,8],[87,49,112,75]],[[20,49,113,8],[86,49,113,74]],[[20,49,114,8,1939],[28,49,114,16,1944],[46,49,114,34],[49,49,114,37],[51,49,114,39]],[[16,49,115,6]],[[16,49,117,6],[23,49,117,13,1946],[24,49,117,13,1946],[27,49,117,13,1946],[42,49,117,13,1946],[55,49,117,26],[57,49,117,27,1938],[64,49,117,34,1939]],[[12,49,118,4]],[[8,49,119,4],[13,49,119,9,1961],[20,49,119,9,1961],[39,49,119,28],[40,49,119,29,1979],[45,49,119,34]],[[12,49,119,36]],[[16,49,120,6],[23,49,120,13,1959],[30,49,120,20,1964],[34,49,120,24],[35,49,120,25,1980],[39,49,120,29],[40,49,121,8],[41,49,121,9,1981],[55,49,122,10,1930],[78,49,122,33,1940],[83,49,122,38,1938],[90,49,122,45,1939],[99,49,122,54,1941],[112,49,122,67,1981],[126,49,123,8],[126,49,124,8],[180,49,123,62],[196,49,124,78]],[[16,49,125,8],[52,49,125,44]],[[16,49,126,8]],[[20,49,127,10],[27,49,127,17,1938]],[[16,49,128,8]],[[12,49,130,4]],[[8,49,131,4]],[[12,49,131,13]],[[16,49,132,6,1959]],[[16,49,133,6],[23,49,133,13,1938]],[[12,49,134,4]],[[4,49,135,2]],[[0,49,136,0]],[[0,49,138,7],[9,49,138,16,1931],[25,49,139,2,1938],[30,49,139,29],[32,49,140,2,1982],[38,49,140,24]],[[4,49,142,2],[10,49,142,8],[12,49,142,10,1940],[15,49,142,13],[17,49,142,15,1983],[30,49,142,28],[32,49,142,30,1984],[44,49,142,42],[46,49,142,44,1971],[58,49,142,56],[60,49,142,58],[63,49,142,61,1982]],[[4,49,143,2],[10,49,143,8,1939],[20,49,143,27],[21,49,143,28]],[[4,49,144,2],[10,49,144,8,1985],[17,49,144,15,1986],[18,49,144,15,1986],[21,49,144,15,1986],[40,49,144,15,1986],[57,49,144,32],[59,49,144,33,1940]],[[4,49,145,2],[10,49,145,8,1941],[24,49,145,22,1984],[41,49,145,39]],[[4,49,147,2,1939],[12,49,147,10,1987],[38,49,147,36],[41,49,147,39]],[[4,49,148,2,1939],[12,49,148,10,1941],[23,49,148,21],[26,49,148,24,1941]],[[4,49,150,2],[8,49,150,6,1983],[23,49,150,21]],[[8,49,151,4],[15,49,151,11,1929],[33,49,151,29,1938],[40,49,151,36,1939],[49,49,151,45,1940],[53,49,151,49,1988],[61,49,151,57],[65,49,151,61,1941]],[[4,49,152,2]],[[4,49,154,2],[71,49,154,69]],[[4,49,155,2],[44,49,155,42]],[[4,49,156,2],[8,49,156,6,1989],[17,49,156,15,1990],[31,49,156,29],[32,49,156,30],[57,49,156,55]],[[8,49,157,4],[15,49,157,11,1929],[33,49,157,29,1938],[40,49,157,36,1939],[49,49,157,45,1985],[55,49,157,51,1941]],[[4,49,158,2]],[[4,49,160,2],[76,49,160,74]],[[4,49,161,2],[71,49,161,69]],[[4,49,162,2],[21,49,162,19]],[[4,49,163,2],[10,49,163,8,1991],[23,49,163,21],[27,49,163,25,1975],[31,49,163,29,1938],[37,49,163,35,1943],[49,49,163,47],[51,49,163,49,1992],[60,49,163,58,1993],[66,49,163,64]],[[4,49,164,2],[10,49,164,8,1959],[19,49,164,17,1994],[20,49,164,17,1994],[23,49,164,17,1994],[35,49,164,17,1994],[43,49,164,42],[45,49,165,4,1940],[50,49,166,4,1991],[62,49,167,4,1938],[68,49,167,10,1966],[73,49,167,15],[75,49,168,4,1938],[81,49,168,10,1995],[85,49,168,14],[87,49,169,4,1938],[93,49,169,10,1996],[100,49,169,17],[102,49,170,4,1997],[118,49,170,4,1997],[133,49,170,19],[134,49,170,20,1998],[141,49,170,27],[143,49,171,4,1971],[157,49,172,4,1939]],[[4,49,174,2],[11,49,174,9,1930],[34,49,174,32,1940],[39,49,174,37,1938],[46,49,174,44,1939],[55,49,174,53,1941],[68,49,174,66,1959]],[[0,49,175,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,50,3,16,1999],[68,50,3,16,1999]],[],[],[[15,50,3,16,1999]],[],[],[[36,50,1,43]],[[0,50,3,7],[9,50,3,16,1999],[43,50,3,50],[44,50,4,2,2000],[53,50,5,2,2001],[68,50,6,20]],[[4,50,7,2],[108,50,7,106]],[[4,50,8,2],[8,50,9,4,2002],[14,50,9,10,2003],[21,50,9,17],[22,50,9,18,2000],[34,50,10,5,2000],[35,50,10,5,2000],[42,50,10,12],[43,50,10,13],[45,50,10,15],[50,50,10,20],[66,50,11,6,2000],[73,50,11,13],[74,50,11,14],[76,50,11,16],[81,50,11,21],[97,50,12,6,2000],[104,50,12,13],[105,50,12,14],[107,50,12,16],[112,50,12,21],[123,50,13,6,2000],[130,50,13,13],[131,50,13,14],[133,50,13,16],[138,50,13,21],[149,50,14,6,2000],[156,50,14,13],[157,50,14,14],[159,50,14,16],[164,50,14,21],[176,50,15,6,2000],[183,50,15,13],[184,50,15,14],[186,50,15,16],[191,50,15,21],[203,50,16,6,2000],[210,50,16,13],[211,50,16,14],[213,50,16,16],[218,50,16,21],[231,50,17,6,2000],[238,50,17,13],[239,50,17,14],[241,50,17,16],[246,50,17,21],[255,50,17,29],[258,50,18,4]],[[8,50,19,4],[15,50,19,11]],[[4,50,20,2]],[[4,50,22,2],[72,50,22,70]],[[4,50,23,2],[8,50,23,6],[15,50,23,13,2000],[27,50,23,25],[39,50,23,37,2004],[40,50,23,37,2004],[43,50,23,37,2004],[63,50,23,37,2004],[89,50,23,63],[91,50,23,64,2000],[101,50,23,74]],[[8,50,24,4],[15,50,24,11]],[[4,50,25,2]],[[4,50,27,2],[51,50,27,49]],[[4,50,28,2],[8,50,28,6,2001],[24,50,28,22]],[[8,50,29,4],[12,50,29,9],[18,50,29,15,2005],[25,50,29,22,2001],[40,50,29,38]],[[12,50,30,6],[16,50,30,10,1999],[50,50,30,44,2001],[64,50,30,58],[65,50,30,59,2005],[69,50,30,63],[72,50,30,66]],[[16,50,31,8],[23,50,31,15]],[[12,50,32,6]],[[8,50,33,4]],[[4,50,34,2]],[[4,50,36,2],[11,50,36,9]],[[0,50,37,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,51,21,16,2006],[22,51,21,34],[24,51,21,34]],[[15,51,21,16,2006]],[],[[4,51,11,16,2007],[18,51,11,30],[20,51,11,30]],[[15,51,11,16,2007]],[],[],[[33,51,5,39]],[[28,51,6,38]],[[23,51,7,38]],[[51,51,8,50]],[[32,51,9,32]],[[0,51,11,7],[9,51,11,16,2007],[24,51,11,31,2008],[29,51,11,58]],[[4,51,12,2],[78,51,12,76]],[[4,51,13,2],[74,51,13,72]],[[4,51,14,2],[73,51,14,71]],[[4,51,15,2],[10,51,15,8,2009],[27,51,15,25,2008],[33,51,15,31,2010],[40,51,15,38]],[[4,51,16,2],[10,51,16,8,2011],[31,51,16,29,2008],[37,51,16,35,2012],[41,51,16,39]],[[4,51,17,2,2013],[5,51,17,2,2013],[8,51,17,2,2013],[15,51,17,2,2013],[36,51,17,23],[38,51,17,24,2009],[54,51,17,40,2011]],[[4,51,18,2],[11,51,18,9,2006],[30,51,18,28,2008],[37,51,18,35,2014],[53,51,18,35,2014],[68,51,18,50],[69,51,18,51,2015],[79,51,18,61]],[[0,51,19,0]],[[0,51,21,7],[9,51,21,16,2006],[28,51,22,2,2008],[33,51,22,29],[35,51,23,2,2016],[50,51,23,74]],[[4,51,25,2],[10,51,25,8,2009],[27,51,25,25,2008],[33,51,25,31,2010],[40,51,25,38]],[[4,51,27,2],[82,51,27,80]],[[4,51,28,2],[81,51,28,79]],[[4,51,29,2],[82,51,29,80]],[[4,51,30,2],[10,51,30,8,2017],[30,51,30,28,2018],[31,51,30,28,2018],[34,51,30,28,2018],[69,51,30,28,2018],[102,51,30,61],[104,51,30,62,2008],[110,51,30,68,2012],[114,51,30,72],[118,51,31,6,2008],[124,51,31,12,2019],[139,51,31,27],[143,51,31,31,2009],[160,51,32,6]],[[4,51,34,2],[77,51,34,75]],[[4,51,35,2],[73,51,35,71]],[[4,51,36,2],[10,51,36,8,2020],[32,51,36,30,2008],[38,51,36,36,2021],[50,51,36,48]],[[4,51,37,2],[10,51,37,8,2022],[23,51,37,21],[27,51,37,25,2023],[31,51,37,29,2020],[52,51,37,50,2024],[61,51,37,59,2025],[67,51,37,65]],[[4,51,38,2],[10,51,38,8,2026],[37,51,38,35,2008],[43,51,38,41,2012],[47,51,38,45]],[[4,51,39,2],[10,51,39,8,2027],[25,51,39,23]],[[4,51,41,2],[10,51,41,8,2028],[27,51,41,25]],[[8,51,42,4,2012],[14,51,42,10,2008],[20,51,42,16,2012],[24,51,42,20]],[[8,51,43,4,2029],[24,51,43,20,2008],[30,51,43,26,2029],[44,51,43,40]],[[8,51,44,4,2030],[14,51,44,10]],[[8,51,45,4,2031],[14,51,45,10]],[[4,51,46,2]],[[4,51,48,2],[10,51,48,8,2032],[16,51,48,14,2033],[21,51,48,19,2032],[24,51,48,22]],[[4,51,49,2],[10,51,49,8,2034],[19,51,49,17,2035],[20,51,49,17,2035],[23,51,49,17,2035],[35,51,49,17,2035],[56,51,49,38],[58,51,50,4,2032],[63,51,51,4,2022],[75,51,52,4,2020],[96,51,53,4,2028],[112,51,54,4,2022],[124,51,55,4,2008],[130,51,55,10,2036],[135,51,55,15],[137,51,56,4,2026],[163,51,57,4,2016],[180,51,58,4,2017],[199,51,59,4,2027]],[[4,51,62,2],[10,51,62,8,2037],[20,51,62,27],[21,51,62,28]],[[4,51,63,2,2037],[12,51,63,10,2038],[38,51,63,36],[41,51,63,39]],[[4,51,65,2],[11,51,65,9,2039],[12,51,65,9,2039],[15,51,65,9,2039],[32,51,65,9,2039],[54,51,65,31],[56,51,65,32,2022],[68,51,65,44,2008],[75,51,65,51,2037],[84,51,65,60],[91,51,65,67,2034]],[[0,51,66,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,52,12,16,2040],[53,52,12,16,2040]],[],[],[[15,52,12,16,2040]],[],[],[[35,52,0,34]],[[33,52,7,58]],[[28,52,8,38]],[[32,52,9,31]],[[32,52,10,32]],[[0,52,12,7],[9,52,12,16,2040],[28,52,13,2,2041],[33,52,13,29],[35,52,14,2,2042],[41,52,14,27]],[[4,52,16,2],[10,52,16,8,2043],[20,52,16,27],[21,52,16,28]],[[4,52,17,2,2043],[12,52,17,10,2044],[38,52,17,36],[41,52,17,39]],[[4,52,19,2],[75,52,19,73]],[[4,52,20,2],[78,52,20,76]],[[4,52,21,2],[78,52,21,76]],[[4,52,22,2],[34,52,22,32]],[[4,52,23,2],[10,52,23,8,2045],[21,52,23,19,2042],[28,52,23,26,2046],[31,52,23,29]],[[4,52,24,2],[10,52,24,8,2047],[21,52,24,19],[25,52,24,23,2048],[29,52,24,27,2042],[36,52,24,34,2049],[39,52,24,37],[41,52,24,39,2050],[50,52,24,48,2051],[56,52,24,54]],[[4,52,25,2],[10,52,25,8,2052],[22,52,25,20,2042],[29,52,25,27,2053],[33,52,25,31]],[[4,52,26,2],[8,52,26,6,2045],[20,52,26,18,2052],[34,52,26,32],[40,52,26,38]],[[8,52,27,4],[81,52,27,77]],[[8,52,28,4],[29,52,28,25]],[[8,52,29,4],[15,52,29,11,2054],[16,52,29,11,2054],[19,52,29,11,2054],[36,52,29,11,2054],[53,52,29,28],[55,52,29,29,2041],[62,52,29,36,2043],[71,52,29,45,2047],[80,52,29,54,2055],[84,52,29,58],[86,52,29,60]],[[4,52,30,2]],[[4,52,31,2],[10,52,31,8,2056],[23,52,31,21],[27,52,31,25,2048],[31,52,31,29,2041],[37,52,31,35,2057],[49,52,31,47],[51,52,31,49,2050],[60,52,31,58,2051],[66,52,31,64]],[[4,52,32,2],[8,52,32,6,2042],[15,52,32,13,2058],[27,52,32,25],[32,52,32,30,2041],[38,52,32,36,2059],[42,52,32,40],[44,52,32,42]],[[8,52,33,4],[72,52,33,68]],[[8,52,34,4],[79,52,34,75]],[[8,52,35,4],[48,52,35,44]],[[8,52,36,4],[15,52,36,11,2060],[16,52,36,11,2060],[19,52,36,11,2060],[35,52,36,11,2060],[49,52,36,25],[51,52,36,26,2041]],[[4,52,37,2]],[[4,52,38,2],[76,52,38,74]],[[4,52,39,2],[55,52,39,53]],[[4,52,40,2],[10,52,40,8,2061],[30,52,40,28,2062],[31,52,40,28,2062],[34,52,40,28,2062],[53,52,40,28,2062],[70,52,40,45],[72,52,40,46,2047]],[[4,52,41,2],[10,52,41,8,2063],[25,52,41,23,2042],[32,52,41,30,2064],[39,52,41,37]],[[4,52,42,2],[53,52,42,51]],[[4,52,43,2],[10,52,43,8,2065],[24,52,43,22]],[[4,52,44,2],[10,52,44,8,2066],[25,52,44,23]],[[4,52,45,2],[10,52,45,8,2067],[16,52,45,14,2068],[21,52,45,19,2067],[24,52,45,22]],[[4,52,46,2],[10,52,46,8,2069],[19,52,46,17,2070],[20,52,46,17,2070],[23,52,46,17,2070],[35,52,46,17,2070],[56,52,46,38],[58,52,47,4,2067],[63,52,48,4,2047],[73,52,49,4,2061],[92,52,50,4,2052],[103,52,51,4,2056],[115,52,52,4,2041],[121,52,52,10,2071],[126,52,52,15],[128,52,53,4,2041],[134,52,53,10,2059],[138,52,53,14],[140,52,54,4,2072],[156,52,54,4,2072],[171,52,54,19],[172,52,54,20,2073],[182,52,54,30],[184,52,55,4,2063],[198,52,56,4,2066]],[[4,52,58,2],[11,52,58,9,2074],[12,52,58,9,2074],[15,52,58,9,2074],[32,52,58,9,2074],[54,52,58,31],[56,52,58,32,2047],[66,52,58,42,2041],[73,52,58,49,2043],[82,52,58,58,2065],[95,52,58,71,2069]],[[0,52,59,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,53,17,16,2075],[49,53,17,16,2075]],[],[],[[15,53,17,16,2075]],[],[],[[35,53,0,34]],[[36,53,6,49]],[[32,53,12,7]],[[33,53,14,34]],[[0,53,17,7],[9,53,17,16,2075],[24,53,18,2,2076],[29,53,18,29],[31,53,19,2,2077],[37,53,19,23]],[[4,53,21,2],[78,53,21,76]],[[4,53,22,2],[96,53,22,94]],[[4,53,23,2],[100,53,23,98]],[[4,53,24,2],[97,53,24,95]],[[4,53,25,2],[66,53,25,64]],[[4,53,26,2],[109,53,26,107]],[[4,53,27,2],[8,53,27,6,2078]],[[4,53,28,2],[8,53,28,6,2079]],[[4,53,29,2],[10,53,29,8,2080],[25,53,29,23,2077],[32,53,29,30,2080],[44,53,29,42]],[[4,53,30,2],[8,53,30,6,2080],[22,53,30,20]],[[8,53,31,4,2078],[24,53,31,20,2080],[37,53,31,33,2081],[41,53,31,37]],[[8,53,32,4,2079],[25,53,32,21,2080],[38,53,32,34,2079],[52,53,32,48]],[[4,53,33,2],[11,53,33,9]],[[8,53,34,4,2078],[24,53,34,20,2076],[30,53,34,26,2081],[34,53,34,30]],[[8,53,35,4,2079],[25,53,35,21,2076],[31,53,35,27,2079],[45,53,35,41]],[[4,53,36,2]],[[4,53,38,2],[10,53,38,8,2082],[23,53,38,21],[27,53,38,25,2083],[31,53,38,29,2076],[37,53,38,35,2084],[49,53,38,47],[51,53,38,49,2085],[60,53,38,58,2086],[66,53,38,64]],[[4,53,39,2],[10,53,39,8,2087],[24,53,39,22,2077],[31,53,39,29,2088],[34,53,39,32]],[[4,53,40,2],[10,53,40,8,2089],[33,53,40,31,2090],[34,53,40,31,2090],[37,53,40,31,2090],[56,53,40,31,2090],[73,53,40,48],[75,53,40,49,2087]],[[4,53,41,2],[10,53,41,8,2091],[28,53,42,4,2092],[29,53,42,4,2092],[32,53,42,4,2092],[52,53,42,4,2092],[84,53,42,36],[86,53,42,37,2078],[104,53,42,55,2087],[116,53,42,67,2093],[124,53,42,75]],[[4,53,44,2],[10,53,44,8,2094],[16,53,44,14,2095],[21,53,44,19,2094],[24,53,44,22]],[[4,53,45,2],[10,53,45,8,2096],[25,53,45,54]],[[8,53,46,4,2097],[28,53,46,24]],[[8,53,47,4,2098],[29,53,47,25]],[[4,53,48,2]],[[4,53,49,2],[10,53,49,8,2099],[17,53,49,15,2100],[18,53,49,15,2100],[21,53,49,15,2100],[37,53,49,15,2100],[55,53,49,33],[57,53,50,4,2094],[62,53,51,4,2082],[74,53,52,4,2076],[80,53,52,10,2101],[85,53,52,15],[87,53,53,4,2076],[93,53,53,10,2081],[97,53,53,14],[99,53,54,4,2078],[114,53,55,4,2102],[130,53,55,4,2102],[145,53,55,19],[146,53,55,20,2103],[162,53,55,36],[164,53,56,4],[170,53,57,4],[176,53,58,4],[182,53,59,4],[188,53,60,4],[195,53,61,4],[202,53,62,4,2096]],[[4,53,65,2],[8,53,65,6,2099],[17,53,65,15],[23,53,65,21]],[[8,53,66,4],[14,53,66,10,2104],[24,53,66,29]],[[12,53,67,6,2105],[40,53,67,34]],[[8,53,68,4]],[[8,53,69,4],[15,53,69,11,2106],[16,53,69,11,2106],[19,53,69,11,2106],[36,53,69,11,2106],[53,53,69,28],[55,53,69,29,2076],[62,53,69,36,2104],[71,53,69,45,2089],[93,53,69,67]],[[4,53,70,2]],[[4,53,72,2,2107],[5,53,72,2,2107],[8,53,72,2,2107],[24,53,72,2,2107],[44,53,72,22],[46,53,73,4,2099],[52,53,74,4,2087],[65,53,75,4,2091],[82,53,76,4,2102],[98,53,76,4,2102],[113,53,76,19],[114,53,76,20,2103],[130,53,76,36],[132,53,77,4,2096]],[[4,53,80,2],[11,53,80,9]],[[8,53,81,4],[28,53,81,24]],[[8,53,82,4,2084],[22,53,82,18,2089]],[[8,53,83,4,2079]],[[8,53,84,4,2108],[17,53,84,13]],[[12,53,85,6,2109],[25,53,85,19]],[[12,53,86,6,2110],[27,53,86,21]],[[12,53,87,6],[105,53,87,99]],[[12,53,88,6,2105],[40,53,88,34]],[[8,53,89,4]],[[8,53,90,4,2111],[27,53,90,23,2076],[33,53,90,29,2111],[50,53,90,46]],[[8,53,91,4,2101],[15,53,91,11,2099],[20,53,91,16,2112],[24,53,91,20]],[[8,53,92,4],[32,53,92,28]],[[8,53,93,4,2081],[14,53,93,10,2078]],[[8,53,95,4,2113],[17,53,95,13,2091]],[[8,53,96,4],[78,53,96,74]],[[8,53,97,4],[80,53,97,76]],[[8,53,98,4],[67,53,98,63]],[[8,53,99,4,2114],[25,53,99,21]],[[8,53,100,4,2115],[19,53,100,15]],[[4,53,101,2]],[[0,53,102,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,54,7,16,2116],[52,54,7,16,2116]],[],[],[[15,54,7,16,2116]],[],[],[[32,54,4,35]],[[32,54,5,32]],[[0,54,7,7],[9,54,7,16,2116],[27,54,7,34,2117],[32,54,7,61]],[[4,54,8,2],[11,54,8,9,2118],[12,54,8,9,2118],[15,54,8,9,2118],[31,54,8,9,2118],[49,54,8,27],[51,54,8,28,2117],[58,54,8,35,2119],[74,54,8,35,2119],[89,54,8,50],[90,54,8,51,2120],[100,54,8,61]],[[0,54,9,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,55,0,13,2121],[27,55,0,36],[29,55,0,36]],[[15,55,0,13,2121]],[],[[4,55,25,16,2122],[38,55,25,50],[40,55,25,50]],[[15,55,25,16,2122]],[],[],[[0,55,0,7],[6,55,0,13,2121],[38,55,0,45,2123]],[[4,55,1,2,2124],[16,55,1,14],[19,55,1,17,2125],[23,55,1,58],[24,55,1,60]],[[8,55,2,4],[13,55,2,9],[17,55,2,13,2125]],[[8,55,3,4],[12,55,3,8],[13,55,3,9,2126],[17,55,3,13],[20,55,3,16]],[[4,55,4,2]],[[0,55,5,0]],[[0,55,25,7],[9,55,25,16,2122],[44,55,26,2,2127],[49,55,26,16]],[[4,55,28,2],[11,55,28,9],[12,55,28,10],[13,55,29,4,2127],[14,55,29,4,2127],[23,55,30,4],[30,55,30,11,2127],[40,55,30,21],[52,55,31,4,2127],[69,55,31,21,2121],[92,55,31,43]],[[0,55,33,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,56,9,16,2128],[49,56,9,16,2128]],[],[],[[15,56,9,16,2128]],[],[],[[29,56,0,28]],[[0,56,9,7],[9,56,9,16,2128],[24,56,9,31,2129],[32,56,9,47],[34,56,9,49,2130],[37,56,9,57]],[[4,56,10,2],[8,56,10,6,2129],[17,56,10,15,2131],[27,56,10,25],[28,56,10,26],[34,56,10,32]],[[8,56,11,4],[14,56,11,10,2132],[24,56,11,20,2130],[28,56,11,24,2133],[34,56,11,30],[37,56,11,33,2130],[41,56,11,37,2134],[49,56,11,45]],[[8,56,12,4],[15,56,12,11],[19,56,12,15,2135],[23,56,13,6],[23,56,16,6],[23,56,14,6],[116,56,14,99],[134,56,13,117]],[[8,56,15,6],[109,56,15,107]],[[8,56,16,7,2132],[9,56,16,7,2132],[17,56,16,15,2136],[25,56,16,23],[26,56,16,24],[33,56,16,31,2132],[43,56,16,41,2132],[53,56,16,51],[56,56,16,53],[60,56,16,58,2129]],[[4,56,18,2]],[[4,56,20,2],[11,56,20,9],[15,56,20,13,2135],[19,56,20,17,2137],[20,56,20,17,2137],[23,56,20,17,2137],[36,56,20,17,2137],[47,56,20,28],[49,56,20,29,2129],[60,56,20,40,2130],[64,56,20,44,2138],[68,56,20,48]],[[0,56,21,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,57,15,16,2139],[20,57,15,32],[22,57,15,32]],[[15,57,15,16,2139]],[],[[4,57,92,16,2140],[34,57,92,46],[36,57,92,46]],[[15,57,92,16,2140]],[],[[4,57,84,16,2141],[28,57,84,40],[30,57,84,40]],[[15,57,84,16,2141]],[],[[4,57,76,16,2142],[27,57,76,39],[29,57,76,39]],[[15,57,76,16,2142]],[],[[4,57,60,16,2143],[21,57,60,33],[23,57,60,33]],[[15,57,60,16,2143]],[],[[4,57,37,16,2144],[12,57,37,24],[14,57,37,24]],[[15,57,37,16,2144]],[],[],[[36,57,0,35]],[[31,57,6,7]],[[0,57,8,0],[6,57,8,6,2145],[27,57,9,2],[34,57,9,9,2146],[45,57,9,20],[59,57,11,8,2147],[67,57,11,16],[196,57,12,8,2145],[214,57,12,26],[217,57,13,6,2148]],[[0,57,15,7],[9,57,15,16,2139],[26,57,16,2,2149],[29,57,16,13],[31,57,17,2,2150],[35,57,17,20],[37,57,18,2,2151],[50,57,18,35,2152],[70,57,18,35,2152],[88,57,18,53],[89,57,18,54,2153],[106,57,18,71]],[[4,57,20,2],[10,57,20,8,2154],[18,57,20,16],[25,57,20,16],[39,57,20,46],[40,57,20,16],[44,57,20,20,2155],[50,57,20,26,2156],[65,57,20,26,2156],[84,57,20,45],[87,57,20,16],[108,57,20,16]],[[15,57,20,16]],[[20,57,20,16]],[[22,57,20,16]],[[4,57,20,45]],[[4,57,21,2,2154],[10,57,21,8,2157],[16,57,21,14],[19,57,21,17],[22,57,21,20,2156],[37,57,21,20,2156],[56,57,21,39],[57,57,21,40],[58,57,21,41],[60,57,21,43,2150],[65,57,21,48],[66,57,21,49],[68,57,21,51,2149],[72,57,21,55],[73,57,21,56],[75,57,21,58,2151],[86,57,21,69],[87,57,21,70],[88,57,21,71]],[[4,57,22,2],[11,57,22,9,2154]],[[0,57,23,0]],[[0,57,37,7],[9,57,37,16,2144],[18,57,38,2],[45,57,38,29],[48,57,39,2,2149],[51,57,39,13],[53,57,40,2,2150],[57,57,40,21]],[[4,57,42,2,2150],[13,57,42,11,2145],[33,57,42,31,2158],[45,57,42,43,2159],[56,57,43,6,2160],[71,57,43,6,2160],[83,57,43,18],[84,57,43,19,2161],[88,57,43,23],[91,57,44,6,2160],[106,57,44,6,2160],[118,57,44,18],[119,57,44,19,2162],[126,57,44,26]],[[4,57,46,2],[10,57,46,8,2139],[27,57,46,25,2149],[32,57,46,30,2150],[38,57,46,36,2152],[58,57,46,36,2152],[76,57,46,54],[77,57,46,55,2153],[94,57,46,72]],[[0,57,47,0]],[[0,57,60,7],[9,57,60,16,2143],[27,57,61,2],[54,57,61,29],[57,57,62,2,2149],[60,57,62,13],[62,57,63,2,2150],[69,57,63,23,2160],[84,57,63,23,2160],[96,57,63,35],[97,57,63,36,2162],[104,57,63,43]],[[4,57,65,2],[10,57,65,8,2139],[27,57,65,25,2149],[32,57,65,30,2150],[38,57,65,36,2152],[58,57,65,36,2152],[76,57,65,54],[77,57,65,55,2163],[94,57,65,72]],[[0,57,66,0]],[[0,57,76,7],[9,57,76,16,2142],[33,57,76,40,2154],[38,57,76,54]],[[4,57,77,2],[8,57,77,6],[9,57,77,7,2164],[10,57,77,7,2164],[13,57,77,7,2164],[28,57,77,7,2164],[43,57,77,22],[45,57,77,23,2154],[53,57,77,31],[60,57,77,38]],[[4,57,79,2],[76,57,79,74]],[[4,57,80,2],[22,57,80,20]],[[4,57,81,2],[11,57,81,9,2154],[17,57,81,15,2157],[23,57,81,21],[24,57,81,22,2165],[29,57,81,27],[30,57,81,28],[35,57,81,33,2166],[40,57,81,38],[41,57,81,39],[44,57,81,42],[45,57,81,43],[48,57,81,46,2167],[52,57,81,50],[53,57,81,51]],[[0,57,82,0]],[[0,57,84,7],[9,57,84,16,2141],[34,57,84,41,2154],[39,57,84,61]],[[4,57,85,2],[8,57,85,6],[9,57,85,7,2164],[10,57,85,7,2164],[13,57,85,7,2164],[28,57,85,7,2164],[43,57,85,22],[45,57,85,23,2154],[53,57,85,31]],[[8,57,86,4],[14,57,86,10],[21,57,86,10],[35,57,86,43],[36,57,86,10],[40,57,86,14,2155],[46,57,86,20],[71,57,86,10],[92,57,86,10]],[[19,57,86,10]],[[24,57,86,10]],[[26,57,86,10]],[[8,57,86,42]],[[4,57,87,2]],[[4,57,89,2],[11,57,89,9,2154],[17,57,89,15,2157],[23,57,89,21],[24,57,89,22,2165],[29,57,89,27],[30,57,89,28],[35,57,89,33],[37,57,89,35],[38,57,89,36],[40,57,89,38]],[[0,57,90,0]],[[0,57,92,7],[9,57,92,16,2140],[40,57,92,47,2154],[45,57,92,67]],[[4,57,93,2],[8,57,93,6],[9,57,93,7,2164],[10,57,93,7,2164],[13,57,93,7,2164],[28,57,93,7,2164],[43,57,93,22],[45,57,93,23,2154],[53,57,93,31]],[[8,57,94,4],[14,57,94,10],[21,57,94,10],[35,57,94,43],[36,57,94,10],[40,57,94,14,2155],[46,57,94,20],[71,57,94,10],[92,57,94,10]],[[19,57,94,10]],[[24,57,94,10]],[[26,57,94,10]],[[8,57,94,42]],[[4,57,95,2]],[[4,57,97,2],[11,57,97,9,2168],[18,57,97,16,2154],[24,57,97,22,2157],[30,57,97,28],[31,57,97,29,2165],[36,57,97,34],[37,57,97,35],[42,57,97,40,2169],[44,57,97,42],[45,57,97,43],[46,57,97,44]],[[0,57,98,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,58,2,18,2172],[8,58,2,26,2173],[11,58,2,29],[12,58,2,30,2174],[34,58,2,52]],[],[],[],[],[[31,58,4,16,2170],[46,58,4,16,2170]],[],[],[[15,58,4,16,2170]],[],[],[[31,58,0,30]],[[0,58,2,0],[6,58,2,6,2171],[57,58,2,67]],[[0,58,4,7],[9,58,4,16,2170],[21,58,4,28,2175],[25,58,4,40]],[[4,58,5,2],[11,58,5,9,2176],[12,58,5,9,2176],[15,58,5,9,2176],[30,58,5,9,2176],[43,58,5,22],[45,58,5,23,2175],[51,58,5,29,2171]],[[0,58,6,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,59,2,18,2179],[8,59,2,26,2180],[11,59,2,29],[12,59,2,30,2181],[34,59,2,52]],[],[],[],[],[[31,59,4,16,2177],[49,59,4,16,2177]],[],[],[[15,59,4,16,2177]],[],[],[[29,59,0,28]],[[0,59,2,0],[6,59,2,6,2178],[57,59,2,67]],[[0,59,4,7],[9,59,4,16,2177],[24,59,4,31,2182],[28,59,4,43]],[[4,59,5,2],[8,59,5,6,2179],[16,59,5,14,2180],[19,59,5,17],[20,59,5,18,2183],[50,59,5,48],[52,59,5,50]],[],[[4,59,11,2],[53,59,11,51]],[[4,59,12,2],[8,59,12,6,2178],[17,59,12,15,2185],[23,59,12,21],[28,59,12,26],[31,59,12,29],[38,59,12,36,2182]],[[4,59,14,2,2182],[11,59,14,9,2182],[16,59,14,14,2186],[21,59,14,19],[22,59,14,20,2178],[31,59,14,29,2185],[37,59,14,35]],[[4,59,15,2],[8,59,15,6],[9,59,15,7,2182],[14,59,15,12,2187],[24,59,15,22],[25,59,15,23],[31,59,15,29,2182],[38,59,15,36],[39,59,15,37],[40,59,15,38],[42,59,15,40,2182],[48,59,15,46]],[[4,59,16,2],[11,59,16,9,2182]],[[0,59,17,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,60,73,2,2192],[8,60,73,10,2193],[11,60,73,13],[12,60,73,14,2194],[20,60,73,22],[25,60,73,27],[41,60,74,2,2192],[49,60,74,10,2193],[52,60,74,13],[53,60,74,14,2195],[79,60,74,40],[81,60,75,2]],[],[],[],[],[[31,60,255,16,2188],[54,60,255,16,2188]],[],[],[[15,60,255,16,2188]],[],[],[[31,60,4,27]],[[37,60,5,33]],[[34,60,15,7]],[[41,60,16,40]],[[24,60,24,7]],[[32,60,32,31]],[[35,60,33,34]],[[33,60,34,58]],[[51,60,35,50]],[[35,60,40,7]],[[26,60,41,33]],[[31,60,42,29]],[[32,60,43,31]],[[29,60,44,28]],[[37,60,48,7]],[[23,60,49,38]],[[30,60,50,32]],[[28,60,54,7]],[[40,60,61,7]],[[32,60,62,30]],[[32,60,63,32]],[[0,60,65,0],[6,60,65,6,2189],[24,60,66,2,2190],[32,60,66,2,2190],[47,60,66,24]],[[0,60,68,0],[4,60,68,4,2191]],[[0,60,72,0]],[],[[0,60,95,0],[15,60,95,15,2197],[33,60,96,2,2198],[38,60,96,29],[40,60,97,2,2199],[47,60,97,42],[49,60,98,2],[51,60,98,4,2200],[59,60,98,12],[61,60,98,14,2201],[71,60,98,24],[73,60,98,46]],[[4,60,100,2],[10,60,100,8,2202],[32,60,100,30,2203],[33,60,100,30,2203],[36,60,100,30,2203],[44,60,100,30,2203],[71,60,100,57]],[[4,60,101,2],[10,60,101,8,2204],[17,60,101,15,2205],[18,60,101,15,2205],[21,60,101,15,2205],[42,60,101,15,2205],[74,60,101,47],[76,60,101,48,2200]],[[4,60,103,2],[81,60,103,79]],[[4,60,104,2],[82,60,104,80]],[[4,60,105,2],[51,60,105,49]],[[4,60,106,2],[10,60,106,8,2206],[21,60,107,4,2204],[26,60,107,9,2207],[30,60,107,13],[35,60,107,18],[49,60,107,32,2208],[50,60,107,32,2208],[53,60,107,32,2208],[74,60,107,32,2208],[88,60,107,46],[90,60,107,47,2201],[102,60,107,59,2204],[110,60,107,67,2201]],[[4,60,109,2],[10,60,109,8,2209],[17,60,109,15],[23,60,109,21,2210],[24,60,109,21,2210],[27,60,109,21,2210],[35,60,109,21,2210],[46,60,109,32],[48,60,109,33,2206],[58,60,109,43]],[[8,60,109,45,2202]],[[4,60,109,65]],[[4,60,111,2],[10,60,111,8,2211],[20,60,111,42]],[[8,60,112,4,2212],[16,60,112,12,2213],[34,60,112,12,2213],[57,60,112,35]],[[8,60,113,4],[9,60,113,5,2214],[27,60,113,5,2214],[40,60,113,18],[41,60,113,19],[43,60,113,21,2200]],[[8,60,114,4],[9,60,114,5,2215],[27,60,114,5,2215],[56,60,114,34],[57,60,114,35],[59,60,114,37,2216],[60,60,114,37,2216],[63,60,114,37,2216],[82,60,114,37,2216],[116,60,114,71],[118,60,115,6,2198],[124,60,115,12,2217],[128,60,115,16]],[[4,60,117,2]],[[4,60,119,2],[10,60,119,8,2218],[25,60,119,23,2219],[26,60,119,23,2219],[29,60,119,23,2219],[43,60,119,23,2219],[58,60,119,38]],[[4,60,120,2],[8,60,120,6,2218],[22,60,120,20]],[[8,60,121,4,2211],[15,60,121,11],[16,60,121,12],[34,60,121,30],[37,60,121,33,2218]],[[4,60,122,2]],[[4,60,124,2],[8,60,124,6,2199],[17,60,124,15]],[[8,60,125,4,2211],[15,60,125,11],[16,60,125,12,2220],[34,60,125,12,2220],[42,60,125,20],[43,60,125,21],[46,60,125,24,2199]],[[4,60,126,2]],[[4,60,128,2],[8,60,128,6,2192],[16,60,128,14,2193],[19,60,128,17],[20,60,128,18,2194],[28,60,128,26],[33,60,128,31],[44,60,128,45]],[[8,60,129,4],[12,60,129,8,2221],[17,60,129,13,2222],[25,60,129,21],[27,60,129,23]],[[12,60,130,6,2211],[19,60,130,13],[20,60,130,14,2223],[38,60,130,14,2223],[65,60,130,41],[66,60,130,42],[69,60,130,45,2221],[74,60,130,50,2222],[82,60,130,58]],[[8,60,131,4]],[[8,60,133,4],[81,60,133,77]],[[8,60,134,4],[80,60,134,76]],[[8,60,135,4],[81,60,135,77]],[[8,60,136,4,2211],[15,60,136,11],[16,60,136,12,2224],[34,60,136,12,2224],[56,60,136,34],[57,60,136,35],[60,60,136,38,2225],[67,60,137,7,2226],[82,60,137,22],[83,60,137,23],[87,60,137,27,2227],[99,60,137,39],[102,60,137,42],[103,60,137,43],[105,60,137,45],[106,60,138,7,2228],[114,60,138,15],[115,60,138,16]],[[4,60,139,2]],[[4,60,141,2],[10,60,141,8,2229],[16,60,141,14],[22,60,141,20,2230],[28,60,141,26,2198],[34,60,141,32,2231],[46,60,141,44],[48,60,141,46]],[[8,60,141,48,2232],[16,60,141,56]],[[8,60,141,64,2211]],[[8,60,141,73,2209]],[[4,60,141,78]],[[4,60,143,2],[62,60,143,60]],[[4,60,144,2],[10,60,144,8,2233],[37,60,144,35,2229],[41,60,144,39,2211],[48,60,144,46],[49,60,144,47,2234],[52,60,144,50],[53,60,144,51,2235],[71,60,144,51,2235],[99,60,144,79]],[[4,60,145,2],[8,60,145,6,2233],[37,60,145,35],[42,60,145,40]],[[8,60,146,4],[14,60,146,10],[21,60,146,10],[35,60,148,5],[36,60,146,10],[40,60,146,14,2236],[65,60,146,14,2236],[88,60,146,37],[89,60,147,6],[90,60,147,7],[105,60,147,22],[107,60,147,24,2200],[116,60,147,33],[221,60,147,138],[222,60,147,139],[225,60,146,10],[246,60,146,10]],[[19,60,146,10]],[[24,60,146,10]],[[26,60,146,10]],[[8,60,148,4]],[[4,60,149,2]],[[4,60,151,2],[10,60,151,8,2237],[27,60,151,25,2229],[31,60,151,29,2211],[38,60,151,36],[39,60,151,37,2234],[42,60,151,40],[43,60,151,41]],[[4,60,152,2],[10,60,152,8],[11,60,152,9,2238],[22,60,152,19,2239],[36,60,152,33],[39,60,152,36,2237],[55,60,152,52,2240],[61,60,152,58],[69,60,152,66],[71,60,152,68]],[[4,60,153,2],[8,60,153,6,2241]],[[4,60,154,2],[11,60,154,10,2239]],[[8,60,155,4],[13,60,155,9]],[[12,60,156,6,2241],[27,60,156,21,2242],[42,60,156,21,2242],[54,60,156,33],[55,60,156,34,2243],[59,60,156,38]],[[12,60,157,6]],[[8,60,158,4],[13,60,158,9]],[[12,60,159,6,2241],[27,60,159,21,2242],[42,60,159,21,2242],[54,60,159,33],[55,60,159,34,2244],[62,60,159,41]],[[12,60,160,6]],[[8,60,161,4]],[[12,60,162,6,2241],[27,60,162,21,2245]],[[4,60,163,2]],[[4,60,165,2],[10,60,165,8,2246],[24,60,165,22],[25,60,165,23],[26,60,165,24,2229],[30,60,165,28,2211],[37,60,165,35],[38,60,165,36,2234],[41,60,165,39],[42,60,165,40,2247],[60,60,165,40,2247],[84,60,165,64]],[[4,60,167,2],[8,60,167,6,2248],[27,60,167,49,2249],[51,60,167,49,2249],[73,60,167,71]],[[4,60,168,2],[8,60,168,6]],[[8,60,169,4],[14,60,169,10,2250],[35,60,169,31,2229],[39,60,169,35,2211],[46,60,169,42],[47,60,169,43,2234],[50,60,169,46],[51,60,169,47]],[[8,60,170,4],[12,60,170,8,2250],[32,60,170,28]],[[12,60,171,6],[18,60,171,12,2251],[31,60,171,25,2252],[36,60,171,30,2253],[41,60,171,35],[42,60,171,36,2250]],[[12,60,172,6],[16,60,173,8,2251],[31,60,173,23,2254],[55,60,173,23,2254],[90,60,173,58],[94,60,174,8,2251],[109,60,174,23,2255],[133,60,174,23,2255],[163,60,174,53],[165,60,175,8]],[[16,60,176,8,2248],[35,60,176,27,2251]],[[12,60,177,6]],[[8,60,178,4]],[[4,60,179,2],[6,60,179,4],[13,60,179,10],[14,60,179,11]],[[4,60,181,2],[10,60,181,8,2256],[29,60,181,27,2238],[41,60,182,6,2257],[42,60,182,6,2257],[45,60,182,6,2257],[61,60,182,6,2257],[75,60,182,20],[77,60,183,8,2238],[88,60,184,8],[92,60,184,12,2258],[96,60,184,16,2198],[102,60,184,22,2231],[114,60,184,34],[116,60,184,36,2259],[123,60,184,43,2238],[131,60,184,51],[132,60,184,52,2260],[136,60,184,56],[141,60,186,6,2245]],[[4,60,188,2],[10,60,188,8,2261],[24,60,188,22,2229],[28,60,188,26,2211],[35,60,188,33],[36,60,188,34,2234],[39,60,188,37],[40,60,188,38]],[[4,60,189,2],[10,60,189,8,2262],[26,60,189,24],[27,60,189,25],[28,60,190,4,2261],[29,60,190,4,2261],[44,60,190,19,2261],[56,60,190,31,2263],[66,60,190,41],[67,60,190,42,2213],[85,60,190,42,2213],[108,60,190,65],[109,60,190,65]],[[4,60,193,2],[46,60,193,44]],[[4,60,194,2],[101,60,194,99]],[[4,60,195,2],[101,60,195,99]],[[4,60,196,2],[8,60,196,6],[9,60,196,7,2262],[26,60,196,24],[27,60,196,25,2256],[45,60,196,43]],[[8,60,197,4],[106,60,197,102]],[[8,60,198,4],[30,60,198,26]],[[8,60,199,4],[14,60,199,10,2264],[24,60,200,6,2229],[28,60,200,10,2265],[34,60,200,16],[38,60,200,20],[45,60,200,27,2261],[61,60,200,43],[76,60,201,10],[82,60,201,16,2229],[86,60,201,20,2266],[90,60,201,24],[95,60,202,10]],[[8,60,204,4],[14,60,204,10],[21,60,204,10],[35,60,204,28],[36,60,204,10],[40,60,204,14,2267],[46,60,204,20,2264],[56,60,204,10],[77,60,204,10]],[[19,60,204,10]],[[24,60,204,10]],[[26,60,204,10]],[[8,60,204,27]],[[4,60,205,2]],[[4,60,207,2],[8,60,207,6,2268]],[[4,60,208,2],[8,60,208,6,2269]],[[4,60,209,2],[8,60,209,6,2270]],[[4,60,210,2],[8,60,210,6,2271]],[[4,60,212,2],[8,60,212,6,2262],[23,60,212,21]],[[8,60,213,4],[14,60,213,10,2272],[25,60,213,43],[31,60,213,49,2189],[47,60,214,6,2273],[55,60,214,14,2274],[62,60,214,21],[63,60,214,22,2229],[69,60,215,6]],[[12,60,216,8,2275],[24,60,216,8,2275],[39,60,216,8,2275],[49,60,216,18]],[[12,60,217,8,2276],[30,60,217,8,2276],[51,60,217,8,2276],[67,60,217,24]],[[12,60,218,8,2202]],[[12,60,219,8,2277],[26,60,219,22,2191],[48,60,219,44,2191],[67,60,219,63,2211]],[[8,60,220,6]],[[8,60,223,4],[100,60,223,96]],[[8,60,224,4,2268],[23,60,224,19,2256],[42,60,224,38,2245],[54,60,224,50,2272],[63,60,224,59,2278],[64,60,224,60]],[[8,60,225,4],[14,60,225,10,2279],[32,60,225,28,2280],[33,60,225,28,2280],[36,60,225,28,2280],[55,60,225,28,2280],[74,60,225,47],[76,60,225,48,2272],[85,60,225,57,2281],[86,60,225,58]],[[8,60,226,4],[12,60,226,8,2279],[32,60,226,28],[36,60,226,32]],[[12,60,227,6,2269],[31,60,227,25,2279]],[[12,60,228,6,2270],[45,60,228,39,2272],[54,60,228,48,2282],[55,60,228,49]],[[12,60,229,6,2271],[49,60,229,43,2272],[58,60,229,52,2283],[59,60,229,53]],[[8,60,230,4]],[[4,60,231,2],[11,60,231,9]],[[8,60,232,4],[57,60,232,53]],[[8,60,233,4,2268],[23,60,233,19,2245]],[[8,60,234,4,2269],[27,60,234,23,2245]],[[8,60,235,4,2270],[41,60,235,37,2245]],[[8,60,236,4,2271],[45,60,236,41,2245]],[[4,60,237,2]],[[4,60,239,2],[11,60,239,9]],[[8,60,240,4,2268]],[[8,60,241,4,2269]],[[8,60,242,4,2270]],[[8,60,243,4,2271]],[[8,60,244,4,2256]],[[8,60,245,4,2241]],[[8,60,246,4,2248]],[[8,60,247,4,2246]],[[4,60,248,2]],[[0,60,249,0]],[[0,60,255,7],[9,60,255,16,2188],[29,60,256,2,2198],[34,60,256,29],[36,60,257,2,2284],[42,60,257,28]],[[4,60,259,2],[10,60,259,8],[12,60,259,10,2274],[19,60,259,17],[21,60,259,19,2285],[27,60,259,25],[29,60,259,27],[32,60,259,30,2284]],[[4,60,260,2],[10,60,260,8,2286],[20,60,260,39],[21,60,260,40]],[[4,60,262,2,2286],[12,60,262,10,2287],[38,60,262,36],[41,60,262,39]],[[4,60,264,2],[111,60,264,109]],[[4,60,265,2],[71,60,265,69]],[[4,60,266,2],[80,60,266,78]],[[4,60,267,2],[60,60,267,58]],[[4,60,268,2],[10,60,268,8,2199],[20,60,274,4],[20,60,269,4],[20,60,270,4],[77,60,269,61],[78,60,270,62]],[[4,60,271,4],[60,60,271,60]],[[4,60,272,4],[58,60,272,58]],[[4,60,273,4],[16,60,273,16]],[[4,60,274,5,2198],[5,60,274,5,2198],[11,60,274,11,2288],[26,60,274,26],[30,60,274,30,2198],[36,60,274,36,2199],[43,60,274,42],[48,60,275,4,2289],[49,60,275,4,2289],[52,60,275,4,2289],[87,60,275,4,2289],[120,60,275,37],[122,60,275,38,2198],[128,60,275,44,2217],[132,60,275,48],[136,60,276,8,2198],[142,60,276,14,2288],[157,60,276,29],[161,60,276,33,2198],[167,60,276,39,2199],[174,60,276,46],[177,60,277,8]],[[4,60,279,2],[11,60,279,9,2197],[29,60,279,27,2198],[36,60,279,34,2199],[45,60,279,43,2284],[53,60,279,51,2290],[57,60,279,55],[58,60,280,4],[65,60,280,11],[67,60,281,6,2248],[83,60,281,22],[85,60,282,6,2268],[97,60,282,18],[99,60,283,6,2269],[117,60,283,24,2291],[127,60,283,34],[129,60,284,6,2270],[161,60,284,38,2292],[185,60,284,62],[187,60,285,6,2271],[223,60,285,42,2293],[251,60,285,70],[253,60,286,6,2256],[269,60,286,22],[271,60,287,6,2241],[283,60,287,18],[285,60,288,5]],[[8,60,289,6],[12,60,289,10,2248],[33,60,289,31,2249],[57,60,289,31,2249],[79,60,289,53],[81,60,289,55]],[[12,60,290,8],[67,60,290,63]],[[12,60,291,8],[72,60,291,68]],[[12,60,292,8],[67,60,292,63]],[[12,60,293,8],[69,60,293,65]],[[12,60,294,8,2284],[19,60,294,15,2294],[32,60,294,28],[35,60,294,31]],[[12,60,296,8],[76,60,296,72]],[[12,60,297,8],[73,60,297,69]],[[12,60,298,8],[16,60,298,12,2248],[37,60,298,33,2254],[61,60,298,33,2254],[96,60,298,68],[98,60,298,70]],[[16,60,299,10,2295],[17,60,299,10,2295],[20,60,299,10,2295],[27,60,299,10,2295],[48,60,299,31],[50,60,299,32,2199],[59,60,299,41,2198],[65,60,299,47,2217],[69,60,299,51]],[[12,60,300,8]],[[8,60,301,6]],[[8,60,303,6],[14,60,303,12,2296],[28,60,303,26,2241],[45,60,303,43,2242],[60,60,303,43,2242],[72,60,303,55],[73,60,303,56,2244],[80,60,303,63]],[[8,60,304,6,2198],[14,60,304,12,2297],[21,60,304,19],[22,60,304,20,2296],[33,60,304,31],[36,60,304,34,2296]],[[8,60,305,6,2286],[16,60,305,14,2296],[27,60,305,25],[30,60,305,28,2296]],[[8,60,307,6],[12,60,307,10,2256],[33,60,307,31,2245],[44,60,307,42]],[[12,60,308,8],[91,60,308,87]],[[12,60,309,8],[91,60,309,87]],[[12,60,310,8],[98,60,310,94]],[[12,60,311,8],[96,60,311,92]],[[12,60,312,8],[95,60,312,91]],[[12,60,313,8],[55,60,313,51]],[[12,60,314,8],[18,60,314,14,2298],[41,60,314,37,2241],[57,60,314,53,2242],[72,60,314,53,2242],[84,60,314,65],[85,60,314,66,2243],[89,60,314,70]],[[12,60,316,8],[16,60,316,12,2299],[17,60,316,12,2299],[20,60,316,12,2299],[36,60,316,12,2299],[49,60,316,25],[51,60,316,26,2256],[70,60,316,45]],[[16,60,317,10],[65,60,317,59]],[[16,60,318,10],[22,60,318,16,2300],[37,60,318,31,2256],[54,60,318,48,2260],[58,60,318,52]],[[16,60,319,10],[22,60,319,16,2301],[38,60,319,32,2302],[67,60,320,12,2300],[81,60,321,12,2298]],[[16,60,323,10,2285],[23,60,323,17,2301]],[[16,60,324,10],[23,60,324,17,2303],[24,60,324,17,2303],[27,60,324,17,2303],[44,60,324,17,2303],[61,60,324,34],[63,60,324,35,2198],[70,60,324,42,2286],[79,60,324,51,2300],[93,60,324,65,2296]],[[12,60,325,8],[19,60,325,15]],[[16,60,326,10],[65,60,326,59]],[[16,60,327,10],[22,60,327,16,2304],[45,60,327,39,2305],[46,60,327,39,2305],[49,60,327,39,2305],[68,60,327,39,2305],[85,60,327,56],[87,60,328,12,2256],[105,60,329,12]],[[16,60,331,10],[22,60,331,16,2300],[37,60,331,31,2306],[38,60,331,31,2306],[41,60,331,31,2306],[54,60,331,31,2306],[65,60,331,42],[67,60,331,43,2304],[91,60,332,14,2307],[92,60,332,14,2307],[95,60,332,14,2307],[111,60,332,14,2307],[125,60,332,28],[127,60,332,29,2304],[151,60,333,14,2304]],[[16,60,334,10],[22,60,334,16,2301],[38,60,334,32,2302],[67,60,335,12,2300],[81,60,336,12,2298]],[[16,60,338,10,2285],[23,60,338,17,2301]],[[12,60,339,8]],[[8,60,340,6],[15,60,340,13]],[[12,60,341,8],[74,60,341,70]],[[12,60,342,8,2274],[20,60,342,16,2268]],[[8,60,343,6]],[[8,60,345,6],[63,60,345,61]],[[8,60,346,6],[12,60,347,8],[12,60,348,8,2256],[33,60,348,29,2245],[46,60,349,8],[49,60,347,45],[84,60,349,46]],[[8,60,350,8,2248],[29,60,350,29,2249],[53,60,350,29,2249],[75,60,350,51],[79,60,351,8],[113,60,351,42]],[[8,60,352,8,2291],[23,60,352,23,2245],[34,60,353,8]],[[12,60,354,8],[76,60,354,72]],[[12,60,355,8],[38,60,355,34]],[[12,60,356,8],[19,60,356,15,2198]],[[8,60,357,6]],[[8,60,359,6],[12,60,359,10,2291],[27,60,359,25,2245],[40,60,359,38,2256],[61,60,359,59,2245],[72,60,359,70]],[[12,60,360,8],[84,60,360,80]],[[12,60,361,8],[36,60,361,32]],[[12,60,362,8],[84,60,362,80]],[[12,60,363,8],[48,60,363,44]],[[12,60,364,8],[19,60,364,15,2303],[20,60,364,15,2303],[23,60,364,15,2303],[40,60,364,15,2303],[57,60,364,32],[59,60,365,10,2198],[66,60,366,10,2286],[75,60,367,10,2256],[92,60,367,27,2260],[96,60,367,31],[98,60,368,10,2296]],[[8,60,370,6]],[[8,60,372,6],[12,60,372,10],[19,60,372,17,2291],[34,60,372,32],[44,60,372,42]],[[12,60,373,8],[76,60,373,72]],[[12,60,374,8],[64,60,374,60]],[[12,60,375,8],[19,60,375,15,2303],[20,60,375,15,2303],[23,60,375,15,2303],[40,60,375,15,2303],[57,60,375,32],[59,60,375,33,2198],[66,60,375,40,2286],[75,60,375,49,2291],[87,60,375,61,2296]],[[8,60,376,6]],[[8,60,378,6],[81,60,378,79]],[[8,60,379,6],[19,60,379,17]],[[8,60,381,6],[75,60,381,73]],[[8,60,382,6],[23,60,382,21]],[[8,60,383,6],[14,60,383,12,2308],[27,60,383,25],[31,60,383,29,2258],[35,60,383,33,2198],[41,60,383,39,2231],[53,60,383,51],[55,60,383,53,2238],[64,60,383,62,2309],[70,60,383,68]],[[8,60,384,6],[14,60,384,12,2310],[28,60,385,8,2256],[49,60,385,29,2245],[61,60,385,41,2256],[80,60,385,60,2308]],[[8,60,386,6],[14,60,386,12,2311],[41,60,386,39,2198],[47,60,386,45,2217],[51,60,386,49]],[[8,60,387,6],[14,60,387,12,2312],[29,60,387,27]],[[8,60,389,6],[78,60,389,76]],[[8,60,390,6],[40,60,390,38]],[[8,60,391,6],[14,60,391,12,2313],[32,60,392,8,2248],[53,60,392,29,2249],[77,60,392,29,2249],[99,60,392,51],[102,60,393,12,2314],[118,60,393,12,2314],[133,60,393,27],[134,60,393,28,2315],[141,60,393,35],[144,60,394,12,2314],[160,60,394,12,2314],[175,60,394,27],[176,60,394,28,2316],[186,60,394,38]],[[8,60,396,6],[75,60,396,73]],[[8,60,397,6],[68,60,397,66]],[[8,60,398,6],[12,60,398,10,2291],[27,60,398,25,2245],[38,60,398,36]],[[12,60,399,8],[18,60,399,14,2317],[41,60,399,37,2291],[51,60,399,47],[52,60,399,48],[54,60,399,50]],[[12,60,400,8],[16,60,401,10,2317],[41,60,401,35,2245],[54,60,402,10],[115,60,402,71]],[[12,60,403,10],[76,60,403,74]],[[12,60,404,10],[76,60,404,74]],[[12,60,405,10,2317],[33,60,405,31,2318],[45,60,405,43],[49,60,406,10,2292],[78,60,406,39,2245],[91,60,407,10,2293],[124,60,407,43,2245],[135,60,408,10]],[[16,60,409,10],[82,60,409,76]],[[16,60,410,10],[85,60,410,79]],[[16,60,411,10],[85,60,411,79]],[[16,60,412,10],[68,60,412,62]],[[16,60,413,10],[22,60,413,16,2319],[45,60,413,39,2305],[46,60,413,39,2305],[49,60,413,39,2305],[68,60,413,39,2305],[85,60,413,56],[87,60,413,57,2310]],[[16,60,414,10],[22,60,414,16,2320],[39,60,414,33]],[[20,60,415,12,2217],[26,60,415,18,2317],[47,60,415,39,2217],[51,60,415,43]],[[20,60,416,12,2321],[36,60,416,28,2292]],[[20,60,417,12,2322],[26,60,417,18,2317],[47,60,417,39,2323],[55,60,417,47]],[[20,60,418,12,2324],[26,60,418,18,2317],[47,60,418,39,2324],[51,60,418,43]],[[16,60,419,10]],[[16,60,420,10],[22,60,420,16,2325],[28,60,420,22,2326],[33,60,420,27,2325],[36,60,420,30]],[[16,60,421,10],[22,60,421,16,2327],[31,60,421,25,2328],[32,60,421,25,2328],[35,60,421,25,2328],[47,60,421,25,2328],[68,60,421,46],[70,60,422,12,2325],[75,60,423,12,2310],[88,60,424,12,2319],[110,60,425,12,2320],[126,60,426,12,2308],[138,60,427,12,2198],[144,60,427,18,2329],[149,60,427,23],[151,60,428,12,2311],[177,60,429,12,2313],[194,60,430,12,2199],[203,60,431,12,2312]],[[16,60,433,10],[23,60,433,17,2330],[24,60,433,17,2330],[27,60,433,17,2330],[44,60,433,17,2330],[66,60,433,39],[68,60,434,12,2310],[81,60,435,12,2198],[88,60,436,12,2286],[97,60,437,12,2296],[110,60,438,12,2327]],[[12,60,440,8]],[[8,60,441,6]],[[8,60,443,6],[79,60,443,77]],[[8,60,444,6],[79,60,444,77]],[[8,60,445,6],[14,60,445,12,2327],[23,60,445,21,2331],[24,60,445,21,2331],[27,60,445,21,2331],[39,60,445,21,2331],[47,60,445,46],[49,60,446,8,2310],[62,60,447,8,2308],[74,60,448,8,2198],[80,60,448,14,2329],[85,60,448,19],[87,60,449,8,2311],[113,60,450,8,2199],[122,60,451,8,2313],[139,60,452,8,2312],[153,60,453,8,2286]],[[8,60,455,6],[15,60,455,13,2330],[16,60,455,13,2330],[19,60,455,13,2330],[36,60,455,13,2330],[58,60,455,35],[60,60,456,8,2310],[73,60,457,8,2198],[80,60,458,8,2286],[89,60,459,8,2296],[102,60,460,8,2327]],[[4,60,462,4],[7,60,463,4],[8,60,463,5,2332]],[[8,60,464,6],[123,60,464,121]],[[8,60,465,6,2285],[15,60,465,13,2332]],[[8,60,467,6],[15,60,467,13,2198]],[[4,60,468,4]],[[0,60,470,0]],[[0,60,472,0],[9,60,472,9,2302],[38,60,473,2,2300],[50,60,473,22],[52,60,474,2,2298],[72,60,474,36]],[[4,60,476,2],[10,60,476,8,2301],[26,60,476,24,2333],[27,60,476,24,2333],[30,60,476,24,2333],[40,60,476,24,2333],[56,60,476,40],[58,60,476,41,2300],[72,60,476,55,2298]],[[4,60,482,4,2301],[18,60,482,26,2334],[25,60,482,33],[28,60,482,36]],[[4,60,483,2],[11,60,483,9,2301]],[[0,60,484,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,61,60,13,2335],[42,61,60,13,2335]],[],[],[[15,61,60,13,2335]],[],[],[[36,61,7,7]],[[33,61,13,32]],[[36,61,14,35]],[[32,61,15,31]],[[32,61,16,31]],[[35,61,17,34]],[[37,61,18,36]],[[0,61,20,0]],[],[[1,61,22,1],[4,61,23,0],[13,61,23,9,2336],[27,61,24,2,2337],[32,61,24,29],[34,61,25,2,2338],[40,61,25,24]],[[4,61,27,2],[11,61,27,10,2338],[18,61,27,17,2339],[22,61,27,21]],[[8,61,28,4],[13,61,28,9,2340],[33,61,28,9,2340],[48,61,28,24]],[[12,61,28,26]],[[16,61,29,6],[23,61,29,13,2341],[24,61,29,13,2341],[27,61,29,13,2341],[44,61,29,13,2341],[59,61,29,28],[61,61,29,29,2337],[68,61,29,36,2338]],[[12,61,30,4]],[[8,61,31,4],[13,61,31,9,2342],[33,61,31,9,2342],[52,61,31,28]],[[12,61,31,30]],[[16,61,32,6],[23,61,32,13,2343],[24,61,32,13,2343],[27,61,32,13,2343],[47,61,32,13,2343],[65,61,32,31],[67,61,32,32,2337],[74,61,32,39,2338]],[[12,61,33,4]],[[8,61,34,4],[13,61,34,9,2344],[33,61,34,9,2344],[47,61,34,23]],[[12,61,34,25]],[[16,61,35,6],[23,61,35,13,2345],[24,61,35,13,2345],[27,61,35,13,2345],[43,61,35,13,2345],[57,61,35,27],[59,61,35,28,2337],[66,61,35,35,2338]],[[12,61,36,4]],[[8,61,37,4],[13,61,37,9,2346],[33,61,37,9,2346],[47,61,37,23]],[[12,61,37,25]],[[16,61,38,6],[23,61,38,13,2347],[24,61,38,13,2347],[27,61,38,13,2347],[43,61,38,13,2347],[57,61,38,27],[59,61,38,28,2337]],[[12,61,39,4]],[[8,61,40,4],[13,61,40,9,2348],[33,61,40,9,2348],[51,61,40,27]],[[12,61,40,29]],[[16,61,41,6],[23,61,41,13,2349],[24,61,41,13,2349],[27,61,41,13,2349],[46,61,41,13,2349],[63,61,41,30],[65,61,41,31,2337]],[[12,61,42,4]],[[8,61,43,4],[13,61,43,9,2350],[33,61,43,9,2350],[53,61,43,29]],[[12,61,43,31]],[[16,61,44,6],[23,61,44,13,2351],[24,61,44,13,2351],[27,61,44,13,2351],[48,61,44,13,2351],[67,61,44,32],[69,61,44,33,2337],[76,61,44,40,2338]],[[12,61,45,4]],[[8,61,46,4],[71,61,46,67]],[[8,61,47,4]],[[12,61,48,6],[18,61,48,12],[25,61,48,12],[39,61,48,39],[40,61,48,12],[44,61,48,16,2352],[50,61,48,22],[69,61,48,12],[90,61,48,12]],[[23,61,48,12]],[[28,61,48,12]],[[30,61,48,12]],[[12,61,48,38]],[[4,61,49,2]],[[0,61,50,0]],[[0,61,52,0],[9,61,52,9,2353],[23,61,53,2,2337],[28,61,53,29],[30,61,54,2,2354],[37,61,54,25]],[[4,61,56,2],[11,61,56,9,2337]],[[0,61,57,0]],[[0,61,60,7],[6,61,60,13,2335],[16,61,61,2],[23,61,61,9,2355],[34,61,61,20],[48,61,61,34,2353],[64,61,61,50,2336]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,62,26,16,2356],[43,62,26,16,2356]],[],[],[[15,62,26,16,2356]],[],[],[[32,62,1,34]],[[26,62,2,31]],[[27,62,3,37]],[[23,62,4,65]],[[0,62,26,7],[9,62,26,16,2356],[18,62,27,2,2357],[22,62,27,14],[24,62,28,2,2358],[31,62,28,24],[33,62,29,2,2359],[53,62,29,41],[55,62,30,2,2360],[68,62,30,42],[70,62,31,2,2361],[82,62,31,35]],[[4,62,33,2],[10,62,33,8,2362],[16,62,33,14,2363],[17,62,33,14,2363],[20,62,33,14,2363],[36,62,33,14,2363],[53,62,33,31],[55,62,33,32,2357]],[[4,62,34,2],[8,62,34,6,2362],[16,62,34,14],[22,62,34,20]],[[8,62,35,4],[46,62,35,42]],[[8,62,36,4]],[[4,62,37,2]],[[4,62,38,2],[10,62,38,8,2364],[21,62,38,19,2365],[22,62,38,19,2365],[25,62,38,19,2365],[35,62,38,19,2365],[49,62,38,33],[51,62,38,34,2362],[55,62,38,38,2357],[59,62,38,42],[61,62,38,44,2358]],[[4,62,39,2,2366],[5,62,39,2,2366],[8,62,39,2,2366],[19,62,39,2,2366],[39,62,39,22],[41,62,40,4,2364],[51,62,41,4,2359],[73,62,42,4,2360],[88,62,43,4,2367],[95,62,43,4,2367],[111,62,43,20],[112,62,43,21,2368],[119,62,43,28],[121,62,44,4,2361]],[[0,62,46,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,63,379,8,2426],[8,63,379,16,2427],[11,63,379,19],[12,63,379,20,2460],[20,63,379,28],[25,63,379,33],[40,63,379,48]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,63,211,16,2369],[28,63,211,40],[30,63,211,40]],[[15,63,211,16,2369]],[],[[4,63,269,16,2370],[26,63,269,38],[28,63,269,38]],[[15,63,269,16,2370]],[],[[4,63,299,16,2371],[26,63,299,38],[28,63,299,38]],[[15,63,299,16,2371]],[],[[4,63,249,16,2372],[28,63,249,40],[30,63,249,40]],[[15,63,249,16,2372]],[],[[4,63,319,13,2373],[27,63,319,36],[29,63,319,36]],[[15,63,319,13,2373]],[],[],[[36,63,12,7]],[[31,63,13,24]],[[23,63,14,32]],[[28,63,15,27]],[[23,63,19,7]],[[26,63,20,53]],[[32,63,21,40]],[[29,63,22,28]],[[32,63,23,30]],[[23,63,29,63]],[[0,63,62,0],[9,63,62,9,2374],[29,63,63,2,2375],[40,63,63,35],[42,63,64,2,2376],[50,63,64,32]],[[4,63,66,2],[8,63,66,6,2375],[20,63,66,18,2377],[27,63,66,25],[32,63,66,30],[38,63,66,36]],[[8,63,67,4,2375],[20,63,67,16,2377],[27,63,67,23],[30,63,67,26,2375],[42,63,67,38,2377],[49,63,67,45],[50,63,67,46,2378],[54,63,67,50]],[[8,63,68,4],[12,63,68,8,2375],[24,63,68,20,2377],[31,63,68,27],[36,63,68,32],[42,63,68,38]],[[12,63,69,6,2379],[22,63,69,16]],[[16,63,70,8,2375]],[[16,63,71,8,2380],[24,63,71,16,2375],[36,63,71,28,2377],[43,63,71,35]],[[16,63,72,8,2376]],[[12,63,73,6]],[[8,63,74,4]],[[4,63,75,2],[11,63,75,9]],[[8,63,76,4],[57,63,76,53]],[[8,63,77,4],[74,63,77,70]],[[8,63,78,4],[75,63,78,71]],[[8,63,79,4],[12,63,79,8,2375],[24,63,79,20,2381],[36,63,79,32],[38,63,79,34]],[[12,63,80,6,2375],[24,63,80,18,2381],[36,63,80,30],[39,63,80,33]],[[12,63,81,6,2375],[24,63,81,18,2382],[32,63,81,26],[33,63,81,27]],[[16,63,81,29,2383],[22,63,81,35,2384],[42,63,81,35,2384],[56,63,81,49]],[[12,63,81,50],[15,63,81,53,2376]],[[8,63,82,4]],[[4,63,83,2]],[[0,63,84,0]],[[0,63,86,0],[15,63,86,15,2379],[25,63,86,25],[27,63,87,2,2375],[38,63,87,13],[40,63,88,2,2380],[46,63,88,8],[48,63,89,2,2376],[56,63,89,10],[58,63,94,1]],[[4,63,95,2],[10,63,95,8,2385],[22,63,95,20,2375],[34,63,95,32,2386],[39,63,95,37]],[[4,63,97,2,2375],[16,63,97,14,2377],[23,63,97,21],[26,63,97,24,2380]],[[4,63,99,2],[10,63,99,8,2387],[20,63,99,18,2380],[27,63,99,25,2387],[34,63,99,32]],[[4,63,100,2],[10,63,100,8,2388],[25,63,100,23,2375],[37,63,100,35,2380],[43,63,100,41],[44,63,100,42,2385],[55,63,100,53,2387]],[[4,63,102,2],[13,63,102,11,2389],[26,63,102,24,2390],[35,63,102,49]],[[8,63,103,4],[74,63,103,70]],[[8,63,104,4],[12,63,104,8,2380],[19,63,104,15,2391],[28,63,104,24],[30,63,104,26]],[[12,63,105,6],[68,63,105,62]],[[12,63,106,6],[16,63,107,8,2380],[23,63,107,15,2387],[30,63,107,22],[31,63,107,23,2383],[35,63,107,27],[40,63,107,32,2392],[60,63,107,32,2392],[80,63,107,52],[84,63,108,8,2380],[91,63,108,15,2387],[98,63,108,22],[99,63,108,23,2393],[112,63,108,36],[114,63,109,8]],[[16,63,110,8],[75,63,110,67]],[[16,63,111,8],[74,63,111,66]],[[16,63,112,8,2375],[28,63,112,20,2381],[40,63,112,32],[43,63,112,35]],[[12,63,113,6]],[[12,63,114,6],[77,63,114,71]],[[12,63,115,6],[49,63,115,43]],[[12,63,116,6,2374],[32,63,116,26,2375],[45,63,116,39,2376]],[[12,63,117,6]],[[8,63,118,4]],[[8,63,120,4,2375],[20,63,120,16,2386],[25,63,120,21],[28,63,120,24,2390]],[[8,63,122,4,2374],[28,63,122,24,2375],[41,63,122,37,2376]],[[8,63,123,4,2380],[15,63,123,11,2394],[22,63,123,18],[23,63,123,19,2390]],[[4,63,124,2]],[[4,63,126,2],[66,63,126,64]],[[4,63,127,2],[8,63,127,6,2395],[9,63,127,6,2395],[12,63,127,6,2395],[24,63,127,6,2395],[34,63,127,16],[36,63,127,17,2388],[51,63,127,32]],[[8,63,128,4,2388],[21,63,128,17,2396],[25,63,128,21],[26,63,128,22,2389],[40,63,128,36],[41,63,128,37,2397]],[[12,63,129,6,2374],[32,63,129,26,2375],[45,63,129,39,2376]],[[12,63,130,6,2380],[19,63,130,13,2398],[25,63,130,19],[26,63,130,20,2397]],[[8,63,131,4]],[[4,63,132,2],[11,63,132,9]],[[8,63,133,4,2389],[21,63,133,17,2388]],[[4,63,134,2]],[[0,63,135,0]],[[0,63,137,0],[9,63,137,9,2399],[24,63,138,2,2375],[35,63,138,35],[37,63,139,2,2387],[44,63,139,25],[46,63,140,2,2376],[54,63,140,32]],[[4,63,142,2],[8,63,142,6,2400],[20,63,145,6]],[[8,63,145,8,2394],[17,63,145,17,2376]],[[8,63,145,27,2398],[16,63,145,35],[21,63,145,42]],[[4,63,145,44]],[[4,63,147,2],[71,63,147,69]],[[4,63,148,2],[92,63,148,90]],[[4,63,149,2],[63,63,149,61]],[[4,63,150,2],[56,63,150,54]],[[4,63,151,2],[8,63,151,6,2387],[16,63,151,14,2383],[20,63,151,18],[25,63,151,23,2401],[45,63,151,23,2401],[59,63,151,37],[61,63,151,39]],[[8,63,152,4],[69,63,152,65]],[[8,63,153,4],[14,63,153,10,2402],[32,63,153,28],[36,63,153,32,2403],[44,63,153,56],[45,63,153,57,2394],[54,63,153,66,2398]],[[12,63,154,6,2400],[24,63,154,18]],[[16,63,154,20,2394]],[[16,63,154,29,2398]],[[12,63,154,36]],[[8,63,155,4]],[[8,63,157,4,2404],[9,63,157,4,2404],[12,63,157,4,2404],[19,63,157,4,2404],[34,63,157,19],[36,63,157,20]],[[12,63,158,6],[112,63,158,106]],[[12,63,159,6],[77,63,159,71]],[[12,63,160,6,2376],[21,63,160,15,2402]],[[8,63,161,4]],[[4,63,162,2]],[[4,63,164,2],[10,63,164,8,2405],[22,63,164,37]],[[8,63,165,4,2387]],[[8,63,166,4,2378],[14,63,166,10]],[[8,63,167,4,2394],[17,63,167,13,2400],[27,63,167,23,2394],[34,63,167,30]],[[8,63,168,4,2398],[16,63,168,12,2400],[26,63,168,22,2398],[32,63,168,28]],[[4,63,169,2]],[[4,63,171,2],[34,63,171,32]],[[4,63,172,2],[8,63,172,6,2375],[20,63,172,18,2377],[27,63,172,25],[32,63,172,30],[38,63,172,36]],[[8,63,173,4],[73,63,173,69]],[[8,63,174,4],[52,63,174,48]],[[8,63,175,4,2375],[20,63,175,16,2406],[24,63,175,20],[27,63,175,23,2405]],[[8,63,177,4,2379],[18,63,177,14]],[[12,63,178,6,2375]],[[12,63,179,6,2380],[20,63,179,14,2405]],[[12,63,180,6,2376]],[[8,63,181,4]],[[4,63,182,2],[11,63,182,9],[15,63,183,4,2387],[23,63,183,12,2383],[27,63,183,16],[32,63,183,21,2407],[52,63,183,21,2407],[67,63,183,36],[71,63,184,4,2387],[79,63,184,12,2383],[83,63,184,16],[88,63,184,21,2401],[108,63,184,21,2401],[122,63,184,35],[124,63,185,4]],[[8,63,186,4],[87,63,186,83]],[[8,63,187,4],[124,63,187,120]],[[8,63,188,4,2375],[20,63,188,16,2377],[27,63,188,23],[28,63,188,24,2391],[37,63,188,33],[40,63,188,36]],[[8,63,190,4],[84,63,190,80]],[[8,63,191,4],[142,63,191,138]],[[8,63,192,4,2405],[18,63,192,14,2378],[22,63,192,18],[25,63,192,21,2375],[37,63,192,33,2377],[44,63,192,40],[45,63,192,41,2378],[49,63,192,45]],[[8,63,194,4,2379],[18,63,194,14]],[[12,63,195,6,2375]],[[12,63,196,6,2380],[20,63,196,14,2405]],[[12,63,197,6,2376]],[[8,63,198,4]],[[4,63,199,2],[11,63,199,9]],[[8,63,200,4],[76,63,200,72]],[[8,63,201,4],[87,63,201,83]],[[8,63,202,4],[12,63,202,8,2375],[24,63,202,20,2406],[28,63,202,24],[33,63,202,29],[39,63,202,35]],[[12,63,203,6,2375],[24,63,203,18,2406],[28,63,203,22],[29,63,203,23,2378],[33,63,203,27],[36,63,203,30,2405]],[[8,63,204,4]],[[8,63,205,4,2375],[20,63,205,16,2406],[24,63,205,20],[27,63,205,23,2405]],[[4,63,206,2]],[[0,63,207,0]],[[0,63,209,0],[4,63,209,4,2408],[24,63,209,53]],[[0,63,211,7],[9,63,211,16,2369],[34,63,212,2,2409],[46,63,212,30],[48,63,213,2,2410],[68,63,213,57]],[[4,63,215,2],[10,63,215,8,2375],[24,63,215,44]],[[8,63,216,4,2386],[15,63,216,11,2409]],[[8,63,217,4,2382],[18,63,217,14],[19,63,217,15,2387],[28,63,217,40,2376],[39,63,218,6,2399],[54,63,218,21,2375],[67,63,218,34,2387],[76,63,218,43,2376]],[[8,63,219,4,2380],[16,63,219,12],[23,63,219,19,2386],[30,63,219,42,2380]],[[12,63,220,6],[18,63,220,12,2411],[27,63,220,21,2412],[28,63,220,21,2412],[31,63,220,21,2412],[46,63,220,21,2412],[53,63,220,28],[55,63,220,29,2386],[62,63,220,36,2380]],[[12,63,221,6],[19,63,221,13,2411]],[[8,63,222,4]],[[8,63,223,4,2377],[17,63,223,13]],[[8,63,224,4,2406],[14,63,224,10]],[[8,63,225,4,2413],[33,63,226,6,2410],[58,63,226,31],[66,63,227,6],[73,63,227,13,2410],[94,63,227,34,2413],[117,63,227,57],[122,63,227,62],[135,63,229,10,2410],[156,63,229,31,2413],[179,63,229,54],[182,63,230,10]],[[4,63,231,2]],[[4,63,233,2],[8,63,233,6],[15,63,233,13,2414],[26,63,233,24],[39,63,233,37]],[[8,63,234,4],[80,63,234,76]],[[8,63,235,4],[77,63,235,73]],[[8,63,236,4],[50,63,236,46]],[[8,63,237,4],[12,63,237,8,2408],[34,63,237,30],[40,63,237,36]],[[12,63,238,6],[18,63,238,12],[25,63,238,12],[39,63,241,7],[40,63,238,12],[44,63,238,16,2415],[50,63,239,8],[120,63,240,10],[134,63,238,12],[155,63,238,12]],[[23,63,238,12]],[[28,63,238,12]],[[30,63,238,12]],[[12,63,241,6]],[[8,63,242,4]],[[8,63,243,4,2408],[28,63,243,24,2375]],[[4,63,244,2]],[[4,63,246,2],[11,63,246,9,2375]],[[0,63,247,0]],[[0,63,249,7],[9,63,249,16,2372]],[[4,63,250,2],[11,63,250,9,2408],[33,63,250,31],[40,63,250,38,2408],[58,63,250,56,2386],[63,63,250,61],[66,63,250,64]],[[0,63,251,0]],[[0,63,253,0],[9,63,253,9,2416]],[[4,63,254,2],[8,63,254,6,2408],[30,63,254,28],[36,63,254,34]],[[8,63,255,4],[14,63,255,10],[21,63,255,10],[35,63,257,5],[36,63,255,10],[40,63,255,14,2415],[46,63,256,6],[122,63,255,10],[143,63,255,10]],[[19,63,255,10]],[[24,63,255,10]],[[26,63,255,10]],[[8,63,257,4]],[[4,63,258,2]],[[4,63,259,2],[11,63,259,9,2408]],[[0,63,260,0]],[[0,63,262,0],[9,63,262,9,2417]],[[4,63,263,2],[8,63,263,6,2408],[30,63,263,28],[36,63,263,34]],[[8,63,264,4],[15,63,264,11,2408],[33,63,264,29,2413],[56,63,264,52]],[[4,63,265,2]],[[4,63,266,2],[11,63,266,9]],[[0,63,267,0]],[[0,63,269,7],[9,63,269,16,2370],[32,63,270,2,2418],[36,63,270,14],[38,63,271,2,2419],[50,63,271,46],[52,63,272,2,2420],[64,63,272,23],[66,63,273,2,2421],[81,63,273,38]],[[4,63,275,2],[77,63,275,75]],[[4,63,276,2],[72,63,276,70]],[[4,63,277,2],[10,63,277,8,2422],[16,63,277,14],[20,63,277,18,2423],[24,63,277,22,2424],[25,63,277,22,2424],[28,63,277,22,2424],[41,63,277,22,2424],[52,63,277,33],[54,63,277,34,2418],[61,63,277,41,2425],[70,63,277,50,2418],[74,63,277,54]],[[4,63,278,2],[8,63,278,6,2426],[16,63,278,14,2427],[19,63,278,17],[20,63,278,18,2428],[48,63,278,46],[50,63,278,48]],[],[[4,63,282,2,2430],[5,63,282,2,2430],[8,63,282,2,2430],[15,63,282,2,2430],[42,63,282,29],[44,63,282,30,2421]],[[4,63,284,2],[10,63,284,8,2413],[36,63,284,34,2417]],[[4,63,285,2],[8,63,285,6,2413],[36,63,285,34],[42,63,285,40]],[[8,63,286,4,2413],[32,63,286,28,2418],[38,63,286,34,2419]],[[4,63,287,2]],[[4,63,289,2,2431],[5,63,289,2,2431],[8,63,289,2,2431],[24,63,289,2,2431],[47,63,289,25],[49,63,289,26]],[[8,63,290,4,2383],[14,63,290,10,2407],[34,63,290,10,2407],[49,63,290,25]],[[8,63,291,4,2422]],[[8,63,292,4,2432],[23,63,292,19,2433],[24,63,292,19,2433],[27,63,292,19,2433],[43,63,292,19,2433],[56,63,292,32],[58,63,292,33,2422]],[[8,63,293,4,2434],[24,63,293,20,2425],[33,63,293,29,2435],[39,63,293,35]],[[8,63,294,4,2420]],[[8,63,295,4,2419]],[[4,63,296,2]],[[0,63,297,0]],[[0,63,299,7],[9,63,299,16,2371],[32,63,300,2,2418],[36,63,300,14],[38,63,301,2,2436],[50,63,301,43]],[[4,63,303,2],[10,63,303,8,2413],[36,63,303,34,2417]],[[4,63,304,2],[8,63,304,6,2413],[36,63,304,34],[42,63,304,40]],[[8,63,305,4,2413],[32,63,305,28,2418],[38,63,305,34]],[[4,63,306,2]],[[4,63,307,2,2431],[5,63,307,2,2431],[8,63,307,2,2431],[24,63,307,2,2431],[47,63,307,25],[49,63,307,26]],[[8,63,308,4,2383],[14,63,308,10,2401],[34,63,308,10,2401],[48,63,308,24]],[[8,63,309,4,2422],[13,63,309,9],[17,63,309,13,2423],[21,63,309,17,2418]],[[8,63,310,4,2436]],[[4,63,311,2]],[[0,63,312,0]],[[0,63,319,7],[6,63,319,13,2373],[32,63,319,58]],[[4,63,320,2,2437],[10,63,320,8],[14,63,320,14,2414],[21,63,320,21,2438],[28,63,320,28],[29,63,320,29,2437],[33,63,320,33]],[[4,63,321,2,2439],[13,63,321,11],[17,63,321,17,2414],[24,63,321,24,2438],[31,63,321,31],[32,63,321,32,2439],[39,63,321,39]],[[4,63,322,2,2440],[14,63,324,4],[14,63,323,4],[82,63,324,72],[83,63,323,73]],[[4,63,325,4],[53,63,325,53]],[[4,63,326,4],[5,63,326,5,2418],[11,63,326,19,2441]],[[8,63,327,6],[14,63,327,12,2375],[28,63,327,26,2416]],[[8,63,328,6],[14,63,328,12,2442],[29,63,328,27,2441],[38,63,328,36,2443],[46,63,328,44,2444],[66,63,328,44,2444],[78,63,328,56],[79,63,328,57,2445],[83,63,328,61]],[[8,63,330,6],[94,63,330,92]],[[8,63,331,6],[83,63,331,81]],[[8,63,332,6],[12,63,332,10,2446]],[[8,63,333,6],[15,63,333,14,2442]],[[12,63,334,8],[17,63,334,13,2444],[37,63,334,13,2444],[49,63,334,25],[50,63,334,26,2445],[54,63,334,30]],[[16,63,334,32]],[[20,63,335,10],[120,63,335,110]],[[20,63,336,10,2446],[36,63,336,26,2447],[43,63,336,26,2447],[56,63,336,39],[57,63,336,40,2448],[60,63,336,43]],[[20,63,337,10]],[[16,63,338,8]],[[12,63,339,8],[17,63,339,13,2444],[37,63,339,13,2444],[49,63,339,25],[50,63,339,26,2449],[54,63,339,30]],[[16,63,339,32]],[[20,63,340,10,2446],[36,63,340,26,2447],[43,63,340,26,2447],[56,63,340,39],[57,63,340,40,2450],[61,63,340,44]],[[20,63,341,10]],[[16,63,342,8]],[[12,63,343,8]],[[16,63,343,17]],[[20,63,344,10,2442]],[[20,63,345,10],[74,63,345,64]],[[20,63,346,10],[71,63,346,61]],[[20,63,347,10],[86,63,347,76]],[[20,63,348,10],[42,63,348,32]],[[20,63,349,10,2446],[36,63,349,26,2447],[43,63,349,26,2447],[56,63,349,39],[57,63,349,40,2448],[60,63,349,43]],[[16,63,350,8]],[[8,63,351,6]],[[8,63,353,6,2451],[9,63,353,6,2451],[12,63,353,6,2451],[22,63,353,6,2451],[30,63,353,30],[32,63,354,8,2418],[38,63,355,8,2375],[50,63,355,20,2386],[55,63,355,25],[56,63,355,26,2452],[63,63,355,33],[65,63,356,8,2375],[77,63,356,20,2386],[82,63,356,25],[83,63,356,26,2453],[87,63,356,30],[89,63,357,8,2446],[104,63,358,8,2441],[113,63,358,17,2454],[129,63,358,33]],[[4,63,360,4]],[[4,63,361,2,2455],[13,63,361,11],[14,63,361,12,2418],[20,63,361,26,2441]],[[8,63,362,4,2404],[9,63,362,4,2404],[12,63,362,4,2404],[19,63,362,4,2404],[34,63,362,19],[36,63,362,20]],[[12,63,363,6,2370],[35,63,363,29,2418],[41,63,363,35],[52,63,363,46,2441],[61,63,363,55,2456],[71,63,363,65],[77,63,363,71]],[[8,63,364,4]],[[4,63,365,2]],[[4,63,366,2,2457],[10,63,366,8],[11,63,366,9,2418],[17,63,366,23,2441]],[[8,63,367,4,2404],[9,63,367,4,2404],[12,63,367,4,2404],[19,63,367,4,2404],[34,63,367,19],[36,63,367,20]],[[12,63,368,6,2370],[35,63,368,29,2418],[41,63,368,35],[49,63,368,43,2441],[58,63,368,52,2456],[68,63,368,62],[74,63,368,68]],[[8,63,369,4]],[[4,63,370,2]],[[4,63,371,2,2458],[13,63,371,11]],[[8,63,372,4,2404],[9,63,372,4,2404],[12,63,372,4,2404],[19,63,372,4,2404],[34,63,372,19],[36,63,372,20]],[[12,63,373,6,2431],[13,63,373,6,2431],[16,63,373,6,2431],[32,63,373,6,2431],[55,63,373,29],[57,63,373,30]],[[16,63,374,8,2383],[22,63,374,14,2384],[42,63,374,14,2384],[56,63,374,28]],[[12,63,375,6]],[[8,63,376,4]],[[4,63,377,2]],[[4,63,378,2,2459],[16,63,378,14]],[[8,63,379,4]],[],[[13,63,383,11]],[[12,63,384,6,2404],[13,63,384,6,2404],[16,63,384,6,2404],[23,63,384,6,2404],[38,63,384,21],[40,63,384,22]],[[16,63,385,8,2431],[17,63,385,8,2431],[20,63,385,8,2431],[36,63,385,8,2431],[59,63,385,31],[61,63,385,32]],[[20,63,386,10,2383],[26,63,386,16,2461],[46,63,386,16,2461],[64,63,386,34]],[[16,63,387,8]],[[12,63,388,6]],[[8,63,389,4]],[[4,63,390,2]],[[0,63,391,0]],[[0,63,393,0],[64,63,393,64]],[[0,63,394,0],[4,63,394,4],[11,63,394,11,2414],[22,63,394,22],[37,63,394,37,2414],[44,63,394,44,2378],[48,63,394,48],[50,63,394,50]],[[4,63,395,2,2414],[11,63,395,9,2378],[15,63,395,13],[16,63,395,14,2462],[22,63,395,20],[25,63,395,23,2373]],[[0,63,396,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,64,29,16,2463],[53,64,29,16,2463]],[],[],[[15,64,29,16,2463]],[],[],[[23,64,0,44]],[[26,64,1,29]],[[0,64,4,0],[6,64,4,6,2464],[23,64,4,23]],[[0,64,5,0],[6,64,5,6,2465],[21,64,5,21]],[[0,64,7,0],[9,64,7,9,2466]],[[4,64,8,2],[10,64,8,8,2467],[30,64,8,28,2468],[39,64,8,37,2469],[56,64,8,54],[57,64,8,55,2464],[72,64,8,70],[73,64,8,71],[75,64,8,73]],[[4,64,9,2],[8,64,9,6,2467],[27,64,9,25,2470],[39,64,9,37,2471],[49,64,9,47],[50,64,9,48],[52,64,9,50],[54,64,9,52]],[[8,64,10,4],[15,64,10,11,2467],[33,64,10,29,2470],[43,64,10,39],[44,64,10,40,2471],[54,64,10,50],[55,64,10,51],[57,64,10,53]],[[4,64,11,2],[11,64,11,9]],[[8,64,12,4],[14,64,12,10,2472],[26,64,12,22,2468],[35,64,12,31,2473],[48,64,12,44],[49,64,12,45,2464]],[[8,64,13,4,2472],[18,64,13,14,2474],[23,64,13,19],[24,64,13,20,2475],[31,64,13,27],[34,64,13,30]],[[8,64,14,4],[14,64,14,10,2476],[26,64,14,22,2468],[35,64,14,31,2473],[48,64,14,44],[49,64,14,45]],[[8,64,15,4,2476],[18,64,15,14,2477],[26,64,15,22],[29,64,15,25]],[[8,64,16,4,2476],[18,64,16,14,2478],[20,64,16,16],[23,64,16,19,2465]],[[8,64,17,4,2476],[18,64,17,14,2479],[22,64,17,18],[25,64,17,21]],[[8,64,18,4,2476],[18,64,18,14,2474],[23,64,18,19],[24,64,18,20,2475],[31,64,18,27],[34,64,19,6]],[[8,64,21,4],[63,64,21,59]],[[8,64,22,4],[14,64,22,10,2480],[23,64,22,19,2472],[33,64,22,29,2481],[45,64,22,41],[46,64,22,42]],[[12,64,22,44,2482],[18,64,22,50]],[[8,64,22,57]],[[8,64,23,4,2480],[15,64,23,11,2483],[26,64,23,22],[27,64,23,23,2476]],[[8,64,24,4,2468],[17,64,24,13,2484],[21,64,24,17],[22,64,24,18,2483],[33,64,24,29],[34,64,24,30,2472]],[[8,64,25,4],[15,64,25,11,2476]],[[4,64,26,2]],[[0,64,27,0]],[[0,64,29,7],[9,64,29,16,2463],[28,64,29,35],[30,64,29,37,2485],[34,64,29,41],[36,64,29,72]],[[4,64,30,2],[10,64,30,8],[11,64,30,9,2486],[23,64,30,21,2487],[37,64,30,35],[40,64,30,38,2488],[41,64,30,38,2488],[44,64,30,38,2488],[51,64,30,38,2488],[59,64,30,46],[61,64,30,67]],[[4,64,32,2,2489],[5,64,32,2,2489],[8,64,32,2,2489],[15,64,32,2,2489],[24,64,32,11],[26,64,32,12]],[[8,64,33,4],[14,64,33,10,2476],[26,64,33,22,2466]],[[8,64,34,4,2487],[22,64,34,18,2476]],[[8,64,35,4],[15,64,35,11]],[[12,64,36,6],[18,64,36,12,2472],[30,64,36,24,2468],[39,64,36,33,2490],[59,64,36,53],[60,64,36,54,2464],[75,64,36,69],[76,64,36,70],[78,64,36,72]],[[12,64,37,6],[16,64,37,10,2472],[27,64,37,21,2491],[40,64,37,34]],[[16,64,38,8,2468],[25,64,38,17,2484],[29,64,38,21],[30,64,38,22,2492],[41,64,38,33],[42,64,38,34,2472]],[[12,64,39,6]],[[8,64,40,4]],[[4,64,41,2],[7,64,41,5],[9,64,41,7]],[[4,64,43,2],[10,64,43,8],[11,64,43,9,2493],[30,64,43,28,2494],[51,64,43,49],[54,64,43,52,2488],[55,64,43,52,2488],[58,64,43,52,2488],[65,64,43,52,2488],[73,64,43,60],[75,64,43,61]],[[4,64,44,2],[10,64,44,8,2495],[26,64,44,24,2496],[27,64,44,24,2496],[30,64,44,24,2496],[37,64,44,24,2496],[43,64,44,30],[45,64,44,51,2497]],[[4,64,46,2,2489],[5,64,46,2,2489],[8,64,46,2,2489],[15,64,46,2,2489],[24,64,46,11],[26,64,46,12]],[[8,64,47,4],[12,64,47,8,2498],[27,64,47,23]],[[8,64,48,4],[12,64,48,8,2468],[21,64,48,17,2499],[26,64,48,22],[28,64,48,24]],[[12,64,49,6,2498],[27,64,49,21,2468],[36,64,49,30,2499],[41,64,49,35]],[[8,64,50,4],[15,64,50,11]],[[12,64,51,6],[18,64,51,12,2500],[31,64,51,25,2468],[40,64,51,34,2501],[53,64,51,47],[54,64,51,48]],[[12,64,52,6],[16,64,52,10,2500],[28,64,52,22]],[[16,64,53,8,2498],[31,64,53,23,2500],[42,64,53,34,2502],[51,64,53,43],[55,64,53,47,2500],[66,64,53,58,2503],[77,64,53,69],[81,64,53,73]],[[12,64,54,6]],[[8,64,55,4]],[[8,64,57,4],[84,64,57,80]],[[8,64,58,4],[41,64,58,37]],[[8,64,59,4],[12,64,60,6,2495],[26,64,60,20,2504],[33,64,60,27],[38,64,60,32,2497],[51,64,61,6,2495],[65,64,61,20,2504],[72,64,61,27],[77,64,61,32,2498],[91,64,62,6]],[[12,64,63,6,2494],[33,64,63,27,2498]],[[8,64,64,4]],[[8,64,65,4,2495],[22,64,65,18,2504],[29,64,65,25],[32,64,65,28,2498]],[[4,64,66,2],[7,64,66,5]],[[8,64,66,6,2485]],[[5,64,66,11]],[[4,64,68,2],[11,64,68,9,2486],[24,64,68,9,2486],[35,64,68,9,2486],[38,64,68,22,2505],[39,64,68,22,2505],[42,64,68,22,2505],[52,64,68,22,2505],[64,64,68,34],[66,64,68,35,2493],[85,64,68,54,2486],[99,64,68,68]],[[0,64,69,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,65,22,7,2509],[8,65,22,15,2510],[11,65,22,18],[12,65,22,19,2511],[47,65,22,54]],[],[],[],[],[[31,65,21,16,2506],[44,65,21,16,2506]],[],[],[[15,65,21,16,2506]],[],[],[[36,65,3,7]],[[0,65,5,0],[29,65,5,29]],[[0,65,6,0]],[],[],[],[],[],[],[],[],[],[],[[1,65,17,1],[4,65,19,0],[10,65,19,6,2507],[19,65,19,15],[22,65,19,18,2508],[42,65,19,18,2508],[72,65,19,48],[73,65,19,49],[77,65,19,53],[78,65,19,54]],[[0,65,21,7],[9,65,21,16,2506]],[[4,65,22,2],[8,65,22,6],[44,65,22,56]],[[8,65,23,4],[14,65,23,10],[21,65,23,10],[35,65,25,5],[36,65,23,10],[40,65,23,14,2512],[46,65,24,6],[47,65,24,7],[158,65,24,118],[159,65,24,119],[162,65,23,10],[183,65,23,10]],[[19,65,23,10]],[[24,65,23,10]],[[26,65,23,10]],[[8,65,25,4]],[[4,65,26,2]],[[4,65,28,2],[10,65,28,8,2513],[18,65,28,16],[25,65,28,16],[39,65,28,33],[40,65,28,16],[44,65,28,20,2512],[50,65,28,26,2507],[59,65,28,16],[80,65,28,16]],[[15,65,28,16]],[[20,65,28,16]],[[22,65,28,16]],[[4,65,28,32]],[[4,65,29,4,2513],[10,65,29,38,2514],[16,65,29,44],[19,65,29,47,2507]],[[4,65,30,2],[10,65,30,8,2513]],[[0,65,31,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,66,23,7,2518],[8,66,23,15,2519],[11,66,23,18],[12,66,23,19,2520],[47,66,23,54]],[],[],[],[],[[31,66,22,16,2515],[47,66,22,16,2515]],[],[],[[15,66,22,16,2515]],[],[],[[36,66,3,7]],[[0,66,5,0],[32,66,5,32]],[[0,66,6,0]],[],[],[],[],[],[],[],[],[],[],[],[[1,66,18,1],[4,66,20,0],[10,66,20,6,2516],[19,66,20,15],[22,66,20,18,2517],[42,66,20,18,2517],[72,66,20,48],[73,66,20,49],[77,66,20,53],[78,66,20,54]],[[0,66,22,7],[9,66,22,16,2515]],[[4,66,23,2],[8,66,23,6],[44,66,23,56]],[[8,66,24,4],[14,66,24,10],[21,66,24,10],[35,66,26,5],[36,66,24,10],[40,66,24,14,2521],[46,66,25,6],[47,66,25,7],[158,66,25,118],[159,66,25,119],[162,66,24,10],[183,66,24,10]],[[19,66,24,10]],[[24,66,24,10]],[[26,66,24,10]],[[8,66,26,4]],[[4,66,27,2]],[[4,66,29,2],[10,66,29,8,2522],[18,66,29,16],[25,66,29,16],[39,66,29,33],[40,66,29,16],[44,66,29,20,2521],[50,66,29,26,2516],[59,66,29,16],[80,66,29,16]],[[15,66,29,16]],[[20,66,29,16]],[[22,66,29,16]],[[4,66,29,32]],[[4,66,30,4,2522],[10,66,30,38,2523],[16,66,30,44],[19,66,30,47,2516]],[[4,66,31,2],[10,66,31,8,2522]],[[0,66,32,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,67,3,16,2524],[51,67,3,16,2524]],[],[],[[15,67,3,16,2524]],[],[],[[30,67,0,36]],[[35,67,1,34]],[[0,67,3,7],[9,67,3,16,2524],[26,67,3,33,2525],[31,67,3,47]],[[4,67,4,2],[8,67,4,6,2526],[9,67,4,6,2526],[12,67,4,6,2526],[31,67,4,6,2526],[48,67,4,23],[50,67,4,24,2525],[60,67,4,34,2527],[61,67,4,34,2527],[64,67,4,34,2527],[78,67,4,34,2527],[97,67,4,53],[99,67,4,54,2525],[107,67,4,62]],[[8,67,5,4],[14,67,5,10,2525]],[[4,67,6,2]],[[4,67,8,2],[8,67,8,6,2525],[25,67,8,23,2528],[34,67,8,32],[45,67,8,43,2525],[52,67,8,50]],[[8,67,9,4,2524],[25,67,9,21,2525],[31,67,9,27,2529],[36,67,9,32]],[[4,67,10,2]],[[0,67,11,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,68,2,13,2530],[22,68,2,31],[24,68,2,31]],[[15,68,2,13,2530]],[],[[4,68,10,16,2531],[24,68,10,36],[26,68,10,36]],[[15,68,10,16,2531]],[],[],[[0,68,0,0],[6,68,0,6,2532],[27,68,0,27]],[[0,68,2,7],[6,68,2,13,2530],[33,68,2,40,2533]],[[4,68,5,2,2534],[16,68,5,30,2535],[27,68,5,49],[28,68,5,51]],[[8,68,6,4],[13,68,6,9],[14,68,6,10],[15,68,6,11],[37,68,6,33],[39,68,6,35,2535],[52,68,6,48],[55,68,6,48],[59,68,6,48],[60,68,5,30,2535],[71,68,5,30,2535],[74,68,5,30,2535],[87,68,5,30,2535],[91,68,5,30,2535],[92,68,3,2,2536],[98,68,3,2,2536],[101,68,3,38,2532]],[[4,68,7,2]],[[0,68,8,0]],[[0,68,10,7],[9,68,10,16,2531],[30,68,10,37,2537],[33,68,10,49]],[[4,68,11,2],[8,68,12,4],[15,68,12,11,2537],[23,68,12,19],[35,68,13,4,2537],[43,68,13,12],[51,68,14,4],[52,68,14,6],[53,68,14,6],[65,68,14,18,2537],[68,68,14,20],[73,68,15,4],[80,68,15,11,2537],[84,68,15,15,2536],[90,68,15,21],[95,68,15,26],[105,68,16,4]],[[8,68,17,4],[15,68,17,11]],[[4,68,18,2]],[[4,68,20,2],[11,68,20,9,2537],[15,68,20,13,2536],[21,68,20,19],[26,68,20,24,2532]],[[0,68,21,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,69,2,13,2538],[25,69,2,34],[27,69,2,34]],[[15,69,2,13,2538]],[],[[4,69,6,16,2539],[27,69,6,39],[29,69,6,39]],[[15,69,6,16,2539]],[],[],[[0,69,0,0],[6,69,0,6,2540],[32,69,0,32]],[[0,69,2,7],[6,69,2,13,2538],[36,69,2,43,2541]],[],[[8,69,2,7],[13,69,2,7],[17,69,2,7],[24,69,2,7],[28,69,2,7],[29,69,3,18,2542],[33,69,3,18,2542],[36,69,3,25,2540]],[],[[0,69,4,0]],[[0,69,6,7],[9,69,6,16,2539],[33,69,7,2,2543],[38,69,7,16]],[[4,69,9,2],[8,69,9,6],[15,69,9,13,2543],[25,69,9,23],[37,69,9,35,2543],[47,69,9,45],[55,69,9,53],[56,69,9,55],[57,69,9,55],[67,69,9,65,2543],[72,69,9,69],[75,69,9,73]],[[8,69,10,4],[15,69,10,11]],[[4,69,11,2]],[[4,69,13,2],[11,69,13,9,2543],[17,69,13,15,2542],[21,69,13,19],[26,69,13,24,2540]],[[0,69,14,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,70,10,16,2544],[51,70,10,16,2544]],[],[],[[15,70,10,16,2544]],[],[],[[39,70,0,47]],[[28,70,1,27]],[[30,70,2,36]],[[35,70,3,34]],[[34,70,7,7]],[[36,70,8,37]],[[0,70,10,7],[9,70,10,16,2544],[26,70,10,33,2545],[31,70,10,47]],[[4,70,11,2],[8,70,12,4,2546],[9,70,12,4,2546],[12,70,12,4,2546],[31,70,12,4,2546],[48,70,12,21],[50,70,12,22,2545],[60,70,13,4,2547],[61,70,13,4,2547],[64,70,13,4,2547],[78,70,13,4,2547],[97,70,13,23],[99,70,13,24,2545],[109,70,14,4,2548],[110,70,14,4,2548],[113,70,14,4,2548],[133,70,14,4,2548],[153,70,14,24],[155,70,14,25,2545],[165,70,15,4,2549],[166,70,15,4,2549],[169,70,15,4,2549],[187,70,15,4,2549],[204,70,15,21],[206,70,15,22,2545],[216,70,16,4,2550],[217,70,16,4,2550],[220,70,16,4,2550],[232,70,16,4,2550],[242,70,16,14],[244,70,16,15,2545],[254,70,17,4,2551],[255,70,17,4,2551],[258,70,17,4,2551],[281,70,17,4,2551],[311,70,17,34],[313,70,17,35,2545],[323,70,18,4,2552],[324,70,18,4,2552],[327,70,18,4,2552],[345,70,18,4,2552],[372,70,18,31],[374,70,18,32,2545],[382,70,19,4]],[[8,70,20,4],[14,70,20,10,2545]],[[4,70,21,2]],[[4,70,23,2],[8,70,23,6,2545],[25,70,23,23,2553],[34,70,23,32],[45,70,23,43,2545],[52,70,23,50]],[[8,70,24,4,2544],[25,70,24,21,2545],[31,70,24,27,2554],[36,70,24,32]],[[4,70,25,2]],[[0,70,26,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,71,0,0]],[],[],[],[],[],[[1,71,6,1]],[],[],[[31,71,7,13,2555],[51,71,7,13,2555]],[],[],[[15,71,7,13,2555]],[],[],[[0,71,7,7],[6,71,7,13,2555],[25,71,8,2],[32,71,8,9,2556],[43,71,8,20],[57,71,10,8,2557],[65,71,10,16],[188,71,11,8,2555],[204,71,11,24],[207,71,13,8,2557],[215,71,13,16],[339,71,14,8,2555],[355,71,14,24]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,72,14,9,2558],[27,72,14,32],[29,72,14,32]],[[15,72,14,9,2558],[40,72,14,9,2558],[63,72,14,32]],[],[[4,72,9,9,2559],[16,72,9,21],[18,72,9,21]],[[15,72,9,9,2559],[30,72,9,9,2559],[42,72,9,21]],[],[[4,72,11,9,2560],[13,72,11,18],[15,72,11,18]],[[15,72,11,9,2560],[26,72,11,9,2560],[35,72,11,18]],[],[[4,72,10,9,2561],[12,72,10,17],[14,72,10,17]],[[15,72,10,9,2561],[25,72,10,9,2561],[33,72,10,17]],[],[[4,72,8,19,2562],[21,72,8,36],[23,72,8,36]],[[15,72,8,19,2562],[25,72,8,19,2562],[42,72,8,36]],[],[[4,72,8,9,2563],[12,72,8,17],[14,72,8,17]],[[15,72,8,9,2563],[25,72,8,9,2563],[33,72,8,17]],[],[[4,72,12,9,2564],[16,72,12,21],[18,72,12,21]],[[15,72,12,9,2564],[29,72,12,9,2564],[41,72,12,21]],[],[[4,72,2,16,2565],[38,72,2,50],[40,72,2,50]],[[15,72,2,16,2565]],[],[[4,72,13,9,2566],[20,72,13,25],[22,72,13,25]],[[15,72,13,9,2566],[32,72,13,9,2566],[48,72,13,25]],[],[],[[41,72,0,40]],[[26,72,8,44]],[[31,72,9,29]],[[26,72,10,25]],[[27,72,11,26]],[[30,72,12,29]],[[33,72,13,33]],[[0,72,2,7],[9,72,2,16,2565]],[[4,72,3,2],[10,72,3,8],[17,72,3,8],[31,72,5,3],[32,72,3,8],[36,72,3,12,2567],[42,72,4,4],[115,72,3,8],[136,72,3,8]],[[15,72,3,8]],[[20,72,3,8]],[[22,72,3,8]],[[4,72,5,2]],[[0,72,6,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,73,74,6,2595],[8,73,74,14,2596],[11,73,74,17],[12,73,74,18,2597],[20,73,74,26]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,73,288,2],[76,73,288,74]],[[4,73,289,2],[56,73,289,54]],[[4,73,290,2,2568],[27,73,290,25],[29,73,290,25]],[[15,73,290,2,2568],[48,73,290,2,2568],[71,73,290,25]],[],[[4,73,298,2,2569],[16,73,298,14],[18,73,298,14]],[[15,73,298,2,2569],[38,73,298,2,2569],[50,73,298,14]],[],[[4,73,122,2,2570],[29,73,122,27],[31,73,122,27]],[[15,73,122,2,2570],[48,73,122,2,2570],[73,73,122,27]],[],[[4,73,294,2,2571],[13,73,294,11],[15,73,294,11]],[[15,73,294,2,2571],[38,73,294,2,2571],[47,73,294,11]],[],[[4,73,293,2,2572],[12,73,293,10],[14,73,293,10]],[[15,73,293,2,2572],[38,73,293,2,2572],[46,73,293,10]],[],[[4,73,297,2,2573],[21,73,297,19],[23,73,297,19]],[[15,73,297,2,2573],[38,73,297,2,2573],[55,73,297,19]],[],[[4,73,296,2,2574],[12,73,296,10],[14,73,296,10]],[[15,73,296,2,2574],[38,73,296,2,2574],[46,73,296,10]],[],[[4,73,295,2,2575],[16,73,295,14],[18,73,295,14]],[[15,73,295,2,2575],[38,73,295,2,2575],[50,73,295,14]],[],[[4,73,284,9,2576],[38,73,284,43],[40,73,284,43]],[[15,73,284,9,2576],[40,73,284,9,2576],[74,73,284,43]],[],[[4,73,299,2,2577],[20,73,299,18],[22,73,299,18]],[[15,73,299,2,2577],[38,73,299,2,2577],[54,73,299,18]],[],[[4,73,172,16,2578],[13,73,172,25],[15,73,172,25]],[[15,73,172,16,2578]],[],[[4,73,102,16,2579],[15,73,102,27],[17,73,102,27]],[[15,73,102,16,2579]],[],[[4,73,145,16,2580],[13,73,145,25],[15,73,145,25]],[[15,73,145,16,2580]],[],[[4,73,55,16,2581],[19,73,55,31],[21,73,55,31]],[[15,73,55,16,2581]],[],[[4,73,259,16,2582],[28,73,259,40],[30,73,259,40]],[[15,73,259,16,2582]],[],[[4,73,214,16,2583],[29,73,214,41],[31,73,214,41]],[[15,73,214,16,2583]],[],[[4,73,123,2,2584],[25,73,123,23],[27,73,123,23]],[[15,73,123,2,2584],[48,73,123,2,2584],[69,73,123,23]],[],[],[],[[65,73,2,48]],[[47,73,7,7]],[[49,73,14,7]],[[25,73,18,7]],[[49,73,124,7]],[[41,73,284,51]],[[39,73,300,7]],[[0,73,20,0],[6,73,20,6,2585],[30,73,21,2],[37,73,21,9,2586],[48,73,21,20],[62,73,23,8,2587],[70,73,23,16],[187,73,24,8,2585],[208,73,24,29],[211,73,25,6,2588]],[[0,73,27,0],[6,73,27,6,2589],[31,73,28,2],[38,73,28,9,2586],[49,73,28,20],[63,73,30,8,2587],[71,73,30,16],[188,73,31,8,2589],[210,73,31,30],[213,73,32,6,2588]],[[0,73,55,7],[9,73,55,16,2581]],[[4,73,56,2,2589],[29,73,56,27]],[[4,73,58,2],[10,73,58,8,2590],[25,73,58,23,2591],[26,73,58,23,2591],[29,73,58,23,2591],[36,73,58,23,2591],[46,73,58,33],[48,73,58,34,2592],[81,73,58,34,2592],[100,73,58,53]],[[4,73,60,2],[66,73,60,64]],[[4,73,61,2],[78,73,61,76]],[[4,73,62,2],[22,73,62,20]],[[4,73,63,2],[10,73,63,8,2593],[33,73,63,31,2594],[34,73,63,31,2594],[37,73,63,31,2594],[44,73,63,31,2594],[51,73,63,38],[53,73,63,39]],[[8,73,64,4],[12,73,64,8],[13,73,64,9,2590],[27,73,64,23]],[[12,73,65,6],[85,73,65,79]],[[12,73,66,6],[25,73,66,19]],[[12,73,67,6],[19,73,67,13]],[[8,73,68,4]],[[8,73,70,4],[15,73,70,11],[19,73,70,15,2568],[52,73,70,15,2568],[75,73,70,38],[76,73,70,39,2590]],[[4,73,71,2],[7,73,71,5]],[[8,73,71,6,2590]],[[5,73,71,19]],[[4,73,73,2],[51,73,73,49]],[[4,73,74,2],[60,73,74,31],[76,73,74,47],[85,73,74,56,2598],[92,73,74,56,2598],[99,73,74,61],[101,73,74,63]],[[8,73,75,4],[14,73,75,10,2599],[35,73,75,31,2600],[36,73,75,31,2600],[39,73,75,31,2600],[46,73,75,31,2600],[49,73,75,34],[51,73,75,35,2601],[84,73,75,35,2601],[109,73,75,60]],[[8,73,76,4],[12,73,76,8,2599],[32,73,76,28]],[[12,73,77,6],[19,73,77,13,2600],[20,73,77,13,2600],[23,73,77,13,2600],[30,73,77,13,2600],[33,73,77,16],[35,73,77,17,2599],[54,73,77,36,2590],[66,73,77,48]],[[8,73,78,4]],[[4,73,79,2]],[[4,73,81,2],[11,73,81,9,2593]],[[0,73,82,0]],[[0,73,102,7],[9,73,102,16,2579]],[[4,73,103,2,2585],[28,73,103,26]],[[4,73,105,2],[82,73,105,80]],[[4,73,106,2],[78,73,106,76]],[[4,73,107,2],[10,73,107,8,2602],[21,73,107,19,2591],[22,73,107,19,2591],[25,73,107,19,2591],[32,73,107,19,2591],[42,73,107,29],[44,73,107,30,2603],[77,73,107,30,2603],[92,73,107,45]],[[4,73,109,2],[51,73,109,49]],[[4,73,110,2],[8,73,110,6,2595],[16,73,110,14,2596],[19,73,110,17],[20,73,110,18,2597],[28,73,110,26],[60,73,110,31],[76,73,110,47],[85,73,110,56,2598],[92,73,110,56,2598],[99,73,110,61],[101,73,110,63]],[[8,73,111,4],[14,73,111,10,2599],[35,73,111,31,2600],[36,73,111,31,2600],[39,73,111,31,2600],[46,73,111,31,2600],[49,73,111,34],[51,73,111,35,2601],[84,73,111,35,2601],[109,73,111,60]],[[8,73,112,4],[12,73,112,8,2599],[32,73,112,28]],[[12,73,113,6],[19,73,113,13,2600],[20,73,113,13,2600],[23,73,113,13,2600],[30,73,113,13,2600],[33,73,113,16],[35,73,113,17,2599],[54,73,113,36,2602],[62,73,113,44]],[[8,73,114,4]],[[4,73,115,2]],[[4,73,117,2],[11,73,117,9,2602]],[[0,73,118,0]],[[0,73,145,7],[9,73,145,16,2580]],[[4,73,146,2],[10,73,146,8,2604],[19,73,146,17,2591],[20,73,146,17,2591],[23,73,146,17,2591],[30,73,146,17,2591],[40,73,146,27],[42,73,146,28,2605],[73,73,146,28,2605],[89,73,146,44]],[[4,73,147,2],[8,73,147,6,2604],[19,73,147,17],[25,73,147,23]],[[8,73,148,4],[14,73,148,10],[21,73,148,10],[35,73,148,66],[36,73,148,10],[40,73,148,14,2606],[46,73,148,20],[94,73,148,10],[115,73,148,10]],[[19,73,148,10]],[[24,73,148,10]],[[26,73,148,10]],[[8,73,148,65]],[[4,73,149,2]],[[4,73,151,2],[11,73,151,9,2604]],[[0,73,152,0]],[[0,73,172,7],[9,73,172,16,2578]],[[4,73,173,2,2585],[28,73,173,26]],[[4,73,175,2],[10,73,175,8,2607],[19,73,175,17,2591],[20,73,175,17,2591],[23,73,175,17,2591],[30,73,175,17,2591],[40,73,175,27],[42,73,175,28,2608],[75,73,175,28,2608],[92,73,175,45]],[[4,73,177,2],[51,73,177,49]],[[4,73,178,2],[8,73,178,6,2595],[16,73,178,14,2596],[19,73,178,17],[20,73,178,18,2597],[28,73,178,26],[60,73,178,31],[76,73,178,47],[85,73,178,56,2598],[92,73,178,56,2598],[99,73,178,61],[101,73,178,63]],[[8,73,179,4],[14,73,179,10,2599],[35,73,179,31,2600],[36,73,179,31,2600],[39,73,179,31,2600],[46,73,179,31,2600],[49,73,179,34],[51,73,179,35,2601],[84,73,179,35,2601],[109,73,179,60]],[[8,73,180,4],[12,73,180,8,2599],[32,73,180,28]],[[12,73,181,6],[19,73,181,13,2600],[20,73,181,13,2600],[23,73,181,13,2600],[30,73,181,13,2600],[33,73,181,16],[35,73,181,17,2599],[54,73,181,36,2607],[60,73,181,42]],[[8,73,182,4]],[[4,73,183,2]],[[4,73,185,2],[11,73,185,9,2607]],[[0,73,186,0]],[[0,73,214,7],[9,73,214,16,2583],[35,73,215,2,2609],[54,73,215,29],[64,73,215,39]],[[4,73,217,2,2585],[28,73,217,26]],[[4,73,219,2],[10,73,219,8,2610],[20,73,219,18,2591],[21,73,219,18,2591],[24,73,219,18,2591],[31,73,219,18,2591],[41,73,219,28],[43,73,219,29,2611],[74,73,219,29,2611],[93,73,219,48]],[[4,73,220,2],[92,73,220,90]],[[4,73,221,2],[8,73,221,6],[9,73,221,7,2610],[18,73,221,16],[25,73,221,23]],[[4,73,223,2],[51,73,223,49]],[[4,73,224,2],[8,73,224,6,2595],[16,73,224,14,2596],[19,73,224,17],[20,73,224,18,2597],[28,73,224,26],[60,73,224,31],[76,73,224,47],[85,73,224,56,2598],[92,73,224,56,2598],[99,73,224,61],[101,73,224,63]],[[8,73,225,4],[14,73,225,10,2599],[35,73,225,31,2600],[36,73,225,31,2600],[39,73,225,31,2600],[46,73,225,31,2600],[49,73,225,34],[51,73,225,35,2601],[84,73,225,35,2601],[109,73,225,60]],[[8,73,226,4],[12,73,226,8,2599],[32,73,226,28]],[[12,73,227,6],[18,73,227,12,2612],[28,73,228,8,2599],[47,73,228,27,2613],[77,73,228,57],[79,73,228,59,2614],[83,73,228,63,2609]],[[12,73,229,6],[16,73,229,10,2612],[25,73,229,19]],[[16,73,230,8],[103,73,230,95]],[[16,73,231,8],[91,73,231,83]],[[16,73,232,8],[23,73,232,15,2600],[24,73,232,15,2600],[27,73,232,15,2600],[34,73,232,15,2600],[37,73,232,18],[39,73,232,19,2612]],[[12,73,233,6]],[[8,73,234,4]],[[4,73,235,2]],[[4,73,237,2],[11,73,237,9,2615],[12,73,237,9,2615],[15,73,237,9,2615],[24,73,237,9,2615],[52,73,237,37],[54,73,237,38,2610],[62,73,237,46,2616],[72,73,237,56],[74,73,237,58,2609]],[[0,73,238,0]],[[0,73,259,7],[9,73,259,16,2582],[34,73,260,2,2609],[53,73,260,29],[63,73,260,39]],[[4,73,262,2,2585],[28,73,262,26]],[[4,73,263,2],[10,73,263,8,2599],[31,73,263,29,2591],[32,73,263,29,2591],[35,73,263,29,2591],[42,73,263,29,2591],[52,73,263,39],[54,73,263,40,2601],[87,73,263,40,2601],[112,73,263,65]],[[4,73,264,2],[10,73,264,8,2617],[35,73,264,33,2583],[61,73,264,59,2609]],[[4,73,266,2],[51,73,266,49]],[[4,73,267,2],[8,73,268,4,2595],[16,73,268,12,2596],[19,73,268,15],[20,73,268,16,2597],[28,73,268,24],[60,73,268,29],[76,73,269,4,2599],[98,73,270,4],[107,73,270,13,2598],[114,73,270,13,2598],[121,73,270,18],[123,73,271,4]],[[8,73,272,4],[14,73,272,10,2612],[24,73,273,6,2599],[43,73,273,25,2618],[72,73,273,54],[74,73,273,56,2614],[78,73,273,60,2609]],[[8,73,274,4],[12,73,274,8,2612],[21,73,274,17]],[[12,73,275,6],[99,73,275,93]],[[12,73,276,6],[87,73,276,81]],[[12,73,277,6],[19,73,277,13,2600],[20,73,277,13,2600],[23,73,277,13,2600],[30,73,277,13,2600],[33,73,277,16],[35,73,277,17,2612]],[[8,73,278,4]],[[4,73,279,2]],[[4,73,281,2],[11,73,281,9,2619],[12,73,281,9,2619],[15,73,281,9,2619],[24,73,281,9,2619],[52,73,281,37],[54,73,281,38,2617],[78,73,281,62,2609]],[[0,73,282,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,74,80,16,2620],[20,74,80,32],[22,74,80,32]],[[15,74,80,16,2620]],[],[[4,74,37,13,2621],[25,74,37,34],[27,74,37,34]],[[15,74,37,13,2621]],[],[],[],[],[[65,74,1,33]],[[28,74,3,26]],[[26,74,4,66]],[[31,74,5,46]],[[0,74,12,0],[9,74,12,9,2622],[24,74,12,24],[26,74,13,2,2623],[34,74,13,10],[36,74,14,2,2624],[41,74,14,7],[43,74,15,2,2625],[55,74,15,14],[57,74,20,1]],[[4,74,21,2],[10,74,21,8,2626],[19,74,21,17,2627],[20,74,21,17,2627],[23,74,21,17,2627],[35,74,21,17,2627],[44,74,21,26]],[[4,74,23,2,2628],[5,74,23,2,2628],[8,74,23,2,2628],[15,74,23,2,2628],[24,74,23,11],[26,74,23,12]],[[8,74,24,4,2629],[15,74,24,4,2629],[22,74,24,9],[23,74,24,10,2630],[38,74,24,25],[39,74,24,26]],[[12,74,25,6],[16,74,25,10,2625],[33,74,25,27,2631],[48,74,25,27,2631],[60,74,25,39],[61,74,25,40,2632],[65,74,25,44],[67,74,25,46]],[[16,74,26,8,2626],[23,74,26,15,2632],[27,74,26,19],[28,74,26,20,2623],[38,74,26,30],[39,74,26,31]],[[12,74,27,6],[19,74,27,13]],[[16,74,28,8,2626],[23,74,28,15,2633],[30,74,28,22],[31,74,28,23,2623],[41,74,28,33],[42,74,28,34]],[[12,74,29,6]],[[12,74,30,6,2624]],[[8,74,31,4]],[[4,74,32,2],[7,74,32,5]],[[8,74,32,6,2623]],[[8,74,32,16,2625]],[[8,74,32,30,2624]],[[8,74,32,37,2626]],[[5,74,32,44]],[[4,74,34,2],[11,74,34,9]],[[0,74,35,0]],[[0,74,37,7],[6,74,37,13,2621],[36,74,37,43,2629],[43,74,37,43,2629],[50,74,37,48],[51,74,37,49,2634],[60,74,37,58]],[[4,74,41,2,2635],[16,74,41,14,2636],[21,74,41,42],[22,74,41,44]],[[8,74,42,4],[13,74,42,9],[14,74,42,10,2636]],[[8,74,43,4],[12,74,43,8],[13,74,43,9,2637],[18,74,43,14],[21,74,43,17]],[[12,74,43,19,2623],[22,74,43,29]],[[12,74,43,35,2625],[26,74,43,49]],[[8,74,43,54]],[[4,74,44,2]],[[4,74,46,2],[11,74,46,9,2638],[36,74,46,34,2639],[41,74,46,44],[43,74,46,46]],[[8,74,47,4],[12,74,47,8,2640],[13,74,47,8,2640],[16,74,47,8,2640],[31,74,47,8,2640],[46,74,47,23],[48,74,47,24,2639],[56,74,47,32]],[[12,74,48,6],[18,74,48,12,2641],[24,74,48,18,2642],[25,74,48,18,2642],[28,74,48,18,2642],[38,74,48,18,2642],[61,74,48,41],[63,74,48,42,2639]],[[12,74,49,6],[18,74,49,12,2625],[33,74,49,27,2643],[34,74,49,27,2643],[37,74,49,27,2643],[47,74,49,27,2643],[71,74,49,51],[73,74,49,52,2639]],[[12,74,50,6],[16,74,50,10],[29,74,50,23,2639],[36,74,50,30]],[[16,74,51,8],[89,74,51,81]],[[16,74,52,8],[96,74,52,88]],[[16,74,53,8],[31,74,53,23]],[[16,74,54,8],[23,74,54,15]],[[20,74,54,17,2623],[30,74,54,27]],[[20,74,54,33,2625],[34,74,54,47]],[[16,74,54,52]],[[12,74,55,6]],[[12,74,57,6],[19,74,57,13]],[[16,74,57,15,2623],[26,74,57,25,2641]],[[16,74,57,30,2625]],[[12,74,57,43]],[[8,74,58,4]],[[8,74,59,4],[48,74,59,44]],[[8,74,60,4],[14,74,60,10,2639]],[[4,74,61,2]],[[4,74,63,2],[141,74,63,139]],[[4,74,64,2,2644],[13,74,64,28]],[[8,74,65,4],[14,74,65,10],[16,74,65,12,2623],[24,74,65,20],[26,74,65,22,2625],[38,74,65,34],[40,74,65,36],[43,74,65,39],[47,74,65,43],[48,74,65,44,2637],[53,74,65,49]],[[8,74,66,4],[12,74,66,8,2623],[25,74,66,21],[33,74,66,29,2625],[50,74,66,46],[56,74,66,52]],[[12,74,67,6],[19,74,67,6],[30,74,67,6],[33,74,68,8],[34,74,68,8],[37,74,68,8],[49,74,68,8],[52,74,68,8],[54,74,68,9,2622],[70,74,68,9,2622]],[[16,74,69,10,2623],[26,74,69,20,2623]],[[16,74,70,10,2625],[30,74,70,24,2625]],[[16,74,71,10,2624],[23,74,71,17],[27,74,71,23],[31,74,71,27],[32,74,71,28,2645],[40,74,71,36],[41,74,71,37]],[[24,74,71,39,2623],[34,74,71,49]],[[20,74,71,54]],[],[[8,74,74,4]],[[8,74,76,4],[15,74,76,11],[19,74,76,15],[20,74,76,16,2636],[25,74,76,21],[26,74,76,22,2646],[34,74,76,30]],[[4,74,77,2]],[[0,74,78,0]],[[0,74,80,7],[9,74,80,16,2620],[26,74,80,33],[28,74,80,35,2646],[36,74,80,43],[38,74,80,76]],[[4,74,81,2],[10,74,81,8,2626],[19,74,81,17,2627],[20,74,81,17,2627],[23,74,81,17,2627],[35,74,81,17,2627],[44,74,81,26]],[[4,74,82,2],[11,74,82,2],[22,74,82,2],[25,74,83,4],[26,74,83,4],[29,74,83,4],[41,74,83,4],[44,74,83,4],[46,74,83,5,2621],[69,74,83,5,2621]],[[8,74,83,27,2626],[16,74,83,35,2626]],[[18,74,83,44,2646]],[],[[0,74,85,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,75,7,16,2647],[50,75,7,16,2647]],[],[],[[15,75,7,16,2647]],[],[],[[25,75,4,36]],[[38,75,5,37]],[[0,75,7,7],[9,75,7,16,2647],[25,75,8,2,2648],[30,75,8,18],[32,75,9,2,2649],[46,75,9,38]],[[4,75,11,2],[11,75,11,9,2650],[31,75,11,29,2648],[38,75,11,36,2649],[54,75,11,52],[58,75,11,56]],[[0,75,12,0]],[[0,75,14,0],[9,75,14,9,2650],[29,75,15,2,2648],[34,75,15,18],[36,75,16,2,2649],[50,75,16,38],[52,75,17,2,2651],[61,75,17,19],[63,75,18,2,2652],[91,75,18,38]],[[4,75,20,2],[10,75,20,8,2653],[23,75,20,21,2654],[30,75,20,28,2655],[34,75,20,32],[35,75,20,33,2649],[51,75,20,49,2656],[57,75,20,55],[62,75,20,60]],[[4,75,21,2],[8,75,21,6,2653],[20,75,21,18]],[[8,75,22,4],[82,75,22,78]],[[8,75,23,4],[15,75,23,11]],[[12,75,23,12,2648]],[[12,75,23,19,2651]],[[12,75,23,30,2652]],[[9,75,23,59]],[[4,75,24,2]],[[4,75,26,2],[59,75,26,57]],[[4,75,27,2],[83,75,27,81]],[[4,75,28,2],[10,75,28,8,2657],[31,75,28,29,2654],[38,75,28,36,2655],[42,75,28,40],[43,75,28,41,2649],[59,75,28,57,2658],[65,75,28,63],[66,75,29,4],[67,75,29,5,2659],[73,75,29,13,2659],[81,75,29,21]],[[4,75,32,2],[70,75,32,68]],[[4,75,33,2],[8,75,33,6],[22,75,33,20,2649],[38,75,33,36]],[[8,75,34,4,2657],[27,75,34,23,2660],[34,75,34,30],[35,75,34,31]],[[4,75,35,2]],[[4,75,37,2],[9,75,37,7],[15,75,37,13,2659],[22,75,37,20,2657],[41,75,37,40]],[[8,75,38,4],[14,75,38,10],[15,75,38,11,2661],[24,75,38,20,2662],[44,75,38,40],[47,75,38,43,2649],[61,75,38,57],[62,75,38,58,2659],[66,75,38,62]],[[8,75,39,4],[72,75,39,68]],[[8,75,40,4],[43,75,40,39]],[[8,75,41,4],[12,75,41,8,2661],[24,75,41,20,2663],[33,75,41,20,2663],[52,75,41,39],[54,75,41,41]],[[12,75,42,6]],[[8,75,43,4]],[[8,75,44,4],[14,75,44,10,2664],[32,75,44,28,2648],[38,75,44,34,2649],[52,75,44,48],[53,75,44,49,2665],[56,75,44,52],[57,75,44,53,2659]],[[8,75,45,4],[12,75,45,8],[13,75,45,9,2664],[30,75,45,26]],[[12,75,46,6]],[[8,75,47,4]],[[8,75,49,4],[14,75,49,10,2666],[25,75,49,21,2667],[26,75,49,21,2667],[29,75,49,21,2667],[51,75,49,21,2667],[71,75,49,41],[73,75,49,42,2661]],[[8,75,50,4],[14,75,50,10,2668],[44,75,50,40,2667],[45,75,50,40,2667],[48,75,50,40,2667],[70,75,50,40,2667],[90,75,50,60],[92,75,50,61,2661],[101,75,50,70]],[[8,75,52,4],[14,75,52,10,2669],[26,75,52,22,2664],[42,75,52,38,2665],[45,75,52,41],[46,75,52,42,2666]],[[8,75,53,4],[12,75,53,8],[13,75,53,9,2669],[24,75,53,20]],[[12,75,54,6]],[[8,75,55,4]],[[8,75,57,4],[14,75,57,10,2670],[21,75,57,17,2650],[41,75,58,6,2669],[52,75,59,6,2662],[73,75,60,6,2651],[85,75,60,18],[91,75,60,24,2666],[101,75,61,6,2651],[113,75,61,18],[119,75,61,24,2668]],[[8,75,64,4],[12,75,64,8,2670],[18,75,64,14]],[[12,75,65,6],[19,75,65,13,2670]],[[8,75,66,4]],[[4,75,67,2]],[[4,75,69,2],[11,75,69,9]],[[0,75,70,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,76,0,0]],[],[[1,76,2,1]],[],[],[[31,76,3,13,2671],[53,76,3,13,2671]],[],[],[[15,76,3,13,2671]],[],[],[[0,76,3,7],[6,76,3,13,2671],[27,76,3,34]],[[4,76,4,2,2672],[10,76,4,8],[15,76,4,15]],[[0,76,5,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,77,21,13,2673],[27,77,21,36],[29,77,21,36]],[[15,77,21,13,2673]],[],[[4,77,76,0],[11,77,76,38],[13,77,76,38]],[[15,77,76,0]],[],[],[],[[23,77,2,53]],[[0,77,12,0],[9,77,12,9,2674],[30,77,12,30,2675],[34,77,12,47]],[[4,77,13,2],[10,77,13,8,2676],[19,77,13,41],[20,77,13,42]],[[4,77,14,2],[8,77,14,7],[12,77,14,11,2677],[16,77,14,15],[19,77,14,18,2677],[23,77,14,22,2675],[28,77,14,27,2678],[38,77,14,37],[39,77,14,38,2679],[45,77,14,44],[47,77,14,46,2677],[51,77,14,51]],[[8,77,15,4],[14,77,15,10,2680],[21,77,15,17,2675],[26,77,15,22,2678],[36,77,15,32],[37,77,15,33,2677],[39,77,15,35]],[[8,77,16,4,2676],[14,77,16,10],[15,77,16,11,2680],[20,77,16,16,2681],[24,77,16,20],[25,77,16,21],[28,77,16,24,2680],[33,77,16,29,2682],[38,77,16,34]],[[4,77,17,2]],[[4,77,18,2],[11,77,18,9,2676]],[[0,77,19,0]],[[0,77,21,7],[6,77,21,13,2673],[38,77,21,45,2683],[45,77,21,45,2683],[54,77,21,54]],[[4,77,29,2,2684],[16,77,29,14,2685],[21,77,29,39],[22,77,29,41]],[[8,77,30,4],[13,77,30,9],[14,77,30,10,2685]],[[8,77,31,4],[12,77,31,8],[13,77,31,9,2686],[18,77,31,14],[21,77,31,17]],[[12,77,31,19,2687],[22,77,31,29]],[[8,77,31,35]],[[8,77,32,4],[12,77,32,8],[13,77,32,9,2688],[21,77,32,17],[24,77,32,20]],[[8,77,33,4],[12,77,33,8],[13,77,33,9,2689],[27,77,33,23],[30,77,33,26],[31,77,33,27]],[[8,77,34,4],[12,77,34,8],[13,77,34,9,2690],[20,77,34,16],[23,77,34,16],[34,77,34,16],[37,77,34,19,2691],[38,77,34,19,2691],[41,77,34,19,2691],[48,77,34,19,2691],[57,77,34,28]],[[4,77,35,2]],[[4,77,37,2],[11,77,37,9,2692],[36,77,37,34,2693],[37,77,37,44],[39,77,37,66]],[[8,77,38,4],[15,77,38,11]],[[12,77,38,13,2687],[22,77,38,23]],[[8,77,38,28]],[[4,77,39,2]],[[4,77,41,2,2694],[24,77,41,22]],[[8,77,42,4],[14,77,42,10,2695],[25,77,42,21],[29,77,42,25],[30,77,42,26,2690],[37,77,42,33],[38,77,42,34,2696],[45,77,42,41]],[[8,77,43,4],[12,77,43,8],[16,77,43,12],[17,77,43,13,2686],[22,77,43,18],[23,77,43,19,2687],[31,77,43,27],[35,77,43,31,2695],[45,77,43,41]],[[12,77,44,6],[69,77,44,63]],[[12,77,45,6,2697],[19,77,45,13,2698],[26,77,45,20],[27,77,45,21],[31,77,45,25],[32,77,45,26,2689],[46,77,45,40],[48,77,45,42,2699],[55,77,45,49],[56,77,45,50],[57,77,45,51],[58,77,45,52,2700],[63,77,45,57,2682],[69,77,45,63]],[[16,77,46,8,2695],[25,77,46,17,2701],[37,77,46,29],[38,77,46,30,2700],[43,77,46,35,2682]],[[12,77,47,6]],[[8,77,48,4]],[[4,77,49,2]],[[4,77,51,2,2702],[13,77,51,11]],[[8,77,52,4],[14,77,52,10],[16,77,52,12,2687],[24,77,52,20],[26,77,52,22],[29,77,52,25],[33,77,52,29],[34,77,52,30,2686],[39,77,52,35]],[[8,77,53,4],[58,77,53,54]],[[8,77,54,4],[12,77,54,8],[19,77,54,15,2703],[30,77,54,26],[45,77,54,41],[46,77,54,42],[50,77,54,46],[51,77,54,47,2688],[59,77,54,55],[61,77,54,57]],[[12,77,55,6],[16,77,55,10],[17,77,55,11,2688],[25,77,55,19],[28,77,55,22,2704],[37,77,55,31,2705],[52,77,55,46],[53,77,55,47,2706],[62,77,55,56]],[[12,77,56,6],[16,77,56,10],[17,77,56,11,2689],[31,77,56,25],[34,77,56,28,2674],[55,77,56,49,2704],[64,77,56,58,2705],[79,77,56,73]],[[8,77,57,4]],[[8,77,59,4],[12,77,59,8,2687],[22,77,59,18]],[[12,77,60,6],[64,77,60,58]],[[12,77,61,6],[19,77,61,6],[30,77,61,6],[33,77,62,8],[34,77,62,8],[37,77,62,8],[49,77,62,8],[52,77,62,8],[54,77,62,9,2707],[62,77,62,9,2707]],[[16,77,63,10,2708],[21,77,63,15],[25,77,63,19],[26,77,63,20,2690],[33,77,63,27]],[[16,77,64,10,2709],[40,77,64,34],[42,77,64,34]],[[16,77,65,10,2710],[41,77,65,35]],[[20,77,66,12,2711],[28,77,66,20],[32,77,66,24],[33,77,66,25,2688],[41,77,66,33]],[[16,77,67,10]],[],[[8,77,70,4]],[[8,77,72,4],[15,77,72,11],[19,77,72,15],[20,77,72,16,2685],[25,77,72,21],[26,77,72,22,2712],[34,77,72,30]],[[4,77,73,2]],[[0,77,74,0]],[[6,77,76,0],[17,77,76,15,2673]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,78,10,0],[42,78,10,0]],[],[],[[15,78,10,24,2713]],[],[],[],[],[[64,78,2,32]],[[82,78,3,36]],[[31,78,4,55]],[[23,78,5,22]],[[0,78,7,0],[6,78,7,6,2714],[23,78,8,2],[30,78,8,9,2715],[41,78,8,20],[56,78,8,35,2716],[57,78,8,35,2716],[60,78,8,35,2716],[67,78,8,35,2716],[72,78,8,40],[74,78,8,41,2715],[81,78,8,48,2717],[90,78,8,57],[91,78,8,58,2718],[100,78,8,67]],[[0,78,10,15],[9,78,10,24,2713],[27,78,10,42],[29,78,11,2,2719],[37,78,11,10],[39,78,12,2,2720],[53,78,12,16],[55,78,13,2,2721],[66,78,13,13],[68,78,14,2,2722],[80,78,14,14],[82,78,15,53]],[[4,78,16,2],[8,78,16,6,2714],[24,78,16,22]],[[8,78,17,4],[90,78,17,86]],[[8,78,18,4],[54,78,18,50]],[[8,78,19,4],[15,78,19,4],[26,78,19,4],[29,78,19,11],[30,78,19,11],[33,78,19,11],[45,78,19,11],[48,78,19,11],[50,78,19,12,2723],[75,78,19,12,2723],[82,78,19,35],[84,78,19,35]],[[22,78,19,37,2719]],[],[[4,78,20,2]],[[4,78,22,2],[11,78,22,2],[22,78,22,2],[25,78,23,4],[26,78,23,4],[29,78,23,4],[41,78,23,4],[44,78,23,4],[46,78,23,5,2724],[61,78,23,5,2724],[74,78,23,18],[76,78,23,18]],[[8,78,24,6,2720],[24,78,24,22,2720]],[[8,78,25,6,2721],[21,78,25,19,2721]],[[8,78,26,6,2722],[22,78,26,20,2722]],[[18,78,28,7,2719]],[],[[0,78,31,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,79,33,6,2731],[8,79,33,14,2732],[11,79,33,17],[12,79,33,18,2733],[20,79,33,26],[25,79,33,31],[39,79,33,45]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,79,139,16,2725],[40,79,139,52],[42,79,139,52]],[[15,79,139,16,2725]],[],[[4,79,83,16,2726],[32,79,83,44],[34,79,83,44]],[[15,79,83,16,2726]],[],[],[[49,79,7,7]],[[25,79,11,7]],[[0,79,21,0],[6,79,21,6,2727],[35,79,21,35],[39,79,21,39,2728]],[[0,79,26,0]],[],[],[[1,79,29,1],[4,79,30,0],[13,79,30,9,2729],[41,79,31,2,2730],[45,79,31,25]],[[4,79,33,2]],[],[[4,79,37,2],[61,79,37,59]],[[4,79,38,2],[10,79,38,8,2734],[19,79,38,17,2727],[46,79,38,44,2735],[49,79,38,47],[50,79,38,48,2730]],[[4,79,39,2],[8,79,39,6,2734],[16,79,39,14]],[[8,79,40,4],[15,79,40,11,2734]],[[4,79,41,2]],[[4,79,43,2],[41,79,43,39]],[[4,79,44,2],[10,79,44,8,2736],[28,79,44,26],[32,79,44,30,2737]],[[4,79,45,2],[10,79,45,8,2738],[29,79,45,27],[33,79,45,31,2737]],[[4,79,47,2],[10,79,47,8,2739],[27,79,47,25,2730],[31,79,47,29],[32,79,47,30],[34,79,47,32]],[[4,79,48,2],[9,79,48,7],[15,79,48,13,2740],[35,79,48,33,2741],[42,79,48,40,2742],[46,79,48,44],[47,79,48,45,2739],[63,79,48,62]],[[8,79,49,4],[14,79,49,10,2743],[25,79,49,21,2744],[26,79,49,21,2744],[29,79,49,21,2744],[38,79,49,21,2744],[66,79,49,49],[68,79,49,50,2730],[74,79,49,56,2740]],[[8,79,51,4],[60,79,51,56]],[[8,79,52,4],[14,79,52,10,2745],[24,79,52,20,2746],[25,79,52,20,2746],[28,79,52,20,2746],[37,79,52,20,2746],[65,79,52,48],[67,79,52,49,2743],[77,79,52,59,2740]],[[8,79,54,4,2736],[24,79,54,20,2747],[27,79,54,23],[28,79,55,6,2740],[46,79,56,6,2748],[47,79,56,6,2748],[50,79,56,6,2748],[83,79,56,6,2748],[116,79,56,39],[118,79,56,40],[146,79,56,68,2745]],[[8,79,58,4,2738],[25,79,58,21,2747],[28,79,58,24],[29,79,59,6,2740],[47,79,60,6,2748],[48,79,60,6,2748],[51,79,60,6,2748],[84,79,60,6,2748],[117,79,60,39],[119,79,60,40],[148,79,60,69,2743]],[[4,79,62,2]],[[4,79,64,2],[10,79,64,8,2749],[19,79,64,45]],[[8,79,65,4,2750],[39,79,65,35,2736]],[[8,79,66,4,2751],[40,79,66,36,2738]],[[4,79,67,2]],[[4,79,69,2],[42,79,69,40]],[[4,79,70,2,2727],[31,79,70,29,2747],[34,79,70,32],[35,79,70,33,2730],[41,79,70,39,2749]],[[4,79,72,2],[11,79,72,9,2749]],[[0,79,73,0]],[[0,79,75,0],[6,79,75,6,2752],[36,79,75,36],[40,79,75,40,2728]],[[0,79,83,7],[9,79,83,16,2726],[38,79,84,2,2730],[42,79,84,25],[44,79,85,2,2753],[52,79,85,18],[54,79,86,2,2754],[66,79,86,31],[68,79,87,2,2755],[78,79,87,20]],[[4,79,89,2],[8,79,89,6,2731],[16,79,89,14,2732],[19,79,89,17],[20,79,89,18,2733],[28,79,89,26],[33,79,89,31],[47,79,89,45]],[],[[4,79,93,2],[47,79,93,45]],[[4,79,94,2],[10,79,94,8,2756],[31,79,94,29,2754],[44,79,94,42,2757],[52,79,94,50]],[[4,79,95,2],[10,79,95,8,2758],[29,79,95,27,2759],[34,79,95,32,2760],[43,79,95,41],[44,79,95,42,2755]],[[4,79,96,2],[10,79,96,8,2761],[21,79,96,19],[24,79,96,22,2753],[33,79,96,31],[34,79,96,32],[36,79,96,34,2756],[55,79,96,53],[56,79,96,54],[58,79,96,56,2758],[76,79,96,74]],[[4,79,98,2],[44,79,98,42]],[[4,79,99,2],[8,79,99,6,2762],[20,79,99,18,2752],[48,79,99,46,2735],[51,79,99,49],[52,79,99,50,2730]],[[4,79,100,2],[8,79,100,6],[9,79,100,7,2762],[20,79,100,18]],[[8,79,101,4,2762],[20,79,101,16],[24,79,101,20,2737]],[[8,79,102,4,2752],[36,79,102,32,2747],[39,79,102,35],[40,79,102,36,2730],[46,79,102,42,2762]],[[4,79,103,2]],[[4,79,105,2],[60,79,105,58]],[[4,79,106,2],[10,79,106,8,2734],[19,79,106,17,2762],[29,79,106,27,2735],[32,79,106,30],[33,79,106,31,2761]],[[4,79,107,2],[8,79,107,6,2734],[16,79,107,14]],[[8,79,108,4],[15,79,108,11,2734]],[[4,79,109,2]],[[4,79,111,2],[10,79,111,8,2763],[33,79,111,31],[37,79,111,35,2764],[70,79,111,35,2764],[93,79,111,58],[94,79,111,59,2754]],[[4,79,113,2],[10,79,113,8,2765],[34,79,113,32,2729],[62,79,113,60,2730]],[[4,79,115,2],[10,79,115,8,2766],[21,79,115,39]],[[8,79,116,4,2753],[18,79,116,14,2748],[19,79,116,14,2748],[22,79,116,14,2748],[55,79,116,14,2748],[88,79,116,47],[90,79,116,48],[105,79,116,63,2753]],[[8,79,117,4,2754],[22,79,117,18,2748],[23,79,117,18,2748],[26,79,117,18,2748],[59,79,117,18,2748],[92,79,117,51],[94,79,118,6],[113,79,119,6,2763]],[[8,79,121,4,2767],[16,79,121,12,2748],[17,79,121,12,2748],[20,79,121,12,2748],[53,79,121,12,2748],[86,79,121,45],[88,79,121,46],[101,79,121,59,2755]],[[8,79,122,4],[11,79,122,7,2765],[32,79,122,28]],[[4,79,123,2]],[[4,79,125,2,2762],[14,79,125,12,2747],[17,79,125,15],[18,79,125,16,2761],[28,79,125,26,2766]],[[4,79,127,2],[11,79,127,9,2766]],[[0,79,128,0]],[[0,79,130,0],[6,79,130,6,2768],[34,79,130,34],[38,79,130,38,2728]],[[0,79,139,7],[9,79,139,16,2725],[46,79,140,2,2730],[50,79,140,25],[52,79,141,2,2769],[69,79,141,46]],[[4,79,143,2],[8,79,143,6,2731],[16,79,143,14,2732],[19,79,143,17],[20,79,143,18,2733],[28,79,143,26],[33,79,143,31],[47,79,143,45]],[],[[4,79,147,2],[10,79,147,8,2739],[27,79,147,25,2730],[31,79,147,29],[32,79,147,30],[34,79,147,32]],[[4,79,148,2],[10,79,148,8,2770],[30,79,148,28,2741],[37,79,148,35,2742],[41,79,148,39],[42,79,148,40,2739]],[[4,79,150,2],[70,79,150,68]],[[4,79,151,2],[8,79,151,6,2770],[26,79,151,24,2771],[32,79,151,30],[37,79,151,35],[40,79,151,38]],[[8,79,152,4],[15,79,152,11]],[[4,79,153,2]],[[4,79,155,2],[44,79,155,42]],[[4,79,156,2],[8,79,156,6,2762],[20,79,156,18,2768],[46,79,156,44,2735],[49,79,156,47],[50,79,156,48,2730]],[[4,79,157,2],[8,79,157,6],[9,79,157,7,2762],[20,79,157,18]],[[8,79,158,4,2762],[20,79,158,16],[24,79,158,20,2737]],[[8,79,159,4,2768],[34,79,159,30,2747],[37,79,159,33],[38,79,159,34,2730],[44,79,159,40,2762]],[[4,79,160,2]],[[4,79,162,2],[67,79,162,65]],[[4,79,163,2],[10,79,163,8,2734],[19,79,163,17,2762],[29,79,163,27,2735],[32,79,163,30],[33,79,163,31,2769]],[[4,79,164,2],[8,79,164,6,2734],[16,79,164,14]],[[8,79,165,4],[15,79,165,11,2734]],[[4,79,166,2]],[[4,79,168,2],[29,79,168,27]],[[4,79,169,2],[10,79,169,8,2765],[34,79,169,32,2729],[62,79,169,60,2730]],[[4,79,170,2],[10,79,170,8,2766],[21,79,170,39]],[[8,79,171,4],[11,79,171,7,2769],[28,79,171,24]],[[8,79,172,4],[11,79,172,7,2765],[32,79,172,28]],[[4,79,173,2]],[[4,79,175,2,2762],[14,79,175,12,2747],[17,79,175,15],[18,79,175,16,2769],[37,79,175,35,2766]],[[4,79,177,2],[11,79,177,9,2766]],[[0,79,178,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,80,58,6,2784],[8,80,58,14,2785],[11,80,58,17],[12,80,58,18,2786],[20,80,58,26]],[[0,80,0,0]],[],[],[],[],[[31,80,152,16,2772],[61,80,152,16,2772]],[],[],[[15,80,152,16,2772]],[],[],[],[],[[65,80,13,34]],[[37,80,14,37]],[[36,80,20,7]],[[26,80,21,25]],[[47,80,22,35]],[[0,80,44,0],[6,80,44,6,2773],[46,80,44,46,2774],[53,80,44,46,2774],[60,80,44,51],[61,80,44,52,2775],[70,80,44,61]],[[4,80,48,2,2776],[16,80,48,14,2777],[21,80,48,57],[22,80,48,59]],[[8,80,49,4],[13,80,49,9],[14,80,49,10,2777]],[[8,80,50,4],[12,80,50,8],[13,80,50,9,2778],[18,80,50,14],[21,80,50,17]],[[12,80,51,6,2779],[29,80,51,23,2780]],[[12,80,52,6,2781],[30,80,52,24,2777],[36,80,52,30,2782],[44,80,52,38]],[[8,80,53,4]],[[4,80,54,2]],[[4,80,56,2,2783],[24,80,56,28]],[[8,80,57,4],[64,80,58,31],[81,80,59,6],[85,80,59,10],[86,80,59,11,2777],[91,80,59,16],[92,80,59,17,2787],[104,80,59,29],[108,80,60,6],[112,80,60,10],[113,80,60,11,2777],[118,80,60,16],[119,80,60,17,2787],[131,80,60,29],[132,80,60,30,2788],[136,80,60,34],[139,80,60,37],[144,80,61,6],[220,80,61,82]],[[8,80,62,6],[9,80,62,7],[13,80,62,11],[14,80,62,12,2777],[19,80,62,17],[20,80,62,18,2787],[32,80,62,30],[33,80,62,31,2789],[36,80,62,34],[37,80,62,35],[50,80,63,6]],[[12,80,64,6],[16,80,64,10,2790],[33,80,65,8],[157,80,66,8]],[[12,80,68,6],[18,80,68,12,2791],[35,80,68,29,2792],[41,80,68,35,2793],[45,80,68,39],[46,80,68,40],[50,80,68,44],[51,80,68,45,2777],[56,80,68,50],[57,80,68,51,2787],[69,80,68,63],[71,80,69,9,2794],[75,80,69,13],[76,80,69,14],[77,80,69,15,2795],[80,80,69,18,2796],[84,80,69,24,2795],[86,80,69,26,2797],[99,80,69,39],[100,80,69,40,2796],[104,80,70,9,2798],[107,80,70,12],[108,80,70,13],[109,80,70,14,2799],[116,80,70,23],[117,80,70,24],[118,80,70,25],[120,80,70,27,2799],[126,80,70,33],[128,80,71,9,2800],[132,80,71,13],[133,80,71,14]],[[12,80,73,6,2790],[30,80,73,24],[50,80,73,44,2791]],[[12,80,75,6,2801],[13,80,75,6,2801],[16,80,75,6,2801],[26,80,75,6,2801],[34,80,75,14],[36,80,75,15,2790]],[[8,80,76,4]],[[4,80,77,2]],[[4,80,79,2],[11,80,79,9,2802],[36,80,79,34,2803],[41,80,79,44],[43,80,79,46]],[[8,80,80,4],[12,80,80,8,2804],[13,80,80,8,2804],[16,80,80,8,2804],[36,80,80,8,2804],[61,80,80,33],[63,80,80,34,2803],[71,80,80,42]],[[12,80,81,6],[18,80,81,12,2805],[31,80,81,25,2806],[32,80,81,25,2806],[35,80,81,25,2806],[55,80,81,25,2806],[82,80,81,52],[84,80,81,53,2803]],[[12,80,82,6],[19,80,82,13]],[[16,80,83,8,2779],[33,80,83,25,2805]],[[12,80,84,6]],[[8,80,85,4]],[[8,80,86,4],[43,80,86,39]],[[8,80,87,4],[14,80,87,10,2803]],[[4,80,88,2]],[[4,80,90,2],[11,80,90,9,2807],[36,80,91,4,2777],[41,80,91,47],[43,80,92,4,2778],[48,80,92,34],[50,80,93,36]],[[8,80,94,4]],[],[],[],[],[[5,80,99,5],[8,80,100,4],[12,80,100,8,2777],[18,80,100,14,2782],[26,80,100,22],[31,80,100,27,2778],[37,80,100,33,2781],[53,80,100,49],[57,80,100,53,2778],[63,80,100,59,2779],[78,80,100,74],[80,80,100,76]],[[12,80,101,6],[19,80,101,13]],[[16,80,102,8,2779],[33,80,102,25,2780]],[[16,80,103,8,2781],[34,80,103,26,2777],[40,80,103,32,2782],[48,80,103,40]],[[12,80,104,6]],[[8,80,105,4]],[[8,80,106,4],[15,80,106,11]],[[12,80,107,6,2779],[29,80,107,23,2778],[35,80,107,29,2779],[50,80,107,44]],[[12,80,108,6,2781],[30,80,108,24,2777],[36,80,108,30,2782],[44,80,108,38]],[[8,80,109,4]],[[4,80,110,2]],[[4,80,112,2,2808],[13,80,112,11]],[[8,80,113,4],[14,80,113,10],[16,80,113,12,2809],[24,80,113,20],[26,80,113,22,2810],[35,80,113,31],[37,80,113,33,2811],[49,80,113,45],[51,80,113,47,2812],[59,80,113,55],[61,80,113,57],[64,80,113,60],[68,80,113,64],[69,80,113,65,2777],[74,80,113,70]],[[8,80,114,4],[14,80,114,10],[16,80,114,12,2779],[31,80,114,27],[33,80,114,29],[36,80,114,32],[40,80,114,36],[41,80,114,37,2778],[46,80,114,42]],[[8,80,115,4],[14,80,115,10,2813],[32,80,115,28]],[[12,80,116,6],[13,80,116,7,2814],[33,80,116,7,2814],[54,80,116,28],[55,80,116,29,2815],[64,80,116,38],[65,80,116,39],[67,80,116,41,2809]],[[12,80,117,6],[13,80,117,7,2814],[33,80,117,7,2814],[54,80,117,28],[55,80,117,29,2816],[64,80,117,38],[65,80,117,39],[67,80,117,41,2810]],[[12,80,118,6],[13,80,118,7,2814],[33,80,118,7,2814],[54,80,118,28],[55,80,118,29,2817],[67,80,118,41],[68,80,118,42],[70,80,118,44,2811]],[[8,80,119,4]],[[8,80,121,4],[12,80,121,8,2779],[29,80,121,25]],[[12,80,122,6],[18,80,122,12,2818],[31,80,123,8,2779],[51,80,123,28,2814],[71,80,123,28,2814],[92,80,123,49],[93,80,123,50,2815],[102,80,123,59],[106,80,123,63,2809]],[[12,80,124,6],[18,80,124,12,2819],[32,80,125,8,2779],[52,80,125,28,2814],[72,80,125,28,2814],[93,80,125,49],[94,80,125,50,2816],[103,80,125,59],[107,80,125,63,2810]],[[12,80,126,6],[18,80,126,12,2820],[35,80,127,8,2779],[55,80,127,28,2814],[75,80,127,28,2814],[96,80,127,49],[97,80,127,50,2817],[109,80,127,62],[113,80,127,66,2811]],[[12,80,129,6],[110,80,129,104]],[[12,80,130,6],[16,80,130,10],[17,80,130,12,2818],[18,80,130,12,2818],[32,80,130,26,2819],[47,80,130,41,2820],[61,80,130,54],[64,80,130,58]],[[16,80,131,8],[23,80,131,15,2812]],[[12,80,132,6]],[[12,80,134,6],[19,80,134,6],[30,80,134,6],[33,80,135,8],[34,80,135,8],[37,80,135,8],[49,80,135,8],[53,80,135,8],[55,80,135,8],[67,80,135,8],[75,80,135,8],[77,80,135,8]],[],[[34,80,136,10],[35,80,136,10],[38,80,136,10],[50,80,136,10],[53,80,136,10],[55,80,136,11,2821],[63,80,136,11,2821]],[[24,80,136,16,2822],[30,80,136,21]],[[24,80,136,30,2823],[33,80,136,38]],[],[[20,80,137,11,2784],[28,80,137,19,2785],[31,80,137,22],[32,80,137,23,2786],[40,80,137,31],[72,80,137,36],[89,80,137,36],[100,80,137,36],[103,80,138,12],[104,80,138,12],[107,80,138,12],[119,80,138,12],[122,80,138,12],[124,80,138,13,2821],[132,80,138,13,2821]],[[24,80,139,14,2822],[30,80,139,19]],[[24,80,140,14,2823],[33,80,140,23,2824],[34,80,140,23,2824],[37,80,140,23,2824],[57,80,140,23,2824],[91,80,140,57],[93,80,140,58,2779]],[],[[20,80,143,11,2813],[35,80,143,26],[36,80,143,27,2779],[52,80,143,43]],[],[],[[8,80,146,4]],[[8,80,148,4],[15,80,148,11,2812]],[[4,80,149,2]],[[0,80,150,0]],[[0,80,152,7],[9,80,152,16,2772],[36,80,152,43],[38,80,153,2,2809],[46,80,153,10],[48,80,154,2,2810],[57,80,154,11],[59,80,155,2,2811],[71,80,155,14],[73,80,156,2,2812],[81,80,156,10],[83,80,157,34]],[[4,80,158,2],[81,80,158,79]],[[4,80,159,2],[73,80,159,71]],[[4,80,160,2],[76,80,160,74]],[[4,80,161,2],[71,80,161,69]],[[4,80,162,2],[10,80,162,8,2782],[21,80,162,19,2825],[22,80,162,19,2825],[25,80,162,19,2825],[46,80,162,19,2825],[66,80,162,39]],[[4,80,163,2],[10,80,163,8,2787],[25,80,163,23,2826],[26,80,163,23,2826],[29,80,163,23,2826],[36,80,163,23,2826],[46,80,163,33],[48,80,163,34,2827],[79,80,163,34,2827],[97,80,163,52]],[[4,80,164,2],[10,80,164,8,2828],[29,80,164,27],[30,80,164,28],[31,80,164,30,2809],[32,80,164,30,2809],[44,80,164,42,2810],[57,80,164,55,2811],[69,80,164,66]],[[4,80,166,2],[8,80,166,6,2828],[26,80,166,24]],[[8,80,167,4],[15,80,167,4],[26,80,167,4],[29,80,168,6],[30,80,168,6],[33,80,168,6],[45,80,168,6],[48,80,168,6],[50,80,168,7,2773],[83,80,168,7,2773]],[[12,80,169,8,2782],[22,80,169,18,2782]],[[12,80,170,8,2809],[22,80,170,18,2809]],[[12,80,171,8,2810],[23,80,171,19,2810]],[[12,80,172,8,2811],[26,80,172,22,2811]],[[12,80,173,8,2787],[26,80,173,22,2787]],[[22,80,175,9,2812]],[],[[4,80,178,2]],[[4,80,180,2],[11,80,180,2],[22,80,180,2],[25,80,180,9],[26,80,180,9],[29,80,180,9],[41,80,180,9],[44,80,180,9],[46,80,180,9],[58,80,180,9],[66,80,180,9],[68,80,180,9]],[[18,80,180,12,2812]],[],[[0,80,181,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,81,15,16,2829],[37,81,15,49],[39,81,15,49]],[[15,81,15,16,2829]],[],[[4,81,6,16,2830],[22,81,6,34],[24,81,6,34]],[[15,81,6,16,2830]],[],[],[],[],[[64,81,2,18]],[[31,81,3,43]],[[0,81,6,7],[9,81,6,16,2830]],[[4,81,7,2],[10,81,7,8],[17,81,7,8],[31,81,7,68],[32,81,7,8],[36,81,7,12,2831],[42,81,7,18],[94,81,7,8],[115,81,7,8]],[[15,81,7,8]],[[20,81,7,8]],[[22,81,7,8]],[[4,81,7,67]],[[0,81,8,0]],[[0,81,10,0],[9,81,10,9,2832]],[[4,81,11,2,2830]],[[4,81,12,2],[11,81,12,9]],[[0,81,13,0]],[[0,81,15,7],[9,81,15,16,2829],[43,81,15,50],[45,81,16,2,2833],[53,81,16,10],[55,81,19,1]],[[4,81,20,2],[11,81,20,2],[22,81,20,2],[25,81,21,4],[26,81,21,4],[29,81,21,4],[41,81,21,4],[44,81,21,4],[46,81,21,5,2834],[61,81,21,5,2834],[87,81,21,31],[89,81,21,31]],[[8,81,21,32,2835],[18,81,21,32,2835],[29,81,21,32,2835],[32,81,21,42],[33,81,21,42],[36,81,21,42],[48,81,21,42],[51,81,21,42],[53,81,21,43,2832],[86,81,21,43,2832],[87,81,21,43,2832]],[[18,81,22,7,2833]],[],[[0,81,25,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,82,2,13,2836],[29,82,2,38],[31,82,2,38]],[[15,82,2,13,2836]],[],[[4,82,10,13,2837],[40,82,10,49],[42,82,10,49]],[[15,82,10,13,2837]],[],[[4,82,13,16,2838],[27,82,13,39],[29,82,13,39]],[[15,82,13,16,2838]],[],[],[[0,82,2,7],[6,82,2,13,2836],[34,82,3,2],[80,82,4,2],[211,82,5,2],[344,82,6,2],[455,82,7,2],[581,82,8,2]],[[0,82,10,7],[6,82,10,13,2837],[45,82,11,2]],[[0,82,13,7],[9,82,13,16,2838],[33,82,14,2,2839],[40,82,14,58],[42,82,15,2,2840],[45,82,15,14]],[[4,82,17,2,2841],[12,82,17,10,2842],[16,82,17,14],[17,82,18,4],[45,82,19,6,2843],[50,82,19,11,2844],[59,82,19,20],[60,82,19,21,2839],[71,82,20,6],[78,82,21,7],[79,82,21,8,2840],[94,82,21,23,2845],[103,82,21,32,2840],[108,82,21,37,2846],[117,82,21,47],[119,82,21,48]],[[0,82,23,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,83,13,16,2847],[47,83,13,16,2847]],[],[],[[15,83,13,16,2847]],[],[],[[39,83,0,38]],[[0,83,2,0],[9,83,2,9,2848],[27,83,2,27,2849],[38,83,2,46]],[[4,83,3,2],[8,83,3,6,2850],[19,83,3,17,2851],[26,83,3,24,2852],[34,83,3,32],[35,83,3,33,2850],[43,83,3,41]],[[4,83,5,2],[8,83,5,6]],[[8,83,6,4],[31,83,6,27]],[[8,83,7,4,2850],[19,83,7,15],[23,83,7,19,2853],[27,83,7,23,2849],[40,83,7,36,2850],[48,83,7,44]],[[4,83,8,2],[6,83,8,4],[13,83,8,10],[14,83,8,11]],[[4,83,10,2],[11,83,10,9,2850],[24,83,10,22],[34,83,10,32],[42,83,10,40]],[[0,83,11,0]],[[0,83,13,7],[9,83,13,16,2847],[22,83,13,29,2849],[33,83,13,60]],[[4,83,14,2],[10,83,14,8,2854],[19,83,14,17,2855],[20,83,14,17,2855],[23,83,14,17,2855],[46,83,14,17,2855],[67,83,14,38],[69,83,14,39,2849]],[[4,83,15,2],[10,83,15,8,2850],[21,83,15,19,2848],[39,83,15,37,2849],[54,83,15,52]],[[4,83,17,2],[8,83,17,6,2853],[12,83,17,10,2856],[20,83,17,18],[21,83,17,19,2854],[30,83,17,28]],[[8,83,18,4],[71,83,18,67]],[[8,83,19,4],[45,83,19,41]],[[8,83,20,4],[15,83,20,11,2854],[22,83,20,18,2857],[29,83,20,25],[30,83,20,26],[39,83,20,35]],[[4,83,21,2]],[[4,83,23,2],[10,83,23,8],[12,83,23,10,2858],[20,83,23,18],[22,83,23,20,2859],[26,83,23,24],[28,83,23,26],[31,83,23,29,2851],[38,83,23,36,2852],[46,83,23,44]],[[4,83,24,2],[11,83,24,9],[14,83,24,12,2850],[23,83,24,21],[25,83,24,23],[27,83,24,25,2858],[38,83,24,36,2859],[45,83,24,43],[46,83,24,44],[47,83,24,45],[49,83,24,47,2859],[55,83,24,53],[58,83,24,56],[63,83,24,61,2854],[71,83,24,69]],[[0,83,25,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,84,150,7,2918],[8,84,150,15,2919],[11,84,150,18],[12,84,150,19,2920],[21,84,150,28],[23,84,150,30]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,84,147,16,2860],[33,84,147,45],[35,84,147,45]],[[15,84,147,16,2860]],[],[[4,84,23,16,2861],[19,84,23,31],[21,84,23,31]],[[15,84,23,16,2861]],[],[[4,84,187,16,2862],[20,84,187,32],[22,84,187,32]],[[15,84,187,16,2862]],[],[],[[23,84,0,38]],[[47,84,1,42]],[[30,84,2,29]],[[34,84,7,7]],[[24,84,8,40]],[[32,84,13,7]],[[29,84,14,25]],[[32,84,15,31]],[[27,84,16,45]],[[0,84,18,0],[4,84,18,4,2863],[20,84,18,20]],[[0,84,19,0],[4,84,19,4,2864],[16,84,19,16]],[[0,84,20,0],[4,84,20,4,2865],[22,84,20,37]],[[0,84,21,0],[4,84,21,4,2866],[32,84,21,47]],[[0,84,23,7],[9,84,23,16,2861],[25,84,24,2,2867],[36,84,24,21],[38,84,25,2,2868],[58,84,25,44]],[[4,84,27,2],[8,84,27,6],[9,84,27,7,2869],[14,84,27,12,2870],[22,84,27,20],[24,84,27,22]],[[8,84,28,4],[14,84,28,10],[21,84,28,10],[35,84,30,5],[36,84,28,10],[40,84,28,14,2871],[56,84,28,14,2871],[70,84,28,28],[71,84,29,6],[72,84,29,7],[143,84,29,78],[144,84,29,79],[147,84,28,10],[168,84,28,10]],[[19,84,28,10]],[[24,84,28,10]],[[26,84,28,10]],[[8,84,30,4]],[[4,84,31,2]],[[4,84,33,2],[8,84,33,6,2872]],[[4,84,34,2],[8,84,34,6,2873]],[[4,84,36,2],[10,84,36,8,2874],[24,84,36,22],[25,84,36,23,2875]],[[8,84,37,4],[12,84,37,8,2872],[25,84,37,21,2872],[35,84,37,31,2876],[45,84,37,41],[50,84,37,46,2872],[60,84,37,56,2877],[64,84,37,60],[66,84,37,62]],[[12,84,38,6,2872],[22,84,38,16,2878],[26,84,38,20],[27,84,38,21,2875]],[[8,84,39,4]],[[4,84,40,2]],[[4,84,42,2],[10,84,42,8,2879],[36,84,42,34,2860],[66,84,42,64,2874]],[[4,84,44,2],[13,84,44,11,2880]],[[8,84,45,4],[12,84,45,8,2872],[23,84,45,19]],[[12,84,46,6,2872],[22,84,46,16,2881],[27,84,46,21]],[[8,84,47,4]],[[8,84,49,4],[14,84,49,10,2882],[29,84,49,25],[33,84,49,29,2883],[40,84,49,36,2884],[49,84,49,45],[50,84,50,6],[53,84,50,9,2885],[54,84,50,9,2885],[57,84,50,9,2885],[71,84,50,9,2885],[83,84,50,21],[85,84,50,22,2867],[98,84,50,35],[120,84,50,57],[122,84,50,59,2869],[127,84,50,64,2870],[135,84,50,72],[137,84,50,74]],[[8,84,53,4,2882],[21,84,53,17,2886],[31,84,53,27],[34,84,53,30]],[[8,84,55,4],[17,84,55,13,2887]],[[12,84,56,6,2888],[25,84,56,6,2888],[33,84,56,14],[34,84,56,15,2889],[47,84,56,28],[48,84,56,29,2882]],[[12,84,58,6,2863],[28,84,58,22]],[[12,84,59,6,2883],[19,84,59,13,2890],[26,84,59,20],[27,84,59,21,2891],[30,84,59,24],[31,84,59,25]],[[8,84,60,4]],[[8,84,62,4],[17,84,62,13,2892],[31,84,62,27,2893],[36,84,62,46]],[[12,84,63,6],[79,84,63,73]],[[12,84,64,6],[16,84,64,10,2864],[27,84,64,21]],[[16,84,65,8]],[[12,84,66,6]],[[12,84,68,6],[16,84,68,10]],[[16,84,69,8],[22,84,69,14,2894],[32,84,70,10,2893],[38,84,70,16,2875],[42,84,70,20],[54,84,70,32,2895],[68,84,71,14,2896],[87,84,71,33,2893],[93,84,71,39,2875],[97,84,71,43],[101,84,72,14,2897],[106,84,72,19,2898],[111,84,72,24],[112,84,72,25,2893],[118,84,72,31,2875],[122,84,72,35]],[[16,84,74,8],[61,84,74,53]],[[16,84,75,8],[20,84,75,12,2894],[28,84,75,20,2899],[32,84,75,24],[37,84,75,29,2900],[55,84,75,29,2900],[82,84,75,56],[83,84,75,57,2901],[102,84,75,76],[104,84,75,78]],[[20,84,76,10],[24,84,77,12,2865],[44,84,77,32],[52,84,78,12,2865],[72,84,78,32,2894],[80,84,78,40,2875],[84,84,78,44],[85,84,78,45,2902],[94,84,78,54],[96,84,79,12]],[[24,84,80,12],[95,84,80,83]],[[24,84,81,12],[98,84,81,86]],[[24,84,82,12,2883],[31,84,82,19,2903],[39,84,82,27],[40,84,82,28,2904],[46,84,82,34]],[[24,84,83,12,2864],[36,84,83,24]],[[24,84,84,12]],[[20,84,85,10]],[[20,84,86,10,2865],[38,84,86,28,2894],[46,84,86,36,2875],[50,84,86,40],[51,84,86,41,2902],[60,84,86,50]],[[16,84,87,8]],[[16,84,89,8],[78,84,89,70]],[[16,84,90,8],[20,84,91,10,2894],[28,84,91,18,2899],[32,84,91,22],[37,84,91,27,2900],[55,84,91,27,2900],[82,84,91,54],[83,84,91,55,2905],[87,84,91,59],[91,84,92,10],[101,84,92,20,2894],[110,84,93,10]],[[20,84,94,10],[107,84,94,97]],[[20,84,95,10],[24,84,96,12,2866],[54,84,96,42],[62,84,97,12,2866],[92,84,97,42,2894],[100,84,97,50,2906],[104,84,97,54],[106,84,98,12]],[[24,84,99,12,2883],[31,84,99,19,2903],[39,84,99,27],[40,84,99,28,2904],[46,84,99,34]],[[24,84,100,12,2864],[36,84,100,24]],[[24,84,101,12]],[[20,84,102,10]],[[20,84,103,10,2866],[48,84,103,38,2894],[56,84,103,46,2906],[60,84,103,50]],[[16,84,104,8]],[[16,84,106,8,2907],[17,84,106,8,2907],[20,84,106,8,2907],[36,84,106,8,2907],[50,84,106,22],[52,84,107,10,2894],[61,84,108,10,2874],[74,84,109,10,2879],[99,84,110,10,2868]],[[12,84,112,6],[14,84,112,8],[21,84,112,15,2908],[26,84,112,29]],[[16,84,113,8,2909],[17,84,113,8,2909],[20,84,113,8,2909],[28,84,113,8,2909],[51,84,113,31],[53,84,113,32,2893],[60,84,113,39,2908]],[[12,84,114,6]],[[8,84,115,4]],[[8,84,117,4],[17,84,117,13,2910]],[[12,84,118,6,2882],[25,84,118,19,2911],[32,84,118,26],[35,84,118,29]],[[12,84,119,6,2882],[25,84,119,19,2912],[32,84,119,26],[35,84,119,29]],[[12,84,120,6,2882],[25,84,120,19,2881],[30,84,120,24]],[[12,84,121,6,2863]],[[12,84,123,6],[117,84,123,111]],[[12,84,124,6],[16,84,124,10,2863],[32,84,124,26,2913],[43,84,124,26,2913],[71,84,124,54],[73,84,124,56]],[[16,84,125,8,2864],[28,84,125,20]],[[16,84,126,8,2883],[23,84,126,15,2903],[31,84,126,23],[32,84,126,24,2904],[38,84,126,30]],[[16,84,127,8]],[[12,84,128,6]],[[12,84,130,6,2914],[25,84,130,19,2873]],[[12,84,131,6],[40,84,131,34]],[[12,84,132,6,2873],[20,84,132,14,2915],[31,84,132,25,2880],[37,84,132,31,2863],[53,84,132,47],[57,84,132,51],[64,84,132,58]],[[8,84,133,4]],[[8,84,135,4,2882],[21,84,135,17,2916],[27,84,135,23],[30,84,135,26,2887]],[[8,84,136,4,2882],[21,84,136,17,2911],[28,84,136,24],[31,84,136,27,2910]],[[8,84,137,4,2882],[21,84,137,17,2912],[28,84,137,24],[31,84,137,27,2910]],[[8,84,138,4,2882],[21,84,138,17,2917],[30,84,138,26],[33,84,138,29,2892]],[[8,84,140,4,2872],[20,84,140,16,2882]],[[8,84,141,4],[15,84,141,11,2882]],[[4,84,142,2]],[[4,84,144,2],[11,84,144,9,2880]],[[0,84,145,0]],[[0,84,147,7],[9,84,147,16,2860],[39,84,148,2,2874],[50,84,148,37]],[[4,84,150,2],[8,84,150,6]],[],[[4,84,154,2],[8,84,154,6,2921],[16,84,154,47],[18,84,154,49]],[[4,84,155,2],[8,84,155,6,2922]],[[4,84,157,2],[10,84,157,8,2879],[36,84,157,34],[37,84,157,35,2923]],[[8,84,158,4],[12,84,158,8,2922],[22,84,158,18]],[[12,84,159,6,2922],[21,84,159,15,2923]],[[8,84,160,4],[15,84,160,11]],[[12,84,161,6,2921],[18,84,161,12,2924],[22,84,161,16],[23,84,161,17,2923]],[[8,84,162,4]],[[4,84,163,2]],[[4,84,165,2],[10,84,165,8],[11,84,166,4],[107,84,166,100],[120,84,168,4,2925],[124,84,168,8],[125,84,168,9],[126,84,168,10],[128,84,168,12,2926],[135,84,168,19],[137,84,168,21]],[[8,84,169,4,2926],[16,84,169,12]],[[12,84,170,6,2927],[32,84,170,25,2928],[34,84,170,73]],[[16,84,171,8,2922],[27,84,171,19,2928]],[[16,84,173,8],[97,84,173,89]],[[16,84,174,8],[21,84,174,13],[27,84,174,19,2923],[34,84,174,26,2921],[40,84,174,33]],[[20,84,175,10,2928],[23,84,175,13,2923]],[[16,84,176,8]],[[16,84,177,8,2921],[22,84,177,14,2929],[28,84,177,20],[31,84,177,23]],[[12,84,178,6]],[[12,84,179,6,2874]],[[12,84,180,6,2930],[27,84,180,21],[28,84,180,22,2908],[34,84,180,39,2931],[35,84,180,39,2931],[38,84,180,39,2931],[54,84,180,39,2931],[71,84,180,56],[73,84,180,57,2908],[78,84,180,62,2874]],[[8,84,181,4]],[[4,84,182,2]],[[4,84,184,2],[11,84,184,9,2879]],[[0,84,185,0]],[[0,84,187,7],[9,84,187,16,2862],[26,84,187,33,2872],[35,84,187,65]],[[4,84,188,2],[10,84,188,8],[12,84,188,10,2932],[16,84,188,14],[18,84,188,16],[21,84,188,19,2933],[22,84,188,19,2933],[25,84,188,19,2933],[32,84,188,19,2933],[42,84,188,29],[44,84,188,30,2934],[75,84,188,30,2934],[100,84,188,55]],[[4,84,190,2,2935],[5,84,190,2,2935],[8,84,190,2,2935],[15,84,190,2,2935],[24,84,190,11],[26,84,190,12]],[[8,84,191,4],[12,84,191,8],[13,84,191,9,2872],[24,84,191,20]],[[12,84,192,6],[18,84,192,12],[25,84,192,12],[39,84,192,79],[40,84,192,12],[44,84,192,16,2871],[60,84,192,16,2871],[74,84,192,30],[75,84,192,31],[125,84,192,12],[146,84,192,12]],[[23,84,192,12]],[[28,84,192,12]],[[30,84,192,12]],[[12,84,192,78]],[[8,84,193,4]],[[8,84,195,4],[66,84,195,62]],[[8,84,196,4],[103,84,196,99]],[[8,84,197,4],[12,84,197,8,2918],[20,84,197,16,2919],[23,84,197,19],[24,84,197,20,2920],[33,84,197,29],[48,84,197,31]],[[12,84,198,6]],[[8,84,199,4]],[],[],[[8,84,201,4],[49,84,201,45]],[[8,84,202,4],[14,84,202,10,2936],[25,84,202,21,2937],[37,84,202,33]],[[4,84,214,2],[7,84,214,5]],[[8,84,214,6,2932]],[[8,84,214,12,2872]],[[5,84,214,22]],[[0,84,215,0]],[[0,84,217,0],[6,84,217,6,2941],[20,84,217,20],[24,84,217,24,2942]],[[0,84,219,0],[9,84,219,9,2896],[28,84,219,28,2875],[32,84,219,45]],[[4,84,220,2,2943],[21,84,220,19,2875],[27,84,220,25]],[[4,84,221,2],[10,84,221,8,2944],[17,84,221,15],[21,84,221,19,2945],[30,84,221,28,2875]],[[4,84,222,2],[10,84,222,8,2946],[24,84,222,22,2944],[29,84,222,27,2947],[37,84,222,35],[38,84,222,36]],[[4,84,224,2],[11,84,224,10,2946]],[[8,84,225,4],[13,84,225,9,2900],[31,84,225,9,2900],[58,84,225,36],[59,84,225,37,2948],[84,84,225,62]],[[12,84,225,64]],[[16,84,226,6],[22,84,226,12,2949],[41,84,226,31],[45,84,226,35,2950],[56,84,226,46,2875],[62,84,226,52]],[[16,84,228,6],[23,84,228,13]],[[20,84,229,8,2899],[26,84,229,14,2900],[44,84,229,14,2900],[71,84,229,41],[72,84,229,42,2948],[97,84,229,67]],[[20,84,230,8,2949]],[[16,84,231,6]],[[12,84,232,4]],[[8,84,233,4],[13,84,233,9,2900],[31,84,233,9,2900],[58,84,233,36],[59,84,233,37,2951],[76,84,233,54]],[[12,84,233,56]],[[16,84,234,6,2943],[33,84,234,23,2875],[39,84,234,29]],[[16,84,235,6],[22,84,235,12,2952],[40,84,235,30,2944],[45,84,235,35,2947],[53,84,235,43],[54,84,235,44]],[[16,84,236,6,2943],[33,84,236,23,2875],[39,84,236,29],[43,84,236,33,2952]],[[16,84,238,6],[22,84,238,12,2953],[34,84,238,24,2941],[46,84,238,36,2954],[52,84,238,42],[53,84,239,8],[57,84,239,12,2950],[68,84,239,23,2875],[74,84,239,29],[77,84,239,32,2952]],[[16,84,242,6],[22,84,242,12,2955],[30,84,243,8,2875],[35,84,243,13,2956],[45,84,243,23],[48,84,243,26],[52,84,243,30,2952],[70,84,244,12],[74,84,244,16,2950],[85,84,244,27,2875],[91,84,244,33],[95,84,244,37,2952],[114,84,245,12]],[[16,84,247,6],[23,84,247,13]],[[20,84,248,8,2899],[26,84,248,14,2900],[44,84,248,14,2900],[71,84,248,41],[72,84,248,42,2951],[89,84,248,59]],[[20,84,249,8,2953]],[[20,84,250,8,2955]],[[16,84,251,6]],[[12,84,252,4]],[[8,84,253,4]],[[12,84,253,13]],[[16,84,254,6],[22,84,254,12],[29,84,254,12],[43,84,256,7],[44,84,254,12],[48,84,254,16,2871],[64,84,254,16,2871],[78,84,254,30],[79,84,255,8],[80,84,255,9],[115,84,255,44],[117,84,255,46,2946],[130,84,255,59],[133,84,254,12],[154,84,254,12]],[[27,84,254,12]],[[32,84,254,12]],[[34,84,254,12]],[[16,84,256,6]],[[12,84,257,4]],[[4,84,258,2]],[[0,84,259,0]],[[0,84,261,0],[9,84,261,9,2943],[26,84,261,26,2875],[30,84,261,43],[32,84,261,45,2957],[46,84,261,67]],[[4,84,262,2],[8,84,262,6,2875],[13,84,262,11,2956],[23,84,262,21],[26,84,262,24,2957],[42,84,262,40]],[[8,84,263,4],[14,84,263,10],[21,84,263,10],[35,84,265,5],[36,84,263,10],[40,84,263,14,2871],[56,84,263,14,2871],[70,84,263,28],[71,84,264,6],[72,84,264,7],[128,84,264,63],[130,84,264,65,2957],[145,84,264,80],[157,84,264,92],[159,84,264,94,2875],[164,84,264,99,2956],[174,84,264,109],[175,84,264,110],[176,84,264,111],[177,84,264,112],[180,84,263,10],[201,84,263,10]],[[19,84,263,10]],[[24,84,263,10]],[[26,84,263,10]],[[8,84,265,4]],[[4,84,266,2]],[[0,84,267,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,85,6,0]],[],[],[],[],[],[],[],[],[],[[1,85,16,1],[4,85,17,0],[15,85,17,0]],[],[],[[15,85,17,24,2958]],[],[],[[0,85,17,15],[9,85,17,24,2958],[26,85,18,2,2959],[37,85,18,40],[39,85,19,2,2960],[53,85,19,48],[55,85,20,2,2961],[72,85,20,27],[74,85,21,2,2962],[89,85,21,25],[91,85,22,2,2963],[103,85,22,23],[107,85,22,27]],[[4,85,24,2],[10,85,24,8,2964],[22,85,24,20,2962],[40,85,24,38,2961]],[[4,85,25,2,2965],[12,85,25,10,2966],[15,85,25,13],[16,85,25,14],[17,85,25,15],[40,85,25,38],[42,85,25,40,2964],[52,85,25,50],[54,85,25,52],[55,85,25,53]],[[4,85,26,2],[8,85,26,6],[9,85,26,7,2963],[20,85,26,18]],[[8,85,27,4]],[[4,85,28,2]],[[4,85,29,2,2959],[16,85,30,4,2967],[21,85,30,9,2968],[30,85,30,18],[31,85,30,19]],[[8,85,31,6,2969],[15,85,31,13]],[[8,85,32,6,2970],[12,85,32,10,2971],[19,85,32,17,2972],[36,85,32,34]],[[8,85,33,6,2973],[19,85,33,17,2961]],[[8,85,34,6,2974],[17,85,34,15,2962]],[[8,85,35,6,2975],[14,85,35,12,2971],[21,85,35,19,2976],[29,85,35,27],[30,85,35,28,2977],[38,85,35,36]],[[8,85,36,6,2960]],[[8,85,37,6],[76,85,37,74]],[[8,85,38,6],[62,85,38,60]],[[8,85,39,6,2978],[22,85,39,20,2979],[31,85,39,29,2980],[46,85,39,44],[51,85,39,49]],[[4,85,40,4]],[[4,85,42,2],[8,85,42,6,2981],[13,85,42,11,2982],[34,85,42,32],[36,85,42,34]],[[8,85,43,4,2981],[13,85,43,9,2982],[34,85,43,30],[35,85,43,31,2964]],[[4,85,44,2]],[[0,85,45,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,86,20,13,2983],[47,86,20,13,2983]],[],[],[[15,86,20,13,2983]],[],[],[[0,86,9,0],[79,86,9,79]],[[0,86,10,0],[55,86,10,55]],[[0,86,11,0],[6,86,11,6,2984],[37,86,11,37]],[[0,86,20,7],[6,86,20,13,2983]],[[5,86,21,2],[6,86,21,2],[19,86,21,17],[20,86,21,30]],[[5,86,22,2],[6,86,22,2],[22,86,22,20],[23,86,22,40]],[[5,86,23,2],[6,86,23,2],[27,86,23,25],[28,86,23,45]],[[5,86,24,2],[6,86,24,2],[29,86,24,27],[30,86,24,70]],[[5,86,25,2],[6,86,25,2],[21,86,25,19],[22,86,25,28]],[[4,86,27,2,2985],[17,86,27,16]],[[8,86,28,4],[12,86,28,8],[14,86,28,9],[15,86,28,9],[28,86,28,24],[31,86,28,27],[35,86,28,31,2986]],[[8,86,29,4],[12,86,29,8],[14,86,29,9],[15,86,29,9],[30,86,29,26],[33,86,29,29]],[[4,86,30,2]],[[4,86,32,2],[80,86,32,78]],[[4,86,33,2],[81,86,33,79]],[[4,86,34,2],[72,86,34,70]],[[4,86,35,2],[29,86,35,27]],[[4,86,36,2],[6,86,36,4]],[[4,86,37,2],[81,86,37,79]],[[4,86,38,2],[81,86,38,79]],[[4,86,39,2],[28,86,39,26]],[[5,86,40,2],[6,86,40,2],[30,86,40,28]],[[8,86,41,4],[12,86,41,8],[16,86,41,12],[18,86,41,13],[19,86,41,13],[42,86,41,38],[46,86,41,42],[52,86,41,48]],[[12,86,42,6,2987],[20,86,42,14,2988],[23,86,42,17],[24,86,42,18]],[[12,86,43,6],[16,86,43,10],[18,86,43,11],[19,86,43,11],[34,86,43,28],[37,86,43,31]],[[12,86,44,6],[16,86,44,10],[18,86,44,11],[19,86,44,11],[46,86,44,40]],[[8,86,45,4]],[[4,86,46,2]],[[5,86,48,2],[6,86,48,2],[33,86,48,31]],[[8,86,49,4,2989],[21,86,49,17],[25,86,49,21],[27,86,49,22],[28,86,49,22],[51,86,49,47]],[[8,86,50,4],[12,86,50,8],[14,86,50,9],[15,86,50,9],[38,86,50,34],[41,86,50,37,2990]],[[4,86,51,2]],[[4,86,53,2,2991],[17,86,53,15]],[[8,86,54,4],[12,86,54,8],[14,86,54,9],[15,86,54,9],[36,86,54,32],[39,86,54,35,2990]],[[8,86,55,4],[12,86,55,8],[14,86,55,9],[15,86,55,9],[42,86,55,38]],[[8,86,56,4],[12,86,56,8],[14,86,56,9],[15,86,56,9],[31,86,56,27],[34,86,56,30,2992],[39,86,56,35,2993],[42,86,56,38]],[[8,86,58,4],[51,86,58,47]],[[8,86,59,4],[12,86,59,8],[14,86,59,9],[15,86,59,9],[38,86,59,34],[41,86,59,37,2994],[52,86,60,6],[56,86,60,12],[60,86,60,16],[62,86,60,17],[63,86,60,17],[87,86,60,43],[91,86,61,6],[91,86,62,6,2995],[96,86,62,11,2996],[141,86,62,56],[144,86,63,10],[148,86,64,10,2984],[165,86,61,80]],[[4,86,66,2]],[[4,86,68,2],[44,86,68,42],[48,86,69,2],[49,86,69,2],[56,86,69,11]],[[8,86,70,4],[12,86,70,8],[14,86,70,9],[15,86,70,9],[39,86,70,35]],[[8,86,71,4],[12,86,71,8],[14,86,71,9],[15,86,71,9],[36,86,71,32],[39,86,71,35,2992],[44,86,71,40,2993],[47,86,71,43]],[[4,86,72,2]],[[4,86,74,2,2997],[23,86,74,21,2998],[26,86,74,42],[28,86,74,44]],[[8,86,75,4],[12,86,75,8],[14,86,75,9],[15,86,75,9],[22,86,75,18]],[[8,86,76,4],[14,86,76,10,2999],[31,86,76,27,3000],[66,86,76,62,2998],[70,86,76,66,3001],[74,86,76,70]],[[8,86,77,4],[13,86,77,9],[19,86,77,15,3002],[30,86,77,25,2999],[45,86,77,41]],[[12,86,78,6],[16,86,78,10],[18,86,78,11],[19,86,78,11],[32,86,78,26],[33,86,78,27,3003],[36,86,78,30],[37,86,78,31,3002]],[[8,86,79,4]],[[4,86,80,2]],[[4,86,82,2,3004],[31,86,82,29]],[[8,86,83,4],[12,86,83,8],[14,86,83,9],[15,86,83,9],[22,86,83,18]],[[4,86,84,2]],[[4,86,86,2,3005],[19,86,86,17]],[[8,86,87,4],[12,86,87,8],[14,86,87,9],[15,86,87,9],[22,86,87,18]],[[4,86,88,2]],[[4,86,90,2,3006],[22,86,90,20]],[[8,86,91,4],[12,86,91,8],[14,86,91,9],[15,86,91,9],[22,86,91,18]],[[4,86,92,2]],[[4,86,94,2]],[],[],[],[[3,86,98,3],[6,86,99,2,3007],[16,86,99,30]],[[8,86,100,4],[62,86,100,58]],[[8,86,101,4],[74,86,101,70]],[[8,86,102,4],[10,86,102,6]],[[8,86,103,4],[79,86,103,75]],[[8,86,104,4],[70,86,104,66]],[[8,86,105,4],[14,86,105,10,3008],[27,86,106,6],[31,86,106,10],[33,86,106,11],[34,86,106,11],[55,86,106,34],[59,86,106,38],[67,86,106,46],[71,86,106,50],[73,86,106,51],[74,86,106,51],[90,86,106,69],[94,86,106,73]],[[8,86,107,4],[12,86,107,8],[13,86,107,9,3008],[27,86,107,23],[28,86,107,24],[32,86,107,28],[34,86,107,29],[35,86,107,29],[50,86,107,46],[52,86,107,48]],[[12,86,108,6],[43,86,108,37]],[[12,86,109,6],[16,86,109,10],[18,86,109,11],[19,86,109,11],[46,86,109,40]],[[12,86,110,6],[19,86,110,13]],[[8,86,111,4]],[[8,86,112,4],[12,86,112,8],[14,86,112,9],[15,86,112,9],[39,86,112,35]],[[8,86,114,4],[14,86,114,10,3009],[23,86,114,19]],[[12,86,115,6,3008]],[[12,86,116,6,2999],[28,86,116,22],[32,86,116,26],[34,86,116,27],[35,86,116,27],[48,86,116,42]],[[12,86,117,6,3010],[31,86,117,25],[35,86,117,29],[37,86,117,30],[38,86,117,30],[54,86,117,48]],[[12,86,118,6,3011],[29,86,118,23],[33,86,118,27],[35,86,118,28],[36,86,118,28],[57,86,118,51],[61,86,118,55,2992],[66,86,118,60,2993],[69,86,118,63]],[[8,86,119,4]],[[8,86,120,4],[12,86,120,8],[14,86,120,9],[15,86,120,9],[28,86,120,24],[31,86,120,27],[35,86,120,31,2986]],[[8,86,121,4],[12,86,121,8],[14,86,121,9],[15,86,121,9],[30,86,121,26],[33,86,121,29]],[[8,86,122,4],[15,86,122,11,3009]],[[4,86,123,2]],[[0,86,124,0]],[[0,86,126,0],[9,86,126,9,3000],[44,86,127,2,3001],[48,86,127,43]],[[4,86,129,2],[10,86,129,8,2999],[27,86,129,38],[31,86,129,42,2986]],[[4,86,131,2],[10,86,131,8,3012],[20,86,131,18,3013],[26,86,131,24,3014],[33,86,131,31],[34,86,131,32,3001],[42,86,131,40,3001],[49,86,131,47]],[[8,86,131,48,3001]],[[5,86,131,53]],[[4,86,132,2],[9,86,132,7],[15,86,132,13,3015],[25,86,132,23,3012],[33,86,132,32]],[[8,86,133,4],[94,86,133,90]],[[8,86,134,4],[12,86,135,6,3015],[19,86,135,13,3016],[23,86,135,17],[28,86,135,22],[41,86,136,6,3015],[48,86,136,13,3017],[59,86,136,24],[60,86,136,25,3016],[64,86,136,29],[69,86,136,34],[90,86,137,6,3015],[97,86,137,13,3017],[108,86,137,24],[109,86,137,25,3018],[115,86,137,31],[120,86,137,36,2990],[131,86,138,6]],[[12,86,139,6]],[[8,86,140,4]],[[8,86,142,4],[13,86,142,9],[19,86,142,15,3019],[35,86,142,31,3015],[42,86,142,38,3017],[53,86,142,49],[54,86,142,50,3018],[60,86,142,56],[61,86,142,58]],[[12,86,143,6],[17,86,143,11],[23,86,143,17,3020],[31,86,143,25,3021],[38,86,143,32,3022],[42,86,143,36],[43,86,143,37,3019],[56,86,143,50,3023],[63,86,143,57],[65,86,143,60]],[[16,86,144,8],[22,86,144,14,3024],[28,86,144,20],[44,86,144,36,3025],[48,86,144,40],[49,86,144,41,3020]],[[16,86,145,8],[20,86,145,12,3024],[28,86,145,20],[34,86,145,26]],[[20,86,146,10]],[[16,86,147,8]],[[16,86,149,8,2999],[31,86,149,23,3003],[34,86,149,26],[35,86,149,27,3024],[38,86,149,30],[39,86,149,31],[41,86,149,33]],[[12,86,150,6]],[[8,86,151,4]],[[4,86,152,2]],[[4,86,154,2],[11,86,154,9,2999]],[[0,86,155,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,87,25,16,3026],[22,87,25,34],[24,87,25,34]],[[15,87,25,16,3026]],[],[[4,87,10,16,3027],[45,87,10,57],[47,87,10,57]],[[15,87,10,16,3027]],[],[],[[34,87,0,39]],[[32,87,1,31]],[[0,87,8,0],[6,87,8,6,3028],[14,87,8,14],[18,87,8,18,3029]],[[0,87,10,7],[9,87,10,16,3027],[51,87,11,2,3030],[60,87,11,19]],[[4,87,13,2],[8,87,13,6,3031],[15,87,13,13,3028],[21,87,13,19,3032],[24,87,13,22],[25,87,13,23,3030]],[[4,87,15,2],[8,87,15,6],[9,87,15,7,3031],[15,87,15,13]],[[8,87,16,4],[14,87,16,10],[16,87,16,12,3033],[24,87,16,20],[26,87,16,22,3034],[34,87,16,30],[36,87,16,32],[39,87,16,35],[43,87,16,39,3035]],[[8,87,17,4,3031],[15,87,17,11]],[[12,87,17,13,3033]],[[12,87,17,23,3036],[20,87,17,31,3034],[29,87,17,40,3037],[38,87,17,49]],[[8,87,17,52]],[[8,87,18,4,3028],[14,87,18,10,3038],[17,87,18,13],[18,87,18,14,3030],[29,87,18,25,3031]],[[8,87,19,4,3031],[13,87,19,9,3036],[19,87,19,15],[20,87,19,16,3039],[26,87,19,22],[27,87,19,23,3040],[34,87,19,30],[35,87,19,31],[39,87,19,37,3028],[45,87,19,43,3041],[51,87,19,49],[52,87,19,50,3030]],[[4,87,20,2]],[[4,87,22,2],[11,87,22,9,3031]],[[0,87,23,0]],[[0,87,25,7],[9,87,25,16,3026],[28,87,26,2,3042],[42,87,26,52]],[[4,87,31,2],[8,87,31,6,3030]],[[4,87,33,2],[8,87,33,6,3042],[24,87,33,22]],[[8,87,34,4,3030],[20,87,34,16,3042],[34,87,34,30],[35,87,34,31,3043],[53,87,34,31,3043],[75,87,34,53],[76,87,34,54],[80,87,34,58,3044]],[[8,87,36,4],[12,87,36,8],[13,87,36,9,3030],[24,87,36,20]],[[12,87,37,6],[18,87,37,12],[25,87,37,12],[39,87,39,7],[40,87,37,12],[44,87,37,16,3045],[60,87,37,16,3045],[74,87,37,30],[75,87,38,8],[76,87,38,9],[87,87,38,20],[89,87,38,22,3046],[94,87,38,27,3047],[103,87,38,36],[104,87,38,37,3043],[122,87,38,37,3043],[144,87,38,59],[146,87,38,61],[162,87,38,77],[163,87,38,78],[166,87,37,12],[187,87,37,12]],[[23,87,37,12]],[[28,87,37,12]],[[30,87,37,12]],[[12,87,39,6]],[[8,87,40,4]],[[4,87,41,2],[11,87,41,9]],[[8,87,42,4,3030],[20,87,42,16,3048],[25,87,42,21,3049],[33,87,42,29]],[[8,87,44,4],[12,87,44,8],[13,87,44,9,3030],[24,87,44,20]],[[12,87,45,6],[18,87,45,12],[25,87,45,12],[39,87,47,7],[40,87,45,12],[44,87,45,16,3045],[60,87,45,16,3045],[74,87,45,30],[75,87,46,8],[76,87,46,9],[147,87,46,80],[148,87,46,81],[151,87,45,12],[172,87,45,12]],[[23,87,45,12]],[[28,87,45,12]],[[30,87,45,12]],[[12,87,47,6]],[[8,87,48,4]],[[4,87,49,2]],[[4,87,51,2],[10,87,51,8],[12,87,51,10,3033],[20,87,51,18],[22,87,51,20],[25,87,51,23,3027],[67,87,51,65,3030]],[[4,87,53,2],[11,87,53,9]],[[8,87,53,11,3033]],[[4,87,53,20]],[[0,87,54,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,88,57,42,3066],[8,88,57,50,3067],[11,88,57,53],[12,88,57,54,3068],[21,88,57,63]],[[0,88,0,0],[45,88,0,45]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[4,88,547,0],[11,88,596,1],[13,88,596,1]],[[15,88,547,24,3050]],[],[[4,88,115,16,3051],[21,88,115,33],[23,88,115,33]],[[15,88,115,16,3051]],[],[[4,88,215,16,3052],[18,88,215,30],[20,88,215,30]],[[15,88,215,16,3052]],[],[[4,88,71,16,3053],[34,88,71,46],[36,88,71,46]],[[15,88,71,16,3053]],[],[],[],[],[[23,88,3,43]],[[68,88,4,22]],[[80,88,5,34]],[[24,88,9,7]],[[30,88,14,7]],[[37,88,15,36]],[[44,88,16,43]],[[33,88,17,32]],[[37,88,18,36]],[[27,88,19,33]],[[34,88,23,7]],[[37,88,30,37]],[[75,88,31,29]],[[44,88,32,29]],[[34,88,33,45]],[[35,88,37,7]],[[32,88,38,31]],[[30,88,39,58]],[[24,88,42,76]],[[37,88,43,33]],[[0,88,50,0],[6,88,50,6,3054],[33,88,51,2,3055],[41,88,51,2,3055],[65,88,51,33]],[[0,88,53,0],[4,88,53,4,3056],[32,88,53,37]],[[0,88,54,0],[4,88,54,4,3057],[24,88,54,24,3058],[29,88,54,29,3059],[34,88,54,34],[35,88,54,35,3058],[40,88,54,40,3060],[46,88,54,46],[51,88,54,51],[57,88,54,57,3061],[62,88,54,62,3062],[65,88,54,65]],[[0,88,55,0],[4,88,55,4,3063],[16,88,55,16]],[[0,88,56,0],[4,88,56,4,3064],[31,88,56,46]],[[0,88,57,0],[6,88,57,6,3065],[60,88,58,4],[64,88,58,8,3069],[92,88,58,8,3069],[104,88,58,20],[109,88,59,4]],[[0,88,61,0],[4,88,61,4,3070],[30,88,61,30,3071],[38,88,61,38,3072],[45,88,61,45]],[[0,88,62,0],[4,88,62,4,3073],[37,88,62,49],[42,88,62,56]],[[0,88,63,0],[9,88,63,9,3074]],[[4,88,64,2,3070],[30,88,64,28],[34,88,64,32,3071],[42,88,64,40],[43,88,64,41,3072]],[[8,88,65,4,3073],[41,88,65,37]],[[12,88,66,6,3072]],[[8,88,67,4]],[[4,88,68,2]],[[0,88,69,0]],[[0,88,71,7],[9,88,71,16,3053]],[[4,88,72,2],[11,88,72,9,3070]],[[0,88,73,0]],[[0,88,75,0],[50,88,75,50]],[[0,88,76,0],[9,88,76,9,3075],[29,88,76,29,3076],[33,88,76,41]],[[4,88,77,2],[42,88,77,40]],[[4,88,78,2,3056],[32,88,78,30,3076]],[[0,88,79,0]],[[0,88,81,0]],[],[],[],[[1,88,85,1],[4,88,86,0],[13,88,86,9,3077]],[[4,88,87,2],[8,88,87,6,3066],[16,88,87,14,3067],[19,88,87,17],[20,88,87,18,3068],[29,88,87,27],[44,88,87,29]],[[8,88,88,4],[15,88,88,11]],[[4,88,89,2]],[],[],[[0,88,95,0]],[[0,88,97,0],[45,88,97,45]],[[0,88,98,0],[9,88,98,9,3079]],[[4,88,99,2],[11,88,99,9,3080],[18,88,99,16,3081],[21,88,99,19],[22,88,99,20,3082],[28,88,99,26],[35,88,99,33]],[[0,88,100,0]],[[0,88,101,0],[9,88,101,9,3083],[27,88,101,27,3084],[29,88,101,34]],[[4,88,102,2],[8,88,102,6,3079],[27,88,102,25]],[[8,88,103,4,3084]],[[4,88,104,2],[11,88,104,9]],[[8,88,105,4],[17,88,105,13,3085],[25,88,105,21,3082],[31,88,105,32]],[[12,88,106,6],[16,88,106,10,3082],[27,88,106,21],[35,88,106,29]],[[16,88,107,8,3080],[23,88,107,15,3081],[26,88,107,18],[27,88,107,19,3086],[46,88,107,38],[47,88,107,39,3085]],[[16,88,108,8,3084]],[[12,88,109,6]],[[8,88,110,4]],[[8,88,111,4,3080],[15,88,111,11,3081],[18,88,111,14],[19,88,111,15,3087],[35,88,111,31],[36,88,111,32,3085]],[[4,88,112,2]],[[0,88,113,0]],[[0,88,115,7],[9,88,115,16,3051],[27,88,116,2,3088],[30,88,116,10],[32,88,117,2,3089],[43,88,117,37]],[[4,88,119,2],[10,88,119,8,3090],[23,88,120,4,3088],[30,88,121,5],[31,88,121,6,3088],[35,88,121,10,3091],[40,88,121,15],[44,88,121,19,3088],[48,88,121,23,3091],[53,88,121,28],[54,88,121,29,3092],[59,88,121,34],[60,88,121,35],[66,88,121,41,3093],[71,88,121,46],[72,88,121,47],[75,88,121,50],[78,88,121,53,3094],[82,88,121,57],[83,88,121,58],[92,88,122,6,3088],[96,88,122,10,3095],[103,88,122,17],[107,88,123,6,3088],[113,88,123,12],[115,88,123,13]],[[4,88,125,2,3089],[16,88,126,4,3096],[21,88,126,9,3097],[30,88,126,18],[31,88,126,19]],[[8,88,127,6,3098],[15,88,127,13]],[[8,88,128,6,3090]],[[8,88,129,6,3099],[25,88,129,23],[26,88,129,24],[27,88,129,25,3100],[48,88,129,25,3100],[67,88,129,44],[68,88,129,45,3099],[83,88,129,60]],[[8,88,130,6,3101],[25,88,130,23,3088],[31,88,130,29,3088],[35,88,130,33,3101],[50,88,130,48],[53,88,130,51,3102]],[[4,88,131,4]],[[4,88,134,2],[8,88,134,6,3063],[19,88,134,17]],[[4,88,135,2,3063],[16,88,135,14]],[[4,88,136,2,3103],[11,88,136,9,3104],[19,88,136,17],[20,88,136,18,3105],[26,88,136,24]],[[0,88,137,0]],[[0,88,139,0],[65,88,139,65]],[[0,88,140,0],[9,88,140,9,3106],[32,88,140,32,3089],[43,88,140,70]],[[4,88,141,2],[8,88,141,6],[9,88,141,7,3077],[32,88,141,30],[33,88,141,31,3079],[52,88,141,50]],[[8,88,142,4,3073]],[[8,88,143,4,3107],[22,88,143,4,3107],[32,88,143,14],[33,88,143,15,3108],[42,88,143,24]],[[8,88,144,4,3109],[9,88,144,4,3109],[12,88,144,4,3109],[30,88,144,4,3109],[37,88,144,20],[39,88,144,21,3089],[52,88,144,34],[54,88,144,36],[56,88,144,38,3064],[82,88,144,65,3061],[87,88,144,70,3062],[90,88,144,73]],[[8,88,145,4]],[[4,88,146,2]],[[4,88,148,2],[13,88,148,11,3110],[32,88,149,4,3088],[35,88,149,12],[37,88,150,4,3111],[51,88,150,46]],[[8,88,152,4],[12,88,152,8,3088],[19,88,152,15,3100],[40,88,152,15,3100],[59,88,152,34],[60,88,152,35,3099],[75,88,152,50],[79,88,152,54,3111],[97,88,152,72],[103,88,152,78]],[[12,88,153,6],[16,88,153,10,3088],[21,88,153,15]],[[16,88,154,8,3112],[24,88,154,16,3113],[28,88,154,20],[29,88,154,21,3114],[37,88,154,21,3114],[62,88,154,46]],[[12,88,155,6],[19,88,155,13],[23,88,155,17,3100],[44,88,155,17,3100],[63,88,155,36],[64,88,155,37,3099],[79,88,155,52],[81,88,155,54]],[[16,88,156,8,3112],[24,88,156,16,3113],[28,88,156,20],[29,88,156,21,3115],[37,88,156,21,3115],[73,88,156,57]],[[12,88,157,6]],[[12,88,158,6,3051],[30,88,158,24,3088],[35,88,158,29,3089]],[[12,88,159,6]],[[8,88,160,4]],[[8,88,162,4,3107],[22,88,162,4,3107],[32,88,162,14],[33,88,162,15,3108],[42,88,162,24]],[[8,88,164,4],[12,88,164,8,3077],[33,88,164,29]],[[12,88,165,6],[75,88,165,69]],[[12,88,166,6,3106],[35,88,166,29,3089]],[[12,88,167,6]],[[8,88,168,4]],[[8,88,170,4,3107],[22,88,170,4,3107],[32,88,170,14],[33,88,170,15,3116],[42,88,170,24]],[[8,88,171,4,3073]],[[8,88,172,4,3109],[9,88,172,4,3109],[12,88,172,4,3109],[30,88,172,4,3109],[37,88,172,20],[39,88,173,6,3089],[52,88,174,6,3111],[68,88,175,6,3064],[94,88,176,6,3061],[99,88,176,11,3062],[102,88,176,14]],[[8,88,179,4],[12,88,179,8,3066],[20,88,179,16,3067],[23,88,179,19],[24,88,179,20,3117],[40,88,179,36],[42,88,179,38]],[],[[4,88,187,2]],[[4,88,189,2],[63,88,189,61]],[[4,88,190,2,3080],[11,88,190,9,3081],[14,88,190,12],[15,88,191,5,3120],[20,88,191,10],[21,88,191,11],[34,88,191,24],[37,88,191,27],[44,88,192,5,3121],[48,88,192,9],[49,88,192,10],[50,88,192,11,3111]],[[8,88,193,6],[12,88,193,10,3111],[30,88,193,28],[36,88,193,34]],[[12,88,194,8],[19,88,194,15]],[[8,88,195,6]],[[8,88,197,6],[82,88,197,80]],[[8,88,198,6],[75,88,198,73]],[[8,88,199,6],[113,88,199,111]],[[8,88,200,6,3107],[22,88,200,6,3107],[32,88,200,16],[33,88,200,17,3122],[48,88,200,32]],[[8,88,201,6],[67,88,201,65]],[[8,88,202,6],[15,88,202,13,3080],[22,88,202,20,3081],[25,88,202,23],[26,88,202,24,3123],[31,88,202,29]],[[4,88,203,4],[7,88,204,5,3121],[11,88,204,9],[12,88,205,6],[13,88,205,7,3111]],[[8,88,206,8,3110],[27,88,206,27],[33,88,206,33,3111]],[[4,88,207,6],[7,88,208,6],[8,88,208,7,3088]],[[8,88,209,8,3110],[27,88,209,27,3088],[32,88,209,32]],[[4,88,210,6]],[[0,88,212,0]],[[0,88,215,7],[9,88,215,16,3052],[24,88,216,2,3095],[31,88,216,34],[33,88,217,2,3089],[44,88,217,40],[46,88,218,2,3124],[69,88,218,71],[71,88,219,2,3125],[91,88,219,44]],[[4,88,221,2],[13,88,221,11,3126],[26,88,221,24,3127],[32,88,221,54]],[[8,88,222,4],[38,88,222,34]],[[8,88,223,4],[14,88,223,10,3128],[26,88,223,22,3129],[27,88,223,22,3129],[30,88,223,22,3129],[53,88,223,22,3129],[60,88,223,43],[62,88,223,44]],[[12,88,224,6,3127],[20,88,224,14,3127]],[[12,88,225,6,3130],[22,88,225,16],[24,88,225,18]],[[8,88,226,4]],[[8,88,228,4],[37,88,228,33]],[[8,88,229,4,3107],[22,88,229,4,3107],[32,88,229,14],[33,88,229,15,3131],[45,88,229,27],[46,88,229,28,3128],[56,88,229,38,3127],[62,88,229,44],[63,88,229,45],[65,88,229,47]],[[8,88,231,4],[40,88,231,36]],[[8,88,232,4],[12,88,232,9],[16,88,232,13,3132],[20,88,232,17],[23,88,232,20,3132],[27,88,232,24,3128],[37,88,232,34,3127],[43,88,232,40],[44,88,232,41,3133],[50,88,232,47],[52,88,232,49,3132],[56,88,232,54]],[[12,88,233,6,3112],[20,88,233,14,3134],[25,88,233,19],[26,88,233,20,3135],[27,88,233,20,3135],[30,88,233,20,3135],[41,88,233,20,3135],[48,88,233,29],[50,88,233,30,3128],[60,88,233,40,3127],[66,88,233,46],[67,88,233,47,3132],[69,88,233,49]],[[8,88,234,4]],[[8,88,236,4],[40,88,236,36]],[[8,88,237,4],[50,88,237,46]],[[8,88,238,4],[12,88,238,8,3066],[20,88,238,16,3067],[23,88,238,19],[24,88,238,20,3117],[40,88,238,36],[42,88,238,38]],[],[[4,88,244,2]],[[4,88,246,2],[13,88,246,11,3136]],[[8,88,247,4],[12,88,247,8,3066],[20,88,247,16,3067],[23,88,247,19],[24,88,247,20,3068],[33,88,247,29],[48,88,247,31]],[[12,88,248,6],[18,88,248,12,3137],[30,88,248,24,3065],[43,88,248,38,3138],[50,88,248,45]],[[12,88,249,6],[16,88,249,10,3137],[29,88,249,23],[35,88,249,29]],[[16,88,250,8,3109],[17,88,250,8,3109],[20,88,250,8,3109],[38,88,250,8,3109],[45,88,250,24],[47,88,251,10,3089],[60,88,252,10]],[[23,88,252,14,3137],[33,88,252,24,3111],[47,88,252,38]],[[17,88,252,39],[19,88,253,10,3137],[29,88,253,20,3139],[46,88,253,37],[48,88,254,10,3137],[58,88,254,20,3140],[73,88,254,35],[75,88,255,10],[75,88,256,10,3137],[85,88,256,20,3141],[95,88,256,30],[144,88,255,79]],[[12,88,258,6]],[[12,88,259,6,3107],[26,88,259,6,3107],[36,88,259,16],[37,88,259,17,3108],[46,88,259,26]],[[8,88,260,4],[15,88,260,11]],[],[[4,88,263,2]],[[4,88,265,2],[11,88,265,10,3095],[19,88,265,18,3142],[23,88,265,22]],[[8,88,266,4],[13,88,266,9,3143],[31,88,266,9,3143],[58,88,266,36],[59,88,266,37,3144],[71,88,266,49]],[[12,88,266,51]],[[16,88,267,6],[20,88,267,10,3066],[28,88,267,18,3067],[31,88,267,21],[32,88,267,22,3145],[52,88,267,42],[56,88,267,44]],[[20,88,268,8,3125],[41,88,268,29,3146],[55,88,268,43],[58,88,268,46,3095],[66,88,268,54,3147],[70,88,268,58]],[[20,88,270,8],[86,88,270,74]],[[20,88,271,8],[88,88,271,76]],[[20,88,272,8],[84,88,272,72]],[[20,88,273,8],[60,88,273,48]],[[20,88,275,8],[26,88,275,14,3148],[37,88,275,25,3125],[58,88,275,46,3149],[66,88,275,54],[69,88,276,12,3095],[77,88,276,20,3147],[81,88,276,24],[82,88,276,25,3125],[103,88,276,46,3149],[111,88,276,54],[112,88,276,55],[115,88,277,12,3102]],[[20,88,279,8,3107],[34,88,279,8,3107],[44,88,279,18],[45,88,279,19,3150],[62,88,279,36],[63,88,280,10,3148],[76,88,280,23,3102],[88,88,280,35],[100,88,280,47,3148],[111,88,280,58],[122,88,280,69]],[[16,88,282,6]],[[16,88,283,6]],[[12,88,284,4]],[[8,88,285,4],[13,88,285,9,3143],[31,88,285,9,3143],[58,88,285,36],[59,88,285,37,3151],[67,88,285,45]],[[12,88,285,47]],[[16,88,286,6,3107],[30,88,286,6,3107],[40,88,286,16],[41,88,286,17,3152],[62,88,286,38]],[[16,88,288,6],[20,88,288,10,3066],[28,88,288,18,3067],[31,88,288,21],[32,88,288,22,3068],[41,88,288,31],[56,88,288,33]],[[20,88,289,8,3065],[33,88,289,22,3153],[43,88,289,32]],[[16,88,290,6],[23,88,290,13]],[],[[16,88,295,6]],[[12,88,296,4]],[[8,88,297,4],[13,88,297,9,3143],[31,88,297,9,3143],[58,88,297,36],[59,88,297,37,3155],[64,88,297,42]],[[8,88,298,4],[13,88,298,9,3143],[31,88,298,9,3143],[58,88,298,36],[59,88,298,37,3156],[63,88,298,41]],[[12,88,298,43]],[[16,88,299,6,3107],[30,88,299,6,3107],[40,88,299,16],[41,88,299,17,3157],[62,88,299,38]],[[16,88,301,6],[20,88,301,10,3095],[28,88,301,18,3076],[32,88,301,22],[34,88,301,24]],[[20,88,302,8,3075],[40,88,302,28,3095],[48,88,302,36,3076],[52,88,302,40]],[[16,88,303,6]],[[16,88,305,6],[22,88,305,12],[24,88,305,14,3127],[30,88,305,20],[32,88,305,22,3130],[40,88,305,30],[42,88,305,32],[45,88,305,35,3095]],[[16,88,307,6],[57,88,307,47]],[[16,88,308,6],[20,88,308,10],[37,88,308,27,3095],[46,88,309,8,3107],[60,88,309,8,3107],[70,88,309,18],[71,88,309,19,3158],[84,88,309,32],[85,88,309,33,3095],[93,88,309,41,3159],[104,88,309,52]],[[16,88,310,6],[20,88,310,10],[31,88,310,21,3095],[42,88,310,32,3095],[50,88,310,40,3160],[55,88,310,45],[57,88,311,8,3107],[71,88,311,8,3107],[81,88,311,18],[82,88,311,19,3161],[93,88,311,30],[94,88,311,31,3095],[102,88,311,39,3160],[107,88,311,44]],[[16,88,312,6],[20,88,312,10],[38,88,312,28,3095],[47,88,313,8,3107],[61,88,313,8,3107],[71,88,313,18],[72,88,313,19,3162],[86,88,313,33],[87,88,313,34,3095],[95,88,313,42,3163],[107,88,313,54]],[[16,88,314,6],[20,88,314,10],[40,88,314,30,3095],[49,88,315,8,3107],[63,88,315,8,3107],[73,88,315,18],[74,88,315,19,3164],[90,88,315,35],[91,88,315,36,3095],[99,88,315,44,3165],[113,88,315,58]],[[16,88,317,6],[22,88,317,12,3166],[34,88,317,24,3167],[42,88,317,32,3127],[52,88,317,42,3127],[59,88,317,49,3133],[65,88,317,55]],[[16,88,318,6],[82,88,318,72]],[[16,88,319,6],[20,88,319,10,3166],[31,88,319,21]],[[20,88,320,8,3089],[32,88,321,10,3096],[37,88,321,15,3097],[46,88,321,24],[47,88,321,25]],[[24,88,322,12,3098],[31,88,322,19]],[[24,88,323,12,3168],[36,88,323,24,3127],[43,88,323,31,3133],[49,88,323,37]],[[24,88,324,12,3169],[34,88,324,22,3057]],[[20,88,325,10]],[[20,88,328,8,3126],[33,88,328,21,3127]],[[20,88,329,8]],[[16,88,330,6]],[[16,88,332,6],[22,88,332,12,3170],[36,88,332,26,3167],[44,88,332,34,3130],[56,88,332,46,3130],[65,88,332,55,3133],[71,88,332,61]],[[16,88,333,6],[20,88,333,10,3170],[33,88,333,23]],[[20,88,334,8,3089],[32,88,335,10,3096],[37,88,335,15,3097],[46,88,335,24],[47,88,335,25]],[[24,88,336,12,3098],[31,88,336,19]],[[24,88,337,12,3171],[38,88,337,26,3130],[47,88,337,35,3133],[53,88,337,41]],[[24,88,338,12,3169],[34,88,338,22,3057]],[[20,88,339,10]],[[20,88,342,8],[53,88,342,41]],[[20,88,343,8],[26,88,343,14,3172],[46,88,343,34,3129],[47,88,343,34,3129],[50,88,343,34,3129],[73,88,343,34,3129],[80,88,343,55],[82,88,343,56]],[[24,88,344,10,3130],[34,88,344,20,3130]],[[24,88,345,10,3127],[32,88,345,18],[34,88,345,20]],[[20,88,346,8]],[[20,88,348,8],[24,88,348,13],[28,88,348,17,3132],[32,88,348,21],[35,88,348,24,3132],[39,88,348,28,3172],[57,88,348,46,3130],[65,88,348,54],[66,88,348,55,3133],[72,88,348,61],[74,88,348,63,3132],[78,88,348,68]],[[24,88,349,10],[28,88,349,14,3132],[34,88,349,20],[37,88,349,23]],[[28,88,350,12,3112],[36,88,350,20,3113],[40,88,350,24],[41,88,351,14],[88,88,352,16]],[[28,88,354,12]],[[24,88,355,10]],[[24,88,356,10,3112],[32,88,356,18,3113],[36,88,356,22],[37,88,356,23,3135],[38,88,356,23,3135],[41,88,356,23,3135],[52,88,356,23,3135],[59,88,356,32],[61,88,356,33,3172],[79,88,356,51,3130],[87,88,356,59],[88,88,356,60,3132],[90,88,356,62]],[[20,88,357,8]],[[16,88,359,8],[135,88,359,127]],[[16,88,360,6]],[[16,88,362,6,3089],[28,88,363,8,3096],[33,88,363,13,3097],[42,88,363,22],[43,88,363,23]],[[20,88,364,10,3098],[27,88,364,17]],[[20,88,365,10,3169],[30,88,365,20,3057]],[[16,88,366,8]],[[16,88,369,6],[20,88,369,10,3095],[28,88,369,18,3142],[32,88,369,22],[37,88,369,27,3143],[55,88,369,27,3143],[82,88,369,54],[83,88,369,55,3155],[88,88,369,60],[90,88,369,62]],[[20,88,370,8,3136]],[[16,88,371,6]],[[16,88,372,6]],[[12,88,373,4]],[[8,88,374,4],[13,88,374,9,3143],[31,88,374,9,3143],[58,88,374,36],[59,88,374,37,3173],[78,88,374,56]],[[12,88,374,58]],[[16,88,375,6,3124],[40,88,375,30]],[[20,88,376,8,3142],[26,88,376,14,3143],[44,88,376,14,3143],[71,88,376,41],[72,88,376,42,3173],[91,88,376,61]],[[20,88,377,8,3147],[26,88,377,14]],[[24,88,378,10,3174],[35,88,378,21,3095],[43,88,378,29,3147],[47,88,378,33],[48,88,378,34,3174],[57,88,378,43]],[[20,88,379,8]],[[16,88,380,6]],[[16,88,381,6]],[[12,88,382,4]],[[8,88,383,4],[13,88,383,9,3143],[31,88,383,9,3143],[58,88,383,36],[59,88,383,37,3175],[76,88,383,54]],[[12,88,383,56]],[[16,88,384,6,3065],[29,88,384,20,3176],[47,88,384,38],[48,88,384,39,3095]],[[16,88,385,6,3107],[30,88,385,6,3107],[40,88,385,16],[41,88,385,17,3122],[56,88,385,32]],[[16,88,386,6,3124],[40,88,386,30]],[[20,88,387,8,3142],[26,88,387,14,3143],[44,88,387,14,3143],[71,88,387,41],[72,88,387,42,3175],[89,88,387,59]],[[20,88,388,8,3147],[26,88,388,14,3095],[34,88,388,22,3147],[38,88,388,26]],[[16,88,389,6]],[[16,88,390,6],[20,88,390,10,3100],[41,88,390,10,3100],[60,88,390,29],[61,88,390,30,3099],[76,88,390,45],[78,88,390,47]],[[20,88,391,8,3112],[28,88,391,16,3113],[32,88,391,20],[33,88,391,21,3115],[41,88,391,21,3115],[77,88,391,57]],[[20,88,392,8,3051],[38,88,392,26],[44,88,392,32,3089]],[[16,88,393,6]],[[16,88,394,6,3107],[30,88,394,6,3107],[40,88,394,16],[41,88,394,17,3116],[50,88,394,26]],[[16,88,395,6]],[[12,88,396,4]],[[8,88,397,4],[63,88,397,59]],[[8,88,398,4],[13,88,398,9,3143],[31,88,398,9,3143],[58,88,398,36],[59,88,398,37,3177],[83,88,398,61]],[[12,88,398,63]],[[16,88,399,6,3065],[30,88,399,20,3178]],[[16,88,400,6,3089],[28,88,401,8,3096],[33,88,401,13,3097],[42,88,401,22],[43,88,401,23]],[[20,88,402,10,3098],[27,88,402,17]],[[20,88,403,10,3169],[30,88,403,20,3057]],[[20,88,404,10,3076],[26,88,404,16,3095],[34,88,404,24,3076],[38,88,404,28]],[[16,88,405,8]],[[16,88,408,6],[90,88,408,80]],[[16,88,409,6],[55,88,409,45]],[[16,88,410,6,3179],[25,88,410,15,3180],[31,88,410,21],[34,88,410,24],[37,88,410,27,3181],[55,88,410,27,3181],[83,88,410,55],[84,88,410,56],[85,88,410,57],[87,88,410,59,3095],[95,88,410,67,3076],[99,88,410,71],[100,88,410,72],[107,88,410,79],[108,88,410,80]],[[16,88,412,6],[20,88,413,8,3100],[41,88,413,8,3100],[60,88,413,27],[61,88,413,28,3099],[76,88,413,43],[80,88,414,8,3179],[89,88,414,17,3182],[104,88,414,32],[105,88,414,33,3183],[107,88,414,35],[112,88,414,40],[130,88,415,8]],[[20,88,416,8],[24,88,416,12,3063],[35,88,416,23]],[[20,88,417,8,3063],[32,88,417,20]],[[20,88,418,8],[27,88,418,15,3103],[34,88,418,22,3104],[42,88,418,30],[43,88,418,31,3105],[49,88,418,37]],[[16,88,419,6]],[[16,88,421,6,3184],[17,88,421,6,3184],[20,88,421,6,3184],[27,88,421,6,3184],[42,88,421,21],[44,88,421,22]],[[20,88,422,8,3185],[39,88,422,8,3185],[62,88,422,31],[63,88,422,32,3186],[73,88,422,42]],[[20,88,423,8,3107],[34,88,423,8,3107],[44,88,423,18],[45,88,423,19,3116],[54,88,423,28]],[[16,88,424,6]],[[16,88,426,6],[20,88,426,10,3066],[28,88,426,18,3067],[31,88,426,21],[32,88,426,22,3117],[48,88,426,38],[50,88,426,40]],[],[[16,88,433,6]],[[12,88,434,4]],[[8,88,435,4],[13,88,435,9,3143],[31,88,435,9,3143],[58,88,435,36],[59,88,435,37,3187],[70,88,435,48]],[[12,88,435,50]],[[16,88,436,6,3065],[30,88,436,20,3188]],[[16,88,437,6,3089],[28,88,438,8,3096],[33,88,438,13,3097],[42,88,438,22],[43,88,438,23]],[[20,88,439,10,3098],[27,88,439,17]],[[20,88,440,10,3169],[30,88,440,20,3057]],[[16,88,441,8]],[[16,88,443,6],[20,88,443,10,3063],[31,88,443,21]],[[16,88,444,6,3063],[28,88,444,18]],[[16,88,445,6],[23,88,445,13,3103],[30,88,445,20,3104],[38,88,445,28],[39,88,445,29,3105],[45,88,445,35]],[[12,88,446,4]],[[8,88,447,4],[13,88,447,9,3143],[31,88,447,9,3143],[58,88,447,36],[59,88,447,37,3189],[69,88,447,47]],[[8,88,448,4],[13,88,448,9,3143],[31,88,448,9,3143],[58,88,448,36],[59,88,448,37,3190],[71,88,448,49]],[[12,88,448,51]],[[16,88,449,6,3065],[30,88,449,20,3191]],[[16,88,450,6],[101,88,450,91]],[[16,88,451,6],[23,88,451,13,3185],[42,88,451,13,3185],[65,88,451,36],[66,88,451,37,3186],[76,88,451,47]],[[12,88,452,4]],[[8,88,453,4],[13,88,453,9,3143],[31,88,453,9,3143],[58,88,453,36],[59,88,453,37,3192],[71,88,453,49]],[[12,88,453,51]],[[16,88,454,6],[22,88,454,12],[24,88,454,14,3193],[33,88,454,23],[35,88,454,25],[38,88,454,28,3095]],[[16,88,455,6],[20,88,455,10,3193],[31,88,455,21]],[[20,88,456,8],[26,88,456,14,3194],[40,88,456,28,3096],[45,88,456,33,3195],[50,88,456,38],[51,88,456,39,3193]],[[20,88,457,8],[26,88,457,14,3134],[34,88,457,22],[41,88,457,22],[55,88,457,52],[56,88,457,22],[60,88,457,26,3196],[66,88,457,32,3194],[78,88,457,44,3095],[85,88,457,51],[88,88,457,22],[109,88,457,22]],[[31,88,457,22]],[[36,88,457,22]],[[38,88,457,22]],[[20,88,457,51]],[[20,88,458,8,3134],[26,88,458,14,3091],[31,88,458,19],[34,88,458,22,3194],[46,88,458,34,3091],[51,88,458,39]],[[20,88,459,8,3126],[33,88,459,21]],[[24,88,459,22,3134]],[[21,88,459,28]],[[16,88,460,6]],[[16,88,461,6]],[[12,88,462,4]],[[8,88,463,4],[13,88,463,9,3143],[31,88,463,9,3143],[58,88,463,36],[59,88,463,37,3197],[84,88,463,62]],[[12,88,463,64]],[[16,88,464,6]],[[12,88,465,4]],[[8,88,466,4],[13,88,466,9,3143],[31,88,466,9,3143],[58,88,466,36],[59,88,466,37,3198],[74,88,466,52]],[[12,88,466,54]],[[16,88,467,6,3107],[30,88,467,6,3107],[40,88,467,16],[41,88,467,17,3164],[57,88,467,33],[58,88,467,34,3095],[66,88,467,42,3147],[70,88,467,46]],[[16,88,468,6]],[[12,88,469,4]],[[8,88,470,4],[13,88,470,9,3143],[31,88,470,9,3143],[58,88,470,36],[59,88,470,37,3199],[76,88,470,54]],[[12,88,470,56]],[[16,88,471,6],[22,88,471,12],[24,88,471,14,3200],[33,88,471,23],[35,88,471,25,3201],[40,88,471,30],[42,88,471,32],[45,88,471,35,3095]],[[16,88,472,6],[22,88,472,12],[24,88,472,14,3202],[30,88,472,20],[32,88,472,22],[35,88,472,25,3203],[36,88,472,25,3203],[39,88,472,25,3203],[53,88,472,25,3203],[94,88,472,66],[96,88,472,67,3200]],[[16,88,474,6],[20,88,474,10,3201],[27,88,474,17]],[[20,88,475,8,3202],[27,88,475,15,3204],[32,88,475,20],[33,88,475,21,3121],[37,88,475,25],[38,88,475,26],[42,88,475,32,3202],[49,88,475,39,3205],[54,88,475,44],[55,88,475,45,3201],[63,88,475,53,3206],[68,88,475,58],[69,88,475,59,3112],[77,88,475,67,3134],[82,88,475,72]],[[16,88,476,6],[23,88,476,13]],[[20,88,477,8],[90,88,477,78]],[[20,88,478,8],[46,88,478,34]],[[20,88,479,8],[92,88,479,80]],[[20,88,480,8],[89,88,480,77]],[[20,88,481,8],[31,88,481,19]],[[20,88,482,8,3202],[27,88,482,15,3204],[32,88,482,20],[33,88,482,21,3121],[37,88,482,25],[38,88,482,26],[42,88,482,32,3202],[49,88,482,39,3207],[54,88,482,44],[58,88,482,48,3206],[63,88,482,53],[64,88,482,54,3112],[72,88,482,62,3134],[77,88,482,67]],[[16,88,483,6]],[[16,88,485,6]],[[12,88,486,4]],[[8,88,487,4],[13,88,487,9,3143],[31,88,487,9,3143],[58,88,487,36],[59,88,487,37,3208],[86,88,487,64]],[[12,88,487,66]],[[16,88,488,6],[22,88,488,12,3209],[35,88,488,25,3210],[36,88,488,25,3210],[39,88,488,25,3210],[53,88,488,25,3210],[78,88,488,50]],[[16,88,489,6],[22,88,489,12,3211],[33,88,489,46]],[[20,88,490,8,3098],[27,88,490,15,3212],[45,88,490,15,3212],[71,88,490,41],[72,88,490,42,3213],[96,88,490,66]],[[20,88,491,8,3200],[31,88,491,19,3095],[39,88,491,27,3200],[48,88,491,36]],[[20,88,492,8,3209]],[[20,88,493,8,3214],[25,88,493,13,3103],[32,88,493,20,3104],[40,88,493,28],[41,88,493,29,3215],[45,88,493,33]],[[16,88,494,6]],[[16,88,495,6,3089],[28,88,495,18,3096],[33,88,495,23,3097],[42,88,495,32],[43,88,495,33,3211]],[[16,88,496,6]],[[12,88,497,4]],[[8,88,498,4],[13,88,498,9,3143],[31,88,498,9,3143],[58,88,498,36],[59,88,498,37,3216],[80,88,498,58]],[[12,88,498,60]],[[16,88,499,6],[22,88,499,12,3217],[40,88,499,30,3218],[41,88,499,30,3218],[44,88,499,30,3218],[58,88,499,30,3218],[76,88,499,48]],[[16,88,500,6],[22,88,500,12,3211],[33,88,500,48]],[[20,88,501,8,3098],[27,88,501,15,3212],[45,88,501,15,3212],[71,88,501,41],[72,88,501,42,3219],[98,88,501,68]],[[20,88,502,8,3200],[31,88,502,19,3095],[39,88,502,27,3200],[48,88,502,36]],[[20,88,503,8,3217]],[[20,88,504,8,3214],[25,88,504,13,3103],[32,88,504,20,3104],[40,88,504,28],[41,88,504,29,3215],[45,88,504,33]],[[16,88,505,6]],[[16,88,506,6,3089],[28,88,506,18,3096],[33,88,506,23,3097],[42,88,506,32],[43,88,506,33,3211]],[[16,88,507,6]],[[12,88,508,4]],[[8,88,509,4],[13,88,509,9,3143],[31,88,509,9,3143],[58,88,509,36],[59,88,509,37,3220],[74,88,509,52]],[[12,88,509,54]],[[16,88,510,6,3107],[30,88,510,6,3107],[40,88,510,16],[41,88,510,17,3221],[57,88,510,33],[58,88,510,34,3095],[66,88,510,42,3222],[71,88,510,47]],[[16,88,511,6]],[[12,88,512,4]],[[8,88,513,4],[13,88,513,9,3143],[31,88,513,9,3143],[58,88,513,36],[59,88,513,37,3223],[84,88,513,62]],[[12,88,513,64]],[[16,88,514,6,3054],[41,88,515,8],[45,88,515,12,3224],[60,88,515,27]],[[20,88,516,10,3225],[27,88,516,16,3226],[37,88,516,26]],[[24,88,517,12,3226],[35,88,517,23,3227],[42,88,517,30],[43,88,517,31,3095],[51,88,517,39,3228],[67,88,517,55]],[[24,88,518,12,3226],[35,88,518,23,3207],[40,88,518,28]],[[20,88,519,10]],[[16,88,520,8],[20,88,521,8]],[[20,88,521,10,3229],[38,88,521,10,3229],[59,88,521,10,3229],[75,88,521,26]],[[16,88,521,27],[19,88,522,8,3121],[23,88,522,12],[24,88,523,8],[25,88,523,9,3127]],[[20,88,524,10],[25,88,524,15],[31,88,524,21,3134],[40,88,524,30,3127],[47,88,524,38]],[[24,88,525,12,3112],[32,88,525,20,3134],[37,88,525,25],[38,88,525,26,3134]],[[20,88,526,10]],[[16,88,527,8],[19,88,528,8],[20,88,528,9,3088]],[[20,88,529,10,3112],[28,88,529,18,3134],[33,88,529,23],[34,88,530,12],[41,88,530,12],[55,88,530,70],[56,88,530,12],[60,88,530,16,3196],[66,88,530,22],[99,88,530,55]],[[24,88,530,57,3230],[31,88,530,64,3088]],[[20,88,530,68],[24,88,530,12],[45,88,530,12]],[[31,88,530,12]],[[36,88,530,12]],[[38,88,530,12]],[[20,88,530,69]],[[16,88,532,8]],[[16,88,534,6]],[[12,88,535,4]],[[8,88,536,4],[13,88,536,9,3143],[31,88,536,9,3143],[58,88,536,36],[59,88,536,37,3231],[77,88,536,55]],[[8,88,537,4],[13,88,537,9,3143],[31,88,537,9,3143],[58,88,537,36],[59,88,537,37,3232],[73,88,537,51]],[[8,88,538,4],[13,88,538,9,3143],[31,88,538,9,3143],[58,88,538,36],[59,88,538,37,3233],[78,88,538,56]],[[12,88,540,6]],[[8,88,541,4]],[[12,88,541,13]],[[16,88,542,6,3095]],[[12,88,543,4]],[[4,88,544,2]],[[0,88,545,0]],[[0,88,547,15],[9,88,547,24,3050],[19,88,547,34],[21,88,548,2,3234],[29,88,548,10],[31,88,549,2,3235],[42,88,549,13],[44,88,550,2,3236],[53,88,550,11],[55,88,551,2,3125],[75,88,551,22],[77,88,557,1]],[[4,88,558,2,3237],[5,88,558,2,3237],[8,88,558,2,3237],[25,88,558,2,3237],[40,88,558,17],[42,88,558,18,3107],[56,88,558,18,3107],[66,88,558,28],[67,88,558,29,3238],[83,88,558,45],[85,88,558,47,3107],[99,88,558,47,3107],[109,88,558,57],[110,88,558,58,3239],[130,88,558,78]],[[4,88,559,2,3240],[5,88,559,2,3240],[8,88,559,2,3240],[19,88,559,2,3240],[35,88,559,18],[37,88,559,19,3236]],[[4,88,561,2],[82,88,561,80]],[[4,88,562,2],[71,88,562,69]],[[4,88,563,2],[10,88,563,8,3149],[21,88,563,19,3241],[22,88,563,19,3241],[25,88,563,19,3241],[46,88,563,19,3241],[66,88,563,39]],[[4,88,565,2],[8,88,565,6,3066],[16,88,565,14,3067],[19,88,565,17],[20,88,565,18,3145],[40,88,565,38],[44,88,565,40]],[[8,88,566,4],[67,88,566,63]],[[8,88,567,4],[75,88,567,71]],[[8,88,568,4],[62,88,568,58]],[[8,88,569,4,3242],[9,88,569,4,3242],[12,88,569,4,3242],[19,88,569,4,3242],[28,88,569,13],[30,88,569,14]],[[12,88,570,6],[16,88,570,10],[17,88,570,11,3125],[39,88,570,33]],[[16,88,571,8],[22,88,571,14],[29,88,571,14],[43,88,573,9],[44,88,571,14],[48,88,571,18,3243],[64,88,571,18,3243],[78,88,571,32],[79,88,572,10],[140,88,571,14],[161,88,571,14]],[[27,88,571,14]],[[32,88,571,14]],[[34,88,571,14]],[[16,88,573,8]],[[12,88,574,6]],[[12,88,576,6,3125],[33,88,576,27,3149],[41,88,576,35],[44,88,576,38,3149]],[[12,88,578,6],[16,88,578,10,3125],[37,88,578,31,3146],[51,88,578,45],[53,88,578,47]],[[16,88,579,8],[22,88,579,14,3148],[33,88,579,25,3149],[44,88,580,12,3125],[65,88,580,33,3146],[79,88,580,47],[80,88,580,48,3149],[89,88,580,57],[92,88,581,12,3102]],[[16,88,583,8,3107],[30,88,583,8,3107],[40,88,583,18],[41,88,583,19,3150],[58,88,583,36],[59,88,584,10,3148],[72,88,584,23,3102],[84,88,584,35],[96,88,584,47,3148],[107,88,584,58],[118,88,584,69]],[[12,88,586,6]],[[8,88,587,4],[11,88,587,7]],[[12,88,587,8,3149]],[[12,88,587,18,3125]],[[9,88,587,39]],[[4,88,588,2]],[[4,88,590,2],[11,88,590,2],[22,88,590,2],[25,88,591,4],[26,88,591,4],[29,88,591,4],[41,88,591,4],[45,88,591,4],[47,88,591,5,3244],[75,88,591,5,3244],[101,88,591,31],[103,88,591,31]],[[8,88,591,32,3235],[21,88,591,45,3235]],[],[[26,88,592,6],[27,88,592,6],[30,88,592,6],[42,88,592,6],[45,88,592,6],[47,88,592,7,3245],[68,88,592,7,3245],[87,88,592,26],[89,88,592,26]],[[16,88,592,27,3246],[33,88,592,44,3107],[47,88,592,44,3107],[57,88,592,54],[58,88,592,55,3247],[74,88,592,71]],[],[[12,88,593,7,3234]],[],[],[[0,88,596,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,89,60,8,3253],[8,89,60,16,3254],[11,89,60,19],[12,89,60,20,3255],[40,89,60,48],[42,89,60,50]],[],[],[],[],[[31,89,553,0],[42,89,553,0]],[],[],[[15,89,553,24,3248]],[],[],[],[],[],[[65,89,6,7]],[[47,89,11,7]],[[36,89,13,31]],[[35,89,18,34]],[[49,89,25,7]],[[32,89,26,56]],[[36,89,27,35]],[[34,89,28,33]],[[33,89,29,32]],[[36,89,30,35]],[[32,89,31,31]],[[29,89,32,28]],[[36,89,33,34]],[[35,89,34,37]],[[35,89,40,7]],[[26,89,41,66]],[[31,89,42,46]],[[23,89,43,33]],[[76,89,44,30]],[[70,89,45,31]],[[36,89,46,35]],[[30,89,48,50]],[[0,89,50,0],[6,89,50,6,3249],[22,89,52,4],[23,89,52,5]],[[0,89,54,0],[9,89,54,9,3250],[24,89,54,24],[26,89,55,2,3251],[40,89,55,16],[42,89,58,1]],[[4,89,59,2,3252],[5,89,59,2,3252],[8,89,59,2,3252],[15,89,59,2,3252],[33,89,59,20],[35,89,59,21]],[[8,89,60,4]],[],[[8,89,66,4],[14,89,66,10],[16,89,66,12,3260],[20,89,66,16],[22,89,66,18,3261],[29,89,66,25],[31,89,66,27,3262],[43,89,66,39],[45,89,66,41,3263],[59,89,66,55],[61,89,66,57],[64,89,66,60,3251]],[[8,89,68,4],[14,89,68,10,3264],[32,89,68,45]],[[12,89,69,6,3260]],[[12,89,70,6,3263]],[[8,89,71,4]],[[8,89,73,4],[48,89,73,44]],[[8,89,74,4],[14,89,74,10,3265],[29,89,74,25]],[[12,89,75,6],[15,89,75,10,3261],[23,89,75,18,3266],[49,89,75,44],[52,89,75,47,3256],[59,89,75,54,3267],[66,89,75,61],[67,89,75,62,3268],[72,89,75,67],[75,89,75,70],[76,89,75,71],[77,89,75,72]],[[12,89,76,6],[53,89,76,47]],[[12,89,77,6],[94,89,77,88]],[[12,89,78,6],[93,89,78,87]],[[12,89,79,6,3269],[18,89,79,12]],[[12,89,80,6,3270],[45,89,80,39,3264]],[[8,89,81,4]],[[8,89,82,4],[12,89,83,6,3261],[20,89,83,14,3271],[31,89,83,25],[35,89,84,6],[130,89,84,101]],[[8,89,85,6],[67,89,85,65]],[[8,89,86,6,3272],[9,89,86,6,3272],[12,89,86,6,3272],[31,89,86,6,3272],[48,89,86,23],[50,89,86,24],[54,89,86,28,3273],[58,89,86,32,3256],[65,89,86,39,3274],[73,89,86,47],[74,89,86,48,3275],[78,89,86,52],[85,89,86,59,3262],[99,89,87,6]],[[12,89,88,6],[161,89,88,155]],[[12,89,89,6,3261],[20,89,89,14,3271],[31,89,89,25],[34,89,89,28]],[[12,89,90,6,3256],[19,89,90,13,3267],[26,89,90,20],[27,89,90,21,3276],[36,89,90,30],[37,89,90,31,3265],[51,89,90,45],[55,89,90,49,3262]],[[8,89,91,4],[15,89,91,11]],[[12,89,92,6,3256],[19,89,92,13,3267],[26,89,92,20],[27,89,92,21,3277],[39,89,92,33],[40,89,92,34,3265],[54,89,92,48],[58,89,92,52,3262]],[[8,89,93,4]],[[4,89,94,2],[7,89,94,5]],[[8,89,94,6,3251]],[[5,89,94,21]],[[4,89,96,2,3278],[5,89,96,2,3278],[8,89,96,2,3278],[15,89,96,2,3278],[24,89,96,11],[26,89,96,12]],[[8,89,97,4],[77,89,97,73]],[[8,89,98,4],[79,89,98,75]],[[8,89,99,4],[75,89,99,71]],[[8,89,100,4],[70,89,100,66]],[[8,89,101,4,3279],[9,89,101,4,3279],[12,89,101,4,3279],[19,89,101,4,3279],[35,89,101,20],[37,89,101,21,3251],[52,89,101,36,3280],[59,89,101,43],[61,89,101,45,3251],[76,89,101,60,3260],[80,89,101,64]],[[4,89,102,2],[7,89,102,5]],[[8,89,102,6,3251],[23,89,102,21,3280],[30,89,102,28]],[[8,89,102,30,3251],[23,89,102,45,3260],[27,89,102,49]],[[5,89,102,50]],[[4,89,104,2],[11,89,104,9]],[[0,89,105,0]],[[0,89,107,0],[9,89,107,9,3281],[40,89,107,40,3282],[44,89,107,49]],[[4,89,108,2],[8,89,108,6,3282],[16,89,108,14],[22,89,108,20,3282],[29,89,108,27],[30,89,108,28]],[[4,89,109,2],[10,89,109,8,3283],[25,89,109,23,3256],[32,89,109,30,3267],[39,89,109,37],[40,89,109,38,3268],[45,89,109,43]],[[4,89,110,2],[10,89,110,8,3269],[17,89,110,15,3283],[31,89,110,29,3269]],[[4,89,111,2],[8,89,111,6,3269],[14,89,111,12]],[[8,89,112,4,3282],[13,89,112,9,3269],[17,89,112,13],[20,89,112,16,3269]],[[4,89,113,2]],[[4,89,114,2],[10,89,114,8,3270],[44,89,115,4,3283],[58,89,115,18,3270]],[[4,89,116,2],[8,89,116,6,3270],[41,89,116,39]],[[8,89,117,4,3282],[13,89,117,9,3270],[44,89,117,40],[47,89,117,43,3270]],[[4,89,118,2]],[[4,89,120,2],[11,89,120,9,3282]],[[0,89,121,0]],[[0,89,123,0],[9,89,123,9,3284],[14,89,123,14],[16,89,124,2,3285],[29,89,124,15],[31,89,127,1]],[[4,89,128,2],[81,89,128,79]],[[4,89,129,2],[80,89,129,78]],[[4,89,130,2],[54,89,130,52]],[[4,89,131,2],[10,89,131,8,3286],[17,89,131,15,3285],[35,89,131,33],[42,89,131,40,3285],[56,89,131,54,3286],[60,89,131,58],[63,89,131,61]],[[4,89,132,2],[10,89,132,8,3287],[25,89,133,4,3285],[43,89,133,22],[50,89,133,29,3285],[64,89,133,43,3287],[76,89,133,55],[79,89,133,58]],[[4,89,135,2],[81,89,135,79]],[[4,89,136,2],[10,89,136,8,3288],[32,89,136,30,3287],[49,89,136,47],[56,89,136,54,3287],[71,89,136,69,3286]],[[4,89,138,2],[79,89,138,77]],[[4,89,139,2],[79,89,139,77]],[[4,89,140,2],[42,89,140,40]],[[4,89,141,2],[11,89,141,9,3289],[12,89,141,9,3289],[15,89,141,9,3289],[22,89,141,9,3289],[38,89,141,25],[40,89,141,26,3286],[46,89,141,32,3288]],[[0,89,142,0]],[[0,89,144,0]],[],[[1,89,146,1],[4,89,147,0],[13,89,147,9,3290],[20,89,147,16],[22,89,148,2,3291],[33,89,148,13],[35,89,149,2,3292],[46,89,149,13],[48,89,150,2,3293],[57,89,150,11],[59,89,151,2,3294],[79,89,151,22],[81,89,157,1]],[[4,89,158,2],[10,89,158,8,3268],[18,89,158,16,3295],[19,89,158,16,3295],[22,89,158,16,3295],[38,89,158,16,3295],[52,89,158,30],[54,89,158,31,3291]],[[4,89,159,2],[10,89,159,8],[12,89,159,10,3262],[24,89,159,22],[26,89,159,24],[29,89,159,27,3268]],[[4,89,160,2],[71,89,160,69]],[[4,89,161,2],[10,89,161,8],[12,89,161,10,3296],[24,89,161,22],[26,89,161,24,3297],[34,89,161,32],[36,89,161,34],[39,89,161,37,3298],[40,89,161,37,3298],[43,89,161,37,3298],[50,89,161,37,3298],[57,89,161,44],[59,89,161,45]],[[8,89,162,4],[14,89,162,10,3299],[20,89,162,16],[24,89,162,20,3273],[28,89,163,6,3262],[42,89,164,6],[49,89,164,13,3256],[60,89,164,24],[74,89,164,38],[87,89,164,51,3256],[94,89,164,58,3274],[102,89,164,66],[103,89,164,67,3275],[107,89,164,71]],[[8,89,167,4],[15,89,167,11]],[[12,89,168,6],[72,89,168,66]],[[12,89,169,6,3296],[26,89,169,20,3299],[30,89,169,24,3296],[42,89,169,36]],[[12,89,170,6,3297],[22,89,170,16,3300],[23,89,170,16,3300],[26,89,170,16,3300],[39,89,170,16,3300],[50,89,170,27],[52,89,170,28,3299],[56,89,170,32,3297],[64,89,170,40],[68,89,171,10,3301],[69,89,171,10,3301],[72,89,171,10,3301],[88,89,171,10,3301],[102,89,171,24],[104,89,171,25,3299],[108,89,171,29,3297],[116,89,171,37],[120,89,172,10,3299],[124,89,172,14,3297],[132,89,172,22]],[[8,89,173,4]],[[4,89,174,2],[7,89,174,5]],[[8,89,174,6,3262]],[[5,89,174,19]],[[4,89,176,2],[8,89,176,6,3253],[16,89,176,14,3254],[19,89,176,17],[20,89,176,18,3302],[28,89,176,26],[33,89,176,31],[44,89,176,45]],[[8,89,177,4],[14,89,177,10],[16,89,177,12,3303],[21,89,177,17],[23,89,177,19,3260],[27,89,177,23],[29,89,177,25],[32,89,177,28,3268]],[[8,89,179,4],[100,89,179,96]],[[8,89,180,4],[62,89,180,58]],[[8,89,181,4,3278],[9,89,181,4,3278],[12,89,181,4,3278],[19,89,181,4,3278],[28,89,181,13],[30,89,181,14]],[[12,89,182,6],[54,89,182,48]],[[12,89,183,6],[115,89,183,109]],[[12,89,184,6],[47,89,184,41]],[[12,89,185,6,3256],[19,89,185,13,3304],[21,89,185,15],[24,89,185,18]],[[16,89,186,8,3305],[24,89,186,16,3306],[43,89,186,16,3306],[66,89,186,39]],[[16,89,187,8,3303]],[[16,89,188,8,3260]],[[12,89,189,6]],[[8,89,190,4],[11,89,190,7]],[[12,89,190,8,3303]],[[12,89,190,15,3260]],[[9,89,190,20]],[[4,89,191,2]],[[4,89,193,2,3278],[5,89,193,2,3278],[8,89,193,2,3278],[15,89,193,2,3278],[24,89,193,11],[26,89,193,12]],[[8,89,194,4],[66,89,194,62]],[[8,89,195,4],[95,89,195,91]],[[8,89,196,4],[77,89,196,73]],[[8,89,197,4],[112,89,197,108]],[[8,89,198,4],[17,89,198,13,3307],[32,89,198,28,3308],[37,89,198,54]],[[12,89,199,6],[16,89,200,8],[17,89,200,9,3308],[23,89,200,15,3309],[32,89,200,24],[36,89,201,8],[37,89,201,9,3256],[44,89,201,16,3267],[51,89,201,23],[52,89,201,24,3268],[57,89,201,29],[59,89,201,31,3270],[92,89,202,8]],[[16,89,203,8]],[[12,89,204,6]],[[12,89,206,6],[115,89,206,109]],[[12,89,207,6],[129,89,207,123]],[[12,89,208,6],[42,89,208,36]],[[12,89,209,6,3249],[26,89,209,20,3310],[40,89,209,34],[43,89,209,37,3259]],[[12,89,211,6,3311],[13,89,211,6,3311],[16,89,211,6,3311],[32,89,211,6,3311],[55,89,211,29],[57,89,211,30]],[[16,89,212,8,3312],[22,89,212,14,3313],[42,89,212,14,3313],[56,89,212,28]],[[16,89,213,8,3299],[21,89,213,13],[25,89,213,17,3273],[29,89,213,21,3256],[36,89,213,28,3274],[44,89,213,36],[45,89,213,37,3275],[49,89,213,41]],[[16,89,214,8,3265],[30,89,214,22,3256],[37,89,214,29,3267],[44,89,214,36],[45,89,214,37,3268],[50,89,214,42],[51,89,214,43,3270],[82,89,214,74]],[[12,89,215,6]],[[8,89,216,4]],[[8,89,218,4,3256],[15,89,218,11,3314],[31,89,218,27],[32,89,218,28],[44,89,218,40,3307]],[[8,89,220,4],[15,89,220,11]],[[12,89,221,6,3256],[19,89,221,13,3315],[38,89,221,32],[39,89,221,33],[51,89,221,45,3307]],[[8,89,222,4]],[[4,89,223,2],[7,89,223,5],[9,89,223,7]],[[4,89,225,2,3278],[5,89,225,2,3278],[8,89,225,2,3278],[15,89,225,2,3278],[24,89,225,11],[26,89,225,12]],[[8,89,226,4],[89,89,226,85]],[[8,89,227,4],[48,89,227,44]],[[8,89,228,4],[17,89,228,13,3316],[41,89,229,6,3308],[46,89,229,47]],[[12,89,231,6],[18,89,231,12,3317],[26,89,231,20],[38,89,231,32,3308],[46,89,231,40,3308],[52,89,231,46,3318],[58,89,231,52],[61,89,231,55,3308],[67,89,231,61,3317],[72,89,231,66]],[[12,89,232,6],[16,89,232,10,3319],[17,89,232,10,3319],[20,89,232,10,3319],[35,89,232,10,3319],[50,89,232,25],[52,89,232,26,3317],[60,89,232,34]],[[16,89,233,8,3308],[22,89,233,14,3320],[36,89,233,28]],[[16,89,234,8],[22,89,234,14,3299],[28,89,234,20,3321],[29,89,234,20,3321],[32,89,234,20,3321],[42,89,234,20,3321],[65,89,234,43],[67,89,234,44,3317]],[[16,89,235,8],[22,89,235,14,3322],[37,89,235,29,3323],[38,89,235,29,3323],[41,89,235,29,3323],[51,89,235,29,3323],[75,89,235,53],[77,89,235,54,3317]],[[16,89,236,8],[84,89,236,76]],[[16,89,237,8],[51,89,237,43]],[[16,89,238,8],[20,89,238,12,3322],[37,89,238,29,3324],[52,89,238,29,3324],[64,89,238,41],[65,89,238,42,3325],[69,89,238,46],[71,89,238,48]],[[20,89,239,10,3306],[39,89,239,10,3306],[62,89,239,33],[63,89,239,34,3325],[67,89,239,38],[68,89,239,39,3299],[73,89,239,44],[74,89,239,45]],[[16,89,240,8],[23,89,240,15]],[[20,89,241,10,3306],[39,89,241,10,3306],[62,89,241,33],[63,89,241,34,3326],[70,89,241,41],[71,89,241,42,3299],[76,89,241,47],[77,89,241,48]],[[16,89,242,8]],[[12,89,243,6]],[[8,89,244,4]],[[8,89,245,4,3256],[15,89,245,11,3314],[31,89,245,27],[32,89,245,28],[41,89,245,37,3316]],[[8,89,246,4,3256],[15,89,246,11,3314],[31,89,246,27],[32,89,246,28],[54,89,246,50,3316]],[[8,89,248,4],[15,89,248,11]],[[12,89,249,6,3256],[19,89,249,13,3315],[38,89,249,32],[39,89,249,33],[48,89,249,42,3316]],[[12,89,250,6,3256],[19,89,250,13,3315],[38,89,250,32],[39,89,250,33],[61,89,250,55,3316]],[[8,89,251,4]],[[4,89,252,2],[7,89,252,5],[9,89,252,7]],[[4,89,254,2],[74,89,254,72]],[[4,89,255,2],[78,89,255,76]],[[4,89,256,2],[76,89,256,74]],[[4,89,257,2],[81,89,257,79]],[[4,89,258,2],[16,89,258,14]],[[4,89,259,2],[6,89,259,4]],[[4,89,260,2],[74,89,260,72]],[[4,89,261,2],[81,89,261,79]],[[4,89,262,2],[81,89,262,79]],[[4,89,263,2],[27,89,263,25]],[[4,89,264,2],[10,89,264,8],[12,89,264,10,3261],[19,89,264,17],[21,89,264,19],[24,89,264,22,3268]],[[4,89,265,2],[8,89,265,6,3261],[16,89,265,14,3327],[29,89,265,27],[31,89,265,29]],[[8,89,266,4],[120,89,266,116]],[[8,89,267,4],[12,89,267,8,3249],[26,89,267,22,3310],[40,89,267,36],[45,89,267,41,3262],[59,89,267,55]],[[12,89,268,6],[18,89,268,12,3274],[29,89,268,23,3256],[36,89,268,30,3274],[44,89,268,38]],[[12,89,269,6],[16,89,269,10,3261],[24,89,269,18,3271],[35,89,269,29],[37,89,269,31]],[[16,89,270,8,3274],[25,89,270,17,3328],[31,89,270,23],[32,89,270,24,3262]],[[12,89,271,6],[19,89,271,13]],[[16,89,272,8,3274],[25,89,272,17,3326],[32,89,272,24],[33,89,272,25,3262]],[[12,89,273,6]],[[12,89,275,6,3249],[26,89,275,20,3310],[40,89,275,34],[43,89,275,37,3262]],[[8,89,276,4]],[[8,89,277,4],[75,89,277,71]],[[8,89,278,4],[84,89,278,80]],[[8,89,279,4],[39,89,279,35]],[[8,89,280,4],[83,89,280,79]],[[8,89,281,4],[80,89,281,76]],[[8,89,282,4],[39,89,282,35]],[[8,89,283,4],[14,89,283,10,3329],[34,89,283,10,3329],[52,89,283,28]],[[4,89,284,2]],[[4,89,286,2,3278],[5,89,286,2,3278],[8,89,286,2,3278],[15,89,286,2,3278],[24,89,286,11],[26,89,286,12]],[[8,89,287,4],[14,89,287,10,3330],[34,89,287,30,3256],[41,89,287,37,3267],[48,89,287,44],[49,89,287,45,3276],[58,89,287,54],[59,89,287,55,3331],[63,89,287,59],[64,89,287,60,3256],[71,89,287,67,3267],[78,89,287,74]],[[8,89,288,4],[14,89,288,10,3332],[37,89,288,33,3256],[44,89,288,40,3267],[51,89,288,47],[52,89,288,48,3277],[64,89,288,60],[65,89,288,61,3331],[69,89,288,65],[70,89,289,6,3256],[77,89,289,13,3267],[84,89,289,20]],[[8,89,292,4],[160,89,292,156]],[[8,89,293,4],[14,89,293,10,3333],[47,89,293,43],[48,89,294,6,3299]],[[12,89,296,6],[18,89,296,12,3275],[25,89,296,19,3256],[32,89,296,26,3274],[40,89,296,34],[41,89,296,35,3275],[45,89,296,39]],[[12,89,297,6],[18,89,297,12,3264],[36,89,298,8,3256],[43,89,298,15,3267],[50,89,298,22],[51,89,298,23,3268],[56,89,298,28],[58,89,298,30,3270]],[[12,89,300,6,3334],[13,89,300,6,3334],[16,89,300,6,3334],[23,89,300,6,3334],[38,89,300,21],[40,89,300,22]],[[16,89,301,8,3311],[17,89,301,8,3311],[20,89,301,8,3311],[36,89,301,8,3311],[59,89,301,31],[61,89,301,32]],[[20,89,302,10,3312],[26,89,302,16,3313],[46,89,302,16,3313],[60,89,302,30]],[[20,89,303,10,3299],[25,89,303,15],[29,89,303,19,3273],[33,89,303,23,3299],[40,89,303,30,3275],[46,89,303,36,3275]],[[20,89,304,10,3265],[34,89,304,24,3264]],[[16,89,305,8]],[[12,89,306,6]],[[8,89,307,4]],[[8,89,309,4]],[],[],[],[[5,89,313,5],[8,89,314,4,3256],[15,89,314,11,3267],[22,89,314,18],[23,89,314,19,3276],[32,89,314,28],[35,89,314,31],[44,89,314,40,3276],[54,89,315,6,3282],[58,89,315,15],[60,89,316,6,3335],[67,89,316,21],[69,89,317,6,3299],[72,89,317,31]],[[12,89,319,6],[97,89,319,91]],[[12,89,320,6],[81,89,320,75]],[[12,89,321,6],[16,89,321,10,3282],[22,89,321,16,3269],[30,89,321,24,3282],[36,89,321,30,3336],[40,89,321,34]],[[16,89,322,8],[23,89,322,15,3330],[41,89,322,33,3282],[47,89,322,39,3335],[56,89,322,48,3299]],[[12,89,323,6]],[[12,89,325,6,3282],[19,89,325,13,3281],[50,89,325,44,3282]],[[12,89,327,6],[16,89,327,10,3299],[21,89,327,15]],[[16,89,328,8,3333],[47,89,328,39,3299]],[[12,89,329,6]],[[12,89,331,6],[19,89,331,13,3330],[37,89,331,31,3282],[43,89,331,37,3335],[52,89,331,46,3299]],[[8,89,332,4]],[[8,89,334,4]],[],[],[],[[5,89,338,5],[8,89,339,4,3256],[15,89,339,11,3267],[22,89,339,18],[23,89,339,19,3277],[35,89,339,31],[38,89,339,34],[47,89,339,43,3277],[60,89,340,6,3282],[64,89,340,15],[66,89,341,6,3335],[73,89,341,21],[75,89,342,6,3299],[78,89,342,31]],[[12,89,344,6],[97,89,344,91]],[[12,89,345,6],[81,89,345,75]],[[12,89,346,6],[16,89,346,10,3282],[22,89,346,16,3269],[30,89,346,24,3282],[36,89,346,30,3336],[40,89,346,34]],[[16,89,347,8],[23,89,347,15,3332],[44,89,347,36,3282],[50,89,347,42,3335],[59,89,347,51,3299]],[[12,89,348,6]],[[12,89,349,6,3282],[19,89,349,13,3281],[50,89,349,44,3282]],[[12,89,351,6],[16,89,351,10,3299],[21,89,351,15]],[[16,89,352,8,3333],[47,89,352,39,3299]],[[12,89,353,6]],[[12,89,354,6],[19,89,354,13,3332],[40,89,354,34,3282],[46,89,354,40,3335],[55,89,354,49,3299]],[[8,89,355,4]],[[8,89,357,4]],[],[],[],[[5,89,361,5],[8,89,362,4],[14,89,362,10,3337],[27,89,362,23],[28,89,362,24,3308]],[[12,89,363,6],[16,89,363,10],[17,89,363,11,3308],[23,89,363,17,3268],[28,89,363,22],[30,89,363,24]],[[16,89,364,8],[159,89,364,151]],[[16,89,365,8]],[[12,89,366,6]],[[12,89,368,6],[89,89,368,83]],[[12,89,369,6],[16,89,369,10],[17,89,369,11,3308],[23,89,369,17,3268],[28,89,369,22],[29,89,369,23,3269],[33,89,369,27],[35,89,369,29]],[[16,89,370,8,3256],[23,89,370,15,3274],[31,89,370,23],[32,89,370,24,3338],[38,89,370,30]],[[16,89,371,8]],[[12,89,372,6]],[[12,89,374,6],[124,89,374,118]],[[12,89,375,6],[80,89,375,74]],[[12,89,376,6,3334],[13,89,376,6,3334],[16,89,376,6,3334],[23,89,376,6,3334],[38,89,376,21],[40,89,376,22]],[[16,89,377,8,3339],[17,89,377,8,3339],[20,89,377,8,3339],[39,89,377,8,3339],[61,89,377,30],[63,89,378,10,3256],[70,89,378,17,3274],[78,89,378,25],[79,89,378,26,3275],[83,89,378,30],[85,89,379,10,3308],[91,89,379,16,3268],[96,89,379,21],[97,89,379,22,3270],[128,89,379,53]],[[12,89,381,6]],[[8,89,382,4]],[[8,89,384,4],[54,89,384,50]],[[8,89,385,4,3256],[15,89,385,11,3314],[31,89,385,27],[32,89,385,28],[44,89,385,40,3337]],[[8,89,386,4],[15,89,386,11]],[[12,89,387,6,3256],[19,89,387,13,3267],[26,89,387,20],[27,89,387,21,3276],[36,89,387,30],[39,89,387,33,3330]],[[12,89,388,6,3256],[19,89,388,13,3267],[26,89,388,20],[27,89,388,21,3277],[39,89,388,33],[42,89,388,36,3332]],[[12,89,389,6,3256],[19,89,389,13,3315],[38,89,389,32],[39,89,389,33],[51,89,389,45,3337]],[[8,89,390,4]],[[4,89,391,2],[7,89,391,5],[9,89,391,7]],[[4,89,393,2],[10,89,393,8],[12,89,393,10,3303],[17,89,393,15],[19,89,393,17,3260],[23,89,393,21],[25,89,393,23,3280],[32,89,393,30],[34,89,393,32,3340],[51,89,393,49],[53,89,393,51,3341],[68,89,393,66],[70,89,393,68],[73,89,393,71,3268]],[[4,89,395,2],[10,89,395,8,3342],[25,89,395,23,3298],[26,89,395,23,3298],[29,89,395,23,3298],[36,89,395,23,3298],[43,89,395,30],[45,89,395,31]],[[8,89,396,4],[15,89,396,11,3343],[16,89,396,11,3343],[19,89,396,11,3343],[36,89,396,11,3343],[51,89,396,26],[53,89,396,27,3303],[60,89,396,34,3260],[64,89,396,38],[65,89,396,39],[67,89,396,41]],[[4,89,397,2],[7,89,397,5]],[[8,89,397,6,3303]],[[8,89,397,13,3260]],[[5,89,397,18]],[[4,89,399,2],[45,89,399,43]],[[4,89,400,2],[10,89,400,8,3344],[23,89,400,21,3298],[24,89,400,21,3298],[27,89,400,21,3298],[34,89,400,21,3298],[41,89,400,28],[43,89,400,29]],[[8,89,401,4],[15,89,401,11,3345],[16,89,401,11,3345],[19,89,401,11,3345],[39,89,401,11,3345],[56,89,401,28],[58,89,401,29,3260]],[[4,89,402,2],[7,89,402,5]],[[8,89,402,6,3260]],[[5,89,402,11]],[[4,89,404,2],[67,89,404,65]],[[4,89,405,2],[81,89,405,79]],[[4,89,406,2],[73,89,406,71]],[[4,89,407,2],[8,89,407,6,3346],[41,89,407,66]],[[4,89,408,2],[8,89,408,6,3253],[16,89,408,14,3254],[19,89,408,17],[20,89,408,18,3302],[28,89,408,26],[33,89,408,31],[44,89,408,45]],[[8,89,409,4],[14,89,409,10],[16,89,409,12,3347],[44,89,409,40],[46,89,409,42],[49,89,410,6,3348],[57,89,410,14]],[[8,89,412,4,3346],[41,89,412,37,3347],[70,89,413,6,3260],[76,89,414,6,3297],[86,89,415,6,3296],[100,89,416,6,3344]],[[4,89,418,2]],[[4,89,420,2],[10,89,420,8,3349],[32,89,420,30,3298],[33,89,420,30,3298],[36,89,420,30,3298],[43,89,420,30,3298],[50,89,420,37],[52,89,420,38]],[[8,89,421,4],[15,89,421,11]],[[12,89,422,6,3350],[24,89,422,18,3260]],[[12,89,423,6,3351],[29,89,423,23,3303]],[[12,89,424,6,3352],[31,89,424,25]],[[12,89,425,6,3353],[26,89,425,20],[27,89,425,21]],[[12,89,426,6],[84,89,426,78]],[[12,89,427,6],[49,89,427,43]],[[12,89,428,6,3354],[30,89,428,24]],[[12,89,429,6],[41,89,429,35]],[[12,89,430,6],[90,89,430,84]],[[12,89,431,6,3299],[17,89,431,11,3262]],[[12,89,432,6],[44,89,432,38]],[[12,89,433,6,3355],[22,89,433,16]],[[8,89,434,4]],[[4,89,435,2],[7,89,435,5]],[[8,89,435,6,3260]],[[8,89,435,12,3303]],[[8,89,435,19,3262]],[[5,89,435,32]],[[4,89,437,2],[10,89,437,8,3356],[38,89,437,36,3298],[39,89,437,36,3298],[42,89,437,36,3298],[49,89,437,36,3298],[56,89,437,43],[58,89,437,44]],[[8,89,438,4],[15,89,438,11]],[[12,89,439,6,3260]],[[12,89,440,6,3340]],[[12,89,441,6,3280]],[[12,89,442,6,3341]],[[8,89,443,4]],[[4,89,444,2],[7,89,444,5]],[[8,89,444,6,3260]],[[8,89,444,12,3340]],[[8,89,444,31,3280]],[[8,89,444,40,3341]],[[5,89,444,56]],[[4,89,446,2],[8,89,446,6,3286]],[[4,89,447,2],[8,89,447,6,3342],[25,89,447,23],[31,89,447,29]],[[8,89,448,4],[66,89,448,62]],[[8,89,449,4],[82,89,449,78]],[[8,89,450,4],[76,89,450,72]],[[8,89,451,4],[10,89,451,6]],[[8,89,452,4],[80,89,452,76]],[[8,89,453,4],[31,89,453,27]],[[8,89,454,4],[14,89,454,10],[15,89,454,11,3285],[30,89,454,26,3357],[39,89,454,35,3358],[66,89,454,62],[69,89,454,65,3342]],[[8,89,456,4,3286],[15,89,456,4,3286],[26,89,456,4,3286],[29,89,457,6],[30,89,457,6],[33,89,457,6],[45,89,457,6],[48,89,457,6],[50,89,457,7,3284],[56,89,457,7,3284]],[[12,89,462,8,3285],[27,89,462,23,3285]],[[11,89,459,10],[11,89,460,10],[18,89,460,17,3256],[29,89,460,28],[43,89,460,42,3358],[72,89,460,71,3357],[90,89,459,89]],[[4,89,465,2],[11,89,465,9]],[[8,89,466,4,3286],[15,89,466,11]],[[4,89,467,2]],[[4,89,469,2],[8,89,469,6,3359],[18,89,469,6,3359],[29,89,469,6,3359],[32,89,470,4],[33,89,470,4],[36,89,470,4],[48,89,470,4],[52,89,470,4],[54,89,470,5,3360],[72,89,470,5,3360],[88,89,470,21],[90,89,470,21]],[],[[12,89,471,7,3286]],[[26,89,475,6],[27,89,475,6],[30,89,475,6],[42,89,475,6],[45,89,475,6],[47,89,475,7,3361],[67,89,475,7,3361],[85,89,475,25],[87,89,475,25]],[[26,89,475,27,3303],[32,89,475,33,3362],[35,89,475,36]],[],[[26,89,476,6],[27,89,476,6],[30,89,476,6],[42,89,476,6],[45,89,476,6],[47,89,476,7,3363],[67,89,476,7,3363],[85,89,476,25],[87,89,476,25]],[[16,89,476,26,3260],[22,89,476,32,3260]],[],[],[],[[4,89,480,2],[8,89,480,6,3253],[16,89,480,14,3254],[19,89,480,17],[20,89,480,18,3302],[28,89,480,26],[33,89,480,31],[44,89,480,45]],[[8,89,481,4],[74,89,481,70]],[[8,89,482,4],[105,89,482,101]],[[8,89,483,4],[25,89,483,21]],[[8,89,484,4],[54,89,484,50]],[[8,89,485,4],[32,89,485,28]],[[8,89,486,4],[74,89,486,70]],[[8,89,487,4],[12,89,487,8],[19,89,487,15,3256],[30,89,487,26],[43,89,487,39]],[[12,89,488,6],[18,89,488,12],[20,89,488,14,3364],[53,89,488,47],[55,89,488,49],[58,89,489,8,3348],[66,89,489,16]],[[12,89,490,6,3359],[22,89,490,6,3359],[33,89,490,6,3359],[36,89,491,8],[37,89,491,8],[40,89,491,8],[52,89,491,8],[55,89,491,8],[57,89,491,9,3364],[92,89,491,9,3364]],[[26,89,492,11,3359]],[],[[8,89,495,4]],[[8,89,496,4],[14,89,496,10,3365],[28,89,498,8,3348],[36,89,498,16],[162,89,499,8,3366],[169,89,499,15]],[[8,89,501,4,3359],[18,89,501,4,3359],[29,89,501,4,3359],[32,89,502,6],[33,89,502,6],[36,89,502,6],[48,89,502,6],[51,89,502,6],[53,89,502,7,3365],[66,89,502,7,3365]],[[12,89,503,8,3292],[25,89,503,21,3292]],[[12,89,504,8,3293],[23,89,504,19,3293]],[[12,89,505,8,3294],[34,89,505,30,3294]],[[22,89,507,9,3359]],[],[[4,89,510,2],[11,89,510,9]],[],[[4,89,521,2],[11,89,521,2],[22,89,521,2],[25,89,522,4],[26,89,522,4],[29,89,522,4],[41,89,522,4],[45,89,522,4],[47,89,522,4],[59,89,522,4],[67,89,522,4],[69,89,522,4]],[],[[26,89,523,6],[27,89,523,6],[30,89,523,6],[42,89,523,6],[45,89,523,6],[47,89,523,7,3250],[63,89,523,7,3250]],[[16,89,523,22,3251],[32,89,523,38,3268]],[],[[26,89,524,6],[27,89,524,6],[30,89,524,6],[42,89,524,6],[45,89,524,6],[47,89,524,7,3370],[62,89,524,7,3370],[63,89,524,7,3370]],[[26,89,525,6],[27,89,525,6],[30,89,525,6],[42,89,525,6],[45,89,525,6],[47,89,525,7,3371],[80,89,525,7,3371],[105,89,525,32],[106,89,525,33,3372],[114,89,525,41],[116,89,525,41]],[[16,89,526,8,3373],[23,89,526,15,3346]],[[26,89,528,8],[37,89,528,8],[40,89,528,8],[41,89,528,8],[44,89,528,8],[56,89,528,8],[59,89,528,8],[61,89,528,9,3374],[94,89,528,9,3374],[111,89,528,26],[112,89,528,27,3372],[120,89,528,35],[122,89,528,35]],[[20,89,528,36,3373],[27,89,528,43,3344]],[[30,89,529,10],[41,89,529,10],[44,89,529,10],[45,89,529,10],[48,89,529,10],[60,89,529,10],[63,89,529,10],[65,89,529,11,3375],[98,89,529,11,3375],[113,89,529,26],[114,89,529,27,3372],[122,89,529,35],[124,89,529,35]],[[24,89,529,36,3373],[31,89,529,43,3297]],[[34,89,530,12],[45,89,530,12],[48,89,530,12],[49,89,530,12],[52,89,530,12],[64,89,530,12],[67,89,530,12],[69,89,530,13,3376],[102,89,530,13,3376],[121,89,530,32],[122,89,530,33,3372],[130,89,530,41],[132,89,530,41]],[[28,89,530,42,3373],[35,89,530,49,3296]],[[38,89,531,14],[49,89,531,14],[52,89,531,14],[53,89,531,14],[56,89,531,14],[68,89,531,14],[71,89,531,14],[73,89,531,15,3377],[104,89,531,15,3377],[129,89,531,40],[130,89,531,41,3372],[138,89,531,49],[140,89,531,49]],[[32,89,532,16,3373],[39,89,532,23,3356]],[[42,89,539,16],[53,89,539,16],[56,89,539,16],[57,89,539,16],[60,89,539,16],[72,89,539,16],[75,89,539,16],[77,89,539,17,3378],[108,89,539,17,3378],[124,89,539,33],[125,89,539,34,3372],[133,89,539,42],[135,89,539,42]],[[36,89,539,43,3373],[43,89,539,50,3306],[62,89,539,50,3306],[85,89,539,73]],[[46,89,540,18],[57,89,540,18],[60,89,540,18],[61,89,540,18],[64,89,540,18],[76,89,540,18],[79,89,540,18],[81,89,540,19,3379],[112,89,540,19,3379],[131,89,540,38],[132,89,540,39,3372],[140,89,540,47],[142,89,540,47]],[[40,89,540,48,3373],[47,89,540,55,3349]],[[50,89,541,21,3359]],[],[],[],[],[],[],[],[],[],[[0,89,551,0]],[[0,89,553,15],[9,89,553,24,3248],[19,89,553,34],[21,89,554,2,3291],[32,89,554,13],[34,89,555,2,3380],[50,89,555,18],[52,89,556,2,3293],[61,89,556,11],[63,89,557,2,3294],[83,89,557,22],[85,89,563,1]],[[4,89,564,2,3381],[5,89,564,2,3381],[8,89,564,2,3381],[27,89,564,2,3381],[47,89,564,22]],[[4,89,566,2],[10,89,566,8,3305],[19,89,566,8,3305],[30,89,566,8,3305],[33,89,567,4],[34,89,567,4],[37,89,567,4],[49,89,567,4],[52,89,567,4],[54,89,567,5,3290],[62,89,567,5,3290]],[[8,89,568,6,3291],[21,89,568,19,3291]],[[8,89,569,6,3292],[21,89,569,19,3380]],[[8,89,570,6,3293],[19,89,570,17,3293]],[[8,89,571,6,3294],[30,89,571,28,3294]],[],[[4,89,575,2],[90,89,575,88]],[[4,89,576,2],[107,89,576,105]],[[4,89,577,2],[11,89,577,2],[22,89,577,2],[25,89,578,4],[26,89,578,4],[29,89,578,4],[41,89,578,4],[44,89,578,4],[46,89,578,5,3367],[65,89,578,5,3367],[72,89,578,22],[74,89,578,22]],[[8,89,578,23,3368],[24,89,578,39,3382],[37,89,578,39,3382],[44,89,578,57]],[[18,89,579,7,3305]],[],[[0,89,582,0]],[[0,89,584,0],[6,89,584,6,3383],[22,89,584,22],[26,89,584,26,3384]],[[0,89,585,0],[4,89,585,4,3385],[26,89,585,26],[30,89,585,30,3384]],[[0,89,587,0,3386],[11,89,587,11,3387],[26,89,587,26],[29,89,587,29],[38,89,587,39,3275],[42,89,587,51]],[[4,89,588,2],[8,89,588,6,3388],[14,89,588,12,3383],[28,89,588,26,3389],[32,89,588,30]],[[4,89,589,2,3383],[18,89,589,16,3390],[21,89,589,19],[22,89,589,20,3275]],[[4,89,590,2],[8,89,590,6,3383],[22,89,590,20,3389],[26,89,590,24],[31,89,590,29,3388],[36,89,590,34]],[[8,89,591,4,3385],[28,89,591,24,3391],[35,89,591,31],[36,89,591,32],[37,89,591,33,3392],[42,89,591,40,3392]],[[4,89,592,2]],[[4,89,593,2],[48,89,593,46]],[[4,89,594,2],[84,89,594,82]],[[4,89,595,2],[11,89,595,9,3393],[19,89,595,17,3394],[26,89,595,24]],[[0,89,596,0]],[[0,89,598,0],[9,89,598,9,3370]],[[4,89,599,2],[10,89,599,8],[13,89,599,11,3395],[25,89,599,23],[28,89,599,26,3396],[35,89,599,26,3396],[42,89,599,31],[43,89,599,32,3397],[51,89,599,40],[52,89,599,41]],[[4,89,600,2],[10,89,600,8,3398],[31,89,600,29,3383],[45,89,600,43,3389],[49,89,600,47]],[[4,89,601,2,3278],[5,89,601,2,3278],[8,89,601,2,3278],[15,89,601,2,3278],[24,89,601,11],[26,89,601,12]],[[8,89,602,4],[14,89,602,10,3399],[24,89,602,20],[28,89,602,26,3395],[40,89,602,38],[41,89,602,39,3400],[45,89,602,45,3400],[49,89,602,49]],[[8,89,603,4,3385],[28,89,603,24,3390],[31,89,603,27],[32,89,603,28,3399]],[[8,89,604,4],[12,89,604,8,3398],[35,89,604,31,3383],[49,89,604,45,3389],[53,89,604,49],[55,89,604,51]],[[12,89,605,6,3399]],[[8,89,606,4]],[[8,89,607,4],[15,89,607,11]],[[12,89,608,6,3385],[32,89,608,26,3401],[38,89,608,32],[39,89,608,33,3399]],[[8,89,609,4]],[[4,89,610,2],[7,89,610,5]],[[8,89,610,6,3398]],[[8,89,610,26,3395]],[[5,89,610,38]],[[4,89,612,2],[10,89,612,8,3402],[18,89,612,16,3403],[19,89,612,16,3403],[22,89,612,16,3403],[36,89,612,16,3403],[69,89,612,49]],[[4,89,613,2],[11,89,613,9]],[[11,89,613,13,3383]],[[5,89,613,27],[6,89,613,28,3404],[9,89,613,31],[10,89,613,32],[11,89,613,33,3275],[17,89,613,39,3405],[21,89,613,39,3405],[32,89,613,39,3405],[35,89,614,4],[36,89,614,4],[39,89,614,4],[51,89,614,4],[54,89,614,4],[56,89,614,5,3406],[64,89,614,5,3406]],[[12,89,616,6,3407],[17,89,616,10]],[[12,89,617,6,3275],[18,89,617,12],[21,89,617,15,3275],[28,89,617,22,3402],[35,89,617,29]],[[12,89,618,6],[25,89,618,19]],[[12,89,619,6,3408],[24,89,619,17]],[[11,89,615,11,3405]],[[0,89,625,0]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[[31,90,17,16,3409],[59,90,17,16,3409]],[],[],[[15,90,17,16,3409]],[],[],[[35,90,2,34]],[[36,90,3,49]],[[35,90,6,43]],[[32,90,7,51]],[[0,90,17,7],[9,90,17,16,3409],[34,90,17,41],[36,90,18,2,3410],[47,90,18,13],[49,90,19,2,3411],[66,90,19,19],[68,90,20,2,3412],[92,90,20,26],[94,90,21,2,3413],[115,90,21,23],[117,90,22,2,3414],[125,90,22,10],[127,90,23,31]],[[4,90,24,2],[90,90,24,88]],[[4,90,25,2],[102,90,25,100]],[[4,90,26,2],[39,90,26,37]],[[4,90,27,2],[10,90,27,8,3415],[32,90,27,30,3412],[57,90,27,55,3416],[61,90,27,59],[62,90,27,60]],[[4,90,29,2],[10,90,29,8,3417],[33,90,29,31,3418],[34,90,29,31,3418],[37,90,29,31,3418],[56,90,29,31,3418],[82,90,29,57],[84,90,29,58,3411],[101,90,29,75],[102,90,29,76],[104,90,29,78]],[[4,90,30,2],[10,90,30,8],[12,90,31,4,3419],[18,90,31,10,3420],[29,90,31,21],[31,90,32,4,3421],[41,90,32,14,3422],[56,90,32,29],[58,90,33,4,3423],[64,90,33,10,3424],[75,90,33,21],[77,90,34,3],[80,90,34,6,3417]],[[4,90,35,2],[100,90,35,98]],[[4,90,36,2],[52,90,36,50]],[[4,90,38,2],[10,90,38,8,3425],[25,90,39,4],[25,90,40,4],[102,90,39,81],[171,90,40,150]],[[4,90,41,4,3414],[15,90,43,8,3426],[16,90,43,8,3426],[19,90,43,8,3426],[38,90,43,8,3426],[55,90,43,25],[57,90,43,26,3414],[69,90,44,8,3415]],[[4,90,46,2],[10,90,46,8,3427],[25,90,46,23]],[[8,90,47,4,3419],[14,90,47,10,3420]],[[8,90,48,4,3428],[15,90,48,11,3429],[16,90,48,11,3429],[19,90,48,11,3429],[35,90,48,11,3429],[69,90,48,45],[71,90,49,6,3410],[84,90,50,6,3420],[97,90,51,6,3422],[114,90,52,6,3424]],[[8,90,54,4,3430],[17,90,54,13]],[[12,90,55,6,3431],[25,90,55,19]],[[12,90,56,6,3432],[27,90,56,21]],[[12,90,57,6],[79,90,57,73]],[[12,90,58,6],[92,90,58,86]],[[12,90,59,6,3433],[40,90,59,34]],[[8,90,60,4]],[[8,90,61,4,3434],[27,90,61,23]],[[12,90,62,6,3435],[19,90,62,13]],[[12,90,63,6,3436],[28,90,63,22]],[[12,90,64,6,3437],[26,90,64,20]],[[12,90,65,6,3438],[26,90,65,20],[28,90,65,22]],[[8,90,66,4]],[[8,90,67,4,3425]],[[8,90,68,4,3439],[24,90,68,20,3413]],[[8,90,69,4,3440],[17,90,71,6],[17,90,70,6],[17,90,71,7,3441],[18,90,71,7,3441],[19,90,71,7,3441],[22,90,71,7,3441],[42,90,71,7,3441],[74,90,71,39],[76,90,71,40,3420],[87,90,70,76],[92,90,71,56,3414],[102,90,71,66,3442],[110,90,71,73],[115,90,72,6]],[[8,90,73,4,3443],[25,90,73,21]],[[8,90,74,4,3444],[19,90,74,15]],[[4,90,75,2]],[[4,90,77,2],[11,90,77,9,3427]],[[0,90,78,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,91,2,6,3446],[8,91,2,14,3447],[11,91,2,17],[12,91,2,18,3448],[20,91,2,26],[25,91,2,31]],[],[],[],[],[[31,91,0,16,3445],[41,91,0,16,3445]],[],[],[[15,91,0,16,3445]],[],[],[[0,91,0,7],[9,91,0,16,3445]],[[4,91,1,2],[77,91,1,75]],[[4,91,2,2],[44,91,2,45]],[[8,91,3,4],[14,91,3,10,3449],[25,91,3,21],[26,91,3,22,3450]],[[12,91,4,6],[17,91,4,11],[23,91,4,17,3451],[35,91,4,29,3450],[48,91,4,43]],[[16,91,5,8],[20,91,5,12,3451],[29,91,5,21,3452],[33,91,5,25],[38,91,5,30],[51,91,5,43]],[[20,91,6,10],[25,91,6,15],[31,91,6,21,3453],[39,91,6,29,3451],[48,91,6,38,3454],[58,91,6,48],[59,91,6,50]],[[24,91,7,12],[28,91,8,14],[41,91,8,27,3453],[49,91,9,15,3453],[54,91,9,40,3455],[61,91,9,47],[66,91,9,52],[74,91,10,14]],[[28,91,11,14],[34,91,11,20,3456],[41,91,11,27,3453]],[[28,91,12,14],[32,91,12,18,3456],[37,91,12,23,3457],[44,91,12,30],[45,91,12,31,3458],[55,91,12,41],[57,91,12,43,3459],[68,91,12,54],[77,91,12,63]],[[32,91,13,16],[38,91,13,22,3460],[45,91,13,29,3456],[50,91,13,34,3461],[62,91,13,46],[63,91,13,47]],[[32,91,14,16],[36,91,14,20,3460],[42,91,14,26]],[[36,91,15,18],[42,91,15,24],[43,91,15,25,3462],[53,91,15,35,3463],[61,91,15,43],[64,91,15,46,3460],[69,91,15,51,3464],[74,91,15,56],[75,91,15,57],[82,91,15,64]],[[36,91,16,18],[40,91,16,22,3463],[49,91,16,31]],[[40,91,17,20],[46,91,17,26,3465],[62,91,17,42,3466],[69,91,17,49,3467],[77,91,17,57],[78,91,17,58,3468],[84,91,17,64]],[[40,91,18,20],[46,91,18,26,3469],[57,91,18,37]],[[47,91,19,25,3470],[56,91,19,34,3471],[72,91,19,50],[73,91,20,24],[90,91,20,41,3462],[101,91,20,52]],[[44,91,22,22],[110,91,22,88]],[[44,91,23,22],[97,91,23,75]],[[47,91,24,25,3470],[56,91,24,34,3471],[72,91,24,50],[73,91,25,24],[90,91,26,27,3462],[91,91,26,27,3462],[100,91,26,36,3459],[110,91,26,46],[111,91,26,47,3465],[128,91,27,30,3462],[137,91,27,39,3472],[142,91,27,44],[143,91,27,45,3465],[157,91,27,59,3473],[163,91,27,65],[167,91,28,30,3465],[183,91,28,46,3462],[191,91,28,53],[195,91,29,26]],[[41,91,31,21]],[[40,91,33,20],[45,91,33,25],[51,91,33,31,3474],[64,91,33,44,3469],[73,91,33,54]],[[44,91,34,22],[48,91,34,26,3474],[58,91,34,36,3457],[65,91,34,43],[66,91,34,44,3458],[76,91,34,54],[78,91,34,56,3459],[89,91,34,67],[98,91,34,76]],[[48,91,35,24],[54,91,35,30,3475],[66,91,35,42,3474],[76,91,35,52,3461],[88,91,35,64],[89,91,35,65]],[[48,91,36,24],[52,91,36,28,3475],[63,91,36,39]],[[52,91,37,26],[58,91,37,32],[61,91,37,35,3476],[74,91,37,48],[77,91,37,51,3475],[87,91,37,61,3464],[92,91,37,66],[93,91,37,67],[100,91,37,74]],[[52,91,38,26],[56,91,38,30],[57,91,38,31,3476],[73,91,38,47],[74,91,38,48,3476],[89,91,38,63],[90,91,38,64,3463],[99,91,38,73]],[[56,91,39,28],[108,91,39,80]],[[56,91,40,28],[107,91,40,79]],[[56,91,41,28],[108,91,41,80]],[[56,91,42,28],[107,91,42,79]],[[56,91,43,28,3477],[67,91,43,39]],[[60,91,44,30,3474],[70,91,44,40,3478],[76,91,44,46]],[[56,91,45,28],[59,91,45,31]],[[56,91,46,28],[62,91,46,34,3479],[76,91,46,48,3470],[85,91,46,57,3480],[98,91,46,70],[99,91,47,30],[100,91,47,31],[138,91,47,69],[140,91,47,71,3475],[150,91,47,81],[152,91,47,83],[153,91,47,84]],[[56,91,49,28],[60,91,49,32,3479],[73,91,49,45]],[[60,91,50,30,3479],[72,91,50,42,3478],[78,91,50,48]],[[56,91,51,28]],[[52,91,52,26]],[[48,91,53,24]],[[44,91,54,22]],[[40,91,55,20]],[[36,91,56,18]],[[32,91,57,16]],[[28,91,58,14]],[[24,91,59,12]],[[20,91,60,10]],[[16,91,61,8]],[[12,91,62,6]],[[8,91,63,4]],[[8,91,65,4],[70,91,65,66]],[[8,91,66,4],[14,91,66,10,3481],[25,91,66,21],[29,91,66,25,3482],[46,91,66,42,3449]],[[8,91,67,4,3481],[17,91,67,13,3483],[24,91,67,20],[25,91,67,21,3470],[34,91,67,30,3484],[38,91,67,34],[40,91,67,36]],[[12,91,68,6,3485],[23,91,68,17]],[[8,91,69,4]],[[4,91,70,2]],[[0,91,71,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,92,171,4,3533],[8,92,171,12,3534],[11,92,171,15],[12,92,171,16,3535],[20,92,171,24],[25,92,171,29]],[],[],[],[],[[31,92,294,22,3486],[42,92,294,22,3486]],[],[],[[15,92,294,22,3486]],[],[],[],[],[],[[65,92,1,27]],[[64,92,2,18]],[[25,92,8,7]],[[49,92,9,35]],[[36,92,10,35]],[[40,92,14,7]],[[31,92,15,27]],[[37,92,16,33]],[[35,92,20,7]],[[68,92,21,22]],[[42,92,23,41]],[[47,92,24,35]],[[28,92,25,30]],[[35,92,27,61]],[[0,92,29,0],[48,92,29,48]],[[0,92,31,0],[6,92,31,6,3487],[33,92,32,2,3488],[42,92,32,2,3488],[66,92,32,33]],[[0,92,33,0],[6,92,33,6,3489],[24,92,34,2,3490],[33,92,34,2,3490],[48,92,34,24]],[[0,92,36,0],[6,92,36,6,3491],[19,92,36,43,3492]],[[0,92,38,0],[6,92,38,6,3493],[16,92,38,16],[20,92,38,20,3494]],[[0,92,40,0],[4,92,40,4,3495],[30,92,40,67,3496]],[[0,92,41,0],[4,92,41,4,3497],[30,92,42,2,3496]],[[0,92,43,0],[4,92,43,4,3498],[30,92,43,30]],[[0,92,44,0],[4,92,44,4,3499],[31,92,44,31]],[[0,92,46,0],[4,92,46,4,3500],[27,92,46,39]],[[0,92,69,0],[9,92,69,9,3501],[32,92,69,32,3502],[35,92,69,50]],[[4,92,70,2],[8,92,70,6,3502],[11,92,70,9],[12,92,70,10],[14,92,70,12],[19,92,70,17],[22,92,70,20]],[[8,92,71,4,3495],[34,92,71,30],[36,92,71,32]],[[4,92,72,2],[11,92,72,9],[15,92,72,13,3502],[18,92,72,16],[19,92,72,17],[21,92,72,19],[26,92,72,24],[29,92,72,27]],[[8,92,73,4],[12,92,73,8],[13,92,73,9,3495],[38,92,74,6],[44,92,74,12],[51,92,74,12],[65,92,74,74],[66,92,74,12],[70,92,74,16,3503],[76,92,74,22],[130,92,74,12],[151,92,74,12]],[[19,92,74,12]],[[24,92,74,12]],[[26,92,74,12]],[[8,92,74,73]],[[8,92,76,4],[12,92,76,8,3497],[37,92,76,33]],[[12,92,77,6,3497],[36,92,77,30,3504],[43,92,77,37],[44,92,77,38,3493],[52,92,77,46,3505],[58,92,77,52],[59,92,77,53,3502],[62,92,77,56],[63,92,77,57],[65,92,77,59]],[[8,92,78,4],[15,92,78,11]],[[12,92,79,6,3495],[36,92,79,30,3506],[40,92,79,34],[41,92,79,35,3502],[44,92,79,38],[45,92,79,39],[47,92,79,41]],[[8,92,80,4]],[[4,92,81,2],[11,92,81,9],[15,92,81,13,3502],[18,92,81,16],[19,92,81,17],[21,92,81,19],[26,92,81,24],[29,92,81,27]],[[8,92,82,4,3500],[31,92,82,27,3502],[34,92,82,30],[35,92,82,31],[37,92,82,33]],[[4,92,83,2],[11,92,83,9],[15,92,83,13,3502],[18,92,83,16],[19,92,83,17],[21,92,83,19],[26,92,83,24],[29,92,83,27]],[[8,92,84,4],[12,92,84,8],[13,92,84,9,3495],[38,92,85,6],[44,92,85,12],[51,92,85,12],[65,92,85,74],[66,92,85,12],[70,92,85,16,3503],[76,92,85,22],[130,92,85,12],[151,92,85,12]],[[19,92,85,12]],[[24,92,85,12]],[[26,92,85,12]],[[8,92,85,73]],[[8,92,87,4],[56,92,87,52]],[[8,92,88,4],[14,92,88,10,3507],[29,92,88,25,3508],[34,92,88,30,3502],[37,92,88,33],[38,92,88,34],[40,92,88,36]],[[8,92,89,4],[14,92,89,10,3509],[29,92,89,25],[33,92,89,29,3510],[44,92,89,40,3507],[57,92,89,53,3511],[63,92,89,59]],[[8,92,90,4],[12,92,90,9],[16,92,90,13,3512],[20,92,90,17],[23,92,90,20,3512],[27,92,90,24,3507],[40,92,90,37,3511],[46,92,90,43],[48,92,90,45,3512],[52,92,90,50]],[[12,92,91,6,3509],[24,92,91,18],[25,92,91,19,3512],[27,92,91,21],[30,92,91,24,3507],[43,92,91,37,3513],[53,92,91,47],[54,92,91,48,3512]],[[8,92,92,4]],[[8,92,94,4],[12,92,94,8,3497],[37,92,94,33]],[[12,92,95,6,3497],[36,92,95,30,3504],[43,92,95,37],[44,92,95,38,3509]],[[8,92,96,4],[15,92,96,11]],[[12,92,97,6,3495],[36,92,97,30,3506],[40,92,97,34],[41,92,97,35,3509]],[[8,92,98,4]],[[4,92,99,2]],[[0,92,100,0]],[[0,92,102,0],[9,92,102,9,3514],[35,92,102,35,3515],[38,92,102,71]],[[4,92,103,2],[129,92,103,127]],[[4,92,104,2],[11,92,104,9,3515],[15,92,104,13,3516],[26,92,104,24],[31,92,104,29],[39,92,104,37,3515],[43,92,104,41,3516],[54,92,104,52],[57,92,104,55]],[[0,92,105,0]],[[0,92,107,0],[76,92,107,76]],[[0,92,108,0],[77,92,108,77]],[[0,92,109,0],[68,92,109,68]],[[0,92,110,0],[70,92,110,70]],[[0,92,111,0],[53,92,111,53]],[[0,92,112,0],[60,92,112,60]],[[0,92,113,0],[72,92,113,72]],[[0,92,114,0],[63,92,114,63]],[[0,92,115,0],[9,92,115,9,3517],[38,92,115,38,3515],[41,92,115,74]],[[4,92,116,2],[8,92,116,6,3495],[33,92,116,31]],[[8,92,117,4,3495],[32,92,117,28,3518],[39,92,117,35],[40,92,117,36],[41,92,117,37,3519]],[[12,92,118,6,3515],[16,92,118,10,3504],[23,92,118,17],[24,92,118,18],[31,92,118,25,3519],[39,92,118,33],[50,92,118,44,3493],[58,92,118,52,3505],[64,92,118,58],[65,92,118,59,3519],[72,92,118,66,3519]],[[8,92,119,4]],[[8,92,120,4],[12,92,120,8,3498],[39,92,120,35],[40,92,120,36,3499],[66,92,120,62]],[[12,92,121,6],[16,92,121,10,3514],[42,92,121,36,3515],[48,92,121,42]],[[16,92,122,8,3515],[20,92,122,12,3520],[25,92,122,17],[26,92,123,10],[33,92,123,10],[47,92,125,11],[48,92,123,10],[52,92,123,14,3503],[58,92,124,12],[212,92,123,10],[233,92,123,10]],[[27,92,123,10]],[[32,92,123,10]],[[34,92,123,10]],[[16,92,125,10]],[[12,92,127,6],[19,92,127,13]],[[16,92,128,8,3515],[20,92,128,12,3521],[25,92,128,17]],[[12,92,129,6]],[[12,92,130,6,3499],[39,92,130,33]],[[12,92,131,6,3495],[38,92,131,32,3496]],[[8,92,132,4]],[[4,92,133,2]],[[4,92,135,2,3497],[30,92,135,28,3515]],[[0,92,136,0]],[[0,92,138,0],[81,92,138,81]],[[0,92,139,0],[6,92,139,6,3522],[25,92,139,25]],[[4,92,140,2],[8,92,140,6,3497],[35,92,140,33],[36,92,140,34,3499],[62,92,140,60]],[[8,92,141,4,3497],[32,92,141,28,3521],[37,92,141,33]],[[8,92,142,4,3499],[35,92,142,31]],[[8,92,143,4,3495],[34,92,143,30,3496]],[[4,92,144,2]],[[4,92,145,2,3498],[30,92,145,28]],[[0,92,146,0]],[[0,92,148,0],[48,92,148,48]],[[0,92,149,0],[4,92,149,4,3492],[13,92,149,13,3523],[23,92,149,23],[28,92,149,28],[39,92,149,39]],[[4,92,150,2,3492],[13,92,150,11,3524],[29,92,150,27],[30,92,150,28],[50,92,150,48,3522],[68,92,150,66]],[[0,92,151,0],[7,92,151,7]],[[4,92,152,2],[73,92,152,71]],[[4,92,153,2,3525],[15,92,153,13,3522]],[[0,92,154,0]],[[0,92,156,0],[6,92,156,6,3526],[36,92,156,37,3527],[41,92,156,42,3528],[49,92,156,50],[52,92,156,53,3527],[57,92,156,58,3528],[65,92,156,66],[69,92,156,70],[71,92,156,72]],[[0,92,158,0],[93,92,158,93]],[[0,92,159,0],[46,92,159,46]],[[0,92,160,0,3526],[28,92,160,28,3518],[35,92,160,35],[36,92,160,36,3501]],[[0,92,161,0,3526],[28,92,161,28,3511],[34,92,161,34],[37,92,161,37]],[[0,92,163,0],[97,92,163,97]],[[0,92,164,0,3526],[28,92,164,28,3506],[32,92,164,32],[35,92,164,35,3501]],[[0,92,166,0],[6,92,166,6,3529],[17,92,166,17],[21,92,166,21,3530],[36,92,166,36]],[[4,92,167,2,3531],[11,92,167,8,3532],[21,92,167,18]],[[8,92,168,4,3517],[37,92,168,33,3532]],[[4,92,169,2]],[[0,92,170,0]],[[0,92,171,0],[40,92,171,43]],[[4,92,172,2],[23,92,172,21]],[[4,92,173,2,3529],[13,92,173,11,3536],[17,92,173,15],[20,92,173,18]],[[0,92,174,0]],[[0,92,176,0],[4,92,176,4,3537]],[[0,92,180,0],[4,92,181,2,3533],[12,92,181,10,3534],[15,92,181,13],[16,92,181,14,3535],[24,92,181,22],[29,92,181,27],[45,92,182,2,3533],[53,92,182,10,3534],[56,92,182,13],[57,92,182,14,3538],[83,92,182,40],[87,92,183,2],[94,92,183,9,3539],[105,92,183,20],[118,92,184,2]],[],[[0,92,191,0],[6,92,191,6,3542],[26,92,192,2],[26,92,193,2,3539],[33,92,193,9,3543],[45,92,192,21],[53,92,193,29]],[[0,92,195,0],[4,92,195,4,3544]],[[0,92,196,0],[4,92,196,4,3542],[23,92,196,23]],[[4,92,197,2,3544],[28,92,197,26,3545],[36,92,197,34,3546],[43,92,197,41],[44,92,198,4,3489],[60,92,198,39,3542],[79,92,198,58]],[[8,92,199,6,3547],[20,92,199,6,3547],[35,92,199,6,3547],[45,92,199,16]],[[8,92,200,6,3548],[26,92,200,6,3548],[47,92,200,6,3548],[63,92,200,22]],[[8,92,201,6,3537]],[[4,92,202,4],[8,92,203,4,3549],[12,92,203,8],[13,92,203,9],[20,92,203,16,3550],[48,92,204,4,3551],[49,92,204,4,3551],[52,92,204,4,3551],[71,92,204,4,3551],[115,92,204,48],[117,92,205,6],[123,92,205,12,3542],[142,92,206,6,3550]],[[0,92,209,0],[7,92,209,7]],[[4,92,210,2,3544],[28,92,210,26,3487],[53,92,211,4,3529],[63,92,212,4]],[[8,92,213,6,3547],[20,92,213,6,3547],[35,92,213,6,3547],[45,92,213,16]],[[8,92,214,6,3548],[26,92,214,6,3548],[47,92,214,6,3548],[63,92,214,22]],[[8,92,215,6,3537]],[[8,92,216,6,3552],[19,92,216,17]],[[4,92,217,4]],[[0,92,219,0]],[[0,92,221,0],[9,92,221,9,3553],[20,92,221,20],[22,92,222,2,3554],[39,92,222,19],[41,92,223,2,3555],[52,92,223,13],[54,92,224,2,3556],[63,92,224,11],[65,92,225,2,3557],[85,92,225,22],[87,92,231,1]],[[4,92,232,2],[10,92,232,8,3558],[19,92,232,8,3558],[30,92,232,8,3558],[33,92,233,4],[34,92,233,4],[37,92,233,4],[49,92,233,4],[52,92,233,4],[54,92,233,5,3559],[65,92,233,5,3559],[72,92,233,14],[74,92,233,14]],[[8,92,234,6,3555],[21,92,234,19,3555]],[[8,92,235,6,3560],[26,92,235,24,3554],[44,92,235,42,3561],[45,92,235,43]],[[8,92,236,6,3556],[19,92,236,17,3556]],[[8,92,237,6,3557],[30,92,237,28,3557]],[],[[4,92,241,2],[8,92,241,6,3533],[16,92,241,14,3534],[19,92,241,17],[20,92,241,18,3535],[28,92,241,26],[60,92,241,31],[77,92,241,48,3554],[95,92,241,66,3562],[96,92,241,67],[98,92,241,69]],[[8,92,242,4],[92,92,242,88]],[[8,92,243,4],[88,92,243,84]],[[8,92,244,4],[15,92,244,4],[26,92,244,4],[29,92,245,6],[30,92,245,6],[33,92,245,6],[45,92,245,6],[48,92,245,6],[50,92,245,7,3563],[81,92,245,7,3563],[99,92,245,25],[101,92,245,25]],[[12,92,245,26,3564],[19,92,245,33,3554],[37,92,245,51,3562],[38,92,245,52]],[[22,92,246,9,3558]],[],[[4,92,249,2]],[[4,92,251,2],[11,92,251,9,3558]],[[0,92,252,0]],[[0,92,254,0],[6,92,254,6,3565],[28,92,254,28,3533],[36,92,254,36,3534],[39,92,254,39],[40,92,254,40,3566],[62,92,254,62],[67,92,255,4,3567],[74,92,255,4,3567],[81,92,255,9],[82,92,255,10,3568],[92,92,255,20],[95,92,256,4,3567],[109,92,256,9],[110,92,256,10,3569],[118,92,256,18]],[[0,92,258,0],[9,92,258,9,3570],[14,92,258,14],[16,92,258,16,3571],[24,92,258,24],[26,92,258,55]],[[4,92,259,2],[8,92,259,6,3533],[16,92,259,14,3534],[19,92,259,17],[20,92,259,18,3572],[36,92,259,34],[38,92,259,36]],[],[[4,92,268,2],[11,92,268,9,3571]],[[0,92,269,0]],[[0,92,271,0],[6,92,271,6,3579],[34,92,271,34,3533],[42,92,271,42,3534],[45,92,271,45],[46,92,271,46,3580],[73,92,271,73]],[[0,92,273,0],[9,92,273,9,3581]],[[4,92,274,2],[11,92,274,9],[16,92,274,16]],[[0,92,275,0]],[[0,92,277,0],[6,92,277,6,3582],[25,92,277,53]],[[4,92,278,2,3583],[34,92,278,32,3579],[72,92,280,6,3496],[98,92,281,6,3581]],[[4,92,282,2,3584],[24,92,282,2,3584],[44,92,282,2,3584],[62,92,282,20]],[[4,92,283,2,3585],[19,92,283,2,3585],[43,92,283,2,3585],[56,92,283,15]],[[4,92,284,2,3586],[21,92,284,2,3586],[45,92,284,2,3586],[60,92,284,17]],[[0,92,285,0]],[[0,92,294,7],[15,92,294,22,3486],[23,92,295,2,3587],[43,92,295,57],[45,92,296,2,3588],[56,92,296,21]],[[4,92,298,2],[8,92,298,6,3557]],[[4,92,299,2],[8,92,299,6,3556]],[[4,92,301,2],[8,92,301,6,3533],[16,92,301,14,3534],[19,92,301,17],[20,92,301,18,3535],[28,92,301,26],[33,92,301,31],[44,92,301,45]],[[8,92,302,4],[14,92,302,10],[16,92,302,12,3589],[31,92,302,27],[33,92,302,29],[36,92,303,6,3541],[44,92,303,14]],[[8,92,305,4,3557],[31,92,305,27]],[[12,92,305,29,3590],[22,92,305,39]],[[12,92,305,45,3591],[28,92,305,61]],[[8,92,305,66]],[[8,92,306,4,3556],[20,92,306,16,3589],[36,92,306,32,3588],[49,92,306,45,3557]],[[4,92,307,2]],[[4,92,308,2],[10,92,308,8,3554],[30,92,308,28],[36,92,308,34,3544]],[[4,92,309,2],[73,92,309,71]],[[4,92,310,2],[47,92,310,45]],[[4,92,311,2,3592],[5,92,311,2,3592],[8,92,311,2,3592],[20,92,311,2,3592],[33,92,311,15],[35,92,311,16,3554],[53,92,311,34,3593],[54,92,311,35]],[[4,92,313,2],[10,92,313,8,3594],[29,92,313,27,3595],[34,92,313,32,3577],[37,92,313,35]],[[4,92,314,2],[10,92,314,8,3555],[24,92,314,44,3596],[25,92,314,44,3596],[28,92,314,44,3596],[47,92,314,44,3596],[71,92,314,68],[73,92,315,4,3597],[74,92,315,4,3597],[77,92,315,4,3597],[103,92,315,4,3597],[127,92,315,28],[129,92,315,29]],[[8,92,316,6,3598],[21,92,316,19,3594]],[[8,92,317,6,3599],[27,92,317,25,3554],[45,92,317,43,3600],[46,92,317,44]],[[8,92,318,6,3601],[34,92,318,32,3554],[52,92,318,50,3602],[53,92,318,51]],[[8,92,319,6,3603],[31,92,319,29,3554],[49,92,319,47,3604],[50,92,319,48]],[[8,92,320,6,3605],[18,92,320,16,3539],[25,92,320,23,3605],[33,92,320,31]],[[4,92,321,4],[8,92,322,4,3587]],[[4,92,325,2],[10,92,325,8,3606],[20,92,325,8,3606],[31,92,325,8,3606],[34,92,326,4],[35,92,326,4],[38,92,326,4],[50,92,326,4],[53,92,326,4],[55,92,326,5,3565],[76,92,326,5,3565]],[[18,92,327,6],[29,92,327,6],[32,92,327,6],[33,92,327,6],[36,92,327,6],[48,92,327,6],[51,92,327,6],[53,92,327,7,3607],[86,92,327,7,3607],[104,92,327,25],[105,92,327,26,3608],[113,92,327,34],[115,92,327,34]],[[12,92,327,35,3564],[19,92,327,42]],[[16,92,327,44,3609],[24,92,327,52]],[[12,92,327,57]],[[22,92,328,8],[33,92,328,8],[36,92,328,8],[37,92,328,8],[40,92,328,8],[52,92,328,8],[55,92,328,8],[57,92,328,9,3570],[63,92,328,9,3570]],[[26,92,329,10],[37,92,329,10],[40,92,329,10],[41,92,329,10],[44,92,329,10],[56,92,329,10],[59,92,329,10],[61,92,329,11,3553],[73,92,329,11,3553]],[[20,92,330,12,3554],[39,92,330,31,3554]],[[20,92,331,12,3555],[33,92,331,25,3555]],[[20,92,332,12,3556],[31,92,332,23,3556]],[[20,92,333,12,3557],[42,92,333,34,3557]],[],[],[],[],[[4,92,340,2],[8,92,340,6,3492],[17,92,340,15,3610],[32,92,340,30],[33,92,340,31,3611],[35,92,340,33],[40,92,340,38],[58,92,340,56]],[[8,92,341,4],[12,92,341,8,3612],[22,92,341,18,3606]],[[8,92,342,4],[70,92,342,66]],[[8,92,343,4],[12,92,343,8,3533],[20,92,343,16,3534],[23,92,343,19],[24,92,343,20,3535],[32,92,343,28],[37,92,343,33],[48,92,343,47]],[[12,92,344,6],[18,92,344,12],[20,92,344,14,3613],[46,92,344,40],[48,92,344,42],[51,92,345,8,3541],[59,92,345,16]],[[12,92,347,6],[94,92,347,88]],[[12,92,348,6,3612],[22,92,348,6,3612],[33,92,348,6,3612],[36,92,349,8],[37,92,349,8],[40,92,349,8],[52,92,349,8],[55,92,349,8],[57,92,349,9,3613],[85,92,349,9,3613]],[[26,92,349,37,3612]],[],[[8,92,351,4]],[[8,92,353,4,3614],[16,92,353,4,3614],[23,92,353,18],[24,92,353,19,3615],[34,92,353,29],[35,92,353,30,3491],[47,92,353,42,3582],[65,92,353,60,3616],[71,92,353,66],[72,92,353,67,3612]],[[4,92,354,2],[11,92,354,9]],[[8,92,355,4,3567],[15,92,355,4,3567],[22,92,355,9],[23,92,355,10,3617],[38,92,355,25],[39,92,355,26]],[[12,92,356,6,3614],[20,92,356,6,3614],[27,92,356,20],[28,92,356,21,3618],[39,92,356,32],[40,92,356,33,3491],[52,92,356,45,3606],[61,92,356,54]],[[16,92,357,8],[19,92,357,11,3582],[35,92,357,27]],[[16,92,358,8,3619],[27,92,358,19,3500]],[[12,92,359,6]],[[8,92,360,4]],[[4,92,361,2]],[[4,92,363,2],[77,92,363,75]],[[4,92,364,2],[8,92,364,6,3533],[16,92,364,14,3534],[19,92,364,17],[20,92,364,18,3535],[28,92,364,26],[33,92,364,31],[44,92,364,45]],[[8,92,365,4],[14,92,365,10],[16,92,365,12,3620],[22,92,365,18],[24,92,365,20],[27,92,366,6,3541],[35,92,366,14]],[[8,92,367,4,3620]],[[4,92,368,2]],[[0,92,369,0]],[],[],[],[],[],[],[],[],[],[],[],[[0,93,14,8,3631],[8,93,14,16,3632],[11,93,14,19],[12,93,14,20,3633],[20,93,14,28],[25,93,14,33]],[],[],[],[],[[30,93,0,29]],[[36,93,1,35]],[[0,93,3,0,3621],[7,93,3,7,3622],[11,93,3,11],[12,93,3,12,3623],[21,93,3,21],[24,93,3,24]],[[0,93,4,2,3624],[5,93,4,15,3625],[21,93,4,31],[24,93,4,34]],[[0,93,6,0],[62,93,6,62]],[[0,93,7,0],[6,93,7,6,3626],[29,93,7,29,3627],[37,93,7,37]],[[0,93,9,0,3628],[1,93,9,0,3628],[4,93,9,0,3628],[18,93,9,0,3628],[30,93,9,12],[32,93,9,13],[33,93,9,14,3629]],[[4,93,10,2],[10,93,10,8],[12,93,10,10,3630],[19,93,10,17],[21,93,10,19],[24,93,10,22,3627],[32,93,10,30]],[[4,93,11,2],[8,93,11,6]],[[8,93,12,4,3630],[16,93,12,12,3626],[38,93,12,34,3629]],[[4,93,13,2],[13,93,13,12]],[[8,93,14,4],[48,93,14,47]],[[12,93,15,6],[18,93,15,12,3634],[41,93,15,35,3631],[49,93,15,43,3632],[52,93,15,46],[53,93,15,47,3635],[76,93,15,70]],[[12,93,16,6],[18,93,16,12],[20,93,16,14,3636],[33,93,16,27],[35,93,16,29],[38,93,17,8,3627],[46,93,17,16]],[[12,93,18,6],[18,93,18,12],[20,93,18,14,3637],[39,93,18,33],[41,93,18,35],[44,93,19,8,3627],[52,93,19,16]],[[12,93,20,6,3637],[32,93,21,8,3636],[47,93,22,8,3638],[67,93,22,8,3638],[85,93,22,26],[87,93,23,8,3634]],[[8,93,25,4]],[[4,93,26,2]],[[0,93,27,0]]]}}