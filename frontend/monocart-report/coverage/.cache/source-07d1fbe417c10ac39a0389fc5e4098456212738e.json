{"id":"07d1fbe417c10ac39a0389fc5e4098456212738e","url":"http://localhost:3000/_next/static/chunks/turbopack-_23a915ee._.js","source":"(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([\n    typeof document === \"object\" ? document.currentScript : undefined,\n    {\"otherChunks\":[\"static/chunks/[turbopack]_browser_dev_hmr-client_hmr-client_ts_956a0d3a._.js\",\"static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js\",\"static/chunks/node_modules_next_dist_compiled_react-server-dom-turbopack_9212ccad._.js\",\"static/chunks/node_modules_next_dist_compiled_next-devtools_index_1dd7fb59.js\",\"static/chunks/node_modules_next_dist_compiled_a0e4c7b4._.js\",\"static/chunks/node_modules_next_dist_client_17643121._.js\",\"static/chunks/node_modules_next_dist_f3530cac._.js\",\"static/chunks/node_modules_@swc_helpers_cjs_d80fb378._.js\"],\"runtimeModuleIds\":[\"[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js [app-client] (ecmascript)\",\"[project]/node_modules/next/dist/client/app-next-turbopack.js [app-client] (ecmascript)\"]}\n]);\n(() => {\nif (!Array.isArray(globalThis.TURBOPACK)) {\n    return;\n}\n\nconst CHUNK_BASE_PATH = \"/_next/\";\nconst RELATIVE_ROOT_PATH = \"/ROOT\";\nconst RUNTIME_PUBLIC_PATH = \"/_next/\";\nconst CHUNK_SUFFIX = (self.TURBOPACK_CHUNK_SUFFIX ?? document?.currentScript?.getAttribute?.('src')?.replace(/^(.*(?=\\?)|^.*$)/, \"\")) || \"\";\n/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"./runtime-types.d.ts\" />\nconst REEXPORTED_OBJECTS = new WeakMap();\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */ function Context(module, exports) {\n    this.m = module;\n    // We need to store this here instead of accessing it from the module object to:\n    // 1. Make it available to factories directly, since we rewrite `this` to\n    //    `__turbopack_context__.e` in CJS modules.\n    // 2. Support async modules which rewrite `module.exports` to a promise, so we\n    //    can still access the original exports object from functions like\n    //    `esmExport`\n    // Ideally we could find a new approach for async modules and drop this property altogether.\n    this.e = exports;\n}\nconst contextPrototype = Context.prototype;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag;\nfunction defineProp(obj, name, options) {\n    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);\n}\nfunction getOverwrittenModule(moduleCache, id) {\n    let module = moduleCache[id];\n    if (!module) {\n        // This is invoked when a module is merged into another module, thus it wasn't invoked via\n        // instantiateModule and the cache entry wasn't created yet.\n        module = createModuleObject(id);\n        moduleCache[id] = module;\n    }\n    return module;\n}\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */ function createModuleObject(id) {\n    return {\n        exports: {},\n        error: undefined,\n        id,\n        namespaceObject: undefined\n    };\n}\nconst BindingTag_Value = 0;\n/**\n * Adds the getters to the exports object.\n */ function esm(exports, bindings) {\n    defineProp(exports, '__esModule', {\n        value: true\n    });\n    if (toStringTag) defineProp(exports, toStringTag, {\n        value: 'Module'\n    });\n    let i = 0;\n    while(i < bindings.length){\n        const propName = bindings[i++];\n        const tagOrFunction = bindings[i++];\n        if (typeof tagOrFunction === 'number') {\n            if (tagOrFunction === BindingTag_Value) {\n                defineProp(exports, propName, {\n                    value: bindings[i++],\n                    enumerable: true,\n                    writable: false\n                });\n            } else {\n                throw new Error(`unexpected tag: ${tagOrFunction}`);\n            }\n        } else {\n            const getterFn = tagOrFunction;\n            if (typeof bindings[i] === 'function') {\n                const setterFn = bindings[i++];\n                defineProp(exports, propName, {\n                    get: getterFn,\n                    set: setterFn,\n                    enumerable: true\n                });\n            } else {\n                defineProp(exports, propName, {\n                    get: getterFn,\n                    enumerable: true\n                });\n            }\n        }\n    }\n    Object.seal(exports);\n}\n/**\n * Makes the module an ESM with exports\n */ function esmExport(bindings, id) {\n    let module;\n    let exports;\n    if (id != null) {\n        module = getOverwrittenModule(this.c, id);\n        exports = module.exports;\n    } else {\n        module = this.m;\n        exports = this.e;\n    }\n    module.namespaceObject = exports;\n    esm(exports, bindings);\n}\ncontextPrototype.s = esmExport;\nfunction ensureDynamicExports(module, exports) {\n    let reexportedObjects = REEXPORTED_OBJECTS.get(module);\n    if (!reexportedObjects) {\n        REEXPORTED_OBJECTS.set(module, reexportedObjects = []);\n        module.exports = module.namespaceObject = new Proxy(exports, {\n            get (target, prop) {\n                if (hasOwnProperty.call(target, prop) || prop === 'default' || prop === '__esModule') {\n                    return Reflect.get(target, prop);\n                }\n                for (const obj of reexportedObjects){\n                    const value = Reflect.get(obj, prop);\n                    if (value !== undefined) return value;\n                }\n                return undefined;\n            },\n            ownKeys (target) {\n                const keys = Reflect.ownKeys(target);\n                for (const obj of reexportedObjects){\n                    for (const key of Reflect.ownKeys(obj)){\n                        if (key !== 'default' && !keys.includes(key)) keys.push(key);\n                    }\n                }\n                return keys;\n            }\n        });\n    }\n    return reexportedObjects;\n}\n/**\n * Dynamically exports properties from an object\n */ function dynamicExport(object, id) {\n    let module;\n    let exports;\n    if (id != null) {\n        module = getOverwrittenModule(this.c, id);\n        exports = module.exports;\n    } else {\n        module = this.m;\n        exports = this.e;\n    }\n    const reexportedObjects = ensureDynamicExports(module, exports);\n    if (typeof object === 'object' && object !== null) {\n        reexportedObjects.push(object);\n    }\n}\ncontextPrototype.j = dynamicExport;\nfunction exportValue(value, id) {\n    let module;\n    if (id != null) {\n        module = getOverwrittenModule(this.c, id);\n    } else {\n        module = this.m;\n    }\n    module.exports = value;\n}\ncontextPrototype.v = exportValue;\nfunction exportNamespace(namespace, id) {\n    let module;\n    if (id != null) {\n        module = getOverwrittenModule(this.c, id);\n    } else {\n        module = this.m;\n    }\n    module.exports = module.namespaceObject = namespace;\n}\ncontextPrototype.n = exportNamespace;\nfunction createGetter(obj, key) {\n    return ()=>obj[key];\n}\n/**\n * @returns prototype of the object\n */ const getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;\n/** Prototypes that are not expanded for exports */ const LEAF_PROTOTYPES = [\n    null,\n    getProto({}),\n    getProto([]),\n    getProto(getProto)\n];\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */ function interopEsm(raw, ns, allowExportDefault) {\n    const bindings = [];\n    let defaultLocation = -1;\n    for(let current = raw; (typeof current === 'object' || typeof current === 'function') && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){\n        for (const key of Object.getOwnPropertyNames(current)){\n            bindings.push(key, createGetter(raw, key));\n            if (defaultLocation === -1 && key === 'default') {\n                defaultLocation = bindings.length - 1;\n            }\n        }\n    }\n    // this is not really correct\n    // we should set the `default` getter if the imported module is a `.cjs file`\n    if (!(allowExportDefault && defaultLocation >= 0)) {\n        // Replace the binding with one for the namespace itself in order to preserve iteration order.\n        if (defaultLocation >= 0) {\n            // Replace the getter with the value\n            bindings.splice(defaultLocation, 1, BindingTag_Value, raw);\n        } else {\n            bindings.push('default', BindingTag_Value, raw);\n        }\n    }\n    esm(ns, bindings);\n    return ns;\n}\nfunction createNS(raw) {\n    if (typeof raw === 'function') {\n        return function(...args) {\n            return raw.apply(this, args);\n        };\n    } else {\n        return Object.create(null);\n    }\n}\nfunction esmImport(id) {\n    const module = getOrInstantiateModuleFromParent(id, this.m);\n    // any ES module has to have `module.namespaceObject` defined.\n    if (module.namespaceObject) return module.namespaceObject;\n    // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n    const raw = module.exports;\n    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);\n}\ncontextPrototype.i = esmImport;\nfunction asyncLoader(moduleId) {\n    const loader = this.r(moduleId);\n    return loader(esmImport.bind(this));\n}\ncontextPrototype.A = asyncLoader;\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire = // @ts-ignore\ntypeof require === 'function' ? require : function require1() {\n    throw new Error('Unexpected use of runtime require');\n};\ncontextPrototype.t = runtimeRequire;\nfunction commonJsRequire(id) {\n    return getOrInstantiateModuleFromParent(id, this.m).exports;\n}\ncontextPrototype.r = commonJsRequire;\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */ function parseRequest(request) {\n    // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n    // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n    const hashIndex = request.indexOf('#');\n    if (hashIndex !== -1) {\n        request = request.substring(0, hashIndex);\n    }\n    const queryIndex = request.indexOf('?');\n    if (queryIndex !== -1) {\n        request = request.substring(0, queryIndex);\n    }\n    return request;\n}\n/**\n * `require.context` and require/import expression runtime.\n */ function moduleContext(map) {\n    function moduleContext(id) {\n        id = parseRequest(id);\n        if (hasOwnProperty.call(map, id)) {\n            return map[id].module();\n        }\n        const e = new Error(`Cannot find module '${id}'`);\n        e.code = 'MODULE_NOT_FOUND';\n        throw e;\n    }\n    moduleContext.keys = ()=>{\n        return Object.keys(map);\n    };\n    moduleContext.resolve = (id)=>{\n        id = parseRequest(id);\n        if (hasOwnProperty.call(map, id)) {\n            return map[id].id();\n        }\n        const e = new Error(`Cannot find module '${id}'`);\n        e.code = 'MODULE_NOT_FOUND';\n        throw e;\n    };\n    moduleContext.import = async (id)=>{\n        return await moduleContext(id);\n    };\n    return moduleContext;\n}\ncontextPrototype.f = moduleContext;\n/**\n * Returns the path of a chunk defined by its data.\n */ function getChunkPath(chunkData) {\n    return typeof chunkData === 'string' ? chunkData : chunkData.path;\n}\nfunction isPromise(maybePromise) {\n    return maybePromise != null && typeof maybePromise === 'object' && 'then' in maybePromise && typeof maybePromise.then === 'function';\n}\nfunction isAsyncModuleExt(obj) {\n    return turbopackQueues in obj;\n}\nfunction createPromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        reject = rej;\n        resolve = res;\n    });\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(chunkModules, offset, moduleFactories, newModuleId) {\n    let i = offset;\n    while(i < chunkModules.length){\n        let moduleId = chunkModules[i];\n        let end = i + 1;\n        // Find our factory function\n        while(end < chunkModules.length && typeof chunkModules[end] !== 'function'){\n            end++;\n        }\n        if (end === chunkModules.length) {\n            throw new Error('malformed chunk format, expected a factory function');\n        }\n        // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n        // present we know all the additional ids are also present, so we don't need to check.\n        if (!moduleFactories.has(moduleId)) {\n            const moduleFactoryFn = chunkModules[end];\n            applyModuleFactoryName(moduleFactoryFn);\n            newModuleId?.(moduleId);\n            for(; i < end; i++){\n                moduleId = chunkModules[i];\n                moduleFactories.set(moduleId, moduleFactoryFn);\n            }\n        }\n        i = end + 1; // end is pointing at the last factory advance to the next id or the end of the array.\n    }\n}\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\nconst turbopackQueues = Symbol('turbopack queues');\nconst turbopackExports = Symbol('turbopack exports');\nconst turbopackError = Symbol('turbopack error');\nfunction resolveQueue(queue) {\n    if (queue && queue.status !== 1) {\n        queue.status = 1;\n        queue.forEach((fn)=>fn.queueCount--);\n        queue.forEach((fn)=>fn.queueCount-- ? fn.queueCount++ : fn());\n    }\n}\nfunction wrapDeps(deps) {\n    return deps.map((dep)=>{\n        if (dep !== null && typeof dep === 'object') {\n            if (isAsyncModuleExt(dep)) return dep;\n            if (isPromise(dep)) {\n                const queue = Object.assign([], {\n                    status: 0\n                });\n                const obj = {\n                    [turbopackExports]: {},\n                    [turbopackQueues]: (fn)=>fn(queue)\n                };\n                dep.then((res)=>{\n                    obj[turbopackExports] = res;\n                    resolveQueue(queue);\n                }, (err)=>{\n                    obj[turbopackError] = err;\n                    resolveQueue(queue);\n                });\n                return obj;\n            }\n        }\n        return {\n            [turbopackExports]: dep,\n            [turbopackQueues]: ()=>{}\n        };\n    });\n}\nfunction asyncModule(body, hasAwait) {\n    const module = this.m;\n    const queue = hasAwait ? Object.assign([], {\n        status: -1\n    }) : undefined;\n    const depQueues = new Set();\n    const { resolve, reject, promise: rawPromise } = createPromise();\n    const promise = Object.assign(rawPromise, {\n        [turbopackExports]: module.exports,\n        [turbopackQueues]: (fn)=>{\n            queue && fn(queue);\n            depQueues.forEach(fn);\n            promise['catch'](()=>{});\n        }\n    });\n    const attributes = {\n        get () {\n            return promise;\n        },\n        set (v) {\n            // Calling `esmExport` leads to this.\n            if (v !== promise) {\n                promise[turbopackExports] = v;\n            }\n        }\n    };\n    Object.defineProperty(module, 'exports', attributes);\n    Object.defineProperty(module, 'namespaceObject', attributes);\n    function handleAsyncDependencies(deps) {\n        const currentDeps = wrapDeps(deps);\n        const getResult = ()=>currentDeps.map((d)=>{\n                if (d[turbopackError]) throw d[turbopackError];\n                return d[turbopackExports];\n            });\n        const { promise, resolve } = createPromise();\n        const fn = Object.assign(()=>resolve(getResult), {\n            queueCount: 0\n        });\n        function fnQueue(q) {\n            if (q !== queue && !depQueues.has(q)) {\n                depQueues.add(q);\n                if (q && q.status === 0) {\n                    fn.queueCount++;\n                    q.push(fn);\n                }\n            }\n        }\n        currentDeps.map((dep)=>dep[turbopackQueues](fnQueue));\n        return fn.queueCount ? promise : getResult();\n    }\n    function asyncResult(err) {\n        if (err) {\n            reject(promise[turbopackError] = err);\n        } else {\n            resolve(promise[turbopackExports]);\n        }\n        resolveQueue(queue);\n    }\n    body(handleAsyncDependencies, asyncResult);\n    if (queue && queue.status === -1) {\n        queue.status = 0;\n    }\n}\ncontextPrototype.a = asyncModule;\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */ const relativeURL = function relativeURL(inputUrl) {\n    const realUrl = new URL(inputUrl, 'x:/');\n    const values = {};\n    for(const key in realUrl)values[key] = realUrl[key];\n    values.href = inputUrl;\n    values.pathname = inputUrl.replace(/[?#].*/, '');\n    values.origin = values.protocol = '';\n    values.toString = values.toJSON = (..._args)=>inputUrl;\n    for(const key in values)Object.defineProperty(this, key, {\n        enumerable: true,\n        configurable: true,\n        value: values[key]\n    });\n};\nrelativeURL.prototype = URL.prototype;\ncontextPrototype.U = relativeURL;\n/**\n * Utility function to ensure all variants of an enum are handled.\n */ function invariant(never, computeMessage) {\n    throw new Error(`Invariant: ${computeMessage(never)}`);\n}\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */ function requireStub(_moduleId) {\n    throw new Error('dynamic usage of require is not supported');\n}\ncontextPrototype.z = requireStub;\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis;\nfunction applyModuleFactoryName(factory) {\n    // Give the module factory a nice name to improve stack traces.\n    Object.defineProperty(factory, 'name', {\n        value: 'module evaluation'\n    });\n}\n/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n// Used in WebWorkers to tell the runtime about the chunk base path\nconst browserContextPrototype = Context.prototype;\nvar SourceType = /*#__PURE__*/ function(SourceType) {\n    /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n    /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n    /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */ SourceType[SourceType[\"Update\"] = 2] = \"Update\";\n    return SourceType;\n}(SourceType || {});\nconst moduleFactories = new Map();\ncontextPrototype.M = moduleFactories;\nconst availableModules = new Map();\nconst availableModuleChunks = new Map();\nfunction factoryNotAvailableMessage(moduleId, sourceType, sourceData) {\n    let instantiationReason;\n    switch(sourceType){\n        case 0:\n            instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n            break;\n        case 1:\n            instantiationReason = `because it was required from module ${sourceData}`;\n            break;\n        case 2:\n            instantiationReason = 'because of an HMR update';\n            break;\n        default:\n            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n    }\n    return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`;\n}\nfunction loadChunk(chunkData) {\n    return loadChunkInternal(1, this.m.id, chunkData);\n}\nbrowserContextPrototype.l = loadChunk;\nfunction loadInitialChunk(chunkPath, chunkData) {\n    return loadChunkInternal(0, chunkPath, chunkData);\n}\nasync function loadChunkInternal(sourceType, sourceData, chunkData) {\n    if (typeof chunkData === 'string') {\n        return loadChunkPath(sourceType, sourceData, chunkData);\n    }\n    const includedList = chunkData.included || [];\n    const modulesPromises = includedList.map((included)=>{\n        if (moduleFactories.has(included)) return true;\n        return availableModules.get(included);\n    });\n    if (modulesPromises.length > 0 && modulesPromises.every((p)=>p)) {\n        // When all included items are already loaded or loading, we can skip loading ourselves\n        await Promise.all(modulesPromises);\n        return;\n    }\n    const includedModuleChunksList = chunkData.moduleChunks || [];\n    const moduleChunksPromises = includedModuleChunksList.map((included)=>{\n        // TODO(alexkirsz) Do we need this check?\n        // if (moduleFactories[included]) return true;\n        return availableModuleChunks.get(included);\n    }).filter((p)=>p);\n    let promise;\n    if (moduleChunksPromises.length > 0) {\n        // Some module chunks are already loaded or loading.\n        if (moduleChunksPromises.length === includedModuleChunksList.length) {\n            // When all included module chunks are already loaded or loading, we can skip loading ourselves\n            await Promise.all(moduleChunksPromises);\n            return;\n        }\n        const moduleChunksToLoad = new Set();\n        for (const moduleChunk of includedModuleChunksList){\n            if (!availableModuleChunks.has(moduleChunk)) {\n                moduleChunksToLoad.add(moduleChunk);\n            }\n        }\n        for (const moduleChunkToLoad of moduleChunksToLoad){\n            const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad);\n            availableModuleChunks.set(moduleChunkToLoad, promise);\n            moduleChunksPromises.push(promise);\n        }\n        promise = Promise.all(moduleChunksPromises);\n    } else {\n        promise = loadChunkPath(sourceType, sourceData, chunkData.path);\n        // Mark all included module chunks as loading if they are not already loaded or loading.\n        for (const includedModuleChunk of includedModuleChunksList){\n            if (!availableModuleChunks.has(includedModuleChunk)) {\n                availableModuleChunks.set(includedModuleChunk, promise);\n            }\n        }\n    }\n    for (const included of includedList){\n        if (!availableModules.has(included)) {\n            // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n            // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n            availableModules.set(included, promise);\n        }\n    }\n    await promise;\n}\nconst loadedChunk = Promise.resolve(undefined);\nconst instrumentedBackendLoadChunks = new WeakMap();\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(chunkUrl) {\n    return loadChunkByUrlInternal(1, this.m.id, chunkUrl);\n}\nbrowserContextPrototype.L = loadChunkByUrl;\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(sourceType, sourceData, chunkUrl) {\n    const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl);\n    let entry = instrumentedBackendLoadChunks.get(thenable);\n    if (entry === undefined) {\n        const resolve = instrumentedBackendLoadChunks.set.bind(instrumentedBackendLoadChunks, thenable, loadedChunk);\n        entry = thenable.then(resolve).catch((cause)=>{\n            let loadReason;\n            switch(sourceType){\n                case 0:\n                    loadReason = `as a runtime dependency of chunk ${sourceData}`;\n                    break;\n                case 1:\n                    loadReason = `from module ${sourceData}`;\n                    break;\n                case 2:\n                    loadReason = 'from an HMR update';\n                    break;\n                default:\n                    invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n            }\n            let error = new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${cause ? `: ${cause}` : ''}`, cause ? {\n                cause\n            } : undefined);\n            error.name = 'ChunkLoadError';\n            throw error;\n        });\n        instrumentedBackendLoadChunks.set(thenable, entry);\n    }\n    return entry;\n}\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(sourceType, sourceData, chunkPath) {\n    const url = getChunkRelativeUrl(chunkPath);\n    return loadChunkByUrlInternal(sourceType, sourceData, url);\n}\n/**\n * Returns an absolute url to an asset.\n */ function resolvePathFromModule(moduleId) {\n    const exported = this.r(moduleId);\n    return exported?.default ?? exported;\n}\nbrowserContextPrototype.R = resolvePathFromModule;\n/**\n * no-op for browser\n * @param modulePath\n */ function resolveAbsolutePath(modulePath) {\n    return `/ROOT/${modulePath ?? ''}`;\n}\nbrowserContextPrototype.P = resolveAbsolutePath;\n/**\n * Returns a blob URL for the worker.\n * @param chunks list of chunks to load\n */ function getWorkerBlobURL(chunks) {\n    // It is important to reverse the array so when bootstrapping we can infer what chunk is being\n    // evaluated by poping urls off of this array.  See `getPathFromScript`\n    let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\nself.TURBOPACK_CHUNK_SUFFIX = ${JSON.stringify(CHUNK_SUFFIX)};\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\n    let blob = new Blob([\n        bootstrap\n    ], {\n        type: 'text/javascript'\n    });\n    return URL.createObjectURL(blob);\n}\nbrowserContextPrototype.b = getWorkerBlobURL;\n/**\n * Instantiates a runtime module.\n */ function instantiateRuntimeModule(moduleId, chunkPath) {\n    return instantiateModule(moduleId, 0, chunkPath);\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */ function getChunkRelativeUrl(chunkPath) {\n    return `${CHUNK_BASE_PATH}${chunkPath.split('/').map((p)=>encodeURIComponent(p)).join('/')}${CHUNK_SUFFIX}`;\n}\nfunction getPathFromScript(chunkScript) {\n    if (typeof chunkScript === 'string') {\n        return chunkScript;\n    }\n    const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined' ? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute('src');\n    const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''));\n    const path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\n    return path;\n}\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */ function isJs(chunkUrlOrPath) {\n    return regexJsUrl.test(chunkUrlOrPath);\n}\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\n/**\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n */ function isCss(chunkUrl) {\n    return regexCssUrl.test(chunkUrl);\n}\nfunction loadWebAssembly(chunkPath, edgeModule, importsObj) {\n    return BACKEND.loadWebAssembly(1, this.m.id, chunkPath, edgeModule, importsObj);\n}\ncontextPrototype.w = loadWebAssembly;\nfunction loadWebAssemblyModule(chunkPath, edgeModule) {\n    return BACKEND.loadWebAssemblyModule(1, this.m.id, chunkPath, edgeModule);\n}\ncontextPrototype.u = loadWebAssemblyModule;\n/// <reference path=\"./dev-globals.d.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\nconst devContextPrototype = Context.prototype;\n/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ const devModuleCache = Object.create(null);\ndevContextPrototype.c = devModuleCache;\nclass UpdateApplyError extends Error {\n    name = 'UpdateApplyError';\n    dependencyChain;\n    constructor(message, dependencyChain){\n        super(message);\n        this.dependencyChain = dependencyChain;\n    }\n}\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */ const runtimeModules = new Set();\n/**\n * Map from module ID to the chunks that contain this module.\n *\n * In HMR, we need to keep track of which modules are contained in which so\n * chunks. This is so we don't eagerly dispose of a module when it is removed\n * from chunk A, but still exists in chunk B.\n */ const moduleChunksMap = new Map();\n/**\n * Map from a chunk path to all modules it contains.\n */ const chunkModulesMap = new Map();\n/**\n * Chunk lists that contain a runtime. When these chunk lists receive an update\n * that can't be reconciled with the current state of the page, we need to\n * reload the runtime entirely.\n */ const runtimeChunkLists = new Set();\n/**\n * Map from a chunk list to the chunk paths it contains.\n */ const chunkListChunksMap = new Map();\n/**\n * Map from a chunk path to the chunk lists it belongs to.\n */ const chunkChunkListsMap = new Map();\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */ const moduleHotData = new Map();\n/**\n * Maps module instances to their hot module state.\n */ const moduleHotState = new Map();\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */ const queuedInvalidatedModules = new Set();\n/**\n * Gets or instantiates a runtime module.\n */ // @ts-ignore\nfunction getOrInstantiateRuntimeModule(chunkPath, moduleId) {\n    const module = devModuleCache[moduleId];\n    if (module) {\n        if (module.error) {\n            throw module.error;\n        }\n        return module;\n    }\n    // @ts-ignore\n    return instantiateModule(moduleId, SourceType.Runtime, chunkPath);\n}\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */ // @ts-ignore Defined in `runtime-utils.ts`\nconst getOrInstantiateModuleFromParent = (id, sourceModule)=>{\n    if (!sourceModule.hot.active) {\n        console.warn(`Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`);\n    }\n    const module = devModuleCache[id];\n    if (sourceModule.children.indexOf(id) === -1) {\n        sourceModule.children.push(id);\n    }\n    if (module) {\n        if (module.error) {\n            throw module.error;\n        }\n        if (module.parents.indexOf(sourceModule.id) === -1) {\n            module.parents.push(sourceModule.id);\n        }\n        return module;\n    }\n    return instantiateModule(id, SourceType.Parent, sourceModule.id);\n};\nfunction DevContext(module, exports, refresh) {\n    Context.call(this, module, exports);\n    this.k = refresh;\n}\nDevContext.prototype = Context.prototype;\nfunction instantiateModule(moduleId, sourceType, sourceData) {\n    // We are in development, this is always a string.\n    let id = moduleId;\n    const moduleFactory = moduleFactories.get(id);\n    if (typeof moduleFactory !== 'function') {\n        // This can happen if modules incorrectly handle HMR disposes/updates,\n        // e.g. when they keep a `setTimeout` around which still executes old code\n        // and contains e.g. a `require(\"something\")` call.\n        throw new Error(factoryNotAvailableMessage(id, sourceType, sourceData) + ' It might have been deleted in an HMR update.');\n    }\n    const hotData = moduleHotData.get(id);\n    const { hot, hotState } = createModuleHot(id, hotData);\n    let parents;\n    switch(sourceType){\n        case SourceType.Runtime:\n            runtimeModules.add(id);\n            parents = [];\n            break;\n        case SourceType.Parent:\n            // No need to add this module as a child of the parent module here, this\n            // has already been taken care of in `getOrInstantiateModuleFromParent`.\n            parents = [\n                sourceData\n            ];\n            break;\n        case SourceType.Update:\n            parents = sourceData || [];\n            break;\n        default:\n            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n    }\n    const module = createModuleObject(id);\n    const exports = module.exports;\n    module.parents = parents;\n    module.children = [];\n    module.hot = hot;\n    devModuleCache[id] = module;\n    moduleHotState.set(module, hotState);\n    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n    try {\n        runModuleExecutionHooks(module, (refresh)=>{\n            const context = new DevContext(module, exports, refresh);\n            moduleFactory(context, module, exports);\n        });\n    } catch (error) {\n        module.error = error;\n        throw error;\n    }\n    if (module.namespaceObject && module.exports !== module.namespaceObject) {\n        // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n        interopEsm(module.exports, module.namespaceObject);\n    }\n    return module;\n}\nconst DUMMY_REFRESH_CONTEXT = {\n    register: (_type, _id)=>{},\n    signature: ()=>(_type)=>{},\n    registerExports: (_module, _helpers)=>{}\n};\n/**\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n * Next.js' React Refresh runtime hooks into to add module context to the\n * refresh registry.\n */ function runModuleExecutionHooks(module, executeModule) {\n    if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\n        const cleanupReactRefreshIntercept = globalThis.$RefreshInterceptModuleExecution$(module.id);\n        try {\n            executeModule({\n                register: globalThis.$RefreshReg$,\n                signature: globalThis.$RefreshSig$,\n                registerExports: registerExportsAndSetupBoundaryForReactRefresh\n            });\n        } finally{\n            // Always cleanup the intercept, even if module execution failed.\n            cleanupReactRefreshIntercept();\n        }\n    } else {\n        // If the react refresh hooks are not installed we need to bind dummy functions.\n        // This is expected when running in a Web Worker.  It is also common in some of\n        // our test environments.\n        executeModule(DUMMY_REFRESH_CONTEXT);\n    }\n}\n/**\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n */ function registerExportsAndSetupBoundaryForReactRefresh(module, helpers) {\n    const currentExports = module.exports;\n    const prevExports = module.hot.data.prevExports ?? null;\n    helpers.registerExportsForReactRefresh(currentExports, module.id);\n    // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n    if (helpers.isReactRefreshBoundary(currentExports)) {\n        // Save the previous exports on update, so we can compare the boundary\n        // signatures.\n        module.hot.dispose((data)=>{\n            data.prevExports = currentExports;\n        });\n        // Unconditionally accept an update to this module, we'll check if it's\n        // still a Refresh Boundary later.\n        module.hot.accept();\n        // This field is set when the previous version of this module was a\n        // Refresh Boundary, letting us know we need to check for invalidation or\n        // enqueue an update.\n        if (prevExports !== null) {\n            // A boundary can become ineligible if its exports are incompatible\n            // with the previous exports.\n            //\n            // For example, if you add/remove/change exports, we'll want to\n            // re-execute the importing modules, and force those components to\n            // re-render. Similarly, if you convert a class component to a\n            // function, we want to invalidate the boundary.\n            if (helpers.shouldInvalidateReactRefreshBoundary(helpers.getRefreshBoundarySignature(prevExports), helpers.getRefreshBoundarySignature(currentExports))) {\n                module.hot.invalidate();\n            } else {\n                helpers.scheduleUpdate();\n            }\n        }\n    } else {\n        // Since we just executed the code for the module, it's possible that the\n        // new exports made it ineligible for being a boundary.\n        // We only care about the case when we were _previously_ a boundary,\n        // because we already accepted this update (accidental side effect).\n        const isNoLongerABoundary = prevExports !== null;\n        if (isNoLongerABoundary) {\n            module.hot.invalidate();\n        }\n    }\n}\nfunction formatDependencyChain(dependencyChain) {\n    return `Dependency chain: ${dependencyChain.join(' -> ')}`;\n}\nfunction computeOutdatedModules(added, modified) {\n    const newModuleFactories = new Map();\n    for (const [moduleId, entry] of added){\n        if (entry != null) {\n            newModuleFactories.set(moduleId, _eval(entry));\n        }\n    }\n    const outdatedModules = computedInvalidatedModules(modified.keys());\n    for (const [moduleId, entry] of modified){\n        newModuleFactories.set(moduleId, _eval(entry));\n    }\n    return {\n        outdatedModules,\n        newModuleFactories\n    };\n}\nfunction computedInvalidatedModules(invalidated) {\n    const outdatedModules = new Set();\n    for (const moduleId of invalidated){\n        const effect = getAffectedModuleEffects(moduleId);\n        switch(effect.type){\n            case 'unaccepted':\n                throw new UpdateApplyError(`cannot apply update: unaccepted module. ${formatDependencyChain(effect.dependencyChain)}.`, effect.dependencyChain);\n            case 'self-declined':\n                throw new UpdateApplyError(`cannot apply update: self-declined module. ${formatDependencyChain(effect.dependencyChain)}.`, effect.dependencyChain);\n            case 'accepted':\n                for (const outdatedModuleId of effect.outdatedModules){\n                    outdatedModules.add(outdatedModuleId);\n                }\n                break;\n            // TODO(alexkirsz) Dependencies: handle dependencies effects.\n            default:\n                invariant(effect, (effect)=>`Unknown effect type: ${effect?.type}`);\n        }\n    }\n    return outdatedModules;\n}\nfunction computeOutdatedSelfAcceptedModules(outdatedModules) {\n    const outdatedSelfAcceptedModules = [];\n    for (const moduleId of outdatedModules){\n        const module = devModuleCache[moduleId];\n        const hotState = moduleHotState.get(module);\n        if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n            outdatedSelfAcceptedModules.push({\n                moduleId,\n                errorHandler: hotState.selfAccepted\n            });\n        }\n    }\n    return outdatedSelfAcceptedModules;\n}\n/**\n * Adds, deletes, and moves modules between chunks. This must happen before the\n * dispose phase as it needs to know which modules were removed from all chunks,\n * which we can only compute *after* taking care of added and moved modules.\n */ function updateChunksPhase(chunksAddedModules, chunksDeletedModules) {\n    for (const [chunkPath, addedModuleIds] of chunksAddedModules){\n        for (const moduleId of addedModuleIds){\n            addModuleToChunk(moduleId, chunkPath);\n        }\n    }\n    const disposedModules = new Set();\n    for (const [chunkPath, addedModuleIds] of chunksDeletedModules){\n        for (const moduleId of addedModuleIds){\n            if (removeModuleFromChunk(moduleId, chunkPath)) {\n                disposedModules.add(moduleId);\n            }\n        }\n    }\n    return {\n        disposedModules\n    };\n}\nfunction disposePhase(outdatedModules, disposedModules) {\n    for (const moduleId of outdatedModules){\n        disposeModule(moduleId, 'replace');\n    }\n    for (const moduleId of disposedModules){\n        disposeModule(moduleId, 'clear');\n    }\n    // Removing modules from the module cache is a separate step.\n    // We also want to keep track of previous parents of the outdated modules.\n    const outdatedModuleParents = new Map();\n    for (const moduleId of outdatedModules){\n        const oldModule = devModuleCache[moduleId];\n        outdatedModuleParents.set(moduleId, oldModule?.parents);\n        delete devModuleCache[moduleId];\n    }\n    // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n    // children.\n    return {\n        outdatedModuleParents\n    };\n}\n/**\n * Disposes of an instance of a module.\n *\n * Returns the persistent hot data that should be kept for the next module\n * instance.\n *\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\n * This must be done in a separate step afterwards.\n * This is important because all modules need to be disposed to update the\n * parent/child relationships before they are actually removed from the devModuleCache.\n * If this was done in this method, the following disposeModule calls won't find\n * the module from the module id in the cache.\n */ function disposeModule(moduleId, mode) {\n    const module = devModuleCache[moduleId];\n    if (!module) {\n        return;\n    }\n    const hotState = moduleHotState.get(module);\n    const data = {};\n    // Run the `hot.dispose` handler, if any, passing in the persistent\n    // `hot.data` object.\n    for (const disposeHandler of hotState.disposeHandlers){\n        disposeHandler(data);\n    }\n    // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n    // module is still importing other modules.\n    module.hot.active = false;\n    moduleHotState.delete(module);\n    // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n    // Remove the disposed module from its children's parent list.\n    // It will be added back once the module re-instantiates and imports its\n    // children again.\n    for (const childId of module.children){\n        const child = devModuleCache[childId];\n        if (!child) {\n            continue;\n        }\n        const idx = child.parents.indexOf(module.id);\n        if (idx >= 0) {\n            child.parents.splice(idx, 1);\n        }\n    }\n    switch(mode){\n        case 'clear':\n            delete devModuleCache[module.id];\n            moduleHotData.delete(module.id);\n            break;\n        case 'replace':\n            moduleHotData.set(module.id, data);\n            break;\n        default:\n            invariant(mode, (mode)=>`invalid mode: ${mode}`);\n    }\n}\nfunction applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError) {\n    // Update module factories.\n    for (const [moduleId, factory] of newModuleFactories.entries()){\n        applyModuleFactoryName(factory);\n        moduleFactories.set(moduleId, factory);\n    }\n    // TODO(alexkirsz) Run new runtime entries here.\n    // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n    // Re-instantiate all outdated self-accepted modules.\n    for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules){\n        try {\n            instantiateModule(moduleId, SourceType.Update, outdatedModuleParents.get(moduleId));\n        } catch (err) {\n            if (typeof errorHandler === 'function') {\n                try {\n                    errorHandler(err, {\n                        moduleId,\n                        module: devModuleCache[moduleId]\n                    });\n                } catch (err2) {\n                    reportError(err2);\n                    reportError(err);\n                }\n            } else {\n                reportError(err);\n            }\n        }\n    }\n}\nfunction applyUpdate(update) {\n    switch(update.type){\n        case 'ChunkListUpdate':\n            applyChunkListUpdate(update);\n            break;\n        default:\n            invariant(update, (update)=>`Unknown update type: ${update.type}`);\n    }\n}\nfunction applyChunkListUpdate(update) {\n    if (update.merged != null) {\n        for (const merged of update.merged){\n            switch(merged.type){\n                case 'EcmascriptMergedUpdate':\n                    applyEcmascriptMergedUpdate(merged);\n                    break;\n                default:\n                    invariant(merged, (merged)=>`Unknown merged type: ${merged.type}`);\n            }\n        }\n    }\n    if (update.chunks != null) {\n        for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks)){\n            const chunkUrl = getChunkRelativeUrl(chunkPath);\n            switch(chunkUpdate.type){\n                case 'added':\n                    BACKEND.loadChunkCached(SourceType.Update, chunkUrl);\n                    break;\n                case 'total':\n                    DEV_BACKEND.reloadChunk?.(chunkUrl);\n                    break;\n                case 'deleted':\n                    DEV_BACKEND.unloadChunk?.(chunkUrl);\n                    break;\n                case 'partial':\n                    invariant(chunkUpdate.instruction, (instruction)=>`Unknown partial instruction: ${JSON.stringify(instruction)}.`);\n                    break;\n                default:\n                    invariant(chunkUpdate, (chunkUpdate)=>`Unknown chunk update type: ${chunkUpdate.type}`);\n            }\n        }\n    }\n}\nfunction applyEcmascriptMergedUpdate(update) {\n    const { entries = {}, chunks = {} } = update;\n    const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(entries, chunks);\n    const { outdatedModules, newModuleFactories } = computeOutdatedModules(added, modified);\n    const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted);\n    applyInternal(outdatedModules, disposedModules, newModuleFactories);\n}\nfunction applyInvalidatedModules(outdatedModules) {\n    if (queuedInvalidatedModules.size > 0) {\n        computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId)=>{\n            outdatedModules.add(moduleId);\n        });\n        queuedInvalidatedModules.clear();\n    }\n    return outdatedModules;\n}\nfunction applyInternal(outdatedModules, disposedModules, newModuleFactories) {\n    outdatedModules = applyInvalidatedModules(outdatedModules);\n    const outdatedSelfAcceptedModules = computeOutdatedSelfAcceptedModules(outdatedModules);\n    const { outdatedModuleParents } = disposePhase(outdatedModules, disposedModules);\n    // we want to continue on error and only throw the error after we tried applying all updates\n    let error;\n    function reportError(err) {\n        if (!error) error = err;\n    }\n    applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError);\n    if (error) {\n        throw error;\n    }\n    if (queuedInvalidatedModules.size > 0) {\n        applyInternal(new Set(), [], new Map());\n    }\n}\nfunction computeChangedModules(entries, updates) {\n    const chunksAdded = new Map();\n    const chunksDeleted = new Map();\n    const added = new Map();\n    const modified = new Map();\n    const deleted = new Set();\n    for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates)){\n        switch(mergedChunkUpdate.type){\n            case 'added':\n                {\n                    const updateAdded = new Set(mergedChunkUpdate.modules);\n                    for (const moduleId of updateAdded){\n                        added.set(moduleId, entries[moduleId]);\n                    }\n                    chunksAdded.set(chunkPath, updateAdded);\n                    break;\n                }\n            case 'deleted':\n                {\n                    // We could also use `mergedChunkUpdate.modules` here.\n                    const updateDeleted = new Set(chunkModulesMap.get(chunkPath));\n                    for (const moduleId of updateDeleted){\n                        deleted.add(moduleId);\n                    }\n                    chunksDeleted.set(chunkPath, updateDeleted);\n                    break;\n                }\n            case 'partial':\n                {\n                    const updateAdded = new Set(mergedChunkUpdate.added);\n                    const updateDeleted = new Set(mergedChunkUpdate.deleted);\n                    for (const moduleId of updateAdded){\n                        added.set(moduleId, entries[moduleId]);\n                    }\n                    for (const moduleId of updateDeleted){\n                        deleted.add(moduleId);\n                    }\n                    chunksAdded.set(chunkPath, updateAdded);\n                    chunksDeleted.set(chunkPath, updateDeleted);\n                    break;\n                }\n            default:\n                invariant(mergedChunkUpdate, (mergedChunkUpdate)=>`Unknown merged chunk update type: ${mergedChunkUpdate.type}`);\n        }\n    }\n    // If a module was added from one chunk and deleted from another in the same update,\n    // consider it to be modified, as it means the module was moved from one chunk to another\n    // AND has new code in a single update.\n    for (const moduleId of added.keys()){\n        if (deleted.has(moduleId)) {\n            added.delete(moduleId);\n            deleted.delete(moduleId);\n        }\n    }\n    for (const [moduleId, entry] of Object.entries(entries)){\n        // Modules that haven't been added to any chunk but have new code are considered\n        // to be modified.\n        // This needs to be under the previous loop, as we need it to get rid of modules\n        // that were added and deleted in the same update.\n        if (!added.has(moduleId)) {\n            modified.set(moduleId, entry);\n        }\n    }\n    return {\n        added,\n        deleted,\n        modified,\n        chunksAdded,\n        chunksDeleted\n    };\n}\nfunction getAffectedModuleEffects(moduleId) {\n    const outdatedModules = new Set();\n    const queue = [\n        {\n            moduleId,\n            dependencyChain: []\n        }\n    ];\n    let nextItem;\n    while(nextItem = queue.shift()){\n        const { moduleId, dependencyChain } = nextItem;\n        if (moduleId != null) {\n            if (outdatedModules.has(moduleId)) {\n                continue;\n            }\n            outdatedModules.add(moduleId);\n        }\n        // We've arrived at the runtime of the chunk, which means that nothing\n        // else above can accept this update.\n        if (moduleId === undefined) {\n            return {\n                type: 'unaccepted',\n                dependencyChain\n            };\n        }\n        const module = devModuleCache[moduleId];\n        const hotState = moduleHotState.get(module);\n        if (// The module is not in the cache. Since this is a \"modified\" update,\n        // it means that the module was never instantiated before.\n        !module || hotState.selfAccepted && !hotState.selfInvalidated) {\n            continue;\n        }\n        if (hotState.selfDeclined) {\n            return {\n                type: 'self-declined',\n                dependencyChain,\n                moduleId\n            };\n        }\n        if (runtimeModules.has(moduleId)) {\n            queue.push({\n                moduleId: undefined,\n                dependencyChain: [\n                    ...dependencyChain,\n                    moduleId\n                ]\n            });\n            continue;\n        }\n        for (const parentId of module.parents){\n            const parent = devModuleCache[parentId];\n            if (!parent) {\n                continue;\n            }\n            // TODO(alexkirsz) Dependencies: check accepted and declined\n            // dependencies here.\n            queue.push({\n                moduleId: parentId,\n                dependencyChain: [\n                    ...dependencyChain,\n                    moduleId\n                ]\n            });\n        }\n    }\n    return {\n        type: 'accepted',\n        moduleId,\n        outdatedModules\n    };\n}\nfunction handleApply(chunkListPath, update) {\n    switch(update.type){\n        case 'partial':\n            {\n                // This indicates that the update is can be applied to the current state of the application.\n                applyUpdate(update.instruction);\n                break;\n            }\n        case 'restart':\n            {\n                // This indicates that there is no way to apply the update to the\n                // current state of the application, and that the application must be\n                // restarted.\n                DEV_BACKEND.restart();\n                break;\n            }\n        case 'notFound':\n            {\n                // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n                // or the page itself was deleted.\n                // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n                // If it is a runtime chunk list, we restart the application.\n                if (runtimeChunkLists.has(chunkListPath)) {\n                    DEV_BACKEND.restart();\n                } else {\n                    disposeChunkList(chunkListPath);\n                }\n                break;\n            }\n        default:\n            throw new Error(`Unknown update type: ${update.type}`);\n    }\n}\nfunction createModuleHot(moduleId, hotData) {\n    const hotState = {\n        selfAccepted: false,\n        selfDeclined: false,\n        selfInvalidated: false,\n        disposeHandlers: []\n    };\n    const hot = {\n        // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n        // decide whether to warn whenever an HMR-disposed module required other\n        // modules. We might want to remove it.\n        active: true,\n        data: hotData ?? {},\n        // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n        accept: (modules, _callback, _errorHandler)=>{\n            if (modules === undefined) {\n                hotState.selfAccepted = true;\n            } else if (typeof modules === 'function') {\n                hotState.selfAccepted = modules;\n            } else {\n                throw new Error('unsupported `accept` signature');\n            }\n        },\n        decline: (dep)=>{\n            if (dep === undefined) {\n                hotState.selfDeclined = true;\n            } else {\n                throw new Error('unsupported `decline` signature');\n            }\n        },\n        dispose: (callback)=>{\n            hotState.disposeHandlers.push(callback);\n        },\n        addDisposeHandler: (callback)=>{\n            hotState.disposeHandlers.push(callback);\n        },\n        removeDisposeHandler: (callback)=>{\n            const idx = hotState.disposeHandlers.indexOf(callback);\n            if (idx >= 0) {\n                hotState.disposeHandlers.splice(idx, 1);\n            }\n        },\n        invalidate: ()=>{\n            hotState.selfInvalidated = true;\n            queuedInvalidatedModules.add(moduleId);\n        },\n        // NOTE(alexkirsz) This is part of the management API, which we don't\n        // implement, but the Next.js React Refresh runtime uses this to decide\n        // whether to schedule an update.\n        status: ()=>'idle',\n        // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n        addStatusHandler: (_handler)=>{},\n        removeStatusHandler: (_handler)=>{},\n        // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n        // want the webpack code paths to ever update (the turbopack paths handle\n        // this already).\n        check: ()=>Promise.resolve(null)\n    };\n    return {\n        hot,\n        hotState\n    };\n}\n/**\n * Removes a module from a chunk.\n * Returns `true` if there are no remaining chunks including this module.\n */ function removeModuleFromChunk(moduleId, chunkPath) {\n    const moduleChunks = moduleChunksMap.get(moduleId);\n    moduleChunks.delete(chunkPath);\n    const chunkModules = chunkModulesMap.get(chunkPath);\n    chunkModules.delete(moduleId);\n    const noRemainingModules = chunkModules.size === 0;\n    if (noRemainingModules) {\n        chunkModulesMap.delete(chunkPath);\n    }\n    const noRemainingChunks = moduleChunks.size === 0;\n    if (noRemainingChunks) {\n        moduleChunksMap.delete(moduleId);\n    }\n    return noRemainingChunks;\n}\n/**\n * Disposes of a chunk list and its corresponding exclusive chunks.\n */ function disposeChunkList(chunkListPath) {\n    const chunkPaths = chunkListChunksMap.get(chunkListPath);\n    if (chunkPaths == null) {\n        return false;\n    }\n    chunkListChunksMap.delete(chunkListPath);\n    for (const chunkPath of chunkPaths){\n        const chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n        chunkChunkLists.delete(chunkListPath);\n        if (chunkChunkLists.size === 0) {\n            chunkChunkListsMap.delete(chunkPath);\n            disposeChunk(chunkPath);\n        }\n    }\n    // We must also dispose of the chunk list's chunk itself to ensure it may\n    // be reloaded properly in the future.\n    const chunkListUrl = getChunkRelativeUrl(chunkListPath);\n    DEV_BACKEND.unloadChunk?.(chunkListUrl);\n    return true;\n}\n/**\n * Disposes of a chunk and its corresponding exclusive modules.\n *\n * @returns Whether the chunk was disposed of.\n */ function disposeChunk(chunkPath) {\n    const chunkUrl = getChunkRelativeUrl(chunkPath);\n    // This should happen whether the chunk has any modules in it or not.\n    // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n    DEV_BACKEND.unloadChunk?.(chunkUrl);\n    const chunkModules = chunkModulesMap.get(chunkPath);\n    if (chunkModules == null) {\n        return false;\n    }\n    chunkModules.delete(chunkPath);\n    for (const moduleId of chunkModules){\n        const moduleChunks = moduleChunksMap.get(moduleId);\n        moduleChunks.delete(chunkPath);\n        const noRemainingChunks = moduleChunks.size === 0;\n        if (noRemainingChunks) {\n            moduleChunksMap.delete(moduleId);\n            disposeModule(moduleId, 'clear');\n            availableModules.delete(moduleId);\n        }\n    }\n    return true;\n}\n/**\n * Adds a module to a chunk.\n */ function addModuleToChunk(moduleId, chunkPath) {\n    let moduleChunks = moduleChunksMap.get(moduleId);\n    if (!moduleChunks) {\n        moduleChunks = new Set([\n            chunkPath\n        ]);\n        moduleChunksMap.set(moduleId, moduleChunks);\n    } else {\n        moduleChunks.add(chunkPath);\n    }\n    let chunkModules = chunkModulesMap.get(chunkPath);\n    if (!chunkModules) {\n        chunkModules = new Set([\n            moduleId\n        ]);\n        chunkModulesMap.set(chunkPath, chunkModules);\n    } else {\n        chunkModules.add(moduleId);\n    }\n}\n/**\n * Marks a chunk list as a runtime chunk list. There can be more than one\n * runtime chunk list. For instance, integration tests can have multiple chunk\n * groups loaded at runtime, each with its own chunk list.\n */ function markChunkListAsRuntime(chunkListPath) {\n    runtimeChunkLists.add(chunkListPath);\n}\nfunction registerChunk(registration) {\n    const chunkPath = getPathFromScript(registration[0]);\n    let runtimeParams;\n    // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n    if (registration.length === 2) {\n        runtimeParams = registration[1];\n    } else {\n        runtimeParams = undefined;\n        installCompressedModuleFactories(registration, /* offset= */ 1, moduleFactories, (id)=>addModuleToChunk(id, chunkPath));\n    }\n    return BACKEND.registerChunk(chunkPath, runtimeParams);\n}\n/**\n * Subscribes to chunk list updates from the update server and applies them.\n */ function registerChunkList(chunkList) {\n    const chunkListScript = chunkList.script;\n    const chunkListPath = getPathFromScript(chunkListScript);\n    // The \"chunk\" is also registered to finish the loading in the backend\n    BACKEND.registerChunk(chunkListPath);\n    globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS.push([\n        chunkListPath,\n        handleApply.bind(null, chunkListPath)\n    ]);\n    // Adding chunks to chunk lists and vice versa.\n    const chunkPaths = new Set(chunkList.chunks.map(getChunkPath));\n    chunkListChunksMap.set(chunkListPath, chunkPaths);\n    for (const chunkPath of chunkPaths){\n        let chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n        if (!chunkChunkLists) {\n            chunkChunkLists = new Set([\n                chunkListPath\n            ]);\n            chunkChunkListsMap.set(chunkPath, chunkChunkLists);\n        } else {\n            chunkChunkLists.add(chunkListPath);\n        }\n    }\n    if (chunkList.source === 'entry') {\n        markChunkListAsRuntime(chunkListPath);\n    }\n}\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\nlet BACKEND;\n/**\n * Maps chunk paths to the corresponding resolver.\n */ const chunkResolvers = new Map();\n(()=>{\n    BACKEND = {\n        async registerChunk (chunkPath, params) {\n            const chunkUrl = getChunkRelativeUrl(chunkPath);\n            const resolver = getOrCreateResolver(chunkUrl);\n            resolver.resolve();\n            if (params == null) {\n                return;\n            }\n            for (const otherChunkData of params.otherChunks){\n                const otherChunkPath = getChunkPath(otherChunkData);\n                const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n                // Chunk might have started loading, so we want to avoid triggering another load.\n                getOrCreateResolver(otherChunkUrl);\n            }\n            // This waits for chunks to be loaded, but also marks included items as available.\n            await Promise.all(params.otherChunks.map((otherChunkData)=>loadInitialChunk(chunkPath, otherChunkData)));\n            if (params.runtimeModuleIds.length > 0) {\n                for (const moduleId of params.runtimeModuleIds){\n                    getOrInstantiateRuntimeModule(chunkPath, moduleId);\n                }\n            }\n        },\n        /**\n     * Loads the given chunk, and returns a promise that resolves once the chunk\n     * has been loaded.\n     */ loadChunkCached (sourceType, chunkUrl) {\n            return doLoadChunk(sourceType, chunkUrl);\n        },\n        async loadWebAssembly (_sourceType, _sourceData, wasmChunkPath, _edgeModule, importsObj) {\n            const req = fetchWebAssembly(wasmChunkPath);\n            const { instance } = await WebAssembly.instantiateStreaming(req, importsObj);\n            return instance.exports;\n        },\n        async loadWebAssemblyModule (_sourceType, _sourceData, wasmChunkPath, _edgeModule) {\n            const req = fetchWebAssembly(wasmChunkPath);\n            return await WebAssembly.compileStreaming(req);\n        }\n    };\n    function getOrCreateResolver(chunkUrl) {\n        let resolver = chunkResolvers.get(chunkUrl);\n        if (!resolver) {\n            let resolve;\n            let reject;\n            const promise = new Promise((innerResolve, innerReject)=>{\n                resolve = innerResolve;\n                reject = innerReject;\n            });\n            resolver = {\n                resolved: false,\n                loadingStarted: false,\n                promise,\n                resolve: ()=>{\n                    resolver.resolved = true;\n                    resolve();\n                },\n                reject: reject\n            };\n            chunkResolvers.set(chunkUrl, resolver);\n        }\n        return resolver;\n    }\n    /**\n   * Loads the given chunk, and returns a promise that resolves once the chunk\n   * has been loaded.\n   */ function doLoadChunk(sourceType, chunkUrl) {\n        const resolver = getOrCreateResolver(chunkUrl);\n        if (resolver.loadingStarted) {\n            return resolver.promise;\n        }\n        if (sourceType === SourceType.Runtime) {\n            // We don't need to load chunks references from runtime code, as they're already\n            // present in the DOM.\n            resolver.loadingStarted = true;\n            if (isCss(chunkUrl)) {\n                // CSS chunks do not register themselves, and as such must be marked as\n                // loaded instantly.\n                resolver.resolve();\n            }\n            // We need to wait for JS chunks to register themselves within `registerChunk`\n            // before we can start instantiating runtime modules, hence the absence of\n            // `resolver.resolve()` in this branch.\n            return resolver.promise;\n        }\n        if (typeof importScripts === 'function') {\n            // We're in a web worker\n            if (isCss(chunkUrl)) {\n            // ignore\n            } else if (isJs(chunkUrl)) {\n                self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);\n                importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n            } else {\n                throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n            }\n        } else {\n            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n            const decodedChunkUrl = decodeURI(chunkUrl);\n            if (isCss(chunkUrl)) {\n                const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n                if (previousLinks.length > 0) {\n                    // CSS chunks do not register themselves, and as such must be marked as\n                    // loaded instantly.\n                    resolver.resolve();\n                } else {\n                    const link = document.createElement('link');\n                    link.rel = 'stylesheet';\n                    link.href = chunkUrl;\n                    link.onerror = ()=>{\n                        resolver.reject();\n                    };\n                    link.onload = ()=>{\n                        // CSS chunks do not register themselves, and as such must be marked as\n                        // loaded instantly.\n                        resolver.resolve();\n                    };\n                    // Append to the `head` for webpack compatibility.\n                    document.head.appendChild(link);\n                }\n            } else if (isJs(chunkUrl)) {\n                const previousScripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n                if (previousScripts.length > 0) {\n                    // There is this edge where the script already failed loading, but we\n                    // can't detect that. The Promise will never resolve in this case.\n                    for (const script of Array.from(previousScripts)){\n                        script.addEventListener('error', ()=>{\n                            resolver.reject();\n                        });\n                    }\n                } else {\n                    const script = document.createElement('script');\n                    script.src = chunkUrl;\n                    // We'll only mark the chunk as loaded once the script has been executed,\n                    // which happens in `registerChunk`. Hence the absence of `resolve()` in\n                    // this branch.\n                    script.onerror = ()=>{\n                        resolver.reject();\n                    };\n                    // Append to the `head` for webpack compatibility.\n                    document.head.appendChild(script);\n                }\n            } else {\n                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n            }\n        }\n        resolver.loadingStarted = true;\n        return resolver.promise;\n    }\n    function fetchWebAssembly(wasmChunkPath) {\n        return fetch(getChunkRelativeUrl(wasmChunkPath));\n    }\n})();\n/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/runtime-base.ts\" />\n/// <reference path=\"../base/dev-base.ts\" />\n/// <reference path=\"./runtime-backend-dom.ts\" />\n/// <reference path=\"../../../shared/require-type.d.ts\" />\nlet DEV_BACKEND;\n(()=>{\n    DEV_BACKEND = {\n        unloadChunk (chunkUrl) {\n            deleteResolver(chunkUrl);\n            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n            const decodedChunkUrl = decodeURI(chunkUrl);\n            if (isCss(chunkUrl)) {\n                const links = document.querySelectorAll(`link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`);\n                for (const link of Array.from(links)){\n                    link.remove();\n                }\n            } else if (isJs(chunkUrl)) {\n                // Unloading a JS chunk would have no effect, as it lives in the JS\n                // runtime once evaluated.\n                // However, we still want to remove the script tag from the DOM to keep\n                // the HTML somewhat consistent from the user's perspective.\n                const scripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n                for (const script of Array.from(scripts)){\n                    script.remove();\n                }\n            } else {\n                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n            }\n        },\n        reloadChunk (chunkUrl) {\n            return new Promise((resolve, reject)=>{\n                if (!isCss(chunkUrl)) {\n                    reject(new Error('The DOM backend can only reload CSS chunks'));\n                    return;\n                }\n                const decodedChunkUrl = decodeURI(chunkUrl);\n                const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n                if (previousLinks.length === 0) {\n                    reject(new Error(`No link element found for chunk ${chunkUrl}`));\n                    return;\n                }\n                const link = document.createElement('link');\n                link.rel = 'stylesheet';\n                if (navigator.userAgent.includes('Firefox')) {\n                    // Firefox won't reload CSS files that were previously loaded on the current page,\n                    // we need to add a query param to make sure CSS is actually reloaded from the server.\n                    //\n                    // I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506\n                    //\n                    // Safari has a similar issue, but only if you have a `<link rel=preload ... />` tag\n                    // pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726\n                    link.href = `${chunkUrl}?ts=${Date.now()}`;\n                } else {\n                    link.href = chunkUrl;\n                }\n                link.onerror = ()=>{\n                    reject();\n                };\n                link.onload = ()=>{\n                    // First load the new CSS, then remove the old ones. This prevents visible\n                    // flickering that would happen in-between removing the previous CSS and\n                    // loading the new one.\n                    for (const previousLink of Array.from(previousLinks))previousLink.remove();\n                    // CSS chunks do not register themselves, and as such must be marked as\n                    // loaded instantly.\n                    resolve();\n                };\n                // Make sure to insert the new CSS right after the previous one, so that\n                // its precedence is higher.\n                previousLinks[0].parentElement.insertBefore(link, previousLinks[0].nextSibling);\n            });\n        },\n        restart: ()=>self.location.reload()\n    };\n    function deleteResolver(chunkUrl) {\n        chunkResolvers.delete(chunkUrl);\n    }\n})();\nfunction _eval({ code, url, map }) {\n    code += `\\n\\n//# sourceURL=${encodeURI(location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX)}`;\n    if (map) {\n        code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(// btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n        // See https://stackoverflow.com/a/26603875\n        unescape(encodeURIComponent(map)))}`;\n    }\n    // eslint-disable-next-line no-eval\n    return eval(code);\n}\nconst chunksToRegister = globalThis.TURBOPACK;\nglobalThis.TURBOPACK = { push: registerChunk };\nchunksToRegister.forEach(registerChunk);\nconst chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS || [];\nglobalThis.TURBOPACK_CHUNK_LISTS = { push: registerChunkList };\nchunkListsToRegister.forEach(registerChunkList);\n})();\n\n\n//# sourceMappingURL=_23a915ee._.js.map","sourceMap":{"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts","turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts","turbopack:///[turbopack]/browser/runtime/base/dev-base.ts","turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts","turbopack:///[turbopack]/browser/runtime/dom/dev-backend-dom.ts"],"sections":[{"offset":{"line":13,"column":0},"map":{"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(\n  this: TurbopackBaseContext<Module>,\n  module: Module,\n  exports: Exports\n) {\n  this.m = module\n  // We need to store this here instead of accessing it from the module object to:\n  // 1. Make it available to factories directly, since we rewrite `this` to\n  //    `__turbopack_context__.e` in CJS modules.\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\n  //    can still access the original exports object from functions like\n  //    `esmExport`\n  // Ideally we could find a new approach for async modules and drop this property altogether.\n  this.e = exports\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: string): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: string): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\n  moduleId: M['id'],\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId\n): Module {\n  let module = moduleCache[id]\n  if (!module) {\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\n    // instantiateModule and the cache entry wasn't created yet.\n    module = createModuleObject(id)\n    moduleCache[id] = module\n  }\n  return module\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n  }\n}\n\ntype BindingTag = 0\nconst BindingTag_Value = 0 as BindingTag\n\n// an arbitrary sequence of bindings as\n// - a prop name\n// - BindingTag_Value, a value to be bound directly, or\n// - 1 or 2 functions to bind as getters and sdetters\ntype EsmBindings = Array<\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\n>\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, bindings: EsmBindings) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  let i = 0\n  while (i < bindings.length) {\n    const propName = bindings[i++] as string\n    const tagOrFunction = bindings[i++]\n    if (typeof tagOrFunction === 'number') {\n      if (tagOrFunction === BindingTag_Value) {\n        defineProp(exports, propName, {\n          value: bindings[i++],\n          enumerable: true,\n          writable: false,\n        })\n      } else {\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\n      }\n    } else {\n      const getterFn = tagOrFunction as () => unknown\n      if (typeof bindings[i] === 'function') {\n        const setterFn = bindings[i++] as (v: unknown) => void\n        defineProp(exports, propName, {\n          get: getterFn,\n          set: setterFn,\n          enumerable: true,\n        })\n      } else {\n        defineProp(exports, propName, {\n          get: getterFn,\n          enumerable: true,\n        })\n      }\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  bindings: EsmBindings,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Module['exports']\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  module.namespaceObject = exports\n  esm(exports, bindings)\n}\ncontextPrototype.s = esmExport\n\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\nfunction ensureDynamicExports(\n  module: Module,\n  exports: Exports\n): ReexportedObjects {\n  let reexportedObjects: ReexportedObjects | undefined =\n    REEXPORTED_OBJECTS.get(module)\n\n  if (!reexportedObjects) {\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n  return reexportedObjects\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Exports\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  const reexportedObjects = ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    reexportedObjects.push(object)\n  }\n}\ncontextPrototype.j = dynamicExport\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = value\n}\ncontextPrototype.v = exportValue\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = module.namespaceObject = namespace\n}\ncontextPrototype.n = exportNamespace\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const bindings: EsmBindings = []\n  let defaultLocation = -1\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      bindings.push(key, createGetter(raw, key))\n      if (defaultLocation === -1 && key === 'default') {\n        defaultLocation = bindings.length - 1\n      }\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && defaultLocation >= 0)) {\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\n    if (defaultLocation >= 0) {\n      // Replace the getter with the value\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\n    } else {\n      bindings.push('default', BindingTag_Value, raw)\n    }\n  }\n\n  esm(ns, bindings)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m)\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\ncontextPrototype.i = esmImport\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport\n  ) => Promise<Exports>\n  return loader(esmImport.bind(this))\n}\ncontextPrototype.A = asyncLoader\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\ncontextPrototype.t = runtimeRequire\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exports {\n  return getOrInstantiateModuleFromParent(id, this.m).exports\n}\ncontextPrototype.r = commonJsRequire\n\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */\nfunction parseRequest(request: string): string {\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n  const hashIndex = request.indexOf('#')\n  if (hashIndex !== -1) {\n    request = request.substring(0, hashIndex)\n  }\n\n  const queryIndex = request.indexOf('?')\n  if (queryIndex !== -1) {\n    request = request.substring(0, queryIndex)\n  }\n\n  return request\n}\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: string): Exports {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): string[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: string): ModuleId => {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: string) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\ncontextPrototype.f = moduleContext\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(\n  chunkModules: CompressedModuleFactories,\n  offset: number,\n  moduleFactories: ModuleFactories,\n  newModuleId?: (id: ModuleId) => void\n) {\n  let i = offset\n  while (i < chunkModules.length) {\n    let moduleId = chunkModules[i] as ModuleId\n    let end = i + 1\n    // Find our factory function\n    while (\n      end < chunkModules.length &&\n      typeof chunkModules[end] !== 'function'\n    ) {\n      end++\n    }\n    if (end === chunkModules.length) {\n      throw new Error('malformed chunk format, expected a factory function')\n    }\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n    // present we know all the additional ids are also present, so we don't need to check.\n    if (!moduleFactories.has(moduleId)) {\n      const moduleFactoryFn = chunkModules[end] as Function\n      applyModuleFactoryName(moduleFactoryFn)\n      newModuleId?.(moduleId)\n      for (; i < end; i++) {\n        moduleId = chunkModules[i] as ModuleId\n        moduleFactories.set(moduleId, moduleFactoryFn)\n      }\n    }\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const module = this.m\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\ncontextPrototype.a = asyncModule\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\nrelativeURL.prototype = URL.prototype\ncontextPrototype.U = relativeURL\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\ncontextPrototype.z = requireStub\n\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis\n\ntype ContextConstructor<M> = {\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\n}\n\nfunction applyModuleFactoryName(factory: Function) {\n  // Give the module factory a nice name to improve stack traces.\n  Object.defineProperty(factory, 'name', {\n    value: 'module evaluation',\n  })\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},{"offset":{"line":514,"column":0},"map":{"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n\n// Used in WebWorkers to tell the runtime about the chunk base path\ndeclare var TURBOPACK_WORKER_LOCATION: string\n// Used in WebWorkers to tell the runtime about the chunk suffix\ndeclare var TURBOPACK_CHUNK_SUFFIX: string\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\n// Note it's stored in reversed order to use push and pop\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\n\n// Injected by rust code\ndeclare var CHUNK_BASE_PATH: string\ndeclare var CHUNK_SUFFIX: string\n\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\n  R: ResolvePathFromModule\n}\n\nconst browserContextPrototype =\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\n\n// Provided by build or dev base\ndeclare function instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module\n\ntype RuntimeParams = {\n  otherChunks: ChunkData[]\n  runtimeModuleIds: ModuleId[]\n}\n\ntype ChunkRegistration = [\n  chunkPath: ChunkScript,\n  ...([RuntimeParams] | CompressedModuleFactories),\n]\n\ntype ChunkList = {\n  script: ChunkListScript\n  chunks: ChunkData[]\n  source: 'entry' | 'dynamic'\n}\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\ninterface RuntimeBackend {\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void\n  /**\n   * Returns the same Promise for the same chunk URL.\n   */\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\n  loadWebAssembly: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module,\n    importsObj: WebAssembly.Imports\n  ) => Promise<Exports>\n  loadWebAssemblyModule: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module\n  ) => Promise<WebAssembly.Module>\n}\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nconst moduleFactories: ModuleFactories = new Map()\ncontextPrototype.M = moduleFactories\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\n\nfunction factoryNotAvailableMessage(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): string {\n  let instantiationReason\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\n      break\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`\n      break\n    case SourceType.Update:\n      instantiationReason = 'because of an HMR update'\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\n}\n\nfunction loadChunk(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkData: ChunkData\n): Promise<void> {\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\n}\nbrowserContextPrototype.l = loadChunk\n\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\n}\n\nasync function loadChunkInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkData: ChunkData\n): Promise<void> {\n  if (typeof chunkData === 'string') {\n    return loadChunkPath(sourceType, sourceData, chunkData)\n  }\n\n  const includedList = chunkData.included || []\n  const modulesPromises = includedList.map((included) => {\n    if (moduleFactories.has(included)) return true\n    return availableModules.get(included)\n  })\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\n    // When all included items are already loaded or loading, we can skip loading ourselves\n    await Promise.all(modulesPromises)\n    return\n  }\n\n  const includedModuleChunksList = chunkData.moduleChunks || []\n  const moduleChunksPromises = includedModuleChunksList\n    .map((included) => {\n      // TODO(alexkirsz) Do we need this check?\n      // if (moduleFactories[included]) return true;\n      return availableModuleChunks.get(included)\n    })\n    .filter((p) => p)\n\n  let promise: Promise<unknown>\n  if (moduleChunksPromises.length > 0) {\n    // Some module chunks are already loaded or loading.\n\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\n      await Promise.all(moduleChunksPromises)\n      return\n    }\n\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\n    for (const moduleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(moduleChunk)) {\n        moduleChunksToLoad.add(moduleChunk)\n      }\n    }\n\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\n\n      availableModuleChunks.set(moduleChunkToLoad, promise)\n\n      moduleChunksPromises.push(promise)\n    }\n\n    promise = Promise.all(moduleChunksPromises)\n  } else {\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\n\n    // Mark all included module chunks as loading if they are not already loaded or loading.\n    for (const includedModuleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(includedModuleChunk)) {\n        availableModuleChunks.set(includedModuleChunk, promise)\n      }\n    }\n  }\n\n  for (const included of includedList) {\n    if (!availableModules.has(included)) {\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n      availableModules.set(included, promise)\n    }\n  }\n\n  await promise\n}\n\nconst loadedChunk = Promise.resolve(undefined)\nconst instrumentedBackendLoadChunks = new WeakMap<\n  Promise<any>,\n  Promise<any> | typeof loadedChunk\n>()\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkUrl: ChunkUrl\n) {\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\n}\nbrowserContextPrototype.L = loadChunkByUrl\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkUrl: ChunkUrl\n): Promise<any> {\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\n  let entry = instrumentedBackendLoadChunks.get(thenable)\n  if (entry === undefined) {\n    const resolve = instrumentedBackendLoadChunks.set.bind(\n      instrumentedBackendLoadChunks,\n      thenable,\n      loadedChunk\n    )\n    entry = thenable.then(resolve).catch((cause) => {\n      let loadReason: string\n      switch (sourceType) {\n        case SourceType.Runtime:\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\n          break\n        case SourceType.Parent:\n          loadReason = `from module ${sourceData}`\n          break\n        case SourceType.Update:\n          loadReason = 'from an HMR update'\n          break\n        default:\n          invariant(\n            sourceType,\n            (sourceType) => `Unknown source type: ${sourceType}`\n          )\n      }\n      let error = new Error(\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\n          cause ? `: ${cause}` : ''\n        }`,\n        cause ? { cause } : undefined\n      )\n      error.name = 'ChunkLoadError'\n      throw error\n    })\n    instrumentedBackendLoadChunks.set(thenable, entry)\n  }\n\n  return entry\n}\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkPath: ChunkPath\n): Promise<void> {\n  const url = getChunkRelativeUrl(chunkPath)\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\n}\n\n/**\n * Returns an absolute url to an asset.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string\n): string {\n  const exported = this.r(moduleId)\n  return exported?.default ?? exported\n}\nbrowserContextPrototype.R = resolvePathFromModule\n\n/**\n * no-op for browser\n * @param modulePath\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  return `/ROOT/${modulePath ?? ''}`\n}\nbrowserContextPrototype.P = resolveAbsolutePath\n\n/**\n * Returns a blob URL for the worker.\n * @param chunks list of chunks to load\n */\nfunction getWorkerBlobURL(chunks: ChunkPath[]): string {\n  // It is important to reverse the array so when bootstrapping we can infer what chunk is being\n  // evaluated by poping urls off of this array.  See `getPathFromScript`\n  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\nself.TURBOPACK_CHUNK_SUFFIX = ${JSON.stringify(CHUNK_SUFFIX)};\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`\n  let blob = new Blob([bootstrap], { type: 'text/javascript' })\n  return URL.createObjectURL(blob)\n}\nbrowserContextPrototype.b = getWorkerBlobURL\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n  return `${CHUNK_BASE_PATH}${chunkPath\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')}${CHUNK_SUFFIX}` as ChunkUrl\n}\n\n/**\n * Return the ChunkPath from a ChunkScript.\n */\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\nfunction getPathFromScript(\n  chunkScript: ChunkListPath | ChunkListScript\n): ChunkListPath\nfunction getPathFromScript(\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\n): ChunkPath | ChunkListPath {\n  if (typeof chunkScript === 'string') {\n    return chunkScript as ChunkPath | ChunkListPath\n  }\n  const chunkUrl =\n    typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined'\n      ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\n      : chunkScript.getAttribute('src')!\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\n  const path = src.startsWith(CHUNK_BASE_PATH)\n    ? src.slice(CHUNK_BASE_PATH.length)\n    : src\n  return path as ChunkPath | ChunkListPath\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n */\nfunction isCss(chunkUrl: ChunkUrl): boolean {\n  return regexCssUrl.test(chunkUrl)\n}\n\nfunction loadWebAssembly(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  return BACKEND.loadWebAssembly(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule,\n    importsObj\n  )\n}\ncontextPrototype.w = loadWebAssembly\n\nfunction loadWebAssemblyModule(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module\n): Promise<WebAssembly.Module> {\n  return BACKEND.loadWebAssemblyModule(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule\n  )\n}\ncontextPrototype.u = loadWebAssemblyModule\n"],"names":[],"mappings":"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","ignoreList":[0]}},{"offset":{"line":741,"column":0},"map":{"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/dev-base.ts"],"sourcesContent":["/// <reference path=\"./dev-globals.d.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\n\ninterface TurbopackDevContext extends TurbopackBrowserBaseContext<HotModule> {\n  k: RefreshContext\n}\n\nconst devContextPrototype = Context.prototype as TurbopackDevContext\n\n/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst devModuleCache: ModuleCache<HotModule> = Object.create(null)\ndevContextPrototype.c = devModuleCache\n\n// This file must not use `import` and `export` statements. Otherwise, it\n// becomes impossible to augment interfaces declared in `<reference>`d files\n// (e.g. `Module`). Hence, the need for `import()` here.\ntype RefreshRuntimeGlobals =\n  import('@next/react-refresh-utils/dist/runtime').RefreshRuntimeGlobals\n\ndeclare var $RefreshHelpers$: RefreshRuntimeGlobals['$RefreshHelpers$']\ndeclare var $RefreshReg$: RefreshRuntimeGlobals['$RefreshReg$']\ndeclare var $RefreshSig$: RefreshRuntimeGlobals['$RefreshSig$']\ndeclare var $RefreshInterceptModuleExecution$: RefreshRuntimeGlobals['$RefreshInterceptModuleExecution$']\n\ntype RefreshContext = {\n  register: RefreshRuntimeGlobals['$RefreshReg$']\n  signature: RefreshRuntimeGlobals['$RefreshSig$']\n  registerExports: typeof registerExportsAndSetupBoundaryForReactRefresh\n}\n\ntype RefreshHelpers = RefreshRuntimeGlobals['$RefreshHelpers$']\n\ntype ModuleFactory = (\n  this: Module['exports'],\n  context: TurbopackDevContext\n) => unknown\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nclass UpdateApplyError extends Error {\n  name = 'UpdateApplyError'\n\n  dependencyChain: ModuleId[]\n\n  constructor(message: string, dependencyChain: ModuleId[]) {\n    super(message)\n    this.dependencyChain = dependencyChain\n  }\n}\n\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */\nconst runtimeModules: Set<ModuleId> = new Set()\n\n/**\n * Map from module ID to the chunks that contain this module.\n *\n * In HMR, we need to keep track of which modules are contained in which so\n * chunks. This is so we don't eagerly dispose of a module when it is removed\n * from chunk A, but still exists in chunk B.\n */\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to all modules it contains.\n */\nconst chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map()\n/**\n * Chunk lists that contain a runtime. When these chunk lists receive an update\n * that can't be reconciled with the current state of the page, we need to\n * reload the runtime entirely.\n */\nconst runtimeChunkLists: Set<ChunkListPath> = new Set()\n/**\n * Map from a chunk list to the chunk paths it contains.\n */\nconst chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to the chunk lists it belongs to.\n */\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map()\n\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */\nconst moduleHotData: Map<ModuleId, HotData> = new Map()\n/**\n * Maps module instances to their hot module state.\n */\nconst moduleHotState: Map<Module, HotState> = new Map()\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */\nconst queuedInvalidatedModules: Set<ModuleId> = new Set()\n\n/**\n * Gets or instantiates a runtime module.\n */\n// @ts-ignore\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module {\n  const module = devModuleCache[moduleId]\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  // @ts-ignore\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// @ts-ignore Defined in `runtime-utils.ts`\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n  HotModule\n> = (id, sourceModule) => {\n  if (!sourceModule.hot.active) {\n    console.warn(\n      `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`\n    )\n  }\n\n  const module = devModuleCache[id]\n\n  if (sourceModule.children.indexOf(id) === -1) {\n    sourceModule.children.push(id)\n  }\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n\n    if (module.parents.indexOf(sourceModule.id) === -1) {\n      module.parents.push(sourceModule.id)\n    }\n\n    return module\n  }\n\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n}\n\nfunction DevContext(\n  this: TurbopackDevContext,\n  module: HotModule,\n  exports: Exports,\n  refresh: RefreshContext\n) {\n  Context.call(this, module, exports)\n  this.k = refresh\n}\nDevContext.prototype = Context.prototype\n\ntype DevContextConstructor = {\n  new (\n    module: HotModule,\n    exports: Exports,\n    refresh: RefreshContext\n  ): TurbopackDevContext\n}\n\nfunction instantiateModule(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module {\n  // We are in development, this is always a string.\n  let id = moduleId as string\n\n  const moduleFactory = moduleFactories.get(id)\n  if (typeof moduleFactory !== 'function') {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    throw new Error(\n      factoryNotAvailableMessage(id, sourceType, sourceData) +\n        ' It might have been deleted in an HMR update.'\n    )\n  }\n\n  const hotData = moduleHotData.get(id)!\n  const { hot, hotState } = createModuleHot(id, hotData)\n\n  let parents: ModuleId[]\n  switch (sourceType) {\n    case SourceType.Runtime:\n      runtimeModules.add(id)\n      parents = []\n      break\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [sourceData as ModuleId]\n      break\n    case SourceType.Update:\n      parents = (sourceData as ModuleId[]) || []\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n\n  const module: HotModule = createModuleObject(id) as HotModule\n  const exports = module.exports\n  module.parents = parents\n  module.children = []\n  module.hot = hot\n\n  devModuleCache[id] = module\n  moduleHotState.set(module, hotState)\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    runModuleExecutionHooks(module, (refresh) => {\n      const context = new (DevContext as any as DevContextConstructor)(\n        module,\n        exports,\n        refresh\n      )\n      moduleFactory(context, module, exports)\n    })\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\nconst DUMMY_REFRESH_CONTEXT = {\n  register: (_type: unknown, _id: unknown) => {},\n  signature: () => (_type: unknown) => {},\n  registerExports: (_module: unknown, _helpers: unknown) => {},\n}\n\n/**\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n * Next.js' React Refresh runtime hooks into to add module context to the\n * refresh registry.\n */\nfunction runModuleExecutionHooks(\n  module: HotModule,\n  executeModule: (ctx: RefreshContext) => void\n) {\n  if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\n    const cleanupReactRefreshIntercept =\n      globalThis.$RefreshInterceptModuleExecution$(module.id)\n    try {\n      executeModule({\n        register: globalThis.$RefreshReg$,\n        signature: globalThis.$RefreshSig$,\n        registerExports: registerExportsAndSetupBoundaryForReactRefresh,\n      })\n    } finally {\n      // Always cleanup the intercept, even if module execution failed.\n      cleanupReactRefreshIntercept()\n    }\n  } else {\n    // If the react refresh hooks are not installed we need to bind dummy functions.\n    // This is expected when running in a Web Worker.  It is also common in some of\n    // our test environments.\n    executeModule(DUMMY_REFRESH_CONTEXT)\n  }\n}\n\n/**\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n */\nfunction registerExportsAndSetupBoundaryForReactRefresh(\n  module: HotModule,\n  helpers: RefreshHelpers\n) {\n  const currentExports = module.exports\n  const prevExports = module.hot.data.prevExports ?? null\n\n  helpers.registerExportsForReactRefresh(currentExports, module.id)\n\n  // A module can be accepted automatically based on its exports, e.g. when\n  // it is a Refresh Boundary.\n  if (helpers.isReactRefreshBoundary(currentExports)) {\n    // Save the previous exports on update, so we can compare the boundary\n    // signatures.\n    module.hot.dispose((data) => {\n      data.prevExports = currentExports\n    })\n    // Unconditionally accept an update to this module, we'll check if it's\n    // still a Refresh Boundary later.\n    module.hot.accept()\n\n    // This field is set when the previous version of this module was a\n    // Refresh Boundary, letting us know we need to check for invalidation or\n    // enqueue an update.\n    if (prevExports !== null) {\n      // A boundary can become ineligible if its exports are incompatible\n      // with the previous exports.\n      //\n      // For example, if you add/remove/change exports, we'll want to\n      // re-execute the importing modules, and force those components to\n      // re-render. Similarly, if you convert a class component to a\n      // function, we want to invalidate the boundary.\n      if (\n        helpers.shouldInvalidateReactRefreshBoundary(\n          helpers.getRefreshBoundarySignature(prevExports),\n          helpers.getRefreshBoundarySignature(currentExports)\n        )\n      ) {\n        module.hot.invalidate()\n      } else {\n        helpers.scheduleUpdate()\n      }\n    }\n  } else {\n    // Since we just executed the code for the module, it's possible that the\n    // new exports made it ineligible for being a boundary.\n    // We only care about the case when we were _previously_ a boundary,\n    // because we already accepted this update (accidental side effect).\n    const isNoLongerABoundary = prevExports !== null\n    if (isNoLongerABoundary) {\n      module.hot.invalidate()\n    }\n  }\n}\n\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\n  return `Dependency chain: ${dependencyChain.join(' -> ')}`\n}\n\nfunction computeOutdatedModules(\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n): {\n  outdatedModules: Set<ModuleId>\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n} {\n  const newModuleFactories = new Map<ModuleId, ModuleFactory>()\n\n  for (const [moduleId, entry] of added) {\n    if (entry != null) {\n      newModuleFactories.set(moduleId, _eval(entry))\n    }\n  }\n\n  const outdatedModules = computedInvalidatedModules(modified.keys())\n\n  for (const [moduleId, entry] of modified) {\n    newModuleFactories.set(moduleId, _eval(entry))\n  }\n\n  return { outdatedModules, newModuleFactories }\n}\n\nfunction computedInvalidatedModules(\n  invalidated: Iterable<ModuleId>\n): Set<ModuleId> {\n  const outdatedModules = new Set<ModuleId>()\n\n  for (const moduleId of invalidated) {\n    const effect = getAffectedModuleEffects(moduleId)\n\n    switch (effect.type) {\n      case 'unaccepted':\n        throw new UpdateApplyError(\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'self-declined':\n        throw new UpdateApplyError(\n          `cannot apply update: self-declined module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'accepted':\n        for (const outdatedModuleId of effect.outdatedModules) {\n          outdatedModules.add(outdatedModuleId)\n        }\n        break\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\n      default:\n        invariant(effect, (effect) => `Unknown effect type: ${effect?.type}`)\n    }\n  }\n\n  return outdatedModules\n}\n\nfunction computeOutdatedSelfAcceptedModules(\n  outdatedModules: Iterable<ModuleId>\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\n  const outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[] = []\n  for (const moduleId of outdatedModules) {\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n    if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n      outdatedSelfAcceptedModules.push({\n        moduleId,\n        errorHandler: hotState.selfAccepted,\n      })\n    }\n  }\n  return outdatedSelfAcceptedModules\n}\n\n/**\n * Adds, deletes, and moves modules between chunks. This must happen before the\n * dispose phase as it needs to know which modules were removed from all chunks,\n * which we can only compute *after* taking care of added and moved modules.\n */\nfunction updateChunksPhase(\n  chunksAddedModules: Map<ChunkPath, Set<ModuleId>>,\n  chunksDeletedModules: Map<ChunkPath, Set<ModuleId>>\n): { disposedModules: Set<ModuleId> } {\n  for (const [chunkPath, addedModuleIds] of chunksAddedModules) {\n    for (const moduleId of addedModuleIds) {\n      addModuleToChunk(moduleId, chunkPath)\n    }\n  }\n\n  const disposedModules: Set<ModuleId> = new Set()\n  for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {\n    for (const moduleId of addedModuleIds) {\n      if (removeModuleFromChunk(moduleId, chunkPath)) {\n        disposedModules.add(moduleId)\n      }\n    }\n  }\n\n  return { disposedModules }\n}\n\nfunction disposePhase(\n  outdatedModules: Iterable<ModuleId>,\n  disposedModules: Iterable<ModuleId>\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\n  for (const moduleId of outdatedModules) {\n    disposeModule(moduleId, 'replace')\n  }\n\n  for (const moduleId of disposedModules) {\n    disposeModule(moduleId, 'clear')\n  }\n\n  // Removing modules from the module cache is a separate step.\n  // We also want to keep track of previous parents of the outdated modules.\n  const outdatedModuleParents = new Map()\n  for (const moduleId of outdatedModules) {\n    const oldModule = devModuleCache[moduleId]\n    outdatedModuleParents.set(moduleId, oldModule?.parents)\n    delete devModuleCache[moduleId]\n  }\n\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n  // children.\n\n  return { outdatedModuleParents }\n}\n\n/**\n * Disposes of an instance of a module.\n *\n * Returns the persistent hot data that should be kept for the next module\n * instance.\n *\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\n * This must be done in a separate step afterwards.\n * This is important because all modules need to be disposed to update the\n * parent/child relationships before they are actually removed from the devModuleCache.\n * If this was done in this method, the following disposeModule calls won't find\n * the module from the module id in the cache.\n */\nfunction disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {\n  const module = devModuleCache[moduleId]\n  if (!module) {\n    return\n  }\n\n  const hotState = moduleHotState.get(module)!\n  const data = {}\n\n  // Run the `hot.dispose` handler, if any, passing in the persistent\n  // `hot.data` object.\n  for (const disposeHandler of hotState.disposeHandlers) {\n    disposeHandler(data)\n  }\n\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n  // module is still importing other modules.\n  module.hot.active = false\n\n  moduleHotState.delete(module)\n\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n\n  // Remove the disposed module from its children's parent list.\n  // It will be added back once the module re-instantiates and imports its\n  // children again.\n  for (const childId of module.children) {\n    const child = devModuleCache[childId]\n    if (!child) {\n      continue\n    }\n\n    const idx = child.parents.indexOf(module.id)\n    if (idx >= 0) {\n      child.parents.splice(idx, 1)\n    }\n  }\n\n  switch (mode) {\n    case 'clear':\n      delete devModuleCache[module.id]\n      moduleHotData.delete(module.id)\n      break\n    case 'replace':\n      moduleHotData.set(module.id, data)\n      break\n    default:\n      invariant(mode, (mode) => `invalid mode: ${mode}`)\n  }\n}\n\nfunction applyPhase(\n  outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[],\n  newModuleFactories: Map<ModuleId, ModuleFactory>,\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\n  reportError: (err: any) => void\n) {\n  // Update module factories.\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\n    applyModuleFactoryName(factory)\n    moduleFactories.set(moduleId, factory)\n  }\n\n  // TODO(alexkirsz) Run new runtime entries here.\n\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n\n  // Re-instantiate all outdated self-accepted modules.\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n    try {\n      instantiateModule(\n        moduleId,\n        SourceType.Update,\n        outdatedModuleParents.get(moduleId)\n      )\n    } catch (err) {\n      if (typeof errorHandler === 'function') {\n        try {\n          errorHandler(err, { moduleId, module: devModuleCache[moduleId] })\n        } catch (err2) {\n          reportError(err2)\n          reportError(err)\n        }\n      } else {\n        reportError(err)\n      }\n    }\n  }\n}\n\nfunction applyUpdate(update: PartialUpdate) {\n  switch (update.type) {\n    case 'ChunkListUpdate':\n      applyChunkListUpdate(update)\n      break\n    default:\n      invariant(update, (update) => `Unknown update type: ${update.type}`)\n  }\n}\n\nfunction applyChunkListUpdate(update: ChunkListUpdate) {\n  if (update.merged != null) {\n    for (const merged of update.merged) {\n      switch (merged.type) {\n        case 'EcmascriptMergedUpdate':\n          applyEcmascriptMergedUpdate(merged)\n          break\n        default:\n          invariant(merged, (merged) => `Unknown merged type: ${merged.type}`)\n      }\n    }\n  }\n\n  if (update.chunks != null) {\n    for (const [chunkPath, chunkUpdate] of Object.entries(\n      update.chunks\n    ) as Array<[ChunkPath, ChunkUpdate]>) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\n\n      switch (chunkUpdate.type) {\n        case 'added':\n          BACKEND.loadChunkCached(SourceType.Update, chunkUrl)\n          break\n        case 'total':\n          DEV_BACKEND.reloadChunk?.(chunkUrl)\n          break\n        case 'deleted':\n          DEV_BACKEND.unloadChunk?.(chunkUrl)\n          break\n        case 'partial':\n          invariant(\n            chunkUpdate.instruction,\n            (instruction) =>\n              `Unknown partial instruction: ${JSON.stringify(instruction)}.`\n          )\n          break\n        default:\n          invariant(\n            chunkUpdate,\n            (chunkUpdate) => `Unknown chunk update type: ${chunkUpdate.type}`\n          )\n      }\n    }\n  }\n}\n\nfunction applyEcmascriptMergedUpdate(update: EcmascriptMergedUpdate) {\n  const { entries = {}, chunks = {} } = update\n  const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(\n    entries,\n    chunks\n  )\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\n    added,\n    modified\n  )\n  const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted)\n\n  applyInternal(outdatedModules, disposedModules, newModuleFactories)\n}\n\nfunction applyInvalidatedModules(outdatedModules: Set<ModuleId>) {\n  if (queuedInvalidatedModules.size > 0) {\n    computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) => {\n      outdatedModules.add(moduleId)\n    })\n\n    queuedInvalidatedModules.clear()\n  }\n\n  return outdatedModules\n}\n\nfunction applyInternal(\n  outdatedModules: Set<ModuleId>,\n  disposedModules: Iterable<ModuleId>,\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n) {\n  outdatedModules = applyInvalidatedModules(outdatedModules)\n\n  const outdatedSelfAcceptedModules =\n    computeOutdatedSelfAcceptedModules(outdatedModules)\n\n  const { outdatedModuleParents } = disposePhase(\n    outdatedModules,\n    disposedModules\n  )\n\n  // we want to continue on error and only throw the error after we tried applying all updates\n  let error: any\n\n  function reportError(err: any) {\n    if (!error) error = err\n  }\n\n  applyPhase(\n    outdatedSelfAcceptedModules,\n    newModuleFactories,\n    outdatedModuleParents,\n    reportError\n  )\n\n  if (error) {\n    throw error\n  }\n\n  if (queuedInvalidatedModules.size > 0) {\n    applyInternal(new Set(), [], new Map())\n  }\n}\n\nfunction computeChangedModules(\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>\n): {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n  deleted: Set<ModuleId>\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>\n} {\n  const chunksAdded = new Map()\n  const chunksDeleted = new Map()\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map()\n  const modified = new Map()\n  const deleted: Set<ModuleId> = new Set()\n\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    switch (mergedChunkUpdate.type) {\n      case 'added': {\n        const updateAdded = new Set(mergedChunkUpdate.modules)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        break\n      }\n      case 'deleted': {\n        // We could also use `mergedChunkUpdate.modules` here.\n        const updateDeleted = new Set(chunkModulesMap.get(chunkPath))\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      case 'partial': {\n        const updateAdded = new Set(mergedChunkUpdate.added)\n        const updateDeleted = new Set(mergedChunkUpdate.deleted)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      default:\n        invariant(\n          mergedChunkUpdate,\n          (mergedChunkUpdate) =>\n            `Unknown merged chunk update type: ${mergedChunkUpdate.type}`\n        )\n    }\n  }\n\n  // If a module was added from one chunk and deleted from another in the same update,\n  // consider it to be modified, as it means the module was moved from one chunk to another\n  // AND has new code in a single update.\n  for (const moduleId of added.keys()) {\n    if (deleted.has(moduleId)) {\n      added.delete(moduleId)\n      deleted.delete(moduleId)\n    }\n  }\n\n  for (const [moduleId, entry] of Object.entries(entries)) {\n    // Modules that haven't been added to any chunk but have new code are considered\n    // to be modified.\n    // This needs to be under the previous loop, as we need it to get rid of modules\n    // that were added and deleted in the same update.\n    if (!added.has(moduleId)) {\n      modified.set(moduleId, entry)\n    }\n  }\n\n  return { added, deleted, modified, chunksAdded, chunksDeleted }\n}\n\ntype ModuleEffect =\n  | {\n      type: 'unaccepted'\n      dependencyChain: ModuleId[]\n    }\n  | {\n      type: 'self-declined'\n      dependencyChain: ModuleId[]\n      moduleId: ModuleId\n    }\n  | {\n      type: 'accepted'\n      moduleId: ModuleId\n      outdatedModules: Set<ModuleId>\n    }\n\nfunction getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\n  const outdatedModules: Set<ModuleId> = new Set()\n\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }\n\n  const queue: QueueItem[] = [\n    {\n      moduleId,\n      dependencyChain: [],\n    },\n  ]\n\n  let nextItem\n  while ((nextItem = queue.shift())) {\n    const { moduleId, dependencyChain } = nextItem\n\n    if (moduleId != null) {\n      if (outdatedModules.has(moduleId)) {\n        // Avoid infinite loops caused by cycles between modules in the dependency chain.\n        continue\n      }\n\n      outdatedModules.add(moduleId)\n    }\n\n    // We've arrived at the runtime of the chunk, which means that nothing\n    // else above can accept this update.\n    if (moduleId === undefined) {\n      return {\n        type: 'unaccepted',\n        dependencyChain,\n      }\n    }\n\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n\n    if (\n      // The module is not in the cache. Since this is a \"modified\" update,\n      // it means that the module was never instantiated before.\n      !module || // The module accepted itself without invalidating globalThis.\n      // TODO is that right?\n      (hotState.selfAccepted && !hotState.selfInvalidated)\n    ) {\n      continue\n    }\n\n    if (hotState.selfDeclined) {\n      return {\n        type: 'self-declined',\n        dependencyChain,\n        moduleId,\n      }\n    }\n\n    if (runtimeModules.has(moduleId)) {\n      queue.push({\n        moduleId: undefined,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n      continue\n    }\n\n    for (const parentId of module.parents) {\n      const parent = devModuleCache[parentId]\n\n      if (!parent) {\n        // TODO(alexkirsz) Is this even possible?\n        continue\n      }\n\n      // TODO(alexkirsz) Dependencies: check accepted and declined\n      // dependencies here.\n\n      queue.push({\n        moduleId: parentId,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n    }\n  }\n\n  return {\n    type: 'accepted',\n    moduleId,\n    outdatedModules,\n  }\n}\n\nfunction handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {\n  switch (update.type) {\n    case 'partial': {\n      // This indicates that the update is can be applied to the current state of the application.\n      applyUpdate(update.instruction)\n      break\n    }\n    case 'restart': {\n      // This indicates that there is no way to apply the update to the\n      // current state of the application, and that the application must be\n      // restarted.\n      DEV_BACKEND.restart()\n      break\n    }\n    case 'notFound': {\n      // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n      // or the page itself was deleted.\n      // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n      // If it is a runtime chunk list, we restart the application.\n      if (runtimeChunkLists.has(chunkListPath)) {\n        DEV_BACKEND.restart()\n      } else {\n        disposeChunkList(chunkListPath)\n      }\n      break\n    }\n    default:\n      throw new Error(`Unknown update type: ${update.type}`)\n  }\n}\n\nfunction createModuleHot(\n  moduleId: ModuleId,\n  hotData: HotData\n): { hot: Hot; hotState: HotState } {\n  const hotState: HotState = {\n    selfAccepted: false,\n    selfDeclined: false,\n    selfInvalidated: false,\n    disposeHandlers: [],\n  }\n\n  const hot: Hot = {\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n    // decide whether to warn whenever an HMR-disposed module required other\n    // modules. We might want to remove it.\n    active: true,\n\n    data: hotData ?? {},\n\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n    accept: (\n      modules?: string | string[] | AcceptErrorHandler,\n      _callback?: AcceptCallback,\n      _errorHandler?: AcceptErrorHandler\n    ) => {\n      if (modules === undefined) {\n        hotState.selfAccepted = true\n      } else if (typeof modules === 'function') {\n        hotState.selfAccepted = modules\n      } else {\n        throw new Error('unsupported `accept` signature')\n      }\n    },\n\n    decline: (dep) => {\n      if (dep === undefined) {\n        hotState.selfDeclined = true\n      } else {\n        throw new Error('unsupported `decline` signature')\n      }\n    },\n\n    dispose: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    addDisposeHandler: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    removeDisposeHandler: (callback) => {\n      const idx = hotState.disposeHandlers.indexOf(callback)\n      if (idx >= 0) {\n        hotState.disposeHandlers.splice(idx, 1)\n      }\n    },\n\n    invalidate: () => {\n      hotState.selfInvalidated = true\n      queuedInvalidatedModules.add(moduleId)\n    },\n\n    // NOTE(alexkirsz) This is part of the management API, which we don't\n    // implement, but the Next.js React Refresh runtime uses this to decide\n    // whether to schedule an update.\n    status: () => 'idle',\n\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n    addStatusHandler: (_handler) => {},\n    removeStatusHandler: (_handler) => {},\n\n    // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n    // want the webpack code paths to ever update (the turbopack paths handle\n    // this already).\n    check: () => Promise.resolve(null),\n  }\n\n  return { hot, hotState }\n}\n\n/**\n * Removes a module from a chunk.\n * Returns `true` if there are no remaining chunks including this module.\n */\nfunction removeModuleFromChunk(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): boolean {\n  const moduleChunks = moduleChunksMap.get(moduleId)!\n  moduleChunks.delete(chunkPath)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)!\n  chunkModules.delete(moduleId)\n\n  const noRemainingModules = chunkModules.size === 0\n  if (noRemainingModules) {\n    chunkModulesMap.delete(chunkPath)\n  }\n\n  const noRemainingChunks = moduleChunks.size === 0\n  if (noRemainingChunks) {\n    moduleChunksMap.delete(moduleId)\n  }\n\n  return noRemainingChunks\n}\n\n/**\n * Disposes of a chunk list and its corresponding exclusive chunks.\n */\nfunction disposeChunkList(chunkListPath: ChunkListPath): boolean {\n  const chunkPaths = chunkListChunksMap.get(chunkListPath)\n  if (chunkPaths == null) {\n    return false\n  }\n  chunkListChunksMap.delete(chunkListPath)\n\n  for (const chunkPath of chunkPaths) {\n    const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!\n    chunkChunkLists.delete(chunkListPath)\n\n    if (chunkChunkLists.size === 0) {\n      chunkChunkListsMap.delete(chunkPath)\n      disposeChunk(chunkPath)\n    }\n  }\n\n  // We must also dispose of the chunk list's chunk itself to ensure it may\n  // be reloaded properly in the future.\n  const chunkListUrl = getChunkRelativeUrl(chunkListPath)\n\n  DEV_BACKEND.unloadChunk?.(chunkListUrl)\n\n  return true\n}\n\n/**\n * Disposes of a chunk and its corresponding exclusive modules.\n *\n * @returns Whether the chunk was disposed of.\n */\nfunction disposeChunk(chunkPath: ChunkPath): boolean {\n  const chunkUrl = getChunkRelativeUrl(chunkPath)\n  // This should happen whether the chunk has any modules in it or not.\n  // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n  DEV_BACKEND.unloadChunk?.(chunkUrl)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)\n  if (chunkModules == null) {\n    return false\n  }\n  chunkModules.delete(chunkPath)\n\n  for (const moduleId of chunkModules) {\n    const moduleChunks = moduleChunksMap.get(moduleId)!\n    moduleChunks.delete(chunkPath)\n\n    const noRemainingChunks = moduleChunks.size === 0\n    if (noRemainingChunks) {\n      moduleChunksMap.delete(moduleId)\n      disposeModule(moduleId, 'clear')\n      availableModules.delete(moduleId)\n    }\n  }\n\n  return true\n}\n\n/**\n * Adds a module to a chunk.\n */\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\n  let moduleChunks = moduleChunksMap.get(moduleId)\n  if (!moduleChunks) {\n    moduleChunks = new Set([chunkPath])\n    moduleChunksMap.set(moduleId, moduleChunks)\n  } else {\n    moduleChunks.add(chunkPath)\n  }\n\n  let chunkModules = chunkModulesMap.get(chunkPath)\n  if (!chunkModules) {\n    chunkModules = new Set([moduleId])\n    chunkModulesMap.set(chunkPath, chunkModules)\n  } else {\n    chunkModules.add(moduleId)\n  }\n}\n\n/**\n * Marks a chunk list as a runtime chunk list. There can be more than one\n * runtime chunk list. For instance, integration tests can have multiple chunk\n * groups loaded at runtime, each with its own chunk list.\n */\nfunction markChunkListAsRuntime(chunkListPath: ChunkListPath) {\n  runtimeChunkLists.add(chunkListPath)\n}\n\nfunction registerChunk(registration: ChunkRegistration) {\n  const chunkPath = getPathFromScript(registration[0])\n  let runtimeParams: RuntimeParams | undefined\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n  if (registration.length === 2) {\n    runtimeParams = registration[1] as RuntimeParams\n  } else {\n    runtimeParams = undefined\n    installCompressedModuleFactories(\n      registration as CompressedModuleFactories,\n      /* offset= */ 1,\n      moduleFactories,\n      (id: ModuleId) => addModuleToChunk(id, chunkPath)\n    )\n  }\n  return BACKEND.registerChunk(chunkPath, runtimeParams)\n}\n\n/**\n * Subscribes to chunk list updates from the update server and applies them.\n */\nfunction registerChunkList(chunkList: ChunkList) {\n  const chunkListScript = chunkList.script\n  const chunkListPath = getPathFromScript(chunkListScript)\n  // The \"chunk\" is also registered to finish the loading in the backend\n  BACKEND.registerChunk(chunkListPath as string as ChunkPath)\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([\n    chunkListPath,\n    handleApply.bind(null, chunkListPath),\n  ])\n\n  // Adding chunks to chunk lists and vice versa.\n  const chunkPaths = new Set(chunkList.chunks.map(getChunkPath))\n  chunkListChunksMap.set(chunkListPath, chunkPaths)\n  for (const chunkPath of chunkPaths) {\n    let chunkChunkLists = chunkChunkListsMap.get(chunkPath)\n    if (!chunkChunkLists) {\n      chunkChunkLists = new Set([chunkListPath])\n      chunkChunkListsMap.set(chunkPath, chunkChunkLists)\n    } else {\n      chunkChunkLists.add(chunkListPath)\n    }\n  }\n\n  if (chunkList.source === 'entry') {\n    markChunkListAsRuntime(chunkListPath)\n  }\n}\n\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= []\n"],"names":[],"mappings":"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","ignoreList":[0]}},{"offset":{"line":1595,"column":0},"map":{"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n\ntype ChunkResolver = {\n  resolved: boolean\n  loadingStarted: boolean\n  resolve: () => void\n  reject: (error?: Error) => void\n  promise: Promise<any>\n}\n\nlet BACKEND: RuntimeBackend\n\n/**\n * Maps chunk paths to the corresponding resolver.\n */\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n\n;(() => {\n  BACKEND = {\n    async registerChunk(chunkPath, params) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\n\n      const resolver = getOrCreateResolver(chunkUrl)\n      resolver.resolve()\n\n      if (params == null) {\n        return\n      }\n\n      for (const otherChunkData of params.otherChunks) {\n        const otherChunkPath = getChunkPath(otherChunkData)\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath)\n\n        // Chunk might have started loading, so we want to avoid triggering another load.\n        getOrCreateResolver(otherChunkUrl)\n      }\n\n      // This waits for chunks to be loaded, but also marks included items as available.\n      await Promise.all(\n        params.otherChunks.map((otherChunkData) =>\n          loadInitialChunk(chunkPath, otherChunkData)\n        )\n      )\n\n      if (params.runtimeModuleIds.length > 0) {\n        for (const moduleId of params.runtimeModuleIds) {\n          getOrInstantiateRuntimeModule(chunkPath, moduleId)\n        }\n      }\n    },\n\n    /**\n     * Loads the given chunk, and returns a promise that resolves once the chunk\n     * has been loaded.\n     */\n    loadChunkCached(sourceType: SourceType, chunkUrl: ChunkUrl) {\n      return doLoadChunk(sourceType, chunkUrl)\n    },\n\n    async loadWebAssembly(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module,\n      importsObj: WebAssembly.Imports\n    ): Promise<Exports> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      const { instance } = await WebAssembly.instantiateStreaming(\n        req,\n        importsObj\n      )\n\n      return instance.exports\n    },\n\n    async loadWebAssemblyModule(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module\n    ): Promise<WebAssembly.Module> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      return await WebAssembly.compileStreaming(req)\n    },\n  }\n\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\n    let resolver = chunkResolvers.get(chunkUrl)\n    if (!resolver) {\n      let resolve: () => void\n      let reject: (error?: Error) => void\n      const promise = new Promise<void>((innerResolve, innerReject) => {\n        resolve = innerResolve\n        reject = innerReject\n      })\n      resolver = {\n        resolved: false,\n        loadingStarted: false,\n        promise,\n        resolve: () => {\n          resolver!.resolved = true\n          resolve()\n        },\n        reject: reject!,\n      }\n      chunkResolvers.set(chunkUrl, resolver)\n    }\n    return resolver\n  }\n\n  /**\n   * Loads the given chunk, and returns a promise that resolves once the chunk\n   * has been loaded.\n   */\n  function doLoadChunk(sourceType: SourceType, chunkUrl: ChunkUrl) {\n    const resolver = getOrCreateResolver(chunkUrl)\n    if (resolver.loadingStarted) {\n      return resolver.promise\n    }\n\n    if (sourceType === SourceType.Runtime) {\n      // We don't need to load chunks references from runtime code, as they're already\n      // present in the DOM.\n      resolver.loadingStarted = true\n\n      if (isCss(chunkUrl)) {\n        // CSS chunks do not register themselves, and as such must be marked as\n        // loaded instantly.\n        resolver.resolve()\n      }\n\n      // We need to wait for JS chunks to register themselves within `registerChunk`\n      // before we can start instantiating runtime modules, hence the absence of\n      // `resolver.resolve()` in this branch.\n\n      return resolver.promise\n    }\n\n    if (typeof importScripts === 'function') {\n      // We're in a web worker\n      if (isCss(chunkUrl)) {\n        // ignore\n      } else if (isJs(chunkUrl)) {\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl)\n        importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl)\n      } else {\n        throw new Error(\n          `can't infer type of chunk from URL ${chunkUrl} in worker`\n        )\n      }\n    } else {\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousLinks.length > 0) {\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolver.resolve()\n        } else {\n          const link = document.createElement('link')\n          link.rel = 'stylesheet'\n          link.href = chunkUrl\n          link.onerror = () => {\n            resolver.reject()\n          }\n          link.onload = () => {\n            // CSS chunks do not register themselves, and as such must be marked as\n            // loaded instantly.\n            resolver.resolve()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(link)\n        }\n      } else if (isJs(chunkUrl)) {\n        const previousScripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousScripts.length > 0) {\n          // There is this edge where the script already failed loading, but we\n          // can't detect that. The Promise will never resolve in this case.\n          for (const script of Array.from(previousScripts)) {\n            script.addEventListener('error', () => {\n              resolver.reject()\n            })\n          }\n        } else {\n          const script = document.createElement('script')\n          script.src = chunkUrl\n          // We'll only mark the chunk as loaded once the script has been executed,\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\n          // this branch.\n          script.onerror = () => {\n            resolver.reject()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(script)\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    }\n\n    resolver.loadingStarted = true\n    return resolver.promise\n  }\n\n  function fetchWebAssembly(wasmChunkPath: ChunkPath) {\n    return fetch(getChunkRelativeUrl(wasmChunkPath))\n  }\n})()\n"],"names":[],"mappings":"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","ignoreList":[0]}},{"offset":{"line":1757,"column":0},"map":{"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/dom/dev-backend-dom.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/runtime-base.ts\" />\n/// <reference path=\"../base/dev-base.ts\" />\n/// <reference path=\"./runtime-backend-dom.ts\" />\n/// <reference path=\"../../../shared/require-type.d.ts\" />\n\nlet DEV_BACKEND: DevRuntimeBackend\n;(() => {\n  DEV_BACKEND = {\n    unloadChunk(chunkUrl) {\n      deleteResolver(chunkUrl)\n\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const links = document.querySelectorAll(\n          `link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`\n        )\n        for (const link of Array.from(links)) {\n          link.remove()\n        }\n      } else if (isJs(chunkUrl)) {\n        // Unloading a JS chunk would have no effect, as it lives in the JS\n        // runtime once evaluated.\n        // However, we still want to remove the script tag from the DOM to keep\n        // the HTML somewhat consistent from the user's perspective.\n        const scripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        for (const script of Array.from(scripts)) {\n          script.remove()\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    },\n\n    reloadChunk(chunkUrl) {\n      return new Promise<void>((resolve, reject) => {\n        if (!isCss(chunkUrl)) {\n          reject(new Error('The DOM backend can only reload CSS chunks'))\n          return\n        }\n\n        const decodedChunkUrl = decodeURI(chunkUrl)\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n\n        if (previousLinks.length === 0) {\n          reject(new Error(`No link element found for chunk ${chunkUrl}`))\n          return\n        }\n\n        const link = document.createElement('link')\n        link.rel = 'stylesheet'\n\n        if (navigator.userAgent.includes('Firefox')) {\n          // Firefox won't reload CSS files that were previously loaded on the current page,\n          // we need to add a query param to make sure CSS is actually reloaded from the server.\n          //\n          // I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506\n          //\n          // Safari has a similar issue, but only if you have a `<link rel=preload ... />` tag\n          // pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726\n          link.href = `${chunkUrl}?ts=${Date.now()}`\n        } else {\n          link.href = chunkUrl\n        }\n\n        link.onerror = () => {\n          reject()\n        }\n        link.onload = () => {\n          // First load the new CSS, then remove the old ones. This prevents visible\n          // flickering that would happen in-between removing the previous CSS and\n          // loading the new one.\n          for (const previousLink of Array.from(previousLinks))\n            previousLink.remove()\n\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolve()\n        }\n\n        // Make sure to insert the new CSS right after the previous one, so that\n        // its precedence is higher.\n        previousLinks[0].parentElement!.insertBefore(\n          link,\n          previousLinks[0].nextSibling\n        )\n      })\n    },\n\n    restart: () => self.location.reload(),\n  }\n\n  function deleteResolver(chunkUrl: ChunkUrl) {\n    chunkResolvers.delete(chunkUrl)\n  }\n})()\n\nfunction _eval({ code, url, map }: EcmascriptModuleEntry): ModuleFactory {\n  code += `\\n\\n//# sourceURL=${encodeURI(\n    location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX\n  )}`\n  if (map) {\n    code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(\n      // btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n      // See https://stackoverflow.com/a/26603875\n      unescape(encodeURIComponent(map))\n    )}`\n  }\n\n  // eslint-disable-next-line no-eval\n  return eval(code)\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,gDAAgD;AAChD,4CAA4C;AAC5C,iDAAiD;AACjD,0DAA0D;AAE1D,IAAI;AACH,CAAC;IACA,cAAc;QACZ,aAAY,QAAQ;YAClB,eAAe;YAEf,gFAAgF;YAChF,MAAM,kBAAkB,UAAU;YAElC,IAAI,MAAM,WAAW;gBACnB,MAAM,QAAQ,SAAS,gBAAgB,CACrC,CAAC,WAAW,EAAE,SAAS,eAAe,EAAE,SAAS,eAAe,EAAE,gBAAgB,eAAe,EAAE,gBAAgB,GAAG,CAAC;gBAEzH,KAAK,MAAM,QAAQ,MAAM,IAAI,CAAC,OAAQ;oBACpC,KAAK,MAAM;gBACb;YACF,OAAO,IAAI,KAAK,WAAW;gBACzB,mEAAmE;gBACnE,0BAA0B;gBAC1B,uEAAuE;gBACvE,4DAA4D;gBAC5D,MAAM,UAAU,SAAS,gBAAgB,CACvC,CAAC,YAAY,EAAE,SAAS,gBAAgB,EAAE,SAAS,gBAAgB,EAAE,gBAAgB,gBAAgB,EAAE,gBAAgB,GAAG,CAAC;gBAE7H,KAAK,MAAM,UAAU,MAAM,IAAI,CAAC,SAAU;oBACxC,OAAO,MAAM;gBACf;YACF,OAAO;gBACL,MAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,UAAU;YAClE;QACF;QAEA,aAAY,QAAQ;YAClB,OAAO,IAAI,QAAc,CAAC,SAAS;gBACjC,IAAI,CAAC,MAAM,WAAW;oBACpB,OAAO,IAAI,MAAM;oBACjB;gBACF;gBAEA,MAAM,kBAAkB,UAAU;gBAClC,MAAM,gBAAgB,SAAS,gBAAgB,CAC7C,CAAC,2BAA2B,EAAE,SAAS,+BAA+B,EAAE,SAAS,+BAA+B,EAAE,gBAAgB,+BAA+B,EAAE,gBAAgB,GAAG,CAAC;gBAGzL,IAAI,cAAc,MAAM,KAAK,GAAG;oBAC9B,OAAO,IAAI,MAAM,CAAC,gCAAgC,EAAE,UAAU;oBAC9D;gBACF;gBAEA,MAAM,OAAO,SAAS,aAAa,CAAC;gBACpC,KAAK,GAAG,GAAG;gBAEX,IAAI,UAAU,SAAS,CAAC,QAAQ,CAAC,YAAY;oBAC3C,kFAAkF;oBAClF,sFAAsF;oBACtF,EAAE;oBACF,qFAAqF;oBACrF,EAAE;oBACF,oFAAoF;oBACpF,6FAA6F;oBAC7F,KAAK,IAAI,GAAG,GAAG,SAAS,IAAI,EAAE,KAAK,GAAG,IAAI;gBAC5C,OAAO;oBACL,KAAK,IAAI,GAAG;gBACd;gBAEA,KAAK,OAAO,GAAG;oBACb;gBACF;gBACA,KAAK,MAAM,GAAG;oBACZ,0EAA0E;oBAC1E,wEAAwE;oBACxE,uBAAuB;oBACvB,KAAK,MAAM,gBAAgB,MAAM,IAAI,CAAC,eACpC,aAAa,MAAM;oBAErB,uEAAuE;oBACvE,oBAAoB;oBACpB;gBACF;gBAEA,wEAAwE;gBACxE,4BAA4B;gBAC5B,aAAa,CAAC,EAAE,CAAC,aAAa,CAAE,YAAY,CAC1C,MACA,aAAa,CAAC,EAAE,CAAC,WAAW;YAEhC;QACF;QAEA,SAAS,IAAM,KAAK,QAAQ,CAAC,MAAM;IACrC;IAEA,SAAS,eAAe,QAAkB;QACxC,eAAe,MAAM,CAAC;IACxB;AACF,CAAC;AAED,SAAS,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAyB;IACtD,QAAQ,CAAC,kBAAkB,EAAE,UAC3B,SAAS,MAAM,GAAG,kBAAkB,MAAM,eACzC;IACH,IAAI,KAAK;QACP,QAAQ,CAAC,kEAAkE,EAAE,KAC3E,0EAA0E;QAC1E,2CAA2C;QAC3C,SAAS,mBAAmB,QAC3B;IACL;IAEA,mCAAmC;IACnC,OAAO,KAAK;AACd","ignoreList":[0]}}],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(\n  this: TurbopackBaseContext<Module>,\n  module: Module,\n  exports: Exports\n) {\n  this.m = module\n  // We need to store this here instead of accessing it from the module object to:\n  // 1. Make it available to factories directly, since we rewrite `this` to\n  //    `__turbopack_context__.e` in CJS modules.\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\n  //    can still access the original exports object from functions like\n  //    `esmExport`\n  // Ideally we could find a new approach for async modules and drop this property altogether.\n  this.e = exports\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: string): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: string): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\n  moduleId: M['id'],\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId\n): Module {\n  let module = moduleCache[id]\n  if (!module) {\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\n    // instantiateModule and the cache entry wasn't created yet.\n    module = createModuleObject(id)\n    moduleCache[id] = module\n  }\n  return module\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n  }\n}\n\ntype BindingTag = 0\nconst BindingTag_Value = 0 as BindingTag\n\n// an arbitrary sequence of bindings as\n// - a prop name\n// - BindingTag_Value, a value to be bound directly, or\n// - 1 or 2 functions to bind as getters and sdetters\ntype EsmBindings = Array<\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\n>\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, bindings: EsmBindings) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  let i = 0\n  while (i < bindings.length) {\n    const propName = bindings[i++] as string\n    const tagOrFunction = bindings[i++]\n    if (typeof tagOrFunction === 'number') {\n      if (tagOrFunction === BindingTag_Value) {\n        defineProp(exports, propName, {\n          value: bindings[i++],\n          enumerable: true,\n          writable: false,\n        })\n      } else {\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\n      }\n    } else {\n      const getterFn = tagOrFunction as () => unknown\n      if (typeof bindings[i] === 'function') {\n        const setterFn = bindings[i++] as (v: unknown) => void\n        defineProp(exports, propName, {\n          get: getterFn,\n          set: setterFn,\n          enumerable: true,\n        })\n      } else {\n        defineProp(exports, propName, {\n          get: getterFn,\n          enumerable: true,\n        })\n      }\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  bindings: EsmBindings,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Module['exports']\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  module.namespaceObject = exports\n  esm(exports, bindings)\n}\ncontextPrototype.s = esmExport\n\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\nfunction ensureDynamicExports(\n  module: Module,\n  exports: Exports\n): ReexportedObjects {\n  let reexportedObjects: ReexportedObjects | undefined =\n    REEXPORTED_OBJECTS.get(module)\n\n  if (!reexportedObjects) {\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n  return reexportedObjects\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Exports\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  const reexportedObjects = ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    reexportedObjects.push(object)\n  }\n}\ncontextPrototype.j = dynamicExport\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = value\n}\ncontextPrototype.v = exportValue\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = module.namespaceObject = namespace\n}\ncontextPrototype.n = exportNamespace\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const bindings: EsmBindings = []\n  let defaultLocation = -1\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      bindings.push(key, createGetter(raw, key))\n      if (defaultLocation === -1 && key === 'default') {\n        defaultLocation = bindings.length - 1\n      }\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && defaultLocation >= 0)) {\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\n    if (defaultLocation >= 0) {\n      // Replace the getter with the value\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\n    } else {\n      bindings.push('default', BindingTag_Value, raw)\n    }\n  }\n\n  esm(ns, bindings)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m)\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\ncontextPrototype.i = esmImport\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport\n  ) => Promise<Exports>\n  return loader(esmImport.bind(this))\n}\ncontextPrototype.A = asyncLoader\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\ncontextPrototype.t = runtimeRequire\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exports {\n  return getOrInstantiateModuleFromParent(id, this.m).exports\n}\ncontextPrototype.r = commonJsRequire\n\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */\nfunction parseRequest(request: string): string {\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n  const hashIndex = request.indexOf('#')\n  if (hashIndex !== -1) {\n    request = request.substring(0, hashIndex)\n  }\n\n  const queryIndex = request.indexOf('?')\n  if (queryIndex !== -1) {\n    request = request.substring(0, queryIndex)\n  }\n\n  return request\n}\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: string): Exports {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): string[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: string): ModuleId => {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: string) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\ncontextPrototype.f = moduleContext\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(\n  chunkModules: CompressedModuleFactories,\n  offset: number,\n  moduleFactories: ModuleFactories,\n  newModuleId?: (id: ModuleId) => void\n) {\n  let i = offset\n  while (i < chunkModules.length) {\n    let moduleId = chunkModules[i] as ModuleId\n    let end = i + 1\n    // Find our factory function\n    while (\n      end < chunkModules.length &&\n      typeof chunkModules[end] !== 'function'\n    ) {\n      end++\n    }\n    if (end === chunkModules.length) {\n      throw new Error('malformed chunk format, expected a factory function')\n    }\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n    // present we know all the additional ids are also present, so we don't need to check.\n    if (!moduleFactories.has(moduleId)) {\n      const moduleFactoryFn = chunkModules[end] as Function\n      applyModuleFactoryName(moduleFactoryFn)\n      newModuleId?.(moduleId)\n      for (; i < end; i++) {\n        moduleId = chunkModules[i] as ModuleId\n        moduleFactories.set(moduleId, moduleFactoryFn)\n      }\n    }\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const module = this.m\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\ncontextPrototype.a = asyncModule\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\nrelativeURL.prototype = URL.prototype\ncontextPrototype.U = relativeURL\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\ncontextPrototype.z = requireStub\n\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis\n\ntype ContextConstructor<M> = {\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\n}\n\nfunction applyModuleFactoryName(factory: Function) {\n  // Give the module factory a nice name to improve stack traces.\n  Object.defineProperty(factory, 'name', {\n    value: 'module evaluation',\n  })\n}\n","/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n\n// Used in WebWorkers to tell the runtime about the chunk base path\ndeclare var TURBOPACK_WORKER_LOCATION: string\n// Used in WebWorkers to tell the runtime about the chunk suffix\ndeclare var TURBOPACK_CHUNK_SUFFIX: string\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\n// Note it's stored in reversed order to use push and pop\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\n\n// Injected by rust code\ndeclare var CHUNK_BASE_PATH: string\ndeclare var CHUNK_SUFFIX: string\n\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\n  R: ResolvePathFromModule\n}\n\nconst browserContextPrototype =\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\n\n// Provided by build or dev base\ndeclare function instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module\n\ntype RuntimeParams = {\n  otherChunks: ChunkData[]\n  runtimeModuleIds: ModuleId[]\n}\n\ntype ChunkRegistration = [\n  chunkPath: ChunkScript,\n  ...([RuntimeParams] | CompressedModuleFactories),\n]\n\ntype ChunkList = {\n  script: ChunkListScript\n  chunks: ChunkData[]\n  source: 'entry' | 'dynamic'\n}\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\ninterface RuntimeBackend {\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void\n  /**\n   * Returns the same Promise for the same chunk URL.\n   */\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\n  loadWebAssembly: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module,\n    importsObj: WebAssembly.Imports\n  ) => Promise<Exports>\n  loadWebAssemblyModule: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module\n  ) => Promise<WebAssembly.Module>\n}\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nconst moduleFactories: ModuleFactories = new Map()\ncontextPrototype.M = moduleFactories\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\n\nfunction factoryNotAvailableMessage(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): string {\n  let instantiationReason\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\n      break\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`\n      break\n    case SourceType.Update:\n      instantiationReason = 'because of an HMR update'\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\n}\n\nfunction loadChunk(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkData: ChunkData\n): Promise<void> {\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\n}\nbrowserContextPrototype.l = loadChunk\n\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\n}\n\nasync function loadChunkInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkData: ChunkData\n): Promise<void> {\n  if (typeof chunkData === 'string') {\n    return loadChunkPath(sourceType, sourceData, chunkData)\n  }\n\n  const includedList = chunkData.included || []\n  const modulesPromises = includedList.map((included) => {\n    if (moduleFactories.has(included)) return true\n    return availableModules.get(included)\n  })\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\n    // When all included items are already loaded or loading, we can skip loading ourselves\n    await Promise.all(modulesPromises)\n    return\n  }\n\n  const includedModuleChunksList = chunkData.moduleChunks || []\n  const moduleChunksPromises = includedModuleChunksList\n    .map((included) => {\n      // TODO(alexkirsz) Do we need this check?\n      // if (moduleFactories[included]) return true;\n      return availableModuleChunks.get(included)\n    })\n    .filter((p) => p)\n\n  let promise: Promise<unknown>\n  if (moduleChunksPromises.length > 0) {\n    // Some module chunks are already loaded or loading.\n\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\n      await Promise.all(moduleChunksPromises)\n      return\n    }\n\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\n    for (const moduleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(moduleChunk)) {\n        moduleChunksToLoad.add(moduleChunk)\n      }\n    }\n\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\n\n      availableModuleChunks.set(moduleChunkToLoad, promise)\n\n      moduleChunksPromises.push(promise)\n    }\n\n    promise = Promise.all(moduleChunksPromises)\n  } else {\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\n\n    // Mark all included module chunks as loading if they are not already loaded or loading.\n    for (const includedModuleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(includedModuleChunk)) {\n        availableModuleChunks.set(includedModuleChunk, promise)\n      }\n    }\n  }\n\n  for (const included of includedList) {\n    if (!availableModules.has(included)) {\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n      availableModules.set(included, promise)\n    }\n  }\n\n  await promise\n}\n\nconst loadedChunk = Promise.resolve(undefined)\nconst instrumentedBackendLoadChunks = new WeakMap<\n  Promise<any>,\n  Promise<any> | typeof loadedChunk\n>()\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkUrl: ChunkUrl\n) {\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\n}\nbrowserContextPrototype.L = loadChunkByUrl\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkUrl: ChunkUrl\n): Promise<any> {\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\n  let entry = instrumentedBackendLoadChunks.get(thenable)\n  if (entry === undefined) {\n    const resolve = instrumentedBackendLoadChunks.set.bind(\n      instrumentedBackendLoadChunks,\n      thenable,\n      loadedChunk\n    )\n    entry = thenable.then(resolve).catch((cause) => {\n      let loadReason: string\n      switch (sourceType) {\n        case SourceType.Runtime:\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\n          break\n        case SourceType.Parent:\n          loadReason = `from module ${sourceData}`\n          break\n        case SourceType.Update:\n          loadReason = 'from an HMR update'\n          break\n        default:\n          invariant(\n            sourceType,\n            (sourceType) => `Unknown source type: ${sourceType}`\n          )\n      }\n      let error = new Error(\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\n          cause ? `: ${cause}` : ''\n        }`,\n        cause ? { cause } : undefined\n      )\n      error.name = 'ChunkLoadError'\n      throw error\n    })\n    instrumentedBackendLoadChunks.set(thenable, entry)\n  }\n\n  return entry\n}\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkPath: ChunkPath\n): Promise<void> {\n  const url = getChunkRelativeUrl(chunkPath)\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\n}\n\n/**\n * Returns an absolute url to an asset.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string\n): string {\n  const exported = this.r(moduleId)\n  return exported?.default ?? exported\n}\nbrowserContextPrototype.R = resolvePathFromModule\n\n/**\n * no-op for browser\n * @param modulePath\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  return `/ROOT/${modulePath ?? ''}`\n}\nbrowserContextPrototype.P = resolveAbsolutePath\n\n/**\n * Returns a blob URL for the worker.\n * @param chunks list of chunks to load\n */\nfunction getWorkerBlobURL(chunks: ChunkPath[]): string {\n  // It is important to reverse the array so when bootstrapping we can infer what chunk is being\n  // evaluated by poping urls off of this array.  See `getPathFromScript`\n  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\nself.TURBOPACK_CHUNK_SUFFIX = ${JSON.stringify(CHUNK_SUFFIX)};\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`\n  let blob = new Blob([bootstrap], { type: 'text/javascript' })\n  return URL.createObjectURL(blob)\n}\nbrowserContextPrototype.b = getWorkerBlobURL\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n  return `${CHUNK_BASE_PATH}${chunkPath\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')}${CHUNK_SUFFIX}` as ChunkUrl\n}\n\n/**\n * Return the ChunkPath from a ChunkScript.\n */\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\nfunction getPathFromScript(\n  chunkScript: ChunkListPath | ChunkListScript\n): ChunkListPath\nfunction getPathFromScript(\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\n): ChunkPath | ChunkListPath {\n  if (typeof chunkScript === 'string') {\n    return chunkScript as ChunkPath | ChunkListPath\n  }\n  const chunkUrl =\n    typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined'\n      ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\n      : chunkScript.getAttribute('src')!\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\n  const path = src.startsWith(CHUNK_BASE_PATH)\n    ? src.slice(CHUNK_BASE_PATH.length)\n    : src\n  return path as ChunkPath | ChunkListPath\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n */\nfunction isCss(chunkUrl: ChunkUrl): boolean {\n  return regexCssUrl.test(chunkUrl)\n}\n\nfunction loadWebAssembly(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  return BACKEND.loadWebAssembly(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule,\n    importsObj\n  )\n}\ncontextPrototype.w = loadWebAssembly\n\nfunction loadWebAssemblyModule(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module\n): Promise<WebAssembly.Module> {\n  return BACKEND.loadWebAssemblyModule(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule\n  )\n}\ncontextPrototype.u = loadWebAssemblyModule\n","/// <reference path=\"./dev-globals.d.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\n\ninterface TurbopackDevContext extends TurbopackBrowserBaseContext<HotModule> {\n  k: RefreshContext\n}\n\nconst devContextPrototype = Context.prototype as TurbopackDevContext\n\n/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst devModuleCache: ModuleCache<HotModule> = Object.create(null)\ndevContextPrototype.c = devModuleCache\n\n// This file must not use `import` and `export` statements. Otherwise, it\n// becomes impossible to augment interfaces declared in `<reference>`d files\n// (e.g. `Module`). Hence, the need for `import()` here.\ntype RefreshRuntimeGlobals =\n  import('@next/react-refresh-utils/dist/runtime').RefreshRuntimeGlobals\n\ndeclare var $RefreshHelpers$: RefreshRuntimeGlobals['$RefreshHelpers$']\ndeclare var $RefreshReg$: RefreshRuntimeGlobals['$RefreshReg$']\ndeclare var $RefreshSig$: RefreshRuntimeGlobals['$RefreshSig$']\ndeclare var $RefreshInterceptModuleExecution$: RefreshRuntimeGlobals['$RefreshInterceptModuleExecution$']\n\ntype RefreshContext = {\n  register: RefreshRuntimeGlobals['$RefreshReg$']\n  signature: RefreshRuntimeGlobals['$RefreshSig$']\n  registerExports: typeof registerExportsAndSetupBoundaryForReactRefresh\n}\n\ntype RefreshHelpers = RefreshRuntimeGlobals['$RefreshHelpers$']\n\ntype ModuleFactory = (\n  this: Module['exports'],\n  context: TurbopackDevContext\n) => unknown\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nclass UpdateApplyError extends Error {\n  name = 'UpdateApplyError'\n\n  dependencyChain: ModuleId[]\n\n  constructor(message: string, dependencyChain: ModuleId[]) {\n    super(message)\n    this.dependencyChain = dependencyChain\n  }\n}\n\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */\nconst runtimeModules: Set<ModuleId> = new Set()\n\n/**\n * Map from module ID to the chunks that contain this module.\n *\n * In HMR, we need to keep track of which modules are contained in which so\n * chunks. This is so we don't eagerly dispose of a module when it is removed\n * from chunk A, but still exists in chunk B.\n */\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to all modules it contains.\n */\nconst chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map()\n/**\n * Chunk lists that contain a runtime. When these chunk lists receive an update\n * that can't be reconciled with the current state of the page, we need to\n * reload the runtime entirely.\n */\nconst runtimeChunkLists: Set<ChunkListPath> = new Set()\n/**\n * Map from a chunk list to the chunk paths it contains.\n */\nconst chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to the chunk lists it belongs to.\n */\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map()\n\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */\nconst moduleHotData: Map<ModuleId, HotData> = new Map()\n/**\n * Maps module instances to their hot module state.\n */\nconst moduleHotState: Map<Module, HotState> = new Map()\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */\nconst queuedInvalidatedModules: Set<ModuleId> = new Set()\n\n/**\n * Gets or instantiates a runtime module.\n */\n// @ts-ignore\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module {\n  const module = devModuleCache[moduleId]\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  // @ts-ignore\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// @ts-ignore Defined in `runtime-utils.ts`\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n  HotModule\n> = (id, sourceModule) => {\n  if (!sourceModule.hot.active) {\n    console.warn(\n      `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`\n    )\n  }\n\n  const module = devModuleCache[id]\n\n  if (sourceModule.children.indexOf(id) === -1) {\n    sourceModule.children.push(id)\n  }\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n\n    if (module.parents.indexOf(sourceModule.id) === -1) {\n      module.parents.push(sourceModule.id)\n    }\n\n    return module\n  }\n\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n}\n\nfunction DevContext(\n  this: TurbopackDevContext,\n  module: HotModule,\n  exports: Exports,\n  refresh: RefreshContext\n) {\n  Context.call(this, module, exports)\n  this.k = refresh\n}\nDevContext.prototype = Context.prototype\n\ntype DevContextConstructor = {\n  new (\n    module: HotModule,\n    exports: Exports,\n    refresh: RefreshContext\n  ): TurbopackDevContext\n}\n\nfunction instantiateModule(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module {\n  // We are in development, this is always a string.\n  let id = moduleId as string\n\n  const moduleFactory = moduleFactories.get(id)\n  if (typeof moduleFactory !== 'function') {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    throw new Error(\n      factoryNotAvailableMessage(id, sourceType, sourceData) +\n        ' It might have been deleted in an HMR update.'\n    )\n  }\n\n  const hotData = moduleHotData.get(id)!\n  const { hot, hotState } = createModuleHot(id, hotData)\n\n  let parents: ModuleId[]\n  switch (sourceType) {\n    case SourceType.Runtime:\n      runtimeModules.add(id)\n      parents = []\n      break\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [sourceData as ModuleId]\n      break\n    case SourceType.Update:\n      parents = (sourceData as ModuleId[]) || []\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n\n  const module: HotModule = createModuleObject(id) as HotModule\n  const exports = module.exports\n  module.parents = parents\n  module.children = []\n  module.hot = hot\n\n  devModuleCache[id] = module\n  moduleHotState.set(module, hotState)\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    runModuleExecutionHooks(module, (refresh) => {\n      const context = new (DevContext as any as DevContextConstructor)(\n        module,\n        exports,\n        refresh\n      )\n      moduleFactory(context, module, exports)\n    })\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\nconst DUMMY_REFRESH_CONTEXT = {\n  register: (_type: unknown, _id: unknown) => {},\n  signature: () => (_type: unknown) => {},\n  registerExports: (_module: unknown, _helpers: unknown) => {},\n}\n\n/**\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n * Next.js' React Refresh runtime hooks into to add module context to the\n * refresh registry.\n */\nfunction runModuleExecutionHooks(\n  module: HotModule,\n  executeModule: (ctx: RefreshContext) => void\n) {\n  if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\n    const cleanupReactRefreshIntercept =\n      globalThis.$RefreshInterceptModuleExecution$(module.id)\n    try {\n      executeModule({\n        register: globalThis.$RefreshReg$,\n        signature: globalThis.$RefreshSig$,\n        registerExports: registerExportsAndSetupBoundaryForReactRefresh,\n      })\n    } finally {\n      // Always cleanup the intercept, even if module execution failed.\n      cleanupReactRefreshIntercept()\n    }\n  } else {\n    // If the react refresh hooks are not installed we need to bind dummy functions.\n    // This is expected when running in a Web Worker.  It is also common in some of\n    // our test environments.\n    executeModule(DUMMY_REFRESH_CONTEXT)\n  }\n}\n\n/**\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n */\nfunction registerExportsAndSetupBoundaryForReactRefresh(\n  module: HotModule,\n  helpers: RefreshHelpers\n) {\n  const currentExports = module.exports\n  const prevExports = module.hot.data.prevExports ?? null\n\n  helpers.registerExportsForReactRefresh(currentExports, module.id)\n\n  // A module can be accepted automatically based on its exports, e.g. when\n  // it is a Refresh Boundary.\n  if (helpers.isReactRefreshBoundary(currentExports)) {\n    // Save the previous exports on update, so we can compare the boundary\n    // signatures.\n    module.hot.dispose((data) => {\n      data.prevExports = currentExports\n    })\n    // Unconditionally accept an update to this module, we'll check if it's\n    // still a Refresh Boundary later.\n    module.hot.accept()\n\n    // This field is set when the previous version of this module was a\n    // Refresh Boundary, letting us know we need to check for invalidation or\n    // enqueue an update.\n    if (prevExports !== null) {\n      // A boundary can become ineligible if its exports are incompatible\n      // with the previous exports.\n      //\n      // For example, if you add/remove/change exports, we'll want to\n      // re-execute the importing modules, and force those components to\n      // re-render. Similarly, if you convert a class component to a\n      // function, we want to invalidate the boundary.\n      if (\n        helpers.shouldInvalidateReactRefreshBoundary(\n          helpers.getRefreshBoundarySignature(prevExports),\n          helpers.getRefreshBoundarySignature(currentExports)\n        )\n      ) {\n        module.hot.invalidate()\n      } else {\n        helpers.scheduleUpdate()\n      }\n    }\n  } else {\n    // Since we just executed the code for the module, it's possible that the\n    // new exports made it ineligible for being a boundary.\n    // We only care about the case when we were _previously_ a boundary,\n    // because we already accepted this update (accidental side effect).\n    const isNoLongerABoundary = prevExports !== null\n    if (isNoLongerABoundary) {\n      module.hot.invalidate()\n    }\n  }\n}\n\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\n  return `Dependency chain: ${dependencyChain.join(' -> ')}`\n}\n\nfunction computeOutdatedModules(\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n): {\n  outdatedModules: Set<ModuleId>\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n} {\n  const newModuleFactories = new Map<ModuleId, ModuleFactory>()\n\n  for (const [moduleId, entry] of added) {\n    if (entry != null) {\n      newModuleFactories.set(moduleId, _eval(entry))\n    }\n  }\n\n  const outdatedModules = computedInvalidatedModules(modified.keys())\n\n  for (const [moduleId, entry] of modified) {\n    newModuleFactories.set(moduleId, _eval(entry))\n  }\n\n  return { outdatedModules, newModuleFactories }\n}\n\nfunction computedInvalidatedModules(\n  invalidated: Iterable<ModuleId>\n): Set<ModuleId> {\n  const outdatedModules = new Set<ModuleId>()\n\n  for (const moduleId of invalidated) {\n    const effect = getAffectedModuleEffects(moduleId)\n\n    switch (effect.type) {\n      case 'unaccepted':\n        throw new UpdateApplyError(\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'self-declined':\n        throw new UpdateApplyError(\n          `cannot apply update: self-declined module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'accepted':\n        for (const outdatedModuleId of effect.outdatedModules) {\n          outdatedModules.add(outdatedModuleId)\n        }\n        break\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\n      default:\n        invariant(effect, (effect) => `Unknown effect type: ${effect?.type}`)\n    }\n  }\n\n  return outdatedModules\n}\n\nfunction computeOutdatedSelfAcceptedModules(\n  outdatedModules: Iterable<ModuleId>\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\n  const outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[] = []\n  for (const moduleId of outdatedModules) {\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n    if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n      outdatedSelfAcceptedModules.push({\n        moduleId,\n        errorHandler: hotState.selfAccepted,\n      })\n    }\n  }\n  return outdatedSelfAcceptedModules\n}\n\n/**\n * Adds, deletes, and moves modules between chunks. This must happen before the\n * dispose phase as it needs to know which modules were removed from all chunks,\n * which we can only compute *after* taking care of added and moved modules.\n */\nfunction updateChunksPhase(\n  chunksAddedModules: Map<ChunkPath, Set<ModuleId>>,\n  chunksDeletedModules: Map<ChunkPath, Set<ModuleId>>\n): { disposedModules: Set<ModuleId> } {\n  for (const [chunkPath, addedModuleIds] of chunksAddedModules) {\n    for (const moduleId of addedModuleIds) {\n      addModuleToChunk(moduleId, chunkPath)\n    }\n  }\n\n  const disposedModules: Set<ModuleId> = new Set()\n  for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {\n    for (const moduleId of addedModuleIds) {\n      if (removeModuleFromChunk(moduleId, chunkPath)) {\n        disposedModules.add(moduleId)\n      }\n    }\n  }\n\n  return { disposedModules }\n}\n\nfunction disposePhase(\n  outdatedModules: Iterable<ModuleId>,\n  disposedModules: Iterable<ModuleId>\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\n  for (const moduleId of outdatedModules) {\n    disposeModule(moduleId, 'replace')\n  }\n\n  for (const moduleId of disposedModules) {\n    disposeModule(moduleId, 'clear')\n  }\n\n  // Removing modules from the module cache is a separate step.\n  // We also want to keep track of previous parents of the outdated modules.\n  const outdatedModuleParents = new Map()\n  for (const moduleId of outdatedModules) {\n    const oldModule = devModuleCache[moduleId]\n    outdatedModuleParents.set(moduleId, oldModule?.parents)\n    delete devModuleCache[moduleId]\n  }\n\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n  // children.\n\n  return { outdatedModuleParents }\n}\n\n/**\n * Disposes of an instance of a module.\n *\n * Returns the persistent hot data that should be kept for the next module\n * instance.\n *\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\n * This must be done in a separate step afterwards.\n * This is important because all modules need to be disposed to update the\n * parent/child relationships before they are actually removed from the devModuleCache.\n * If this was done in this method, the following disposeModule calls won't find\n * the module from the module id in the cache.\n */\nfunction disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {\n  const module = devModuleCache[moduleId]\n  if (!module) {\n    return\n  }\n\n  const hotState = moduleHotState.get(module)!\n  const data = {}\n\n  // Run the `hot.dispose` handler, if any, passing in the persistent\n  // `hot.data` object.\n  for (const disposeHandler of hotState.disposeHandlers) {\n    disposeHandler(data)\n  }\n\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n  // module is still importing other modules.\n  module.hot.active = false\n\n  moduleHotState.delete(module)\n\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n\n  // Remove the disposed module from its children's parent list.\n  // It will be added back once the module re-instantiates and imports its\n  // children again.\n  for (const childId of module.children) {\n    const child = devModuleCache[childId]\n    if (!child) {\n      continue\n    }\n\n    const idx = child.parents.indexOf(module.id)\n    if (idx >= 0) {\n      child.parents.splice(idx, 1)\n    }\n  }\n\n  switch (mode) {\n    case 'clear':\n      delete devModuleCache[module.id]\n      moduleHotData.delete(module.id)\n      break\n    case 'replace':\n      moduleHotData.set(module.id, data)\n      break\n    default:\n      invariant(mode, (mode) => `invalid mode: ${mode}`)\n  }\n}\n\nfunction applyPhase(\n  outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[],\n  newModuleFactories: Map<ModuleId, ModuleFactory>,\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\n  reportError: (err: any) => void\n) {\n  // Update module factories.\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\n    applyModuleFactoryName(factory)\n    moduleFactories.set(moduleId, factory)\n  }\n\n  // TODO(alexkirsz) Run new runtime entries here.\n\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n\n  // Re-instantiate all outdated self-accepted modules.\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n    try {\n      instantiateModule(\n        moduleId,\n        SourceType.Update,\n        outdatedModuleParents.get(moduleId)\n      )\n    } catch (err) {\n      if (typeof errorHandler === 'function') {\n        try {\n          errorHandler(err, { moduleId, module: devModuleCache[moduleId] })\n        } catch (err2) {\n          reportError(err2)\n          reportError(err)\n        }\n      } else {\n        reportError(err)\n      }\n    }\n  }\n}\n\nfunction applyUpdate(update: PartialUpdate) {\n  switch (update.type) {\n    case 'ChunkListUpdate':\n      applyChunkListUpdate(update)\n      break\n    default:\n      invariant(update, (update) => `Unknown update type: ${update.type}`)\n  }\n}\n\nfunction applyChunkListUpdate(update: ChunkListUpdate) {\n  if (update.merged != null) {\n    for (const merged of update.merged) {\n      switch (merged.type) {\n        case 'EcmascriptMergedUpdate':\n          applyEcmascriptMergedUpdate(merged)\n          break\n        default:\n          invariant(merged, (merged) => `Unknown merged type: ${merged.type}`)\n      }\n    }\n  }\n\n  if (update.chunks != null) {\n    for (const [chunkPath, chunkUpdate] of Object.entries(\n      update.chunks\n    ) as Array<[ChunkPath, ChunkUpdate]>) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\n\n      switch (chunkUpdate.type) {\n        case 'added':\n          BACKEND.loadChunkCached(SourceType.Update, chunkUrl)\n          break\n        case 'total':\n          DEV_BACKEND.reloadChunk?.(chunkUrl)\n          break\n        case 'deleted':\n          DEV_BACKEND.unloadChunk?.(chunkUrl)\n          break\n        case 'partial':\n          invariant(\n            chunkUpdate.instruction,\n            (instruction) =>\n              `Unknown partial instruction: ${JSON.stringify(instruction)}.`\n          )\n          break\n        default:\n          invariant(\n            chunkUpdate,\n            (chunkUpdate) => `Unknown chunk update type: ${chunkUpdate.type}`\n          )\n      }\n    }\n  }\n}\n\nfunction applyEcmascriptMergedUpdate(update: EcmascriptMergedUpdate) {\n  const { entries = {}, chunks = {} } = update\n  const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(\n    entries,\n    chunks\n  )\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\n    added,\n    modified\n  )\n  const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted)\n\n  applyInternal(outdatedModules, disposedModules, newModuleFactories)\n}\n\nfunction applyInvalidatedModules(outdatedModules: Set<ModuleId>) {\n  if (queuedInvalidatedModules.size > 0) {\n    computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) => {\n      outdatedModules.add(moduleId)\n    })\n\n    queuedInvalidatedModules.clear()\n  }\n\n  return outdatedModules\n}\n\nfunction applyInternal(\n  outdatedModules: Set<ModuleId>,\n  disposedModules: Iterable<ModuleId>,\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n) {\n  outdatedModules = applyInvalidatedModules(outdatedModules)\n\n  const outdatedSelfAcceptedModules =\n    computeOutdatedSelfAcceptedModules(outdatedModules)\n\n  const { outdatedModuleParents } = disposePhase(\n    outdatedModules,\n    disposedModules\n  )\n\n  // we want to continue on error and only throw the error after we tried applying all updates\n  let error: any\n\n  function reportError(err: any) {\n    if (!error) error = err\n  }\n\n  applyPhase(\n    outdatedSelfAcceptedModules,\n    newModuleFactories,\n    outdatedModuleParents,\n    reportError\n  )\n\n  if (error) {\n    throw error\n  }\n\n  if (queuedInvalidatedModules.size > 0) {\n    applyInternal(new Set(), [], new Map())\n  }\n}\n\nfunction computeChangedModules(\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>\n): {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n  deleted: Set<ModuleId>\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>\n} {\n  const chunksAdded = new Map()\n  const chunksDeleted = new Map()\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map()\n  const modified = new Map()\n  const deleted: Set<ModuleId> = new Set()\n\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    switch (mergedChunkUpdate.type) {\n      case 'added': {\n        const updateAdded = new Set(mergedChunkUpdate.modules)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        break\n      }\n      case 'deleted': {\n        // We could also use `mergedChunkUpdate.modules` here.\n        const updateDeleted = new Set(chunkModulesMap.get(chunkPath))\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      case 'partial': {\n        const updateAdded = new Set(mergedChunkUpdate.added)\n        const updateDeleted = new Set(mergedChunkUpdate.deleted)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      default:\n        invariant(\n          mergedChunkUpdate,\n          (mergedChunkUpdate) =>\n            `Unknown merged chunk update type: ${mergedChunkUpdate.type}`\n        )\n    }\n  }\n\n  // If a module was added from one chunk and deleted from another in the same update,\n  // consider it to be modified, as it means the module was moved from one chunk to another\n  // AND has new code in a single update.\n  for (const moduleId of added.keys()) {\n    if (deleted.has(moduleId)) {\n      added.delete(moduleId)\n      deleted.delete(moduleId)\n    }\n  }\n\n  for (const [moduleId, entry] of Object.entries(entries)) {\n    // Modules that haven't been added to any chunk but have new code are considered\n    // to be modified.\n    // This needs to be under the previous loop, as we need it to get rid of modules\n    // that were added and deleted in the same update.\n    if (!added.has(moduleId)) {\n      modified.set(moduleId, entry)\n    }\n  }\n\n  return { added, deleted, modified, chunksAdded, chunksDeleted }\n}\n\ntype ModuleEffect =\n  | {\n      type: 'unaccepted'\n      dependencyChain: ModuleId[]\n    }\n  | {\n      type: 'self-declined'\n      dependencyChain: ModuleId[]\n      moduleId: ModuleId\n    }\n  | {\n      type: 'accepted'\n      moduleId: ModuleId\n      outdatedModules: Set<ModuleId>\n    }\n\nfunction getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\n  const outdatedModules: Set<ModuleId> = new Set()\n\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }\n\n  const queue: QueueItem[] = [\n    {\n      moduleId,\n      dependencyChain: [],\n    },\n  ]\n\n  let nextItem\n  while ((nextItem = queue.shift())) {\n    const { moduleId, dependencyChain } = nextItem\n\n    if (moduleId != null) {\n      if (outdatedModules.has(moduleId)) {\n        // Avoid infinite loops caused by cycles between modules in the dependency chain.\n        continue\n      }\n\n      outdatedModules.add(moduleId)\n    }\n\n    // We've arrived at the runtime of the chunk, which means that nothing\n    // else above can accept this update.\n    if (moduleId === undefined) {\n      return {\n        type: 'unaccepted',\n        dependencyChain,\n      }\n    }\n\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n\n    if (\n      // The module is not in the cache. Since this is a \"modified\" update,\n      // it means that the module was never instantiated before.\n      !module || // The module accepted itself without invalidating globalThis.\n      // TODO is that right?\n      (hotState.selfAccepted && !hotState.selfInvalidated)\n    ) {\n      continue\n    }\n\n    if (hotState.selfDeclined) {\n      return {\n        type: 'self-declined',\n        dependencyChain,\n        moduleId,\n      }\n    }\n\n    if (runtimeModules.has(moduleId)) {\n      queue.push({\n        moduleId: undefined,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n      continue\n    }\n\n    for (const parentId of module.parents) {\n      const parent = devModuleCache[parentId]\n\n      if (!parent) {\n        // TODO(alexkirsz) Is this even possible?\n        continue\n      }\n\n      // TODO(alexkirsz) Dependencies: check accepted and declined\n      // dependencies here.\n\n      queue.push({\n        moduleId: parentId,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n    }\n  }\n\n  return {\n    type: 'accepted',\n    moduleId,\n    outdatedModules,\n  }\n}\n\nfunction handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {\n  switch (update.type) {\n    case 'partial': {\n      // This indicates that the update is can be applied to the current state of the application.\n      applyUpdate(update.instruction)\n      break\n    }\n    case 'restart': {\n      // This indicates that there is no way to apply the update to the\n      // current state of the application, and that the application must be\n      // restarted.\n      DEV_BACKEND.restart()\n      break\n    }\n    case 'notFound': {\n      // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n      // or the page itself was deleted.\n      // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n      // If it is a runtime chunk list, we restart the application.\n      if (runtimeChunkLists.has(chunkListPath)) {\n        DEV_BACKEND.restart()\n      } else {\n        disposeChunkList(chunkListPath)\n      }\n      break\n    }\n    default:\n      throw new Error(`Unknown update type: ${update.type}`)\n  }\n}\n\nfunction createModuleHot(\n  moduleId: ModuleId,\n  hotData: HotData\n): { hot: Hot; hotState: HotState } {\n  const hotState: HotState = {\n    selfAccepted: false,\n    selfDeclined: false,\n    selfInvalidated: false,\n    disposeHandlers: [],\n  }\n\n  const hot: Hot = {\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n    // decide whether to warn whenever an HMR-disposed module required other\n    // modules. We might want to remove it.\n    active: true,\n\n    data: hotData ?? {},\n\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n    accept: (\n      modules?: string | string[] | AcceptErrorHandler,\n      _callback?: AcceptCallback,\n      _errorHandler?: AcceptErrorHandler\n    ) => {\n      if (modules === undefined) {\n        hotState.selfAccepted = true\n      } else if (typeof modules === 'function') {\n        hotState.selfAccepted = modules\n      } else {\n        throw new Error('unsupported `accept` signature')\n      }\n    },\n\n    decline: (dep) => {\n      if (dep === undefined) {\n        hotState.selfDeclined = true\n      } else {\n        throw new Error('unsupported `decline` signature')\n      }\n    },\n\n    dispose: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    addDisposeHandler: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    removeDisposeHandler: (callback) => {\n      const idx = hotState.disposeHandlers.indexOf(callback)\n      if (idx >= 0) {\n        hotState.disposeHandlers.splice(idx, 1)\n      }\n    },\n\n    invalidate: () => {\n      hotState.selfInvalidated = true\n      queuedInvalidatedModules.add(moduleId)\n    },\n\n    // NOTE(alexkirsz) This is part of the management API, which we don't\n    // implement, but the Next.js React Refresh runtime uses this to decide\n    // whether to schedule an update.\n    status: () => 'idle',\n\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n    addStatusHandler: (_handler) => {},\n    removeStatusHandler: (_handler) => {},\n\n    // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n    // want the webpack code paths to ever update (the turbopack paths handle\n    // this already).\n    check: () => Promise.resolve(null),\n  }\n\n  return { hot, hotState }\n}\n\n/**\n * Removes a module from a chunk.\n * Returns `true` if there are no remaining chunks including this module.\n */\nfunction removeModuleFromChunk(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): boolean {\n  const moduleChunks = moduleChunksMap.get(moduleId)!\n  moduleChunks.delete(chunkPath)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)!\n  chunkModules.delete(moduleId)\n\n  const noRemainingModules = chunkModules.size === 0\n  if (noRemainingModules) {\n    chunkModulesMap.delete(chunkPath)\n  }\n\n  const noRemainingChunks = moduleChunks.size === 0\n  if (noRemainingChunks) {\n    moduleChunksMap.delete(moduleId)\n  }\n\n  return noRemainingChunks\n}\n\n/**\n * Disposes of a chunk list and its corresponding exclusive chunks.\n */\nfunction disposeChunkList(chunkListPath: ChunkListPath): boolean {\n  const chunkPaths = chunkListChunksMap.get(chunkListPath)\n  if (chunkPaths == null) {\n    return false\n  }\n  chunkListChunksMap.delete(chunkListPath)\n\n  for (const chunkPath of chunkPaths) {\n    const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!\n    chunkChunkLists.delete(chunkListPath)\n\n    if (chunkChunkLists.size === 0) {\n      chunkChunkListsMap.delete(chunkPath)\n      disposeChunk(chunkPath)\n    }\n  }\n\n  // We must also dispose of the chunk list's chunk itself to ensure it may\n  // be reloaded properly in the future.\n  const chunkListUrl = getChunkRelativeUrl(chunkListPath)\n\n  DEV_BACKEND.unloadChunk?.(chunkListUrl)\n\n  return true\n}\n\n/**\n * Disposes of a chunk and its corresponding exclusive modules.\n *\n * @returns Whether the chunk was disposed of.\n */\nfunction disposeChunk(chunkPath: ChunkPath): boolean {\n  const chunkUrl = getChunkRelativeUrl(chunkPath)\n  // This should happen whether the chunk has any modules in it or not.\n  // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n  DEV_BACKEND.unloadChunk?.(chunkUrl)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)\n  if (chunkModules == null) {\n    return false\n  }\n  chunkModules.delete(chunkPath)\n\n  for (const moduleId of chunkModules) {\n    const moduleChunks = moduleChunksMap.get(moduleId)!\n    moduleChunks.delete(chunkPath)\n\n    const noRemainingChunks = moduleChunks.size === 0\n    if (noRemainingChunks) {\n      moduleChunksMap.delete(moduleId)\n      disposeModule(moduleId, 'clear')\n      availableModules.delete(moduleId)\n    }\n  }\n\n  return true\n}\n\n/**\n * Adds a module to a chunk.\n */\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\n  let moduleChunks = moduleChunksMap.get(moduleId)\n  if (!moduleChunks) {\n    moduleChunks = new Set([chunkPath])\n    moduleChunksMap.set(moduleId, moduleChunks)\n  } else {\n    moduleChunks.add(chunkPath)\n  }\n\n  let chunkModules = chunkModulesMap.get(chunkPath)\n  if (!chunkModules) {\n    chunkModules = new Set([moduleId])\n    chunkModulesMap.set(chunkPath, chunkModules)\n  } else {\n    chunkModules.add(moduleId)\n  }\n}\n\n/**\n * Marks a chunk list as a runtime chunk list. There can be more than one\n * runtime chunk list. For instance, integration tests can have multiple chunk\n * groups loaded at runtime, each with its own chunk list.\n */\nfunction markChunkListAsRuntime(chunkListPath: ChunkListPath) {\n  runtimeChunkLists.add(chunkListPath)\n}\n\nfunction registerChunk(registration: ChunkRegistration) {\n  const chunkPath = getPathFromScript(registration[0])\n  let runtimeParams: RuntimeParams | undefined\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n  if (registration.length === 2) {\n    runtimeParams = registration[1] as RuntimeParams\n  } else {\n    runtimeParams = undefined\n    installCompressedModuleFactories(\n      registration as CompressedModuleFactories,\n      /* offset= */ 1,\n      moduleFactories,\n      (id: ModuleId) => addModuleToChunk(id, chunkPath)\n    )\n  }\n  return BACKEND.registerChunk(chunkPath, runtimeParams)\n}\n\n/**\n * Subscribes to chunk list updates from the update server and applies them.\n */\nfunction registerChunkList(chunkList: ChunkList) {\n  const chunkListScript = chunkList.script\n  const chunkListPath = getPathFromScript(chunkListScript)\n  // The \"chunk\" is also registered to finish the loading in the backend\n  BACKEND.registerChunk(chunkListPath as string as ChunkPath)\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([\n    chunkListPath,\n    handleApply.bind(null, chunkListPath),\n  ])\n\n  // Adding chunks to chunk lists and vice versa.\n  const chunkPaths = new Set(chunkList.chunks.map(getChunkPath))\n  chunkListChunksMap.set(chunkListPath, chunkPaths)\n  for (const chunkPath of chunkPaths) {\n    let chunkChunkLists = chunkChunkListsMap.get(chunkPath)\n    if (!chunkChunkLists) {\n      chunkChunkLists = new Set([chunkListPath])\n      chunkChunkListsMap.set(chunkPath, chunkChunkLists)\n    } else {\n      chunkChunkLists.add(chunkListPath)\n    }\n  }\n\n  if (chunkList.source === 'entry') {\n    markChunkListAsRuntime(chunkListPath)\n  }\n}\n\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= []\n","/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n\ntype ChunkResolver = {\n  resolved: boolean\n  loadingStarted: boolean\n  resolve: () => void\n  reject: (error?: Error) => void\n  promise: Promise<any>\n}\n\nlet BACKEND: RuntimeBackend\n\n/**\n * Maps chunk paths to the corresponding resolver.\n */\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n\n;(() => {\n  BACKEND = {\n    async registerChunk(chunkPath, params) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\n\n      const resolver = getOrCreateResolver(chunkUrl)\n      resolver.resolve()\n\n      if (params == null) {\n        return\n      }\n\n      for (const otherChunkData of params.otherChunks) {\n        const otherChunkPath = getChunkPath(otherChunkData)\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath)\n\n        // Chunk might have started loading, so we want to avoid triggering another load.\n        getOrCreateResolver(otherChunkUrl)\n      }\n\n      // This waits for chunks to be loaded, but also marks included items as available.\n      await Promise.all(\n        params.otherChunks.map((otherChunkData) =>\n          loadInitialChunk(chunkPath, otherChunkData)\n        )\n      )\n\n      if (params.runtimeModuleIds.length > 0) {\n        for (const moduleId of params.runtimeModuleIds) {\n          getOrInstantiateRuntimeModule(chunkPath, moduleId)\n        }\n      }\n    },\n\n    /**\n     * Loads the given chunk, and returns a promise that resolves once the chunk\n     * has been loaded.\n     */\n    loadChunkCached(sourceType: SourceType, chunkUrl: ChunkUrl) {\n      return doLoadChunk(sourceType, chunkUrl)\n    },\n\n    async loadWebAssembly(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module,\n      importsObj: WebAssembly.Imports\n    ): Promise<Exports> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      const { instance } = await WebAssembly.instantiateStreaming(\n        req,\n        importsObj\n      )\n\n      return instance.exports\n    },\n\n    async loadWebAssemblyModule(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module\n    ): Promise<WebAssembly.Module> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      return await WebAssembly.compileStreaming(req)\n    },\n  }\n\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\n    let resolver = chunkResolvers.get(chunkUrl)\n    if (!resolver) {\n      let resolve: () => void\n      let reject: (error?: Error) => void\n      const promise = new Promise<void>((innerResolve, innerReject) => {\n        resolve = innerResolve\n        reject = innerReject\n      })\n      resolver = {\n        resolved: false,\n        loadingStarted: false,\n        promise,\n        resolve: () => {\n          resolver!.resolved = true\n          resolve()\n        },\n        reject: reject!,\n      }\n      chunkResolvers.set(chunkUrl, resolver)\n    }\n    return resolver\n  }\n\n  /**\n   * Loads the given chunk, and returns a promise that resolves once the chunk\n   * has been loaded.\n   */\n  function doLoadChunk(sourceType: SourceType, chunkUrl: ChunkUrl) {\n    const resolver = getOrCreateResolver(chunkUrl)\n    if (resolver.loadingStarted) {\n      return resolver.promise\n    }\n\n    if (sourceType === SourceType.Runtime) {\n      // We don't need to load chunks references from runtime code, as they're already\n      // present in the DOM.\n      resolver.loadingStarted = true\n\n      if (isCss(chunkUrl)) {\n        // CSS chunks do not register themselves, and as such must be marked as\n        // loaded instantly.\n        resolver.resolve()\n      }\n\n      // We need to wait for JS chunks to register themselves within `registerChunk`\n      // before we can start instantiating runtime modules, hence the absence of\n      // `resolver.resolve()` in this branch.\n\n      return resolver.promise\n    }\n\n    if (typeof importScripts === 'function') {\n      // We're in a web worker\n      if (isCss(chunkUrl)) {\n        // ignore\n      } else if (isJs(chunkUrl)) {\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl)\n        importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl)\n      } else {\n        throw new Error(\n          `can't infer type of chunk from URL ${chunkUrl} in worker`\n        )\n      }\n    } else {\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousLinks.length > 0) {\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolver.resolve()\n        } else {\n          const link = document.createElement('link')\n          link.rel = 'stylesheet'\n          link.href = chunkUrl\n          link.onerror = () => {\n            resolver.reject()\n          }\n          link.onload = () => {\n            // CSS chunks do not register themselves, and as such must be marked as\n            // loaded instantly.\n            resolver.resolve()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(link)\n        }\n      } else if (isJs(chunkUrl)) {\n        const previousScripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousScripts.length > 0) {\n          // There is this edge where the script already failed loading, but we\n          // can't detect that. The Promise will never resolve in this case.\n          for (const script of Array.from(previousScripts)) {\n            script.addEventListener('error', () => {\n              resolver.reject()\n            })\n          }\n        } else {\n          const script = document.createElement('script')\n          script.src = chunkUrl\n          // We'll only mark the chunk as loaded once the script has been executed,\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\n          // this branch.\n          script.onerror = () => {\n            resolver.reject()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(script)\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    }\n\n    resolver.loadingStarted = true\n    return resolver.promise\n  }\n\n  function fetchWebAssembly(wasmChunkPath: ChunkPath) {\n    return fetch(getChunkRelativeUrl(wasmChunkPath))\n  }\n})()\n","/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/runtime-base.ts\" />\n/// <reference path=\"../base/dev-base.ts\" />\n/// <reference path=\"./runtime-backend-dom.ts\" />\n/// <reference path=\"../../../shared/require-type.d.ts\" />\n\nlet DEV_BACKEND: DevRuntimeBackend\n;(() => {\n  DEV_BACKEND = {\n    unloadChunk(chunkUrl) {\n      deleteResolver(chunkUrl)\n\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const links = document.querySelectorAll(\n          `link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`\n        )\n        for (const link of Array.from(links)) {\n          link.remove()\n        }\n      } else if (isJs(chunkUrl)) {\n        // Unloading a JS chunk would have no effect, as it lives in the JS\n        // runtime once evaluated.\n        // However, we still want to remove the script tag from the DOM to keep\n        // the HTML somewhat consistent from the user's perspective.\n        const scripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        for (const script of Array.from(scripts)) {\n          script.remove()\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    },\n\n    reloadChunk(chunkUrl) {\n      return new Promise<void>((resolve, reject) => {\n        if (!isCss(chunkUrl)) {\n          reject(new Error('The DOM backend can only reload CSS chunks'))\n          return\n        }\n\n        const decodedChunkUrl = decodeURI(chunkUrl)\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n\n        if (previousLinks.length === 0) {\n          reject(new Error(`No link element found for chunk ${chunkUrl}`))\n          return\n        }\n\n        const link = document.createElement('link')\n        link.rel = 'stylesheet'\n\n        if (navigator.userAgent.includes('Firefox')) {\n          // Firefox won't reload CSS files that were previously loaded on the current page,\n          // we need to add a query param to make sure CSS is actually reloaded from the server.\n          //\n          // I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506\n          //\n          // Safari has a similar issue, but only if you have a `<link rel=preload ... />` tag\n          // pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726\n          link.href = `${chunkUrl}?ts=${Date.now()}`\n        } else {\n          link.href = chunkUrl\n        }\n\n        link.onerror = () => {\n          reject()\n        }\n        link.onload = () => {\n          // First load the new CSS, then remove the old ones. This prevents visible\n          // flickering that would happen in-between removing the previous CSS and\n          // loading the new one.\n          for (const previousLink of Array.from(previousLinks))\n            previousLink.remove()\n\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolve()\n        }\n\n        // Make sure to insert the new CSS right after the previous one, so that\n        // its precedence is higher.\n        previousLinks[0].parentElement!.insertBefore(\n          link,\n          previousLinks[0].nextSibling\n        )\n      })\n    },\n\n    restart: () => self.location.reload(),\n  }\n\n  function deleteResolver(chunkUrl: ChunkUrl) {\n    chunkResolvers.delete(chunkUrl)\n  }\n})()\n\nfunction _eval({ code, url, map }: EcmascriptModuleEntry): ModuleFactory {\n  code += `\\n\\n//# sourceURL=${encodeURI(\n    location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX\n  )}`\n  if (map) {\n    code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(\n      // btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n      // See https://stackoverflow.com/a/26603875\n      unescape(encodeURIComponent(map))\n    )}`\n  }\n\n  // eslint-disable-next-line no-eval\n  return eval(code)\n}\n"],"names":[],"decodedMappings":[[],[],[],[],[],[],[],[],[],[],[],[],[],[[0,0,0,0]],[],[],[],[],[[1,0,5,1],[4,0,7,0],[56,0,7,52],[59,0,9,0],[104,0,9,45]],[[0,0,19,0],[6,0,19,6],[27,0,19,27],[31,0,19,31]],[[0,0,21,0]],[],[[1,0,23,1],[4,0,24,0],[13,0,24,9],[21,0,26,2],[27,0,26,16],[29,0,27,2],[36,0,27,18]],[[4,0,29,2],[8,0,29,6],[9,0,29,7],[10,0,29,8],[13,0,29,11]],[[4,0,30,2],[84,0,30,82]],[[4,0,31,2],[77,0,31,75]],[[4,0,32,2],[51,0,32,49]],[[4,0,33,2],[82,0,33,80]],[[4,0,34,2],[74,0,34,72]],[[4,0,35,2],[21,0,35,19]],[[4,0,36,2],[96,0,36,94]],[[4,0,37,2],[8,0,37,6],[9,0,37,7],[10,0,37,8],[13,0,37,11]],[[0,0,38,0]],[[0,0,39,0],[6,0,39,6],[25,0,39,25],[33,0,39,33],[42,0,39,42]],[[0,0,70,0],[6,0,70,6],[23,0,70,23],[30,0,70,30],[39,0,70,39],[40,0,70,40],[54,0,70,54]],[[0,0,71,0],[6,0,71,6],[20,0,71,20],[27,0,71,27],[38,0,71,38],[53,0,71,53],[60,0,71,60],[71,0,71,71]],[[0,0,73,0],[9,0,73,9],[20,0,74,2],[23,0,74,10],[25,0,75,2],[29,0,75,19],[31,0,76,2],[38,0,76,45]],[[4,0,78,2],[8,0,78,6],[9,0,78,7],[24,0,78,22],[28,0,78,26],[29,0,78,27],[34,0,78,32],[41,0,78,39],[48,0,78,46],[62,0,78,60],[63,0,78,61],[68,0,78,66],[74,0,78,72]],[[0,0,79,0]],[[0,0,81,0],[9,0,81,9],[30,0,82,2],[41,0,82,34],[43,0,83,2],[45,0,83,14]],[[4,0,85,2],[8,0,85,6],[17,0,85,15],[28,0,85,26],[29,0,85,27],[32,0,85,30]],[[4,0,86,2],[8,0,86,6],[9,0,86,7],[17,0,86,15]],[[8,0,87,4],[98,0,87,94]],[[8,0,88,4],[68,0,88,64]],[[8,0,89,4],[17,0,89,13],[36,0,89,32]],[[8,0,90,4],[19,0,90,15],[20,0,90,16],[23,0,90,19],[26,0,90,22]],[[4,0,91,2]],[[4,0,92,2],[11,0,92,9]],[[0,0,93,0]],[[0,0,95,0]],[],[[1,0,97,1],[4,0,98,0],[13,0,98,9],[32,0,98,28],[34,0,98,40]],[[4,0,99,2],[11,0,99,9]],[[8,0,100,4],[17,0,100,13],[18,0,100,14]],[[8,0,101,4],[15,0,101,11]],[[8,0,102,4]],[[8,0,103,4],[25,0,103,21]],[[4,0,104,2]],[[0,0,105,0]],[[0,0,108,0],[6,0,108,6],[25,0,108,25]],[[0,0,118,0]],[],[[1,0,120,1],[4,0,121,0],[13,0,121,9],[17,0,121,13],[24,0,121,29],[26,0,121,31],[34,0,121,52]],[[4,0,122,2],[15,0,122,13],[24,0,122,22],[38,0,122,36]],[[8,0,122,38],[15,0,122,45]],[[4,0,122,50]],[[4,0,123,2],[8,0,123,6],[21,0,123,19],[32,0,123,30],[41,0,123,39],[54,0,123,52]],[[8,0,123,54],[15,0,123,61]],[[4,0,123,70]],[[4,0,124,2],[8,0,124,6],[12,0,124,10]],[[4,0,125,2],[10,0,125,9],[14,0,125,13],[23,0,125,22],[29,0,125,28],[30,0,125,30]],[[8,0,126,4],[14,0,126,10],[25,0,126,21],[33,0,126,29],[34,0,126,30],[38,0,126,34]],[[8,0,127,4],[14,0,127,10],[30,0,127,26],[38,0,127,34],[39,0,127,35],[43,0,127,39]],[[8,0,128,4],[12,0,128,8],[19,0,128,15],[37,0,128,33],[47,0,128,43]],[[12,0,129,6],[16,0,129,10],[34,0,129,28],[52,0,129,46]],[[16,0,130,8],[27,0,130,19],[36,0,130,28],[46,0,130,38]],[[20,0,131,10],[27,0,131,17],[35,0,131,25],[36,0,131,26],[40,0,131,30]],[[20,0,132,10],[32,0,132,22]],[[20,0,133,10],[30,0,133,20]],[[16,0,134,8]],[[12,0,135,6],[19,0,135,13]],[[16,0,136,8],[22,0,136,14],[26,0,136,18],[32,0,136,24],[33,0,136,25],[49,0,136,41],[51,0,136,43],[66,0,136,58]],[[12,0,137,6]],[[8,0,138,4],[15,0,138,11]],[[12,0,139,6],[18,0,139,12],[29,0,139,23]],[[12,0,140,6],[16,0,140,10],[23,0,140,17],[31,0,140,25],[32,0,140,26],[34,0,140,28],[39,0,140,33],[51,0,140,45]],[[16,0,141,8],[22,0,141,14],[33,0,141,25],[41,0,141,33],[42,0,141,34],[46,0,141,38]],[[16,0,142,8],[27,0,142,19],[36,0,142,28],[46,0,142,38]],[[20,0,143,10],[25,0,143,15]],[[20,0,144,10],[25,0,144,15]],[[20,0,145,10],[32,0,145,22]],[[16,0,146,8]],[[12,0,147,6],[19,0,147,13]],[[16,0,148,8],[27,0,148,19],[36,0,148,28],[46,0,148,38]],[[20,0,149,10],[25,0,149,15]],[[20,0,150,10],[32,0,150,22]],[[16,0,151,8]],[[12,0,152,6]],[[8,0,153,4]],[[4,0,154,2]],[[4,0,155,2],[11,0,155,9],[15,0,155,13],[16,0,155,14]],[[0,0,156,0]],[[0,0,158,0]],[],[[1,0,160,1],[4,0,161,0],[13,0,161,9],[23,0,163,2],[31,0,163,23],[33,0,164,2],[35,0,164,26]],[[4,0,166,2],[8,0,166,6]],[[4,0,167,2],[8,0,167,6]],[[4,0,168,2],[8,0,168,6],[14,0,168,12],[20,0,168,18]],[[8,0,169,4],[17,0,169,13],[38,0,169,34],[42,0,169,38],[43,0,169,39],[44,0,169,40],[46,0,169,42]],[[8,0,170,4],[18,0,170,14],[25,0,170,21],[32,0,170,28]],[[4,0,171,2],[11,0,171,9]],[[8,0,172,4],[17,0,172,13],[21,0,172,17],[22,0,172,18],[23,0,172,19]],[[8,0,173,4],[18,0,173,14],[22,0,173,18],[23,0,173,19],[24,0,173,20]],[[4,0,174,2]],[[4,0,175,2],[11,0,175,9],[26,0,175,24],[29,0,175,27]],[[4,0,176,2],[8,0,176,6],[17,0,176,15]],[[0,0,177,0]],[[0,0,178,0],[17,0,178,17],[18,0,178,18],[21,0,178,21]],[[0,0,181,0],[9,0,181,9],[30,0,182,2],[36,0,182,16],[38,0,183,2],[45,0,183,18]],[[4,0,185,2],[8,0,185,6],[28,0,186,4],[47,0,186,23],[50,0,186,26],[51,0,186,27]],[[4,0,188,2],[8,0,188,6],[9,0,188,7],[28,0,188,26]],[[8,0,189,4],[27,0,189,23],[30,0,189,26],[31,0,189,27],[39,0,189,36],[59,0,189,56],[61,0,189,58]],[[8,0,190,4],[15,0,190,11],[22,0,190,18],[25,0,190,21],[32,0,190,28],[47,0,190,43],[50,0,190,46],[54,0,190,50],[60,0,190,56],[69,0,190,65]],[[12,0,191,6],[17,0,191,10],[23,0,191,16],[25,0,191,18],[29,0,191,22]],[[16,0,192,8],[20,0,193,10],[35,0,193,25],[39,0,193,29],[40,0,193,30],[48,0,193,38],[57,0,194,10],[66,0,194,19],[79,0,195,10],[88,0,195,19],[102,0,196,10]],[[20,0,197,10],[27,0,197,17],[35,0,197,25],[38,0,197,28],[39,0,197,29],[47,0,197,37]],[[16,0,198,8]],[[16,0,199,8],[21,0,199,13],[27,0,199,19],[34,0,199,26],[52,0,199,46]],[[20,0,200,10],[26,0,200,16],[34,0,200,24],[42,0,200,32],[45,0,200,35],[46,0,200,36],[51,0,200,41]],[[20,0,201,10],[24,0,201,14],[34,0,201,24],[45,0,201,35],[52,0,201,42]],[[16,0,202,8]],[[16,0,203,8],[23,0,203,15]],[[12,0,204,6]],[[12,0,205,6],[21,0,205,14],[27,0,205,20]],[[16,0,206,8],[22,0,206,14],[29,0,206,21],[37,0,206,29],[44,0,206,36],[45,0,206,37]],[[16,0,207,8],[21,0,207,13],[27,0,207,19],[34,0,207,26],[52,0,207,46]],[[20,0,208,10],[25,0,208,15],[31,0,208,21],[38,0,208,28],[46,0,208,36],[53,0,208,43],[54,0,208,44],[59,0,208,50]],[[24,0,209,12],[28,0,209,16],[36,0,209,24],[49,0,209,37],[50,0,209,38],[55,0,209,43],[63,0,209,51],[64,0,209,52],[70,0,209,58],[75,0,209,63],[79,0,209,67],[80,0,209,68]],[[20,0,210,10]],[[16,0,211,8]],[[16,0,212,8],[23,0,212,15]],[[12,0,213,6]],[[8,0,214,4]],[[4,0,215,2]],[[4,0,216,2],[11,0,216,9]],[[0,0,217,0]],[[0,0,219,0]],[],[[1,0,221,1],[4,0,222,0],[13,0,222,9],[27,0,224,2],[33,0,224,29],[35,0,225,2],[37,0,225,26]],[[4,0,227,2],[8,0,227,6]],[[4,0,228,2],[8,0,228,6]],[[4,0,229,2],[8,0,229,6],[14,0,229,12],[20,0,229,18]],[[8,0,230,4],[17,0,230,13],[38,0,230,34],[42,0,230,38],[43,0,230,39],[44,0,230,40],[46,0,230,42]],[[8,0,231,4],[18,0,231,14],[25,0,231,21],[32,0,231,28]],[[4,0,232,2],[11,0,232,9]],[[8,0,233,4],[17,0,233,13],[21,0,233,17],[22,0,233,18],[23,0,233,19]],[[8,0,234,4],[18,0,234,14],[22,0,234,18],[23,0,234,19],[24,0,234,20]],[[4,0,235,2]],[[4,0,236,2],[10,0,236,8],[30,0,236,28],[51,0,236,49],[59,0,236,57]],[[4,0,238,2],[8,0,238,6],[15,0,238,13],[26,0,238,24],[38,0,238,36],[49,0,238,47],[55,0,238,53]],[[8,0,239,4],[26,0,239,22],[30,0,239,26],[31,0,239,27]],[[4,0,240,2]],[[0,0,241,0]],[[0,0,242,0],[17,0,242,17],[18,0,242,18],[21,0,242,21]],[[0,0,244,0],[9,0,244,9],[21,0,246,2],[26,0,246,12],[28,0,247,2],[30,0,247,26]],[[4,0,249,2],[8,0,249,6]],[[4,0,250,2],[8,0,250,6],[14,0,250,12],[20,0,250,18]],[[8,0,251,4],[17,0,251,13],[38,0,251,34],[42,0,251,38],[43,0,251,39],[44,0,251,40],[46,0,251,42]],[[4,0,252,2],[11,0,252,9]],[[8,0,253,4],[17,0,253,13],[21,0,253,17],[22,0,253,18],[23,0,253,19]],[[4,0,254,2]],[[4,0,255,2],[11,0,255,9],[18,0,255,16],[21,0,255,19]],[[0,0,256,0]],[[0,0,257,0],[17,0,257,17],[18,0,257,18],[21,0,257,21]],[[0,0,259,0],[9,0,259,9],[25,0,261,2],[34,0,261,16],[36,0,262,2],[38,0,262,26]],[[4,0,264,2],[8,0,264,6]],[[4,0,265,2],[8,0,265,6],[14,0,265,12],[20,0,265,18]],[[8,0,266,4],[17,0,266,13],[38,0,266,34],[42,0,266,38],[43,0,266,39],[44,0,266,40],[46,0,266,42]],[[4,0,267,2],[11,0,267,9]],[[8,0,268,4],[17,0,268,13],[21,0,268,17],[22,0,268,18],[23,0,268,19]],[[4,0,269,2]],[[4,0,270,2],[11,0,270,9],[18,0,270,16],[21,0,270,19],[28,0,270,26],[43,0,270,41],[46,0,270,44]],[[0,0,271,0]],[[0,0,272,0],[17,0,272,17],[18,0,272,18],[21,0,272,21]],[[0,0,274,0],[9,0,274,9],[22,0,274,22],[25,0,274,55],[27,0,274,57],[30,0,274,77]],[[4,0,275,2],[11,0,275,9],[15,0,275,15],[18,0,275,18],[19,0,275,19],[23,0,275,23]],[[0,0,276,0]],[[0,0,278,0]],[],[[1,0,280,1],[4,0,281,0],[10,0,281,6],[21,0,281,36],[28,0,281,43],[42,0,281,57],[45,0,282,4],[46,0,282,5],[52,0,282,13],[59,0,282,20],[73,0,282,34],[74,0,282,35],[81,0,283,4],[82,0,283,5],[88,0,283,13],[92,0,283,17],[101,0,283,26]],[[0,0,285,0],[49,0,285,49],[52,0,286,0],[58,0,286,6],[76,0,286,24]],[[4,0,286,25]],[[4,0,286,31],[13,0,286,40],[14,0,286,41]],[[4,0,286,45],[13,0,286,54],[15,0,286,56]],[[4,0,286,59],[13,0,286,68]],[[1,0,286,78]],[[0,0,288,0]],[],[],[],[],[],[[1,0,294,1],[4,0,295,0],[13,0,295,9],[24,0,296,2],[27,0,296,14],[29,0,297,2],[31,0,297,24],[33,0,298,2],[51,0,298,30]],[[4,0,300,2],[10,0,300,8],[21,0,300,32],[23,0,300,34]],[[4,0,301,2],[8,0,301,6],[26,0,301,24],[27,0,301,25]],[[4,0,302,2],[8,0,303,4],[12,0,303,8],[22,0,303,18],[27,0,304,4],[28,0,304,5],[35,0,304,12],[47,0,304,24],[59,0,304,36],[66,0,304,43],[78,0,304,55],[88,0,304,65],[93,0,305,4],[94,0,305,5],[110,0,305,21],[118,0,305,29],[119,0,305,30],[129,0,306,4],[139,0,306,14],[148,0,306,23],[157,0,307,4]],[[8,0,308,4],[13,0,308,9],[19,0,308,15],[26,0,308,22],[33,0,308,29],[52,0,308,48],[53,0,308,49],[62,0,308,59]],[[12,0,309,6],[21,0,309,15],[25,0,309,19],[26,0,309,20],[31,0,309,25],[44,0,309,38],[49,0,309,43]],[[12,0,310,6],[16,0,310,10],[36,0,310,30],[37,0,310,31],[42,0,310,36],[50,0,310,44],[61,0,310,55]],[[16,0,311,8],[34,0,311,26],[43,0,311,35],[49,0,311,41],[52,0,311,44]],[[12,0,312,6]],[[8,0,313,4]],[[4,0,314,2]],[[4,0,316,2],[33,0,316,31]],[[4,0,317,2],[81,0,317,79]],[[4,0,318,2],[8,0,318,6],[9,0,318,7],[10,0,318,8],[32,0,318,30],[51,0,318,49],[52,0,318,50],[55,0,318,53]],[[8,0,319,4],[102,0,319,98]],[[8,0,320,4],[12,0,320,8],[31,0,320,27],[34,0,320,30]],[[12,0,321,6],[48,0,321,42]],[[12,0,322,6],[21,0,322,15],[27,0,322,21],[28,0,322,22],[45,0,322,39],[48,0,322,42],[66,0,322,60]],[[8,0,323,4],[15,0,323,11]],[[12,0,324,6],[21,0,324,15],[25,0,324,19],[26,0,324,20],[37,0,324,31],[55,0,324,49]],[[8,0,325,4]],[[4,0,326,2]],[[4,0,328,2],[8,0,328,6],[12,0,328,10]],[[4,0,329,2],[11,0,329,9]],[[0,0,330,0]],[[0,0,332,0],[9,0,332,9],[18,0,332,18],[21,0,332,40]],[[4,0,333,2],[8,0,333,6],[15,0,333,13],[23,0,333,21],[35,0,333,33]],[[8,0,334,4],[15,0,334,11],[24,0,334,32],[27,0,334,35],[31,0,334,46]],[[12,0,335,6],[19,0,335,13],[23,0,335,17],[28,0,335,22],[29,0,335,23],[33,0,335,27],[35,0,335,29]],[[8,0,336,4]],[[4,0,337,2],[11,0,337,9]],[[8,0,338,4],[15,0,338,11],[22,0,338,18],[28,0,338,24],[29,0,338,25]],[[4,0,339,2]],[[0,0,340,0]],[[0,0,342,0],[9,0,342,9],[19,0,344,2],[21,0,344,14]],[[4,0,346,2],[10,0,346,8],[19,0,346,17],[52,0,346,50],[56,0,346,54],[60,0,346,58],[61,0,346,59],[62,0,346,60]],[[4,0,348,2],[66,0,348,64]],[[4,0,349,2],[8,0,349,6],[15,0,349,13],[30,0,349,28],[32,0,349,30],[39,0,349,37],[46,0,349,44],[61,0,349,59]],[[4,0,351,2],[101,0,351,99]],[[4,0,352,2],[10,0,352,8],[16,0,352,14],[23,0,352,21],[30,0,352,28]],[[4,0,353,2],[11,0,353,10],[18,0,353,17],[33,0,353,32],[36,0,353,35],[47,0,354,4],[52,0,355,4],[61,0,355,13],[67,0,356,4],[74,0,356,11],[74,0,356,12],[78,0,356,24],[88,0,356,34]],[[0,0,358,0]],[[0,0,359,0],[17,0,359,17],[18,0,359,18],[21,0,359,21]],[[0,0,361,0],[9,0,361,9],[21,0,363,2],[29,0,363,20]],[[4,0,365,2],[10,0,365,8],[19,0,365,17],[23,0,365,21],[24,0,365,22],[25,0,365,23],[26,0,365,24]],[[4,0,368,2],[11,0,368,9],[18,0,368,16],[28,0,368,26],[32,0,368,30],[33,0,368,31],[37,0,368,35]],[[0,0,369,0]],[[0,0,370,0],[17,0,370,17],[18,0,370,18],[21,0,370,21]],[[0,0,372,0],[79,0,372,79]],[[0,0,373,0],[77,0,373,77]],[[0,0,374,0],[6,0,374,6],[23,0,375,2],[36,0,375,15]],[[0,0,376,2],[7,0,376,9],[19,0,376,21],[32,0,378,6],[42,0,379,6],[51,0,379,15]],[[4,0,380,8],[10,0,380,14],[14,0,380,18],[20,0,380,24]],[[0,0,381,6]],[[0,0,382,0],[17,0,382,17],[18,0,382,18],[21,0,382,21]],[[0,0,384,0],[9,0,384,9],[25,0,386,2],[27,0,386,14]],[[4,0,388,2],[11,0,388,9],[44,0,388,42],[48,0,388,46],[52,0,388,50],[53,0,388,51],[54,0,388,52],[56,0,388,54],[63,0,388,61]],[[0,0,389,0]],[[0,0,390,0],[17,0,390,17],[18,0,390,18],[21,0,390,21]],[[0,0,392,0]],[],[],[],[],[],[[1,0,398,1],[4,0,399,0],[13,0,399,9],[26,0,399,22],[33,0,399,37]],[[4,0,400,2],[92,0,400,90]],[[4,0,401,2],[64,0,401,62]],[[4,0,402,2],[10,0,402,8],[22,0,402,20],[30,0,402,28],[37,0,402,35],[38,0,402,36]],[[4,0,403,2],[8,0,403,6],[22,0,403,20],[23,0,403,21],[26,0,403,24]],[[8,0,404,4],[18,0,404,14],[26,0,404,22],[35,0,404,31],[36,0,404,32],[39,0,404,35]],[[4,0,405,2]],[[4,0,407,2],[10,0,407,8],[23,0,407,21],[31,0,407,29],[38,0,407,36],[39,0,407,37]],[[4,0,408,2],[8,0,408,6],[23,0,408,21],[24,0,408,22],[27,0,408,25]],[[8,0,409,4],[18,0,409,14],[26,0,409,22],[35,0,409,31],[36,0,409,32],[39,0,409,35]],[[4,0,410,2]],[[4,0,412,2],[11,0,412,9]],[[0,0,413,0]],[[0,0,414,0]],[],[[1,0,416,1],[4,0,417,0],[13,0,417,9],[27,0,417,23],[30,0,417,44]],[[4,0,418,2],[13,0,418,11],[27,0,418,25],[29,0,418,35]],[[8,0,419,4],[13,0,419,9],[26,0,419,22]],[[8,0,420,4],[12,0,420,8],[27,0,420,23],[31,0,420,27],[32,0,420,28],[37,0,420,33],[42,0,420,38]],[[12,0,421,6],[19,0,421,13],[22,0,421,16],[23,0,421,17],[26,0,421,20],[27,0,421,21],[33,0,421,27]],[[8,0,422,4]],[[8,0,424,4],[14,0,424,10],[18,0,424,14],[22,0,424,18],[28,0,424,24],[29,0,424,25],[49,0,424,45],[51,0,424,47],[54,0,424,50],[55,0,424,51],[56,0,424,52]],[[8,0,425,6],[10,0,425,16],[14,0,425,20],[17,0,425,23]],[[8,0,426,4],[14,0,426,10]],[[4,0,427,2]],[[4,0,429,2],[18,0,429,16],[22,0,429,20],[25,0,429,23]],[[8,0,430,4],[15,0,430,11],[22,0,430,18],[26,0,430,22],[27,0,430,23]],[[4,0,431,2]],[[4,0,433,2],[18,0,433,16],[25,0,433,23],[28,0,433,26],[29,0,433,27]],[[8,0,434,4],[13,0,434,9],[26,0,434,22]],[[8,0,435,4],[12,0,435,8],[27,0,435,23],[31,0,435,27],[32,0,435,28],[37,0,435,33],[42,0,435,38]],[[12,0,436,6],[19,0,436,13],[22,0,436,16],[23,0,436,17],[26,0,436,20],[27,0,436,21],[29,0,436,23]],[[8,0,437,4]],[[8,0,439,4],[14,0,439,10],[18,0,439,14],[22,0,439,18],[28,0,439,24],[29,0,439,25],[49,0,439,45],[51,0,439,47],[54,0,439,50],[55,0,439,51],[56,0,439,52]],[[8,0,440,6],[10,0,440,16],[14,0,440,20],[17,0,440,23]],[[8,0,441,4],[14,0,441,10]],[[4,0,442,2]],[[4,0,444,2],[18,0,444,16],[24,0,444,22],[27,0,444,25],[34,0,444,32]],[[8,0,445,4],[15,0,445,11],[21,0,445,18],[35,0,445,32]],[[4,0,446,2]],[[4,0,448,2],[11,0,448,9]],[[0,0,449,0]],[[0,0,450,0],[17,0,450,17],[18,0,450,18],[21,0,450,21]],[[0,0,452,0]],[],[[1,0,454,1],[4,0,455,0],[13,0,455,9],[26,0,455,22],[35,0,455,42]],[[4,0,456,2],[11,0,456,9],[18,0,456,16],[32,0,456,30],[43,0,456,41],[55,0,456,53],[65,0,456,63],[69,0,456,67]],[[0,0,457,0]],[[0,0,459,0],[9,0,459,9],[19,0,459,28],[31,0,459,45]],[[4,0,460,2],[11,0,461,4],[27,0,461,20],[35,0,462,4],[42,0,462,11],[59,0,462,28],[71,0,463,4],[81,0,463,14],[97,0,464,4],[104,0,464,11],[117,0,464,24],[121,0,464,28],[126,0,464,33]],[[0,0,466,0]],[[0,0,468,0],[9,0,468,9],[26,0,468,40],[29,0,468,46]],[[4,0,469,2],[11,0,469,9],[30,0,469,28]],[[0,0,470,0]],[[0,0,472,0],[9,0,472,9]],[[4,0,473,2],[8,0,473,6]],[[4,0,474,2],[8,0,474,6]],[[4,0,476,2],[10,0,476,8],[20,0,476,18],[24,0,476,22],[32,0,476,33],[33,0,476,34],[38,0,476,39]],[[8,0,477,4],[17,0,477,13]],[[8,0,478,4],[18,0,478,14]],[[4,0,479,2]],[[4,0,481,2],[11,0,481,9]],[[8,0,482,4]],[[8,0,483,4],[17,0,483,13]],[[8,0,484,4],[16,0,484,12]],[[4,0,485,2]],[[0,0,486,0]],[[0,0,488,0],[80,0,488,80]],[[0,0,489,0],[42,0,489,42]],[[0,0,490,0],[25,0,490,25]],[[0,0,491,0],[30,0,491,30]],[[0,0,492,0],[77,0,492,77]],[[0,0,493,0],[72,0,493,72]],[[0,0,494,0],[9,0,494,9],[42,0,495,2],[54,0,495,41],[56,0,496,2],[62,0,496,16],[64,0,497,2],[79,0,497,34],[81,0,498,2],[92,0,498,38]],[[4,0,500,2],[8,0,500,6],[12,0,500,10]],[[4,0,501,2],[10,0,501,9],[14,0,501,13],[27,0,501,26],[33,0,501,32],[34,0,501,34]],[[8,0,502,4],[12,0,502,8],[23,0,502,19],[35,0,502,31],[36,0,502,32],[38,0,502,34]],[[8,0,503,4],[12,0,503,8],[18,0,503,14],[22,0,503,18]],[[8,0,504,4],[36,0,504,32]],[[8,0,505,4],[14,0,506,6],[20,0,506,12],[33,0,506,25],[39,0,506,31],[43,0,507,6],[50,0,507,13],[62,0,507,25],[63,0,507,26],[67,0,507,30],[72,0,507,35],[83,0,508,6]],[[12,0,509,6]],[[8,0,510,4]],[[8,0,511,4],[12,0,511,8],[20,0,511,16],[33,0,511,29],[39,0,511,35],[41,0,511,37]],[[12,0,512,6],[18,0,512,12],[22,0,512,16],[28,0,512,22]],[[8,0,513,4]],[[8,0,514,4],[103,0,514,99]],[[8,0,515,4],[94,0,515,90]],[[8,0,516,4],[12,0,516,8],[13,0,516,9],[29,0,516,25],[32,0,516,28],[33,0,516,29],[44,0,516,40]],[[12,0,517,6],[18,0,517,12],[36,0,517,30],[48,0,517,42],[49,0,517,43],[53,0,517,47]],[[12,0,518,6],[35,0,518,29]],[[12,0,519,6],[26,0,519,20]],[[12,0,520,6],[18,0,520,13],[22,0,520,17],[27,0,520,22],[31,0,520,27]],[[16,0,521,8],[27,0,521,19],[39,0,521,31],[40,0,521,32],[42,0,521,34]],[[16,0,522,8],[32,0,522,24],[35,0,522,27],[36,0,522,28],[46,0,522,38]],[[12,0,523,6]],[[8,0,524,4]],[[8,0,525,4],[12,0,525,8],[18,0,525,14],[21,0,525,16],[107,0,525,102]],[[4,0,526,2]],[[0,0,527,0]],[[0,0,529,0],[43,0,529,43]],[[0,0,530,0],[127,0,530,127]],[[0,0,532,0],[6,0,532,6],[24,0,532,24],[31,0,532,31]],[[0,0,533,0],[6,0,533,6],[25,0,533,25],[32,0,533,32]],[[0,0,534,0],[6,0,534,6],[23,0,534,23],[30,0,534,30]],[[0,0,547,0],[9,0,547,9],[22,0,547,22],[27,0,547,40]],[[4,0,548,2],[8,0,548,6],[17,0,548,15],[23,0,548,21],[29,0,548,27],[37,0,548,54]],[[8,0,549,4],[14,0,549,10],[20,0,549,16]],[[8,0,550,4],[14,0,550,10],[21,0,550,17],[22,0,550,18],[23,0,550,19],[28,0,550,26],[31,0,550,29],[41,0,550,39]],[[8,0,551,4],[14,0,551,10],[21,0,551,17],[22,0,551,18],[23,0,551,19],[28,0,551,27],[31,0,551,30],[41,0,551,40],[46,0,551,45],[49,0,551,48],[59,0,551,58],[64,0,551,63]],[[4,0,552,2]],[[0,0,553,0]],[[0,0,565,0],[9,0,565,9],[18,0,565,18],[22,0,565,29]],[[4,0,566,2],[11,0,566,9],[16,0,566,14],[19,0,566,17],[20,0,566,18],[21,0,566,19]],[[8,0,567,4],[12,0,567,8],[20,0,567,16],[28,0,567,24],[35,0,567,31],[43,0,567,39],[53,0,567,49]],[[12,0,568,6],[16,0,568,10],[33,0,568,27],[39,0,568,33],[46,0,568,40]],[[12,0,569,6],[16,0,569,10],[26,0,569,20],[32,0,569,26]],[[16,0,570,8],[22,0,570,14],[30,0,570,34],[37,0,570,41],[43,0,570,47],[44,0,570,48],[46,0,570,50],[48,0,570,52]],[[20,0,571,10],[26,0,571,16]],[[16,0,572,8]],[[16,0,574,8],[22,0,574,14],[28,0,574,36]],[[20,0,575,10],[21,0,575,11],[38,0,575,28],[40,0,575,30],[41,0,575,31]],[[20,0,576,10],[21,0,576,11],[37,0,576,27],[39,0,576,29],[40,0,576,30],[45,0,576,66],[48,0,576,69]],[[16,0,577,8]],[[16,0,579,8],[20,0,579,12],[24,0,579,16],[25,0,580,10],[26,0,580,11]],[[20,0,581,12],[23,0,581,15],[24,0,581,16],[41,0,581,33],[44,0,581,36]],[[20,0,582,12],[33,0,582,25]],[[16,0,583,10],[19,0,584,10],[20,0,584,11]],[[20,0,585,12],[23,0,585,15],[24,0,585,16],[39,0,585,31],[42,0,585,34]],[[20,0,586,12],[33,0,586,25]],[[16,0,587,10]],[[16,0,590,8],[23,0,590,15]],[[12,0,591,6]],[[8,0,592,4]],[[8,0,594,4],[15,0,594,11]],[[12,0,595,6],[13,0,595,7],[30,0,595,24],[32,0,595,26]],[[12,0,596,6],[13,0,596,7],[29,0,596,23],[31,0,596,25],[36,0,596,32]],[[8,0,597,4]],[[4,0,598,2]],[[0,0,599,0]],[[0,0,601,0],[9,0,601,9],[21,0,603,2],[25,0,608,11],[27,0,609,2],[35,0,609,19]],[[4,0,611,2],[10,0,611,8],[19,0,611,17],[23,0,611,21],[24,0,611,22],[25,0,611,23]],[[4,0,612,2],[10,0,612,8],[18,0,612,40],[29,0,613,6],[36,0,613,13],[42,0,613,19],[43,0,613,20],[45,0,613,22],[47,0,613,24]],[[8,0,613,26],[14,0,613,32]],[[4,0,613,54],[9,0,614,6]],[[4,0,616,2],[10,0,616,8],[22,0,616,37],[26,0,616,41]],[[4,0,618,2],[10,0,618,8],[12,0,618,10],[19,0,618,17],[21,0,618,19],[27,0,618,25],[29,0,618,27],[38,0,618,36],[48,0,618,46],[50,0,618,48],[53,0,618,51]],[[4,0,620,2],[10,0,620,8],[20,0,620,38],[27,0,620,45],[33,0,620,51],[34,0,620,52],[46,0,620,64]],[[8,0,621,4],[9,0,621,5],[26,0,621,22],[28,0,621,24],[35,0,621,31],[42,0,621,38]],[[8,0,622,4],[9,0,622,5],[25,0,622,21],[27,0,622,23],[28,0,622,24]],[[12,0,623,6],[21,0,623,15],[24,0,623,18]],[[12,0,624,6],[22,0,624,16],[29,0,624,23],[30,0,624,24]],[[12,0,625,6],[19,0,625,13],[20,0,625,14],[28,0,625,22],[29,0,625,23],[34,0,625,30]],[[8,0,626,4]],[[4,0,627,2]],[[4,0,629,2],[10,0,629,8],[23,0,629,41]],[[8,0,630,4]],[[12,0,631,6],[19,0,631,13]],[[8,0,632,4]],[[8,0,633,4],[13,0,633,8],[14,0,633,14]],[[12,0,634,6],[49,0,634,43]],[[12,0,635,6],[16,0,635,10],[22,0,635,16],[31,0,635,25]],[[16,0,636,8],[23,0,636,15],[24,0,636,16],[41,0,636,33],[44,0,636,36]],[[12,0,637,6]],[[8,0,638,4]],[[4,0,639,2]],[[4,0,641,2],[11,0,641,9],[25,0,641,23],[26,0,641,24],[34,0,641,32],[45,0,641,43]],[[4,0,642,2],[11,0,642,9],[25,0,642,23],[26,0,642,24],[34,0,642,32],[53,0,642,51]],[[4,0,644,2],[13,0,644,11],[37,0,644,35],[41,0,644,46]],[[8,0,645,4],[14,0,645,10],[28,0,645,24],[37,0,645,33]],[[8,0,647,4],[14,0,647,10],[26,0,647,22],[30,0,648,6],[42,0,648,18],[45,0,648,21],[46,0,648,22],[47,0,648,23]],[[16,0,649,8],[20,0,649,12],[21,0,649,13],[22,0,649,14],[37,0,649,29],[39,0,649,31],[45,0,649,37],[46,0,649,38],[47,0,649,39],[62,0,649,54]],[[16,0,650,8],[23,0,650,15],[24,0,650,16],[25,0,650,17],[42,0,650,34]],[[12,0,651,6]],[[8,0,653,4],[14,0,653,10],[16,0,653,12],[23,0,653,19],[25,0,653,21],[32,0,653,28],[34,0,653,30],[37,0,653,33]],[[8,0,655,4],[14,0,655,10],[19,0,655,29],[26,0,655,36],[32,0,655,42],[33,0,655,43],[37,0,655,49],[45,0,655,57],[57,0,655,69]],[[12,0,656,6],[24,0,656,18]],[[8,0,657,4]],[[8,0,659,4],[17,0,659,13],[25,0,659,21],[26,0,659,34]],[[12,0,660,6],[16,0,660,10],[22,0,660,16],[31,0,660,25],[32,0,660,26],[42,0,660,36],[45,0,660,39],[46,0,660,40],[50,0,660,44]],[[16,0,661,8],[26,0,661,18],[29,0,661,21],[30,0,661,22]],[[16,0,662,8],[20,0,662,12],[25,0,662,17],[27,0,662,19],[33,0,662,25],[41,0,662,54]],[[20,0,663,10],[23,0,663,13],[33,0,663,23]],[[20,0,664,10],[22,0,664,12],[26,0,664,16],[27,0,664,17]],[[16,0,665,8]],[[12,0,666,6]],[[8,0,667,4]],[[8,0,669,4],[20,0,669,16],[23,0,669,19],[24,0,669,20],[25,0,669,21],[31,0,669,29],[34,0,669,32],[35,0,669,33],[51,0,669,49],[52,0,669,50]],[[8,0,671,4],[15,0,671,11],[18,0,671,14],[28,0,671,24],[31,0,671,27],[41,0,671,37]],[[4,0,672,2]],[[4,0,674,2],[13,0,674,11],[25,0,674,23],[28,0,674,32]],[[8,0,675,4],[12,0,675,8],[17,0,675,13]],[[12,0,676,6],[19,0,676,14],[26,0,676,21],[27,0,676,22],[42,0,676,37],[45,0,676,40]],[[8,0,677,4],[15,0,677,11]],[[12,0,678,6],[20,0,678,14],[27,0,678,21],[28,0,678,22],[45,0,678,39]],[[8,0,679,4]],[[8,0,681,4],[21,0,681,17]],[[4,0,682,2]],[[4,0,684,2],[9,0,684,7],[34,0,684,32]],[[4,0,686,2],[8,0,686,6],[17,0,686,15],[23,0,686,21],[29,0,686,27],[38,0,686,53]],[[8,0,687,4],[14,0,687,10],[20,0,687,16]],[[4,0,688,2]],[[0,0,689,0]],[[0,0,690,0],[17,0,690,17],[18,0,690,18],[21,0,690,21]],[[0,0,692,0]],[],[],[],[],[],[],[],[],[[1,0,701,1],[4,0,702,0],[10,0,702,6],[24,0,702,20],[33,0,702,29],[45,0,702,52],[53,0,702,68]],[[4,0,703,2],[10,0,703,8],[20,0,703,18],[24,0,703,22],[28,0,703,26],[38,0,703,36]],[[4,0,704,2],[10,0,704,8],[19,0,704,38],[20,0,704,39]],[[4,0,705,2],[8,0,705,7],[14,0,705,13],[21,0,705,20],[29,0,705,29],[35,0,705,35],[36,0,705,36],[40,0,705,40],[43,0,705,43],[43,0,705,44],[50,0,705,59],[51,0,705,60],[55,0,705,64]],[[4,0,706,2],[11,0,706,9],[15,0,706,13],[18,0,706,16]],[[4,0,707,2],[11,0,707,9],[19,0,707,17],[22,0,707,20],[31,0,707,29],[38,0,707,36],[39,0,707,37],[49,0,707,47]],[[4,0,708,2],[11,0,708,9],[17,0,708,15],[20,0,708,18],[27,0,708,25],[35,0,708,33],[38,0,708,36]],[[4,0,709,2],[11,0,709,9],[19,0,709,17],[22,0,709,20],[29,0,709,27],[35,0,709,33],[38,0,709,36],[39,0,709,37],[42,0,709,40],[50,0,709,62]],[[4,0,710,2],[8,0,710,7],[14,0,710,13],[21,0,710,20],[28,0,711,4],[35,0,711,11],[49,0,711,25],[50,0,711,26],[54,0,711,30],[56,0,711,32],[61,0,711,37]],[[8,0,712,6],[20,0,712,18]],[[8,0,713,6],[22,0,713,20]],[[8,0,714,6],[15,0,714,13],[21,0,714,19],[22,0,714,20],[26,0,714,24]],[[4,0,715,4]],[[0,0,716,0]],[[0,0,717,0],[12,0,717,12],[21,0,717,21],[24,0,717,24],[28,0,717,28],[37,0,717,37]],[[0,0,718,0],[17,0,718,17],[18,0,718,18],[21,0,718,21]],[[0,0,720,0]],[],[[1,0,722,1],[4,0,723,0],[13,0,723,9],[23,0,723,19],[28,0,723,31],[30,0,723,33],[44,0,723,69]],[[4,0,724,2],[10,0,724,8],[14,0,724,12],[20,0,724,18],[21,0,724,19],[32,0,724,30],[34,0,724,32],[49,0,724,47],[57,0,724,55]],[[0,0,725,0]],[[0,0,727,0]],[],[[1,0,729,1],[4,0,730,0],[13,0,730,9],[25,0,730,21],[34,0,730,40]],[[4,0,731,2],[10,0,731,8],[14,0,731,12],[20,0,731,18]],[[0,0,732,0]],[[0,0,733,0],[17,0,733,17],[18,0,733,18],[21,0,733,21]],[[0,0,735,0],[98,0,735,98]],[[0,0,736,0],[17,0,736,17],[18,0,736,18],[21,0,736,21]],[[0,0,742,0],[9,0,742,9],[32,0,742,32],[39,0,742,49]],[[4,0,743,2],[67,0,743,65]],[[4,0,744,2],[11,0,744,9],[25,0,744,23],[26,0,744,24],[35,0,744,33],[43,0,744,41]],[[8,0,745,4],[15,0,745,11]],[[4,0,746,2]],[[0,0,747,0]],[[0,1,0,0]],[],[],[],[],[],[[1,1,6,1],[4,1,8,0],[56,1,8,52],[59,1,10,0],[104,1,10,45]],[[0,1,11,0],[57,1,11,57]],[[0,1,13,0],[67,1,13,67]],[[0,1,29,0],[6,1,29,6],[32,1,30,2],[40,1,30,10],[49,1,30,19]],[[0,1,55,0],[4,1,55,0],[4,1,55,5],[40,1,55,5]],[[4,1,56,2]],[],[],[],[[3,1,60,3]],[[4,1,62,2]],[],[],[[3,1,65,3]],[[4,1,67,2]],[],[],[],[[3,1,71,3]],[[11,1,55,5]],[[2,1,55,5]],[[0,1,103,0],[6,1,103,6],[24,1,103,41],[28,1,103,45]],[[0,1,104,0],[17,1,104,17],[18,1,104,18],[21,1,104,21]],[[0,1,106,0],[6,1,106,6],[25,1,106,61],[29,1,106,65]],[[0,1,108,0],[6,1,108,6],[30,1,108,67],[34,1,108,71]],[[0,1,110,0],[9,1,110,9],[36,1,111,2],[44,1,111,20],[46,1,112,2],[56,1,112,24],[58,1,113,2],[68,1,113,24]],[[4,1,115,2],[8,1,115,6]],[[4,1,116,2],[11,1,116,10]],[[8,1,117,4]],[[12,1,118,6],[34,1,118,28],[35,1,118,29],[63,1,118,57],[65,1,118,59],[77,1,118,71]],[[12,1,119,6]],[[8,1,120,4]],[[12,1,121,6],[34,1,121,28],[35,1,121,29],[71,1,121,65],[73,1,121,67],[85,1,121,79]],[[12,1,122,6]],[[8,1,123,4]],[[12,1,124,6],[34,1,124,28]],[[12,1,125,6]],[[8,1,126,4]],[[12,1,127,6],[22,1,128,8],[34,1,129,8],[35,1,129,9],[48,1,129,24],[49,1,129,25],[70,1,129,46],[72,1,129,48],[84,1,129,60]],[[4,1,131,2]],[[4,1,132,2],[11,1,132,9],[12,1,132,10],[19,1,132,17],[21,1,132,19],[30,1,132,28],[48,1,132,46],[50,1,132,48],[70,1,132,68],[112,1,132,110],[113,1,132,111]],[[0,1,133,0]],[[0,1,135,0],[9,1,135,9],[19,1,137,2],[28,1,137,22]],[[4,1,139,2],[11,1,139,9],[32,1,139,46],[36,1,139,50],[37,1,139,51],[38,1,139,52],[39,1,139,53],[41,1,139,55],[43,1,139,57]],[[0,1,140,0]],[[0,1,141,0],[24,1,141,24],[25,1,141,25],[28,1,141,28]],[[0,1,143,0],[9,1,143,9],[26,1,143,26],[35,1,143,46],[37,1,143,48],[46,1,143,68]],[[4,1,144,2],[11,1,144,9],[32,1,144,47],[43,1,144,58]],[[0,1,145,0]],[[0,1,147,0],[15,1,147,15],[33,1,148,2],[43,1,148,24],[45,1,149,2],[55,1,149,24],[57,1,150,2],[66,1,150,22]],[[4,1,152,2],[8,1,152,6],[15,1,152,13],[29,1,152,27],[39,1,152,37]],[[8,1,153,4],[15,1,153,11],[29,1,153,25],[41,1,153,37],[53,1,153,49]],[[4,1,154,2]],[[4,1,156,2],[10,1,156,8],[25,1,156,23],[35,1,156,33],[43,1,156,41],[47,1,156,45],[49,1,156,47]],[[4,1,157,2],[10,1,157,8],[28,1,157,26],[41,1,157,39],[44,1,157,42],[45,1,157,43],[46,1,157,44]],[[8,1,158,4],[12,1,158,8],[28,1,158,24],[31,1,158,27],[32,1,158,28],[43,1,158,39],[50,1,158,46]],[[8,1,159,4],[15,1,159,11],[32,1,159,28],[35,1,159,31],[36,1,159,32]],[[4,1,160,2]],[[4,1,161,2],[8,1,161,6],[24,1,161,22],[30,1,161,28],[33,1,161,31],[38,1,161,36],[54,1,161,52],[59,1,161,57],[60,1,161,58],[61,1,161,59],[65,1,161,65],[69,1,161,69]],[[8,1,162,4],[95,1,162,91]],[[8,1,163,4],[14,1,163,10],[22,1,163,18],[25,1,163,21],[26,1,163,22]],[[8,1,164,4]],[[4,1,165,2]],[[4,1,167,2],[10,1,167,8],[37,1,167,35],[47,1,167,45],[59,1,167,57],[63,1,167,61],[65,1,167,63]],[[4,1,168,2],[10,1,168,8],[33,1,168,31],[58,1,169,5],[61,1,169,8],[62,1,169,9],[63,1,169,10]],[[8,1,170,6],[49,1,170,47]],[[8,1,171,6],[54,1,171,52]],[[8,1,172,6],[15,1,172,13],[37,1,172,35],[40,1,172,38],[41,1,172,39]],[[4,1,173,4],[7,1,174,5],[13,1,174,11],[14,1,174,12],[15,1,174,13],[19,1,174,19]],[[4,1,176,2],[8,1,176,6]],[[4,1,177,2],[8,1,177,6],[29,1,177,27],[35,1,177,33],[38,1,177,36],[41,1,177,39]],[[8,1,178,4],[60,1,178,56]],[[8,1,180,4],[12,1,180,8],[33,1,180,29],[39,1,180,35],[44,1,180,40],[69,1,180,65],[75,1,180,71],[77,1,180,73]],[[12,1,181,6],[107,1,181,101]],[[12,1,182,6],[18,1,182,12],[26,1,182,20],[29,1,182,23],[30,1,182,24]],[[12,1,183,6]],[[8,1,184,4]],[[8,1,186,4],[14,1,186,10],[35,1,186,47],[39,1,186,51]],[[8,1,187,4],[13,1,187,9],[19,1,187,15],[34,1,187,30],[59,1,187,56]],[[12,1,188,6],[16,1,188,10],[17,1,188,11],[39,1,188,33],[42,1,188,36],[43,1,188,37],[57,1,188,51]],[[16,1,189,8],[35,1,189,27],[38,1,189,30],[39,1,189,31]],[[12,1,190,6]],[[8,1,191,4]],[[8,1,193,4],[13,1,193,9],[19,1,193,15],[40,1,193,36],[59,1,193,56]],[[12,1,194,6],[18,1,194,12],[28,1,194,22],[42,1,194,36],[54,1,194,48],[66,1,194,60]],[[12,1,196,6],[34,1,196,28],[37,1,196,31],[38,1,196,32],[57,1,196,51]],[[12,1,198,6],[33,1,198,27],[37,1,198,31],[38,1,198,32]],[[8,1,199,4]],[[8,1,201,4],[18,1,201,14],[26,1,201,22],[29,1,201,25],[30,1,201,26]],[[4,1,202,2],[11,1,202,9]],[[8,1,203,4],[18,1,203,14],[32,1,203,28],[44,1,203,40],[56,1,203,52],[66,1,203,62],[70,1,203,66]],[[8,1,205,4],[96,1,205,92]],[[8,1,206,4],[13,1,206,9],[19,1,206,15],[42,1,206,38],[67,1,206,64]],[[12,1,207,6],[16,1,207,10],[17,1,207,11],[39,1,207,33],[42,1,207,36],[43,1,207,37],[65,1,207,59]],[[16,1,208,8],[38,1,208,30],[41,1,208,33],[42,1,208,34],[63,1,208,55]],[[12,1,209,6]],[[8,1,210,4]],[[4,1,211,2]],[[4,1,213,2],[9,1,213,7],[15,1,213,13],[27,1,213,25],[40,1,213,39]],[[8,1,214,4],[12,1,214,8],[13,1,214,9],[30,1,214,26],[33,1,214,29],[34,1,214,30],[45,1,214,41]],[[12,1,215,6],[145,1,215,139]],[[12,1,216,6],[117,1,216,111]],[[12,1,217,6],[29,1,217,23],[32,1,217,26],[33,1,217,27],[43,1,217,37]],[[8,1,218,4]],[[4,1,219,2]],[[4,1,221,2],[10,1,221,8]],[[0,1,222,0]],[[0,1,224,0],[6,1,224,6],[20,1,224,20],[28,1,224,28],[35,1,224,35],[36,1,224,36]],[[0,1,225,0],[6,1,225,6],[38,1,225,38],[42,1,225,42]],[[0,1,229,0],[88,1,229,88]],[[0,1,230,0],[9,1,230,9],[24,1,232,2],[32,1,232,20]],[[4,1,234,2],[11,1,234,9],[37,1,234,51],[41,1,234,55],[42,1,234,56],[43,1,234,57],[44,1,234,58],[46,1,234,60],[48,1,234,62]],[[0,1,235,0]],[[0,1,236,0],[24,1,236,24],[25,1,236,25],[28,1,236,28]],[[0,1,238,0],[88,1,238,88]],[[0,1,239,0],[9,1,239,9],[32,1,240,2],[42,1,240,24],[44,1,241,2],[54,1,241,24],[56,1,242,2],[64,1,242,20]],[[4,1,244,2],[10,1,244,8],[21,1,244,19],[29,1,244,27],[44,1,244,42],[45,1,244,43],[57,1,244,55]],[[4,1,245,2],[8,1,245,6],[16,1,245,14],[46,1,245,44],[49,1,245,47],[50,1,245,48]],[[4,1,246,2],[8,1,246,6],[18,1,246,16],[29,1,246,27]],[[8,1,247,4],[14,1,247,10],[24,1,247,20],[54,1,247,50],[57,1,247,53],[58,1,247,54],[62,1,247,58],[63,1,248,6],[94,1,249,6],[104,1,250,6]],[[8,1,252,4],[16,1,252,12],[25,1,252,21],[29,1,252,25],[30,1,252,26],[39,1,252,35],[44,1,252,40],[45,1,252,41],[46,1,252,42]],[[12,1,253,6],[16,1,253,10]],[[12,1,254,6],[19,1,254,14]],[[16,1,255,8]],[[20,1,256,10],[33,1,256,23],[34,1,256,24],[67,1,256,57],[69,1,256,59],[81,1,256,71]],[[20,1,257,10]],[[16,1,258,8]],[[20,1,259,10],[33,1,259,23],[34,1,259,24],[46,1,259,36],[48,1,259,38],[60,1,259,50]],[[20,1,260,10]],[[16,1,261,8]],[[20,1,262,10],[33,1,262,23]],[[20,1,263,10]],[[16,1,264,8]],[[20,1,265,10],[30,1,266,12],[42,1,267,12],[43,1,267,13],[56,1,267,28],[57,1,267,29],[78,1,267,50],[80,1,267,52],[92,1,267,64]],[[12,1,269,6]],[[12,1,270,6],[16,1,270,10],[24,1,270,18],[28,1,270,22],[34,1,271,8],[35,1,271,9],[56,1,271,30],[58,1,271,32],[67,1,271,41],[68,1,271,42],[70,1,271,44],[83,1,272,10],[91,1,272,18],[92,1,272,19],[94,1,272,21],[96,1,272,23],[103,1,272,30],[106,1,272,33],[110,1,273,10],[112,1,274,8],[120,1,274,16]],[[16,1,274,18]],[[12,1,274,24],[16,1,274,28]],[[12,1,276,6],[18,1,276,12],[22,1,276,16],[25,1,276,19]],[[12,1,277,6],[18,1,277,12]],[[8,1,278,4]],[[8,1,279,4],[38,1,279,34],[41,1,279,37],[42,1,279,38],[52,1,279,48]],[[4,1,280,2]],[[4,1,282,2],[11,1,282,9]],[[0,1,283,0]],[[0,1,285,0],[88,1,285,88]],[[0,1,286,0],[9,1,286,9],[23,1,287,2],[33,1,287,24],[35,1,288,2],[45,1,288,24],[47,1,289,2],[56,1,289,22]],[[4,1,291,2],[10,1,291,8],[16,1,291,14],[36,1,291,34]],[[4,1,292,2],[11,1,292,9],[34,1,292,32],[46,1,292,44],[58,1,292,56]],[[0,1,293,0]],[[0,1,295,0]],[],[[1,1,297,1],[4,1,298,0],[13,1,298,9],[35,1,300,2],[43,1,300,18]],[[4,1,302,2],[10,1,302,8],[21,1,302,19],[25,1,302,23],[26,1,302,24],[27,1,302,25],[28,1,302,26]],[[4,1,303,2],[11,1,303,9],[21,1,303,19],[32,1,303,30]],[[0,1,304,0]],[[0,1,305,0],[24,1,305,24],[25,1,305,25],[28,1,305,28]],[[0,1,307,0]],[],[],[[1,1,310,1],[4,1,311,0],[13,1,311,9],[33,1,311,29],[43,1,311,48]],[[4,1,312,2],[11,1,312,9],[12,1,312,10],[18,1,312,16],[20,1,312,18],[34,1,312,32],[38,1,312,36]],[[0,1,313,0]],[[0,1,314,0],[24,1,314,24],[25,1,314,25],[28,1,314,28]],[[0,1,316,0]],[],[],[[1,1,319,1],[4,1,320,0],[13,1,320,9],[30,1,320,26],[36,1,320,45]],[[4,1,321,2],[98,1,321,96]],[[4,1,322,2],[75,1,322,73]],[[4,1,323,2],[8,1,323,6],[20,1,323,18],[21,1,323,19],[54,1,323,52],[56,1,323,54],[61,1,323,59],[70,1,323,68],[71,1,323,69],[80,1,323,78],[86,1,323,84],[88,1,323,86]],[[30,1,324,30],[32,1,324,32],[37,1,324,37],[46,1,324,46],[47,1,324,47],[61,1,324,61]],[[33,1,325,33],[35,1,325,35],[40,1,325,40],[49,1,325,49],[50,1,325,50],[57,1,325,57],[64,1,325,64],[67,1,325,67],[70,1,325,70],[71,1,325,71],[93,1,325,93],[99,1,325,99],[102,1,325,102]],[[104,1,326,104],[105,1,326,105]],[[4,1,327,2],[8,1,327,6],[15,1,327,13],[19,1,327,17],[24,1,327,22]],[[8,1,327,23]],[[5,1,327,33],[7,1,327,35]],[[8,1,327,37],[14,1,327,43]],[[4,1,327,61]],[[4,1,328,2],[11,1,328,9],[15,1,328,13],[30,1,328,28],[31,1,328,29]],[[0,1,329,0]],[[0,1,330,0],[24,1,330,24],[25,1,330,25],[28,1,330,28]],[[0,1,332,0]],[],[[1,1,334,1],[4,1,335,0],[13,1,335,9],[38,1,336,2],[46,1,336,20],[48,1,337,2],[57,1,337,22]],[[4,1,339,2],[11,1,339,9],[29,1,339,27],[42,1,339,57]],[[0,1,340,0]],[[0,1,341,0]],[],[[1,1,343,1],[4,1,344,0],[13,1,344,9],[33,1,344,29],[42,1,344,65]],[[4,1,345,2],[11,1,345,9],[14,1,345,12],[32,1,345,30],[42,1,346,5],[47,1,346,10],[48,1,346,11],[53,1,347,5],[56,1,347,8],[57,1,347,9],[58,1,347,10],[62,1,347,16],[81,1,347,35],[85,1,348,5],[89,1,348,9],[90,1,348,10],[97,1,348,17],[111,1,348,31]],[[0,1,349,0]],[[0,1,358,0],[9,1,358,9],[27,1,359,2],[38,1,359,72]],[[4,1,361,2],[8,1,361,6],[15,1,361,13],[31,1,361,29],[41,1,361,39]],[[8,1,362,4],[15,1,362,11]],[[4,1,363,2]],[[4,1,364,2],[10,1,364,8],[21,1,365,4],[28,1,365,11],[58,1,365,41],[72,1,366,8],[98,1,366,34],[101,1,366,37],[106,1,367,8],[118,1,367,20],[130,1,367,32],[131,1,367,33]],[[4,1,368,2],[10,1,368,8],[16,1,368,14],[35,1,368,33],[44,1,368,42],[51,1,368,49],[52,1,368,50],[63,1,368,61]],[[4,1,369,2],[10,1,369,8],[17,1,369,15],[21,1,369,19],[31,1,369,29],[32,1,369,30],[51,1,370,6],[55,1,370,10],[60,1,370,15],[61,1,370,16],[77,1,370,32],[83,1,370,38],[87,1,371,6]],[[4,1,372,2],[11,1,372,9]],[[0,1,373,0]],[[0,1,375,0],[6,1,375,6],[19,1,375,19]],[[0,1,376,0]],[],[[1,1,378,1],[4,1,379,0],[13,1,379,9],[18,1,379,14],[32,1,379,50]],[[4,1,380,2],[11,1,380,9],[22,1,380,20],[26,1,380,24],[27,1,380,25]],[[0,1,381,0]],[[0,1,383,0],[6,1,383,6],[20,1,383,20]],[[0,1,384,0]],[],[[1,1,386,1],[4,1,387,0],[13,1,387,9],[19,1,387,15],[27,1,387,33]],[[4,1,388,2],[11,1,388,9],[23,1,388,21],[27,1,388,25],[28,1,388,26]],[[0,1,389,0]],[[0,1,391,0],[9,1,391,9],[25,1,393,2],[34,1,393,22],[36,1,394,2],[46,1,394,38],[48,1,395,2],[58,1,395,33]],[[4,1,397,2],[11,1,397,9],[19,1,397,17],[34,1,397,32],[38,1,399,4],[42,1,399,8],[43,1,399,9],[44,1,399,10],[45,1,399,11],[47,1,399,13],[49,1,400,4],[60,1,401,4],[72,1,402,4]],[[0,1,404,0]],[[0,1,405,0],[17,1,405,17],[18,1,405,18],[21,1,405,21]],[[0,1,407,0],[9,1,407,9],[31,1,409,2],[40,1,409,22],[42,1,410,2],[52,1,410,38]],[[4,1,412,2],[11,1,412,9],[19,1,412,17],[40,1,412,38],[44,1,414,4],[48,1,414,8],[49,1,414,9],[50,1,414,10],[51,1,414,11],[53,1,414,13],[55,1,415,4],[66,1,416,4]],[[0,1,418,0]],[[0,1,419,0],[17,1,419,17],[18,1,419,18],[21,1,419,21]],[[0,2,0,0],[43,2,0,43]],[[0,2,1,0],[44,2,1,44]],[[0,2,2,0],[44,2,2,44]],[[0,2,8,0],[6,2,8,6],[28,2,8,28],[36,2,8,36],[45,2,8,45]],[[0,2,10,0]],[],[],[],[],[],[[1,2,16,1],[4,2,18,0],[56,2,18,52],[59,2,20,0],[65,2,20,6],[82,2,20,47],[89,2,20,54],[95,2,20,60],[96,2,20,61]],[[0,2,21,0],[20,2,21,20],[21,2,21,21],[24,2,21,24]],[[0,2,53,0],[6,2,53,6],[31,2,53,31]],[[4,2,54,2],[11,2,54,9],[30,2,54,27]],[[4,2,56,2],[20,2,56,29]],[[4,2,58,2],[16,2,58,14],[23,2,58,29],[25,2,58,31],[40,2,58,58],[41,2,58,60]],[[8,2,59,4],[13,2,59,9],[14,2,59,10]],[[8,2,60,4],[12,2,60,8],[13,2,60,9],[28,2,60,24],[31,2,60,27]],[[4,2,61,2]],[[0,2,62,0]],[[0,2,64,0]],[],[[1,2,66,1],[4,2,67,0],[10,2,67,6],[27,2,67,38],[31,2,67,42]],[[0,2,69,0]],[],[],[],[],[],[[1,2,75,1],[4,2,76,0],[10,2,76,6],[28,2,76,55],[32,2,76,59]],[[0,2,77,0]],[],[[1,2,79,1],[4,2,80,0],[10,2,80,6],[28,2,80,55],[32,2,80,59]],[[0,2,81,0]],[],[],[],[[1,2,85,1],[4,2,86,0],[10,2,86,6],[30,2,86,46],[34,2,86,50]],[[0,2,87,0]],[],[[1,2,89,1],[4,2,90,0],[10,2,90,6],[31,2,90,63],[35,2,90,67]],[[0,2,91,0]],[],[[1,2,93,1],[4,2,94,0],[10,2,94,6],[31,2,94,63],[35,2,94,67]],[[0,2,96,0]],[],[],[[1,2,99,1],[4,2,100,0],[10,2,100,6],[26,2,100,46],[30,2,100,50]],[[0,2,101,0]],[],[[1,2,103,1],[4,2,104,0],[10,2,104,6],[27,2,104,46],[31,2,104,50]],[[0,2,105,0]],[],[[1,2,107,1],[4,2,108,0],[10,2,108,6],[37,2,108,48],[41,2,108,52]],[[0,2,110,0]],[],[[1,2,112,1],[4,2,113,0],[17,2,113,13]],[[0,2,114,0],[9,2,114,9],[39,2,115,2],[48,2,115,22],[50,2,116,2],[58,2,116,20]],[[4,2,118,2],[10,2,118,8],[19,2,118,17],[33,2,118,31],[34,2,118,32],[43,2,118,41]],[[4,2,119,2],[8,2,119,6],[16,2,119,14]],[[8,2,120,4],[12,2,120,8],[19,2,120,15],[24,2,120,20],[26,2,120,22]],[[12,2,121,6],[18,2,121,12],[25,2,121,19],[30,2,121,24]],[[8,2,122,4]],[[8,2,123,4],[15,2,123,11]],[[4,2,124,2]],[[4,2,126,2],[17,2,126,15]],[[4,2,127,2],[11,2,127,9],[29,2,127,27],[39,2,127,37],[50,2,127,48],[57,2,127,55],[59,2,127,57]],[[0,2,128,0]],[[0,2,130,0]],[],[[1,2,132,1],[4,2,133,0],[47,2,133,43]],[[0,2,134,0],[6,2,134,6],[41,2,136,4],[42,2,136,5],[46,2,136,9]],[[4,2,137,2],[8,2,137,6],[9,2,137,7],[22,2,137,20],[25,2,137,23],[26,2,137,24],[32,2,137,30],[34,2,137,32]],[[8,2,138,4],[16,2,138,12],[20,2,138,16],[21,2,139,6],[22,2,139,7],[50,2,139,35],[52,2,139,37],[55,2,139,40],[68,2,139,53],[70,2,139,55],[83,2,139,68],[85,2,139,70],[86,2,139,71],[122,2,139,107],[123,2,139,108]],[[4,2,141,2]],[[4,2,143,2],[10,2,143,8],[19,2,143,17],[33,2,143,31],[34,2,143,32],[37,2,143,35]],[[4,2,145,2],[8,2,145,6],[21,2,145,19],[29,2,145,27],[30,2,145,28],[37,2,145,35],[38,2,145,36],[46,2,145,44],[47,2,145,45],[50,2,145,48]],[[8,2,146,4],[21,2,146,17],[29,2,146,25],[30,2,146,26],[34,2,146,30],[35,2,146,31]],[[4,2,147,2]],[[4,2,149,2],[8,2,149,6],[16,2,149,14]],[[8,2,150,4],[12,2,150,8],[19,2,150,15],[24,2,150,20],[26,2,150,22]],[[12,2,151,6],[18,2,151,12],[25,2,151,19],[30,2,151,24]],[[8,2,152,4]],[[8,2,154,4],[12,2,154,8],[19,2,154,15],[26,2,154,22],[27,2,154,23],[34,2,154,30],[35,2,154,31],[48,2,154,44],[50,2,154,46],[56,2,154,52],[57,2,154,53],[60,2,154,56]],[[12,2,155,6],[19,2,155,13],[26,2,155,20],[27,2,155,21],[31,2,155,25],[32,2,155,26],[45,2,155,39],[47,2,155,41]],[[8,2,156,4]],[[8,2,158,4],[15,2,158,11]],[[4,2,159,2]],[[4,2,161,2],[11,2,161,9],[29,2,161,27],[33,2,161,31],[44,2,161,42],[50,2,161,48],[52,2,161,50],[65,2,161,63],[67,2,161,65]],[[0,2,162,0]],[[0,2,164,0],[9,2,164,9],[20,2,166,2],[26,2,166,19],[28,2,167,2],[35,2,167,18],[37,2,168,2],[44,2,168,25]],[[4,2,170,2],[12,2,170,10],[16,2,170,14],[17,2,170,15],[21,2,170,19],[23,2,170,21],[31,2,170,29]],[[4,2,171,2],[8,2,171,6],[9,2,171,7],[10,2,171,8],[13,2,171,11]],[[0,2,172,0]],[[0,2,173,0],[11,2,173,11],[20,2,173,20],[23,2,173,23],[31,2,173,31],[40,2,173,40]],[[0,2,183,0],[9,2,183,9],[27,2,184,2],[35,2,184,20],[37,2,185,2],[47,2,185,24],[49,2,186,2],[59,2,186,24]],[[4,2,188,2],[54,2,188,52]],[[4,2,189,2],[8,2,189,6],[13,2,189,11]],[[4,2,191,2],[10,2,191,8],[26,2,191,24],[42,2,191,40],[45,2,191,43],[46,2,191,44]],[[4,2,192,2],[8,2,192,6],[15,2,192,13],[33,2,192,31],[45,2,192,43]],[[8,2,193,4],[78,2,193,74]],[[8,2,194,4],[82,2,194,78]],[[8,2,195,4],[59,2,195,55]],[[8,2,196,4],[14,2,196,10],[18,2,196,14],[24,2,197,6],[51,2,197,33],[55,2,197,37],[67,2,197,49],[81,2,198,8]],[[4,2,200,2]],[[4,2,202,2],[10,2,202,8],[20,2,202,18],[34,2,202,32],[37,2,202,35],[38,2,202,36]],[[4,2,203,2],[10,2,203,8],[12,2,203,10],[15,2,203,13],[17,2,203,15],[25,2,203,23],[27,2,203,25],[30,2,203,28],[46,2,203,44],[50,2,203,48]],[[4,2,205,2],[8,2,205,6]],[[4,2,206,2],[11,2,206,10]],[[8,2,207,4],[13,2,207,9],[24,2,207,20],[31,2,207,27]],[[12,2,208,6],[27,2,208,21],[30,2,208,24],[31,2,208,25]],[[12,2,209,6],[22,2,209,16],[24,2,209,18]],[[12,2,210,6]],[[8,2,211,4],[13,2,211,9],[24,2,211,20],[30,2,211,26]],[[12,2,212,6],[84,2,212,78]],[[12,2,213,6],[84,2,213,78]],[[12,2,214,6],[22,2,214,16]],[[16,2,214,17]],[[13,2,214,40]],[[12,2,215,6]],[[8,2,216,4],[13,2,216,9],[24,2,216,20],[30,2,216,26]],[[12,2,217,6],[22,2,217,16],[22,2,217,17],[36,2,217,46],[38,2,217,48]],[[12,2,218,6]],[[8,2,219,4]],[[12,2,220,6],[22,2,221,8],[34,2,222,8],[35,2,222,9],[48,2,222,24],[49,2,222,25],[70,2,222,46],[72,2,222,48],[84,2,222,60]],[[4,2,224,2]],[[4,2,226,2],[10,2,226,8],[19,2,226,28],[38,2,226,47]],[[4,2,227,2],[10,2,227,8],[20,2,227,18],[27,2,227,25],[34,2,227,32]],[[4,2,228,2],[11,2,228,9],[18,2,228,16],[21,2,228,19]],[[4,2,229,2],[11,2,229,9],[19,2,229,17],[22,2,229,20],[24,2,229,22]],[[4,2,230,2],[11,2,230,9],[14,2,230,12],[17,2,230,15]],[[4,2,232,2],[18,2,232,16],[19,2,232,17],[22,2,232,20],[25,2,232,23]],[[4,2,233,2],[19,2,233,17],[22,2,233,20],[23,2,233,21],[31,2,233,29]],[[4,2,235,2],[80,2,235,78]],[[4,2,236,2],[8,2,236,6]],[[8,2,237,4],[32,2,237,28],[40,2,237,36],[41,2,237,37]],[[12,2,238,6],[18,2,238,12],[28,2,238,22],[32,2,238,27],[43,2,239,8],[51,2,240,8],[60,2,241,8]],[[12,2,243,6],[26,2,243,20],[35,2,243,29],[43,2,243,37]],[[8,2,244,4]],[[4,2,245,2],[6,2,245,4],[13,2,245,11],[20,2,245,18]],[[8,2,246,4],[15,2,246,11],[20,2,246,16],[23,2,246,19]],[[8,2,247,4],[14,2,247,10]],[[4,2,248,2]],[[4,2,250,2],[8,2,250,6],[15,2,250,13],[30,2,250,28],[34,2,250,32],[41,2,250,39],[48,2,250,46],[53,2,250,51],[60,2,250,58],[75,2,250,73],[77,2,250,75]],[[8,2,251,4],[65,2,251,61]],[[8,2,252,4],[19,2,252,15],[26,2,252,22],[33,2,252,29],[35,2,252,31],[42,2,252,38],[57,2,252,53]],[[4,2,253,2]],[[4,2,255,2],[11,2,255,9]],[[0,2,256,0]],[[0,2,258,0],[6,2,258,6],[30,2,258,30]],[[4,2,259,2],[14,2,259,12],[15,2,259,13],[22,2,259,29],[29,2,259,47]],[[4,2,260,2],[15,2,260,13],[19,2,260,19],[20,2,260,20],[29,2,260,40]],[[4,2,261,2],[21,2,261,19],[22,2,261,20],[31,2,261,38],[43,2,261,61]],[[0,2,262,0]],[[0,2,264,0]],[],[],[],[[1,2,268,1],[4,2,269,0],[13,2,269,9],[37,2,270,2],[43,2,270,19],[45,2,271,2],[58,2,271,46]],[[4,2,273,2],[8,2,273,6],[15,2,273,13],[26,2,273,24],[59,2,273,57],[64,2,273,62],[76,2,273,74]],[[8,2,274,4],[14,2,274,10],[45,2,275,6],[56,2,275,17],[89,2,275,50],[90,2,275,51],[97,2,275,58],[99,2,275,60]],[[8,2,276,4],[12,2,276,8]],[[12,2,277,6],[26,2,277,20]],[[16,2,278,8],[26,2,278,18],[37,2,278,29],[49,2,278,41]],[[16,2,279,8],[27,2,279,19],[38,2,279,30],[50,2,279,42]],[[16,2,280,8],[33,2,280,25]],[[12,2,281,6]],[[8,2,282,4],[17,2,282,14]],[[12,2,283,6],[77,2,283,71]],[[12,2,284,6]],[[8,2,285,4]],[[4,2,286,2],[11,2,286,9]],[[8,2,287,4],[88,2,287,84]],[[8,2,288,4],[87,2,288,83]],[[8,2,289,4],[33,2,289,29]],[[8,2,290,4],[22,2,290,18]],[[4,2,291,2]],[[0,2,292,0]],[[0,2,294,0]],[],[[1,2,296,1],[4,2,297,0],[13,2,297,9],[60,2,298,2],[66,2,298,19],[68,2,299,2],[75,2,299,25]],[[4,2,301,2],[10,2,301,8],[27,2,301,25],[34,2,301,32],[41,2,301,39]],[[4,2,302,2],[10,2,302,8],[24,2,302,22],[31,2,302,29],[34,2,302,32],[35,2,302,33],[39,2,302,37],[40,2,302,38],[51,2,302,49],[55,2,302,53]],[[4,2,304,2],[12,2,304,10],[42,2,304,40],[43,2,304,41],[59,2,304,57],[66,2,304,64],[68,2,304,66]],[[4,2,306,2],[77,2,306,75]],[[4,2,307,2],[32,2,307,30]],[[4,2,308,2],[8,2,308,6],[16,2,308,14],[38,2,308,36],[39,2,308,37],[56,2,308,54]],[[8,2,309,4],[78,2,309,74]],[[8,2,310,4],[22,2,310,18]],[[8,2,311,4],[15,2,311,11],[18,2,311,14],[19,2,311,15],[26,2,311,22],[27,2,311,23],[28,2,311,24]],[[12,2,312,6],[17,2,312,11],[28,2,312,22],[31,2,312,25]],[[8,2,313,4]],[[8,2,314,4],[79,2,314,75]],[[8,2,315,4],[42,2,315,38]],[[8,2,316,4],[15,2,316,11],[18,2,316,14],[19,2,316,15],[25,2,316,21]],[[8,2,318,4],[75,2,318,71]],[[8,2,319,4],[81,2,319,77]],[[8,2,320,4],[29,2,320,25]],[[8,2,321,4],[12,2,321,8],[28,2,321,24],[34,2,321,30]],[[12,2,322,6],[79,2,322,73]],[[12,2,323,6],[41,2,323,35]],[[12,2,324,6],[14,2,324,8]],[[12,2,325,6],[75,2,325,69]],[[12,2,326,6],[78,2,326,72]],[[12,2,327,6],[74,2,327,68]],[[12,2,328,6],[60,2,328,54]],[[12,2,329,6],[16,2,330,8],[24,2,330,16],[60,2,330,52],[61,2,331,10],[69,2,331,18],[96,2,331,45],[97,2,331,46],[111,2,332,10],[119,2,332,18],[146,2,332,45],[147,2,332,46],[165,2,334,8]],[[16,2,335,8],[23,2,335,15],[26,2,335,18],[27,2,335,19],[37,2,335,29]],[[12,2,336,6],[19,2,336,13]],[[16,2,337,8],[24,2,337,16],[38,2,337,30]],[[12,2,338,6]],[[8,2,339,4]],[[4,2,340,2],[11,2,340,9]],[[8,2,341,4],[81,2,341,77]],[[8,2,342,4],[63,2,342,59]],[[8,2,343,4],[76,2,343,72]],[[8,2,344,4],[76,2,344,72]],[[8,2,345,4],[14,2,345,10],[36,2,345,32],[52,2,345,48]],[[8,2,346,4],[12,2,346,8],[33,2,346,29]],[[12,2,347,6],[19,2,347,13],[22,2,347,16],[23,2,347,17],[33,2,347,27]],[[8,2,348,4]],[[4,2,349,2]],[[0,2,350,0]],[[0,2,352,0],[9,2,352,9],[31,2,352,31],[46,2,352,58]],[[4,2,353,2],[11,2,353,9],[12,2,353,10],[30,2,353,28],[32,2,353,30],[48,2,353,46],[52,2,353,50],[53,2,353,51],[62,2,353,60]],[[0,2,354,0]],[[0,2,356,0],[9,2,356,9],[32,2,357,2],[37,2,357,57],[39,2,358,2],[47,2,358,48]],[[4,2,363,2],[10,2,363,8],[31,2,363,29],[35,2,363,33]],[[4,2,365,2],[9,2,365,7],[15,2,365,13],[16,2,365,14],[26,2,365,24],[32,2,365,30],[36,2,365,34],[42,2,365,41]],[[8,2,366,4],[12,2,366,8],[21,2,366,17],[27,2,366,23]],[[12,2,367,6],[31,2,367,25],[34,2,367,28],[35,2,367,29],[45,2,367,39],[51,2,367,45]],[[8,2,368,4]],[[4,2,369,2]],[[4,2,371,2],[10,2,371,8],[28,2,371,26],[55,2,371,53],[64,2,371,62],[68,2,371,66]],[[4,2,373,2],[9,2,373,7],[15,2,373,13],[16,2,373,14],[26,2,373,24],[32,2,373,30],[36,2,373,34],[45,2,373,44]],[[8,2,374,4],[27,2,374,23],[30,2,374,26],[31,2,374,27],[41,2,374,37],[47,2,374,43]],[[4,2,375,2]],[[4,2,377,2],[11,2,377,9]],[[8,2,377,11]],[[8,2,377,28]],[[4,2,377,47]],[[0,2,378,0]],[[0,2,380,0],[9,2,380,9],[36,2,381,2],[47,2,381,33]],[[4,2,383,2],[10,2,383,8],[28,2,383,26],[32,2,383,30]],[[4,2,385,2],[9,2,385,7],[15,2,385,13],[27,2,385,25],[39,2,385,38]],[[8,2,386,4],[14,2,386,10],[23,2,386,19],[48,2,386,44]],[[8,2,388,4],[15,2,388,12],[22,2,388,19],[26,2,388,23]],[[12,2,389,6],[17,2,389,11]],[[16,2,390,8],[22,2,390,14],[26,2,390,18],[43,2,391,10],[44,2,391,11],[84,2,391,51],[86,2,391,53],[108,2,392,12],[115,2,392,19],[130,2,392,34],[132,2,393,12],[133,2,393,13],[134,2,393,14],[136,2,394,10],[143,2,394,17],[158,2,394,32]],[[12,2,396,6],[17,2,396,11]],[[16,2,397,8],[22,2,397,14],[26,2,397,18],[43,2,398,10],[44,2,398,11],[87,2,398,54],[89,2,398,56],[111,2,399,12],[118,2,399,19],[133,2,399,34],[135,2,400,12],[136,2,400,13],[137,2,400,14],[139,2,401,10],[146,2,401,17],[161,2,401,32]],[[12,2,403,6],[17,2,403,11]],[[16,2,404,8],[21,2,404,13],[27,2,404,19],[47,2,404,39],[54,2,404,46],[69,2,404,61],[70,2,404,63]],[[20,2,405,10],[36,2,405,26],[39,2,405,29],[40,2,405,30]],[[16,2,406,8]],[[16,2,407,8]],[[12,2,408,6],[73,2,408,67]],[[12,2,409,6]],[[16,2,410,8],[26,2,410,18],[34,2,410,26],[35,2,410,27],[44,2,410,38],[45,2,410,39],[66,2,410,60],[68,2,410,62],[76,2,410,70],[82,2,410,76]],[[8,2,411,4]],[[4,2,412,2]],[[4,2,414,2],[11,2,414,9]],[[0,2,415,0]],[[0,2,417,0],[9,2,417,9],[44,2,418,2],[59,2,418,37]],[[4,2,420,2],[10,2,420,8],[40,2,423,8],[42,2,423,10]],[[4,2,424,2],[9,2,424,7],[15,2,424,13],[27,2,424,25],[43,2,424,42]],[[8,2,425,4],[14,2,425,10],[23,2,425,19],[37,2,425,33],[38,2,425,34],[47,2,425,43]],[[8,2,426,4],[14,2,426,10],[25,2,426,21],[40,2,426,36],[43,2,426,39],[44,2,426,40]],[[8,2,427,4],[12,2,427,8],[22,2,427,18],[31,2,427,27],[43,2,427,39],[47,2,427,43],[48,2,427,44],[57,2,427,53],[72,2,427,68],[74,2,427,70]],[[12,2,428,6],[40,2,428,34],[44,2,428,38],[45,2,428,39]],[[16,2,429,8]],[[16,2,430,8],[30,2,430,22],[39,2,430,31],[51,2,430,43]],[[12,2,431,6]],[[8,2,432,4]],[[4,2,433,2]],[[4,2,434,2],[11,2,434,9]],[[0,2,435,0]],[[0,2,437,0]],[],[],[],[[1,2,441,1],[4,2,442,0],[13,2,442,9],[31,2,443,2],[49,2,443,51],[51,2,444,2],[71,2,444,53]],[[4,2,446,2],[9,2,446,7],[15,2,446,13],[16,2,446,14],[27,2,446,25],[42,2,446,40],[46,2,446,44],[65,2,446,64]],[[8,2,447,4],[13,2,447,9],[19,2,447,15],[31,2,447,27],[46,2,447,43]],[[12,2,448,6],[29,2,448,23],[39,2,448,33]],[[8,2,449,4]],[[4,2,450,2]],[[4,2,452,2],[10,2,452,8],[28,2,452,41],[32,2,452,45]],[[4,2,453,2],[9,2,453,7],[15,2,453,13],[16,2,453,14],[27,2,453,25],[42,2,453,40],[46,2,453,44],[67,2,453,66]],[[8,2,454,4],[13,2,454,9],[19,2,454,15],[31,2,454,27],[46,2,454,43]],[[12,2,455,6],[16,2,455,10],[38,2,455,32],[48,2,455,42],[60,2,455,54]],[[16,2,456,8],[32,2,456,24],[35,2,456,27],[36,2,456,28]],[[12,2,457,6]],[[8,2,458,4]],[[4,2,459,2]],[[4,2,461,2],[11,2,461,9]],[[8,2,461,11]],[[4,2,461,27]],[[0,2,462,0]],[[0,2,464,0],[9,2,464,9],[22,2,465,2],[37,2,465,37],[39,2,466,2],[54,2,466,37]],[[4,2,468,2],[9,2,468,7],[15,2,468,13],[27,2,468,25],[43,2,468,42]],[[8,2,469,4],[22,2,469,18],[32,2,469,28]],[[4,2,470,2]],[[4,2,472,2],[9,2,472,7],[15,2,472,13],[27,2,472,25],[43,2,472,42]],[[8,2,473,4],[22,2,473,18],[32,2,473,28]],[[4,2,474,2]],[[4,2,476,2],[65,2,476,63]],[[4,2,477,2],[78,2,477,76]],[[4,2,478,2],[10,2,478,8],[34,2,478,32],[38,2,478,36]],[[4,2,479,2],[9,2,479,7],[15,2,479,13],[27,2,479,25],[43,2,479,42]],[[8,2,480,4],[14,2,480,10],[26,2,480,22],[40,2,480,36],[41,2,480,37],[50,2,480,46]],[[8,2,481,4],[30,2,481,26],[33,2,481,29],[34,2,481,30],[44,2,481,40],[55,2,481,51]],[[8,2,482,4],[15,2,482,11],[29,2,482,25],[30,2,482,26],[39,2,482,35]],[[4,2,483,2]],[[4,2,485,2],[75,2,485,73]],[[4,2,486,2],[16,2,486,14]],[[4,2,488,2],[11,2,488,9]],[[8,2,488,11]],[[4,2,488,33]],[[0,2,489,0]],[[0,2,491,0]],[],[],[],[],[],[],[],[],[],[],[],[[1,2,503,1],[4,2,504,0],[13,2,504,9],[27,2,504,23],[35,2,504,41],[37,2,504,43],[41,2,504,68]],[[4,2,505,2],[10,2,505,8],[19,2,505,17],[33,2,505,31],[34,2,505,32],[43,2,505,41]],[[4,2,506,2],[8,2,506,6],[9,2,506,7],[17,2,506,15]],[[8,2,507,4]],[[4,2,508,2]],[[4,2,510,2],[10,2,510,8],[21,2,510,19],[36,2,510,34],[39,2,510,37],[40,2,510,38]],[[4,2,511,2],[10,2,511,8],[17,2,511,15],[18,2,511,16]],[[4,2,513,2],[71,2,513,69]],[[4,2,514,2],[25,2,514,23]],[[4,2,515,2],[9,2,515,7],[15,2,515,13],[33,2,515,31],[42,2,515,40],[57,2,515,55],[58,2,515,57]],[[8,2,516,4],[23,2,516,19]],[[4,2,517,2]],[[4,2,519,2],[78,2,519,76]],[[4,2,520,2],[47,2,520,45]],[[4,2,521,2],[11,2,521,9],[14,2,521,12],[15,2,521,13],[21,2,521,19],[24,2,521,22]],[[4,2,523,2],[19,2,523,17],[25,2,523,23],[26,2,523,24]],[[4,2,525,2],[74,2,525,72]],[[4,2,527,2],[66,2,527,64]],[[4,2,528,2],[76,2,528,74]],[[4,2,529,2],[22,2,529,20]],[[4,2,530,2],[9,2,530,7],[15,2,530,13],[26,2,530,24],[33,2,530,31],[41,2,530,39],[42,2,530,41]],[[8,2,531,4],[14,2,531,10],[22,2,531,18],[36,2,531,32],[37,2,531,33],[45,2,531,41]],[[8,2,532,4],[12,2,532,8],[13,2,532,9],[20,2,532,16]],[[12,2,533,6]],[[8,2,534,4]],[[8,2,536,4],[14,2,536,10],[20,2,536,16],[26,2,536,22],[33,2,536,29],[34,2,536,30],[41,2,536,37],[42,2,536,38],[49,2,536,45],[51,2,536,47]],[[8,2,537,4],[12,2,537,8],[19,2,537,15],[22,2,537,18]],[[12,2,538,6],[18,2,538,12],[25,2,538,19],[26,2,538,20],[32,2,538,26],[33,2,538,27],[38,2,538,32]],[[8,2,539,4]],[[4,2,540,2]],[[4,2,542,2],[11,2,542,10]],[[8,2,543,4],[13,2,543,9]],[[12,2,544,6],[19,2,544,13],[33,2,544,27],[34,2,544,28],[41,2,544,35],[43,2,544,37],[44,2,544,38]],[[12,2,545,6],[26,2,545,20],[32,2,545,26],[33,2,545,27],[40,2,545,34],[42,2,545,36]],[[12,2,546,6]],[[8,2,547,4],[13,2,547,9]],[[12,2,548,6],[26,2,548,20],[29,2,548,23],[30,2,548,24],[37,2,548,31],[39,2,548,33],[41,2,548,35]],[[12,2,549,6]],[[8,2,550,4]],[[12,2,551,6],[22,2,551,16],[28,2,551,22],[29,2,551,23],[36,2,551,32],[37,2,551,33],[51,2,551,47],[53,2,551,49],[59,2,551,55]],[[4,2,552,2]],[[0,2,553,0]],[[0,2,555,0],[9,2,555,9],[20,2,556,2],[47,2,559,5],[49,2,560,2],[67,2,560,50],[69,2,561,2],[90,2,561,55],[92,2,562,2],[103,2,562,33]],[[4,2,564,2],[31,2,564,29]],[[4,2,565,2],[9,2,565,7],[15,2,565,13],[16,2,565,14],[26,2,565,24],[34,2,565,32],[38,2,565,36],[57,2,565,55],[64,2,565,62],[67,2,565,66]],[[8,2,566,4],[31,2,566,27]],[[8,2,567,4],[24,2,567,20],[27,2,567,23],[28,2,567,24],[38,2,567,34]],[[4,2,568,2]],[[4,2,570,2],[52,2,570,50]],[[4,2,572,2],[76,2,572,74]],[[4,2,574,2],[57,2,574,55]],[[4,2,575,2],[9,2,575,7],[15,2,575,13],[17,2,575,15],[25,2,575,23],[27,2,575,25],[39,2,575,37],[41,2,575,39],[45,2,575,43],[73,2,575,72]],[[8,2,576,4],[12,2,576,8]],[[12,2,577,6],[30,2,578,8],[40,2,579,8],[51,2,579,19],[57,2,579,25],[59,2,580,8],[81,2,580,30],[84,2,580,33],[85,2,580,34]],[[8,2,582,4],[10,2,582,6],[17,2,582,13],[22,2,582,18]],[[12,2,583,6],[16,2,583,10],[23,2,583,17],[40,2,583,34],[52,2,583,46]],[[16,2,584,8],[20,2,584,12]],[[20,2,585,10],[33,2,585,23],[38,2,585,28]],[[24,2,585,30]],[[24,2,585,40],[32,2,585,48],[46,2,585,62],[47,2,585,63],[56,2,585,72]],[[20,2,585,73]],[[16,2,586,8],[18,2,586,10],[25,2,586,17],[31,2,586,23]],[[20,2,587,10],[32,2,587,22]],[[20,2,588,10],[32,2,588,22]],[[16,2,589,8]],[[12,2,590,6],[19,2,590,13]],[[16,2,591,8],[28,2,591,20]],[[12,2,592,6]],[[8,2,593,4]],[[4,2,594,2]],[[0,2,595,0]],[[0,2,597,0],[9,2,597,9],[21,2,597,21],[27,2,597,42]],[[4,2,598,2],[11,2,598,10],[18,2,598,17],[22,2,598,21]],[[8,2,599,4],[13,2,599,9]],[[12,2,600,6],[33,2,600,27]],[[12,2,601,6]],[[8,2,602,4]],[[12,2,603,6],[22,2,603,16],[30,2,603,24],[31,2,603,25],[40,2,603,36],[41,2,603,37],[62,2,603,58],[64,2,603,60],[71,2,603,67],[75,2,603,71],[77,2,603,73]],[[4,2,604,2]],[[0,2,605,0]],[[0,2,607,0],[9,2,607,9],[30,2,607,30],[36,2,607,53]],[[4,2,608,2],[8,2,608,6],[15,2,608,13],[21,2,608,19],[25,2,608,23],[31,2,608,29]],[[8,2,609,4],[13,2,609,9],[19,2,609,15],[29,2,609,25],[36,2,609,32],[42,2,609,38],[43,2,609,40]],[[12,2,610,6],[19,2,610,14],[26,2,610,21],[30,2,610,25]],[[16,2,611,8],[21,2,611,13]],[[20,2,612,10],[48,2,612,38]],[[20,2,613,10]],[[16,2,614,8]],[[20,2,615,10],[30,2,615,20],[38,2,615,28],[39,2,615,29],[48,2,615,40],[49,2,615,41],[70,2,615,62],[72,2,615,64],[79,2,615,71],[83,2,615,75],[85,2,615,77]],[[12,2,616,6]],[[8,2,617,4]],[[4,2,618,2]],[[4,2,620,2],[8,2,620,6],[15,2,620,13],[21,2,620,19],[25,2,620,23],[31,2,620,29]],[[8,2,621,4],[13,2,621,9],[19,2,621,15],[20,2,621,16],[31,2,621,27],[43,2,621,39],[47,2,621,43],[54,2,621,50],[61,2,621,57],[62,2,622,6],[69,2,622,13],[75,2,622,19],[77,2,623,42]],[[12,2,624,6],[18,2,624,12],[29,2,624,23],[49,2,624,43]],[[12,2,626,6],[19,2,626,14],[31,2,626,26],[35,2,626,30]],[[16,2,627,8],[21,2,627,13]],[[20,2,628,10],[28,2,628,18],[43,2,628,33],[44,2,628,34],[55,2,628,45],[61,2,628,51],[63,2,628,53]],[[20,2,629,10]],[[16,2,630,8],[21,2,630,13]],[[20,2,631,10],[32,2,631,22],[43,2,631,33],[46,2,631,36]],[[20,2,632,10]],[[16,2,633,8],[21,2,633,13]],[[20,2,634,10],[32,2,634,22],[43,2,634,33],[46,2,634,36]],[[20,2,635,10]],[[16,2,636,8],[21,2,636,13]],[[20,2,637,10],[30,2,638,12],[42,2,638,24],[53,2,638,35],[55,2,639,12],[56,2,639,13],[70,2,640,14],[71,2,640,15],[100,2,640,44],[102,2,640,46],[107,2,640,51],[116,2,640,60],[117,2,640,61],[130,2,640,74],[131,2,640,75],[132,2,640,76]],[[20,2,642,10]],[[16,2,643,8]],[[20,2,644,10],[30,2,645,12],[43,2,646,12],[44,2,646,13],[58,2,646,29],[59,2,646,30],[86,2,646,57],[88,2,646,59],[100,2,646,71],[104,2,646,75],[106,2,646,77]],[[12,2,648,6]],[[8,2,649,4]],[[4,2,650,2]],[[0,2,651,0]],[[0,2,653,0],[9,2,653,9],[37,2,653,37],[43,2,653,67]],[[4,2,654,2],[10,2,654,8],[12,2,654,10],[22,2,654,20],[23,2,654,21],[24,2,654,22],[26,2,654,24],[35,2,654,33],[36,2,654,34],[37,2,654,35],[39,2,654,37],[42,2,654,40]],[[4,2,655,2],[10,2,655,8],[12,2,655,10],[17,2,655,15],[19,2,655,17],[27,2,655,25],[29,2,655,27],[40,2,655,38],[42,2,655,40],[55,2,655,53],[57,2,655,55],[60,2,655,58],[82,2,656,4],[91,2,657,4]],[[4,2,659,2],[10,2,659,8],[12,2,659,10],[27,2,659,25],[29,2,659,27],[47,2,659,45],[49,2,659,47],[52,2,659,50],[75,2,660,4],[82,2,661,4]],[[4,2,663,2],[10,2,663,8],[12,2,663,10],[27,2,663,25],[29,2,663,27],[32,2,663,30],[50,2,663,48],[63,2,663,61]],[[4,2,665,2],[18,2,665,16],[35,2,665,33],[52,2,665,50]],[[0,2,666,0]],[[0,2,668,0],[9,2,668,9],[33,2,668,33],[48,2,668,63]],[[4,2,669,2],[8,2,669,6],[33,2,669,31],[37,2,669,35],[40,2,669,38],[43,2,669,41]],[[8,2,670,4],[35,2,670,31],[61,2,670,57],[68,2,670,64],[69,2,670,65],[70,2,670,66]],[[12,2,671,6],[28,2,671,22],[31,2,671,25],[32,2,671,26]],[[8,2,672,4]],[[8,2,674,4],[33,2,674,29],[38,2,674,34]],[[4,2,675,2]],[[4,2,677,2],[11,2,677,9]],[[0,2,678,0]],[[0,2,680,0],[9,2,680,9],[23,2,681,2],[38,2,681,32],[40,2,682,2],[55,2,682,37],[57,2,683,2],[75,2,683,50]],[[4,2,685,2],[22,2,685,20],[46,2,685,44]],[[4,2,687,2],[10,2,687,8],[40,2,688,4],[75,2,688,39]],[[4,2,690,2],[10,2,690,8],[12,2,690,10],[33,2,690,31],[35,2,690,33],[38,2,690,36],[51,2,691,4],[68,2,692,4]],[[4,2,695,2],[96,2,695,94]],[[4,2,696,2],[8,2,696,6]],[[4,2,698,2],[13,2,698,11],[25,2,698,23],[28,2,698,31]],[[8,2,699,4],[12,2,699,8],[13,2,699,9],[20,2,699,16],[28,2,699,24]],[[4,2,700,2]],[[4,2,702,2],[15,2,703,4],[44,2,704,4],[64,2,705,4],[87,2,706,4]],[[4,2,709,2],[8,2,709,6],[15,2,709,13]],[[8,2,710,4],[14,2,710,10]],[[4,2,711,2]],[[4,2,713,2],[8,2,713,6],[33,2,713,31],[37,2,713,35],[40,2,713,38],[43,2,713,41]],[[8,2,714,4],[22,2,714,18],[26,2,714,22],[33,2,714,29],[35,2,714,31],[37,2,714,33],[41,2,714,37]],[[4,2,715,2]],[[0,2,716,0]],[[0,2,718,0],[9,2,718,9],[31,2,719,2],[38,2,719,50],[40,2,720,2],[47,2,720,57]],[[4,2,728,2],[10,2,728,8],[24,2,728,22],[28,2,728,26]],[[4,2,729,2],[10,2,729,8],[26,2,729,24],[30,2,729,28]],[[4,2,730,2],[10,2,730,8],[18,2,730,54],[22,2,730,58]],[[4,2,731,2],[10,2,731,8],[21,2,731,19],[25,2,731,23]],[[4,2,732,2],[10,2,732,8],[20,2,732,33],[24,2,732,37]],[[4,2,734,2],[9,2,734,7],[15,2,734,13],[16,2,734,14],[27,2,734,25],[45,2,734,43],[49,2,734,47],[56,2,734,54],[63,2,734,61],[64,2,734,62],[73,2,736,5]],[[8,2,737,4],[15,2,737,12],[33,2,737,30],[37,2,737,34]],[[12,2,738,6],[17,2,738,11]],[[16,2,738,20]],[[20,2,739,8],[26,2,739,14],[40,2,739,28],[44,2,739,32],[48,2,739,36],[66,2,739,54],[73,2,739,61]],[[20,2,740,8],[25,2,740,13],[31,2,740,19],[43,2,740,31],[55,2,740,44]],[[24,2,741,10],[30,2,741,16],[33,2,741,19],[34,2,741,20],[44,2,741,30],[51,2,741,37],[52,2,741,38],[61,2,741,47]],[[20,2,742,8]],[[20,2,743,8],[32,2,743,20],[35,2,743,23],[36,2,743,24],[47,2,743,35]],[[20,2,744,8]],[[16,2,745,6]],[[12,2,746,6],[17,2,746,11]],[[16,2,746,22]],[[20,2,747,8],[74,2,747,62]],[[20,2,748,8],[26,2,748,14],[42,2,748,30],[46,2,748,34],[50,2,748,38],[66,2,748,54],[69,2,748,57],[70,2,748,58]],[[20,2,749,8],[25,2,749,13],[31,2,749,19],[43,2,749,31],[57,2,749,46]],[[24,2,750,10],[32,2,750,18],[35,2,750,21],[36,2,750,22]],[[20,2,751,8]],[[20,2,752,8],[34,2,752,22],[37,2,752,25],[38,2,752,26],[49,2,752,37]],[[20,2,753,8]],[[16,2,754,6]],[[12,2,755,6],[17,2,755,11]],[[16,2,755,22]],[[20,2,756,8],[26,2,756,14],[40,2,756,28],[44,2,756,32],[48,2,756,36],[66,2,756,54],[71,2,756,59]],[[20,2,757,8],[26,2,757,14],[42,2,757,30],[46,2,757,34],[50,2,757,38],[68,2,757,56],[75,2,757,63]],[[20,2,758,8],[25,2,758,13],[31,2,758,19],[43,2,758,31],[55,2,758,44]],[[24,2,759,10],[30,2,759,16],[33,2,759,19],[34,2,759,20],[44,2,759,30],[51,2,759,37],[52,2,759,38],[61,2,759,47]],[[20,2,760,8]],[[20,2,761,8],[25,2,761,13],[31,2,761,19],[43,2,761,31],[57,2,761,46]],[[24,2,762,10],[32,2,762,18],[35,2,762,21],[36,2,762,22]],[[20,2,763,8]],[[20,2,764,8],[32,2,764,20],[35,2,764,23],[36,2,764,24],[47,2,764,35]],[[20,2,765,8],[34,2,765,22],[37,2,765,25],[38,2,765,26],[49,2,765,37]],[[20,2,766,8]],[[16,2,767,6]],[[12,2,768,6]],[[16,2,769,8],[26,2,770,10],[45,2,771,10],[46,2,771,11],[66,2,772,12],[67,2,772,13],[101,2,772,47],[103,2,772,49],[121,2,772,67],[125,2,772,71],[127,2,772,73]],[[8,2,774,4]],[[4,2,775,2]],[[4,2,777,2],[88,2,777,86]],[[4,2,778,2],[93,2,778,91]],[[4,2,779,2],[43,2,779,41]],[[4,2,780,2],[9,2,780,7],[15,2,780,13],[27,2,780,25],[33,2,780,31],[37,2,780,35],[40,2,780,39]],[[8,2,781,4],[12,2,781,8],[20,2,781,16],[23,2,781,19],[24,2,781,20],[35,2,781,31]],[[12,2,782,6],[18,2,782,12],[24,2,782,18],[25,2,782,19]],[[12,2,783,6],[20,2,783,14],[26,2,783,20],[27,2,783,21]],[[8,2,784,4]],[[4,2,785,2]],[[4,2,787,2],[9,2,787,7],[15,2,787,13],[16,2,787,14],[26,2,787,24],[32,2,787,30],[36,2,787,34],[43,2,787,41],[50,2,787,48],[51,2,787,49],[60,2,787,59]],[[8,2,788,4],[88,2,788,84]],[[8,2,789,4],[26,2,789,22]],[[8,2,790,4],[88,2,790,84]],[[8,2,791,4],[58,2,791,54]],[[8,2,792,4],[12,2,792,8],[13,2,792,9],[19,2,792,15],[22,2,792,18],[23,2,792,19],[34,2,792,30]],[[12,2,793,6],[21,2,793,15],[24,2,793,18],[25,2,793,19],[35,2,793,29]],[[8,2,794,4]],[[4,2,795,2]],[[4,2,797,2],[11,2,797,9]],[[8,2,797,11]],[[8,2,797,18]],[[8,2,797,27]],[[8,2,797,37]],[[8,2,797,50]],[[4,2,797,64]],[[0,2,798,0]],[[0,2,816,0],[9,2,816,9],[34,2,816,34],[42,2,816,52]],[[4,2,817,2],[10,2,817,8],[28,2,817,41],[32,2,817,45]],[[4,2,821,2],[10,2,821,8],[18,2,821,29]],[[8,2,822,4]],[[12,2,823,6]],[[12,2,824,6],[29,2,824,23],[31,2,824,25]],[[8,2,825,4]],[[5,2,826,3]],[[4,2,828,2],[8,2,828,6]],[[4,2,829,2],[10,2,829,10],[21,2,829,21],[27,2,829,27],[32,2,829,32],[35,2,829,37]],[[8,2,830,4],[14,2,830,10],[16,2,830,12],[24,2,830,20],[26,2,830,22],[41,2,830,37],[43,2,830,39],[46,2,830,42]],[[8,2,832,4],[12,2,832,8],[24,2,832,20],[30,2,832,26]],[[12,2,833,6],[16,2,833,10],[32,2,833,26],[35,2,833,29],[36,2,833,30],[47,2,833,41]],[[16,2,835,8]],[[12,2,836,6]],[[12,2,838,6],[28,2,838,22],[31,2,838,25],[32,2,838,26]],[[8,2,839,4]],[[8,2,841,4],[78,2,841,74]],[[8,2,842,4],[45,2,842,41]],[[8,2,843,4],[12,2,843,8],[25,2,843,21],[36,2,843,32]],[[12,2,844,6],[19,2,844,13]],[[16,2,845,8],[22,2,845,14]],[[16,2,846,8]],[[12,2,847,6]],[[8,2,848,4]],[[8,2,850,4],[14,2,850,10],[23,2,850,19],[37,2,850,33],[38,2,850,34],[47,2,850,43]],[[8,2,851,4],[14,2,851,10],[25,2,851,21],[40,2,851,36],[43,2,851,39],[44,2,851,40]],[[8,2,853,4],[12,2,854,6],[81,2,854,75]],[[8,2,855,6],[66,2,855,64]],[[8,2,856,6],[9,2,856,7],[19,2,858,7],[28,2,858,16],[40,2,858,28],[44,2,858,32],[45,2,858,33],[54,2,858,42],[69,2,858,57],[71,2,859,6]],[[12,2,860,6]],[[8,2,861,4]],[[8,2,863,4],[12,2,863,8],[21,2,863,17],[33,2,863,29],[35,2,863,31]],[[12,2,864,6],[19,2,864,13]],[[16,2,865,8],[22,2,865,14]],[[16,2,866,8]],[[16,2,867,8]],[[12,2,868,6]],[[8,2,869,4]],[[8,2,871,4],[12,2,871,8],[27,2,871,23],[30,2,871,26],[31,2,871,27],[42,2,871,38]],[[12,2,872,6],[18,2,872,12],[22,2,872,16],[23,2,872,17]],[[16,2,873,8],[26,2,873,18]],[[16,2,874,8],[33,2,874,25]],[[23,2,874,29]],[[20,2,874,46]],[[17,2,874,55]],[[12,2,875,6]],[[12,2,876,6]],[[8,2,877,4]],[[8,2,879,4],[13,2,879,9],[19,2,879,15],[31,2,879,27],[38,2,879,34],[45,2,879,41],[46,2,879,43]],[[12,2,880,6],[18,2,880,12],[27,2,880,21],[41,2,880,35],[42,2,880,36],[51,2,880,45]],[[12,2,882,6],[16,2,882,10],[17,2,882,11],[25,2,882,19]],[[16,2,884,8]],[[12,2,885,6]],[[12,2,887,6],[72,2,887,66]],[[12,2,888,6],[33,2,888,27]],[[12,2,890,6],[18,2,890,12],[22,2,890,16],[23,2,890,17]],[[16,2,891,8],[26,2,891,18]],[[16,2,892,8],[33,2,892,25]],[[23,2,892,29]],[[20,2,892,46]],[[17,2,892,55]],[[12,2,893,6]],[[8,2,894,4]],[[4,2,895,2]],[[4,2,897,2],[11,2,897,9]],[[8,2,898,4],[14,2,898,10]],[[8,2,899,4]],[[8,2,900,4]],[[4,2,901,2]],[[0,2,902,0]],[[0,2,904,0],[9,2,904,9],[21,2,904,21],[34,2,904,49],[36,2,904,51],[42,2,904,72]],[[4,2,905,2],[11,2,905,10],[18,2,905,17],[22,2,905,21]],[[8,2,906,4],[13,2,906,9]],[[12,2,906,20]],[[16,2,907,6],[108,2,907,98]],[[16,2,908,6],[28,2,908,18],[35,2,908,25],[46,2,908,36]],[[16,2,909,6]],[[12,2,910,4]],[[8,2,911,4],[13,2,911,9]],[[12,2,911,20]],[[16,2,912,6],[81,2,912,71]],[[16,2,913,6],[85,2,913,75]],[[16,2,914,6],[29,2,914,19]],[[16,2,915,6],[28,2,915,18],[35,2,915,25]],[[16,2,916,6]],[[12,2,917,4]],[[8,2,918,4],[13,2,918,9]],[[12,2,918,21]],[[16,2,919,6],[127,2,919,117]],[[16,2,920,6],[50,2,920,40]],[[16,2,921,6],[115,2,921,105]],[[16,2,922,6],[77,2,922,67]],[[16,2,923,6],[20,2,923,10],[38,2,923,28],[41,2,923,31],[42,2,923,32],[58,2,923,48]],[[20,2,924,8],[32,2,924,20],[39,2,924,27]],[[16,2,925,6],[23,2,925,13]],[[20,2,926,8],[37,2,926,25]],[[16,2,927,6]],[[16,2,928,6]],[[12,2,929,4]],[[8,2,930,4]],[[12,2,931,6],[18,2,931,12],[22,2,931,16],[28,2,931,22],[29,2,931,23],[50,2,931,44],[52,2,931,46],[59,2,931,53],[63,2,931,57],[65,2,931,59]],[[4,2,932,2]],[[0,2,933,0]],[[0,2,935,0],[9,2,935,9],[25,2,936,2],[33,2,936,20],[35,2,937,2],[42,2,937,18]],[[4,2,939,2],[10,2,939,8],[21,2,939,29]],[[8,2,940,4],[22,2,940,18]],[[8,2,941,4],[22,2,941,18]],[[8,2,942,4],[25,2,942,21]],[[8,2,943,4],[25,2,943,21],[27,2,943,23]],[[4,2,944,2]],[[4,2,946,2],[10,2,946,8],[16,2,946,19]],[[8,2,947,4],[77,2,947,73]],[[8,2,948,4],[80,2,948,76]],[[8,2,949,4],[47,2,949,43]],[[8,2,950,4],[16,2,950,12]],[[8,2,952,4],[14,2,952,10],[25,2,952,21],[26,2,952,22]],[[8,2,954,4],[75,2,954,71]],[[8,2,955,4],[16,2,955,12],[17,2,956,6],[26,2,957,6],[37,2,958,6]],[[12,2,960,6],[16,2,960,10],[28,2,960,22],[39,2,960,33]],[[16,2,961,8],[25,2,961,17],[37,2,961,29],[40,2,961,32]],[[12,2,962,6],[19,2,962,13],[23,2,962,17],[30,2,962,24],[42,2,962,36],[54,2,962,48]],[[16,2,963,8],[25,2,963,17],[37,2,963,29],[40,2,963,32]],[[12,2,964,6],[19,2,964,13]],[[16,2,965,8],[22,2,965,14],[26,2,965,18],[32,2,965,24]],[[12,2,966,6]],[[8,2,967,4]],[[8,2,969,4],[17,2,969,13],[18,2,969,14]],[[12,2,970,6],[16,2,970,10],[24,2,970,18],[35,2,970,29]],[[16,2,971,8],[25,2,971,17],[37,2,971,29],[40,2,971,32]],[[12,2,972,6],[19,2,972,13]],[[16,2,973,8],[22,2,973,14],[26,2,973,18],[32,2,973,24]],[[12,2,974,6]],[[8,2,975,4]],[[8,2,977,4],[17,2,977,13],[18,2,977,14]],[[12,2,978,6],[21,2,978,15],[36,2,978,30],[37,2,978,31],[41,2,978,35],[42,2,978,36]],[[8,2,979,4]],[[8,2,981,4],[27,2,981,23],[28,2,981,24]],[[12,2,982,6],[21,2,982,15],[36,2,982,30],[37,2,982,31],[41,2,982,35],[42,2,982,36]],[[8,2,983,4]],[[8,2,985,4],[30,2,985,26],[31,2,985,27]],[[12,2,986,6],[18,2,986,12],[24,2,986,18],[33,2,986,27],[48,2,986,42],[49,2,986,43],[56,2,986,50],[57,2,986,51]],[[12,2,987,6],[16,2,987,10],[23,2,987,17],[26,2,987,20]],[[16,2,988,8],[25,2,988,17],[40,2,988,32],[41,2,988,33],[47,2,988,39],[48,2,988,40],[53,2,988,45]],[[12,2,989,6]],[[8,2,990,4]],[[8,2,992,4],[20,2,992,16]],[[12,2,993,6],[21,2,993,15],[36,2,993,30],[39,2,993,33]],[[12,2,994,6],[37,2,994,31],[40,2,994,34],[41,2,994,35]],[[8,2,995,4]],[[8,2,997,4],[77,2,997,73]],[[8,2,998,4],[79,2,998,75]],[[8,2,999,4],[41,2,999,37]],[[8,2,1000,4],[16,2,1000,12],[20,2,1000,18]],[[8,2,1002,4],[83,2,1002,79]],[[8,2,1003,4],[26,2,1003,22],[27,2,1003,23],[39,2,1003,37]],[[8,2,1004,4],[29,2,1004,25],[30,2,1004,26],[42,2,1004,40]],[[8,2,1006,4],[83,2,1006,79]],[[8,2,1007,4],[81,2,1007,77]],[[8,2,1008,4],[25,2,1008,21]],[[8,2,1009,4],[15,2,1009,11],[19,2,1009,17],[27,2,1009,25],[34,2,1009,32],[35,2,1009,33]],[[4,2,1010,2]],[[4,2,1012,2],[11,2,1012,9]],[[8,2,1012,11]],[[8,2,1012,16]],[[4,2,1012,25]],[[0,2,1013,0]],[[0,2,1015,0]],[],[],[[1,2,1018,1],[4,2,1019,0],[13,2,1019,9],[35,2,1020,2],[43,2,1020,20],[45,2,1021,2],[54,2,1021,22]],[[4,2,1023,2],[10,2,1023,8],[25,2,1023,23],[41,2,1023,39],[44,2,1023,42],[45,2,1023,43]],[[4,2,1024,2],[17,2,1024,15],[23,2,1024,21],[24,2,1024,22]],[[4,2,1026,2],[10,2,1026,8],[25,2,1026,23],[41,2,1026,39],[44,2,1026,42],[45,2,1026,43]],[[4,2,1027,2],[17,2,1027,15],[23,2,1027,21],[24,2,1027,22]],[[4,2,1029,2],[10,2,1029,8],[31,2,1029,29],[44,2,1029,42],[48,2,1029,46],[53,2,1029,51]],[[4,2,1030,2],[8,2,1030,6],[28,2,1030,26]],[[8,2,1031,4],[24,2,1031,20],[30,2,1031,26],[31,2,1031,27]],[[4,2,1032,2]],[[4,2,1034,2],[10,2,1034,8],[30,2,1034,28],[43,2,1034,41],[47,2,1034,45],[52,2,1034,50]],[[4,2,1035,2],[8,2,1035,6],[27,2,1035,25]],[[8,2,1036,4],[24,2,1036,20],[30,2,1036,26],[31,2,1036,27]],[[4,2,1037,2]],[[4,2,1039,2],[11,2,1039,9]],[[0,2,1040,0]],[[0,2,1042,0]],[],[[1,2,1044,1],[4,2,1045,0],[13,2,1045,9],[30,2,1045,26],[43,2,1045,54]],[[4,2,1046,2],[10,2,1046,8],[23,2,1046,21],[42,2,1046,40],[45,2,1046,43],[46,2,1046,44]],[[4,2,1047,2],[8,2,1047,6],[22,2,1047,20],[28,2,1047,26]],[[8,2,1048,4],[15,2,1048,11]],[[4,2,1049,2]],[[4,2,1050,2],[23,2,1050,21],[29,2,1050,27],[30,2,1050,28]],[[4,2,1052,2],[9,2,1052,7],[15,2,1052,13],[28,2,1052,26],[39,2,1052,38]],[[8,2,1053,4],[14,2,1053,10],[32,2,1053,28],[51,2,1053,47],[54,2,1053,50],[55,2,1053,51]],[[8,2,1054,4],[24,2,1054,20],[30,2,1054,26],[31,2,1054,27]],[[8,2,1056,4],[12,2,1056,8],[28,2,1056,24],[32,2,1056,28],[37,2,1056,33],[40,2,1056,36]],[[12,2,1057,6],[31,2,1057,25],[37,2,1057,31],[38,2,1057,32]],[[12,2,1058,6],[25,2,1058,19]],[[8,2,1059,4]],[[4,2,1060,2]],[[4,2,1062,2],[77,2,1062,75]],[[4,2,1063,2],[42,2,1063,40]],[[4,2,1064,2],[10,2,1064,8],[25,2,1064,23],[45,2,1064,43]],[[4,2,1066,2],[16,2,1066,14],[27,2,1066,25],[30,2,1066,28]],[[4,2,1068,2],[11,2,1068,9]],[[0,2,1069,0]],[[0,2,1071,0]],[],[],[],[[1,2,1075,1],[4,2,1076,0],[13,2,1076,9],[26,2,1076,22],[35,2,1076,42]],[[4,2,1077,2],[10,2,1077,8],[21,2,1077,19],[41,2,1077,39]],[[4,2,1078,2],[73,2,1078,71]],[[4,2,1079,2],[92,2,1079,90]],[[4,2,1080,2],[16,2,1080,14],[27,2,1080,25],[30,2,1080,28]],[[4,2,1082,2],[10,2,1082,8],[25,2,1082,23],[41,2,1082,39],[44,2,1082,42],[45,2,1082,43]],[[4,2,1083,2],[8,2,1083,6],[24,2,1083,22],[30,2,1083,28]],[[8,2,1084,4],[15,2,1084,11]],[[4,2,1085,2]],[[4,2,1086,2],[17,2,1086,15],[23,2,1086,21],[24,2,1086,22]],[[4,2,1088,2],[9,2,1088,7],[15,2,1088,13],[27,2,1088,25],[40,2,1088,39]],[[8,2,1089,4],[14,2,1089,10],[29,2,1089,25],[45,2,1089,41],[48,2,1089,44],[49,2,1089,45]],[[8,2,1090,4],[21,2,1090,17],[27,2,1090,23],[28,2,1090,24]],[[8,2,1092,4],[14,2,1092,10],[34,2,1092,30],[47,2,1092,43],[51,2,1092,47],[56,2,1092,52]],[[8,2,1093,4],[12,2,1093,8],[31,2,1093,27]],[[12,2,1094,6],[28,2,1094,22],[34,2,1094,28],[35,2,1094,29]],[[12,2,1095,6],[26,2,1095,20],[36,2,1095,30]],[[12,2,1096,6],[29,2,1096,23],[35,2,1096,29],[36,2,1096,30]],[[8,2,1097,4]],[[4,2,1098,2]],[[4,2,1100,2],[11,2,1100,9]],[[0,2,1101,0]],[[0,2,1103,0]],[],[[1,2,1105,1],[4,2,1106,0],[13,2,1106,9],[30,2,1106,26],[38,2,1106,44],[40,2,1106,46],[49,2,1106,66]],[[4,2,1107,2],[8,2,1107,6],[23,2,1107,21],[39,2,1107,37],[42,2,1107,40],[43,2,1107,41]],[[4,2,1108,2],[8,2,1108,6],[9,2,1108,7],[23,2,1108,21]],[[8,2,1109,4],[23,2,1109,19],[27,2,1109,23],[31,2,1109,27]],[[12,2,1109,28]],[[9,2,1109,38]],[[8,2,1110,4],[24,2,1110,20],[27,2,1110,23],[28,2,1110,24],[38,2,1110,34]],[[4,2,1111,2],[11,2,1111,9]],[[8,2,1112,4],[21,2,1112,17],[24,2,1112,20],[25,2,1112,21]],[[4,2,1113,2]],[[4,2,1115,2],[8,2,1115,6],[23,2,1115,21],[39,2,1115,37],[42,2,1115,40],[43,2,1115,41]],[[4,2,1116,2],[8,2,1116,6],[9,2,1116,7],[23,2,1116,21]],[[8,2,1117,4],[23,2,1117,19],[27,2,1117,23],[31,2,1117,27]],[[12,2,1117,28]],[[9,2,1117,37]],[[8,2,1118,4],[24,2,1118,20],[27,2,1118,23],[28,2,1118,24],[39,2,1118,35]],[[4,2,1119,2],[11,2,1119,9]],[[8,2,1120,4],[21,2,1120,17],[24,2,1120,20],[25,2,1120,21]],[[4,2,1121,2]],[[0,2,1122,0]],[[0,2,1124,0]],[],[],[],[[1,2,1128,1],[4,2,1129,0],[13,2,1129,9],[36,2,1129,32],[49,2,1129,60]],[[4,2,1130,2],[22,2,1130,20],[25,2,1130,23],[26,2,1130,24]],[[0,2,1131,0]],[[0,2,1133,0],[9,2,1133,9],[23,2,1133,23],[35,2,1133,54]],[[4,2,1134,2],[10,2,1134,8],[22,2,1134,20],[40,2,1134,38],[52,2,1134,50],[53,2,1134,51],[55,2,1134,53]],[[4,2,1135,2],[8,2,1135,6]],[[4,2,1136,2],[114,2,1136,112]],[[4,2,1137,2],[8,2,1137,6],[21,2,1137,19],[27,2,1137,25],[32,2,1137,30],[35,2,1137,33]],[[8,2,1138,4],[24,2,1138,20],[36,2,1138,32],[37,2,1138,33],[39,2,1138,35]],[[4,2,1139,2],[11,2,1139,9]],[[8,2,1140,4],[24,2,1140,20]],[[8,2,1141,4],[41,2,1142,6],[55,2,1143,6],[66,2,1143,17],[69,2,1143,20],[72,2,1144,6],[89,2,1145,6],[90,2,1145,7],[95,2,1145,24],[112,2,1145,41],[116,2,1145,45]],[[4,2,1147,2]],[[4,2,1148,2],[11,2,1148,9],[19,2,1148,17],[32,2,1148,30],[33,2,1148,31],[44,2,1148,42]],[[0,2,1149,0]],[[0,2,1151,0]],[],[[1,2,1153,1],[4,2,1154,0],[13,2,1154,9],[31,2,1154,27],[40,2,1154,47]],[[4,2,1155,2],[10,2,1155,8],[28,2,1155,26],[38,2,1155,36],[44,2,1155,42]],[[4,2,1156,2],[10,2,1156,8],[26,2,1156,24],[44,2,1156,42]],[[4,2,1157,2],[74,2,1157,72]],[[4,2,1158,2],[12,2,1158,10],[25,2,1158,23],[26,2,1158,24]],[[4,2,1159,2],[15,2,1159,13],[47,2,1159,45],[48,2,1159,47],[52,2,1159,51],[53,2,1159,52]],[[8,2,1160,4]],[[8,2,1161,4],[20,2,1161,16],[24,2,1161,20],[25,2,1161,21],[31,2,1161,27]],[[5,2,1162,3]],[[4,2,1164,2],[51,2,1164,49]],[[4,2,1165,2],[10,2,1165,8],[23,2,1165,21],[27,2,1165,25],[31,2,1165,29],[41,2,1165,39],[47,2,1165,45],[48,2,1165,46],[51,2,1165,49],[52,2,1165,50]],[[4,2,1166,2],[23,2,1166,21],[26,2,1166,24],[27,2,1166,25],[42,2,1166,40]],[[4,2,1167,2],[9,2,1167,7],[15,2,1167,13],[28,2,1167,26],[39,2,1167,38]],[[8,2,1168,4],[12,2,1168,8],[30,2,1168,26],[49,2,1168,45],[52,2,1168,48],[53,2,1168,49]],[[8,2,1169,4],[12,2,1169,8],[13,2,1169,9],[30,2,1169,26]],[[12,2,1170,6],[30,2,1170,24],[34,2,1170,28],[38,2,1170,32]],[[16,2,1170,33]],[[13,2,1170,47]],[[12,2,1171,6],[31,2,1171,25],[34,2,1171,28],[35,2,1171,29],[46,2,1171,40]],[[8,2,1172,4],[15,2,1172,11]],[[12,2,1173,6],[28,2,1173,22],[31,2,1173,25],[32,2,1173,26]],[[8,2,1174,4]],[[4,2,1175,2]],[[4,2,1177,2],[8,2,1177,6],[18,2,1177,16],[24,2,1177,22],[29,2,1177,27],[38,2,1177,36]],[[8,2,1178,4],[31,2,1178,27]],[[4,2,1179,2]],[[0,2,1180,0]],[[0,2,1182,0],[11,2,1182,11],[43,2,1182,43],[48,2,1182,48],[50,2,1182,50]],[[0,3,0,0]],[],[],[],[],[[1,3,5,1],[4,3,7,0],[56,3,7,52],[59,3,9,0],[129,3,9,70]],[[0,3,10,0],[59,3,10,59]],[[0,3,20,0],[4,3,20,4]],[[0,3,22,0]],[],[[1,3,24,1],[4,3,25,0],[10,3,25,6],[27,3,25,53],[31,3,25,57]],[[0,3,27,1],[1,3,27,2]],[[4,3,28,2],[14,3,28,12]],[[8,3,29,4],[14,3,29,10],[29,3,29,24],[38,3,29,33],[40,3,29,35],[46,3,29,41]],[[12,3,30,6],[18,3,30,12],[29,3,30,23],[49,3,30,43]],[[12,3,32,6],[18,3,32,12],[29,3,32,23],[49,3,32,43]],[[12,3,33,6],[21,3,33,15],[28,3,33,22]],[[12,3,35,6],[16,3,35,10],[26,3,35,20],[32,3,35,26]],[[16,3,36,8]],[[12,3,37,6]],[[12,3,39,6],[17,3,39,11],[23,3,39,17],[41,3,39,35],[48,3,39,42],[59,3,39,53],[60,3,39,55]],[[16,3,40,8],[22,3,40,14],[39,3,40,31],[52,3,40,44]],[[16,3,41,8],[22,3,41,14],[38,3,41,30],[58,3,41,50]],[[16,3,43,8],[97,3,43,89]],[[16,3,44,8],[36,3,44,28]],[[12,3,45,6]],[[12,3,47,6],[94,3,47,88]],[[12,3,48,6],[18,3,48,12],[26,3,48,20],[29,3,48,23],[30,3,49,8],[37,3,49,15],[48,3,49,26],[49,3,49,27],[52,3,49,30],[53,3,49,31],[54,3,49,32],[71,3,50,10],[88,3,50,27],[99,3,50,38]],[[12,3,54,6],[16,3,54,10],[23,3,54,17],[39,3,54,33],[40,3,54,34],[46,3,54,40],[49,3,54,43],[52,3,54,46]],[[16,3,55,8],[21,3,55,13],[27,3,55,19],[39,3,55,31],[46,3,55,38],[62,3,55,54],[63,3,55,56]],[[20,3,56,10],[50,3,56,40],[61,3,56,51]],[[16,3,57,8]],[[12,3,58,6]],[[8,3,59,4]],[[8,3,61,4]],[],[],[[5,3,64,5],[8,3,65,4],[25,3,65,20],[35,3,65,42],[37,3,65,44],[45,3,65,62]],[[12,3,66,6],[19,3,66,13],[31,3,66,25],[43,3,66,37]],[[8,3,67,4]],[[8,3,69,4],[14,3,69,10],[31,3,70,6],[42,3,70,29],[44,3,71,6],[55,3,71,29],[57,3,72,6],[70,3,72,30],[72,3,73,6],[83,3,73,43],[85,3,74,6],[95,3,74,37]],[[12,3,76,6],[18,3,76,12],[24,3,76,18],[41,3,76,35]],[[12,3,78,6],[18,3,78,12],[20,3,78,14],[28,3,78,22],[30,3,78,24],[33,3,78,27],[39,3,78,33],[51,3,78,45],[71,3,78,65],[72,3,79,8],[77,3,80,8]],[[12,3,83,6],[19,3,83,13],[28,3,83,22],[35,3,83,29]],[[8,3,84,4]],[[8,3,86,4],[14,3,86,10],[37,3,87,6],[48,3,87,29],[50,3,88,6],[61,3,88,29],[63,3,89,6],[76,3,89,30],[78,3,90,6],[89,3,90,43]],[[12,3,92,6],[18,3,92,12],[24,3,92,18],[41,3,92,35]],[[12,3,94,6],[19,3,94,13],[25,3,94,19],[37,3,94,31],[53,3,94,47],[54,3,94,48]],[[8,3,95,4]],[[4,3,96,2]],[[4,3,98,2],[13,3,98,11],[33,3,98,31],[41,3,98,49]],[[8,3,99,4],[12,3,99,8],[23,3,99,19],[38,3,99,34],[41,3,99,37],[42,3,99,38]],[[8,3,100,4],[12,3,100,8],[13,3,100,9],[23,3,100,19]],[[12,3,101,6],[16,3,101,10]],[[12,3,102,6],[16,3,102,10]],[[12,3,103,6],[18,3,103,12],[28,3,103,22],[32,3,103,26],[40,3,103,40],[41,3,103,41],[55,3,103,55]],[[16,3,104,8],[26,3,104,18]],[[16,3,105,8],[25,3,105,17]],[[12,3,106,6]],[[12,3,107,6],[23,3,107,17]],[[16,3,108,8],[26,3,108,18]],[[16,3,109,8],[32,3,109,24]],[[16,3,110,8]],[[16,3,111,8],[25,3,111,17]],[[20,3,112,10],[29,3,112,20],[37,3,112,28],[40,3,112,31]],[[20,3,113,10]],[[16,3,114,8]],[[16,3,115,8],[24,3,115,16]],[[12,3,116,6]],[[12,3,117,6],[27,3,117,21],[30,3,117,24],[31,3,117,25],[41,3,117,35]],[[8,3,118,4]],[[8,3,119,4],[15,3,119,11]],[[4,3,120,2]],[[4,3,122,2]],[],[],[[3,3,125,3],[6,3,126,2],[15,3,126,11],[27,3,126,23],[37,3,126,45],[39,3,126,47],[47,3,126,65]],[[8,3,127,4],[14,3,127,10],[25,3,127,21],[45,3,127,41]],[[8,3,128,4],[12,3,128,8],[21,3,128,17],[35,3,128,31],[37,3,128,33]],[[12,3,129,6],[19,3,129,13],[28,3,129,22],[35,3,129,29]],[[8,3,130,4]],[[8,3,132,4],[12,3,132,8],[27,3,132,23],[38,3,132,34],[45,3,132,41],[47,3,132,43]],[[12,3,133,6],[92,3,133,86]],[[12,3,134,6],[34,3,134,28]],[[12,3,135,6],[21,3,135,15],[35,3,135,29],[38,3,135,32]],[[12,3,137,6],[16,3,137,10],[22,3,137,16],[33,3,137,27]],[[16,3,138,8],[87,3,138,79]],[[16,3,139,8],[36,3,139,28]],[[16,3,140,8],[25,3,140,17],[32,3,140,24]],[[12,3,141,6]],[[12,3,143,6],[90,3,143,84]],[[12,3,144,6],[86,3,144,80]],[[12,3,145,6],[51,3,145,45]],[[12,3,147,6],[19,3,147,13],[28,3,147,22],[35,3,147,29]],[[8,3,148,4]],[[8,3,150,4],[12,3,150,8],[19,3,150,15],[37,3,150,33],[49,3,150,45]],[[12,3,151,6],[36,3,151,30]],[[12,3,152,6],[16,3,152,10],[22,3,152,16],[33,3,152,27]],[[12,3,153,8],[21,3,153,17]],[[12,3,154,6],[19,3,154,13],[23,3,154,17],[28,3,154,22],[39,3,154,33]],[[16,3,155,8],[21,3,155,13],[46,3,155,38],[47,3,155,40],[51,3,155,44],[52,3,155,45]],[[16,3,156,8],[30,3,156,22],[58,3,156,50]],[[12,3,157,6],[19,3,157,13]],[[16,3,158,8],[22,3,158,14],[26,3,158,18],[32,3,159,10],[33,3,159,11],[68,3,159,46],[70,3,159,48],[79,3,159,57],[89,3,159,67],[90,3,159,68]],[[12,3,161,6]],[[8,3,162,4],[15,3,162,11]],[[12,3,163,6],[92,3,163,86]],[[12,3,164,6],[18,3,164,12],[36,3,164,30],[46,3,164,40]],[[12,3,166,6],[16,3,166,10],[22,3,166,16],[33,3,166,27]],[[16,3,167,8],[22,3,167,14],[38,3,167,30],[47,3,167,39],[63,3,167,55],[64,3,168,10],[65,3,168,11],[92,3,168,38],[94,3,168,40],[103,3,168,49],[134,3,168,80],[136,3,168,82],[145,3,168,91],[176,3,168,122],[178,3,168,124],[194,3,168,140],[225,3,168,171],[227,3,168,173],[243,3,168,189],[246,3,168,192],[247,3,168,193]],[[16,3,170,8],[20,3,170,12],[34,3,170,26],[40,3,170,32],[43,3,170,35],[46,3,170,38]],[[20,3,171,10],[91,3,171,81]],[[20,3,172,10],[40,3,172,30]],[[20,3,173,10],[29,3,173,19],[36,3,173,26]],[[16,3,174,8],[23,3,174,15]],[[20,3,175,10],[26,3,175,16],[33,3,175,23],[42,3,175,32],[55,3,175,45],[56,3,175,46]],[[20,3,176,10],[25,3,176,15],[28,3,176,18],[31,3,176,21]],[[20,3,177,10],[25,3,177,15],[29,3,177,19],[32,3,177,22]],[[20,3,178,10],[25,3,178,15],[32,3,178,22],[35,3,178,25]],[[24,3,179,12],[33,3,179,21],[39,3,179,27]],[[20,3,180,10]],[[20,3,181,10],[25,3,181,15],[31,3,181,21],[34,3,181,24]],[[24,3,182,12],[95,3,182,83]],[[24,3,183,12],[44,3,183,32]],[[24,3,184,12],[33,3,184,21],[40,3,184,28]],[[20,3,185,10]],[[20,3,186,10],[70,3,186,60]],[[20,3,187,10],[29,3,187,19],[33,3,187,23],[34,3,187,24],[45,3,187,35],[46,3,187,36]],[[16,3,188,8]],[[12,3,189,6],[19,3,189,13],[23,3,189,17],[28,3,189,22],[39,3,189,33]],[[16,3,190,8],[22,3,190,14],[40,3,190,32],[49,3,190,41],[65,3,190,57],[66,3,191,10],[67,3,191,11],[79,3,191,23],[81,3,191,25],[90,3,191,34],[106,3,191,50],[108,3,191,52],[117,3,191,61],[133,3,191,77],[135,3,191,79],[151,3,191,95],[167,3,191,111],[169,3,191,113],[185,3,191,129],[188,3,191,132],[189,3,191,133]],[[16,3,193,8],[20,3,193,12],[36,3,193,28],[42,3,193,34],[45,3,193,37],[48,3,193,40]],[[20,3,194,10],[89,3,194,79]],[[20,3,195,10],[86,3,195,76]],[[20,3,196,10],[25,3,196,15],[31,3,196,21],[41,3,196,31],[47,3,196,37],[51,3,196,41],[52,3,196,42],[69,3,196,60]],[[24,3,197,12],[31,3,197,19],[47,3,197,35],[48,3,197,36],[57,3,197,45]],[[28,3,198,14],[37,3,198,23],[43,3,198,29]],[[24,3,199,12]],[[20,3,200,10]],[[16,3,201,8],[23,3,201,15]],[[20,3,202,10],[26,3,202,16],[35,3,202,25],[44,3,202,34],[57,3,202,47],[58,3,202,48]],[[20,3,203,10],[27,3,203,17],[30,3,203,20],[33,3,203,23]],[[20,3,204,10],[93,3,204,83]],[[20,3,205,10],[92,3,205,82]],[[20,3,206,10],[35,3,206,25]],[[20,3,207,10],[27,3,207,17],[34,3,207,24],[37,3,207,27]],[[24,3,208,12],[33,3,208,21],[39,3,208,27]],[[20,3,209,10]],[[20,3,210,10],[70,3,210,60]],[[20,3,211,10],[29,3,211,19],[33,3,211,23],[34,3,211,24],[45,3,211,35],[46,3,211,36]],[[16,3,212,8]],[[12,3,213,6],[19,3,213,13]],[[16,3,214,8],[22,3,214,14],[26,3,214,18],[32,3,214,24],[33,3,214,25],[68,3,214,60],[70,3,214,62],[80,3,214,72]],[[12,3,215,6]],[[8,3,216,4]],[[8,3,218,4],[17,3,218,13],[31,3,218,27],[34,3,218,30]],[[8,3,219,4],[15,3,219,11],[24,3,219,20],[31,3,219,27]],[[4,3,220,2]],[[4,3,222,2],[13,3,222,11],[30,3,222,28],[43,3,222,52]],[[8,3,223,4],[15,3,223,11],[21,3,223,17],[41,3,223,37]],[[4,3,224,2]],[[0,3,225,0],[1,3,225,1]],[[0,4,0,0]],[],[],[],[],[[1,4,5,1],[4,4,7,0],[56,4,7,52],[59,4,9,0],[107,4,9,48]],[[0,4,10,0],[44,4,10,44]],[[0,4,11,0],[49,4,11,49]],[[0,4,12,0],[58,4,12,58]],[[0,4,14,0],[4,4,14,4]],[[0,4,15,1],[1,4,15,2]],[[4,4,16,2],[18,4,16,16]],[[8,4,17,4],[21,4,17,16],[29,4,17,24]],[[12,4,18,6],[27,4,18,21]],[[12,4,20,6],[92,4,20,86]],[[12,4,21,6],[18,4,21,12],[36,4,21,30],[46,4,21,40]],[[12,4,23,6],[16,4,23,10],[22,4,23,16],[33,4,23,27]],[[16,4,24,8],[22,4,24,14],[30,4,24,22],[39,4,24,31],[55,4,24,47],[56,4,25,10],[57,4,25,11],[68,4,25,22],[70,4,25,24],[79,4,25,33],[94,4,25,48],[96,4,25,50],[105,4,25,59],[120,4,25,74],[122,4,25,76],[138,4,25,92],[153,4,25,107],[155,4,25,109],[171,4,25,125],[174,4,25,128],[175,4,25,129]],[[16,4,27,8],[21,4,27,13],[27,4,27,19],[35,4,27,27],[41,4,27,33],[45,4,27,37],[46,4,27,38],[53,4,27,46]],[[20,4,28,10],[25,4,28,15],[31,4,28,21]],[[16,4,29,8]],[[12,4,30,6],[19,4,30,13],[23,4,30,17],[28,4,30,22],[39,4,30,33]],[[16,4,31,8],[83,4,31,75]],[[16,4,32,8],[42,4,32,34]],[[16,4,33,8],[87,4,33,79]],[[16,4,34,8],[76,4,34,68]],[[16,4,35,8],[22,4,35,14],[32,4,35,24],[41,4,35,33],[57,4,35,49],[58,4,36,10],[59,4,36,11],[71,4,36,23],[73,4,36,25],[82,4,36,34],[98,4,36,50],[100,4,36,52],[109,4,36,61],[125,4,36,77],[127,4,36,79],[143,4,36,95],[159,4,36,111],[161,4,36,113],[177,4,36,129],[180,4,36,132],[181,4,36,133]],[[16,4,38,8],[21,4,38,13],[27,4,38,19],[37,4,38,29],[43,4,38,35],[47,4,38,39],[48,4,38,40],[57,4,38,50]],[[20,4,39,10],[27,4,39,17],[33,4,39,23]],[[16,4,40,8]],[[12,4,41,6],[19,4,41,13]],[[16,4,42,8],[22,4,42,14],[26,4,42,18],[32,4,42,24],[33,4,42,25],[68,4,42,60],[70,4,42,62],[80,4,42,72]],[[12,4,43,6]],[[8,4,44,4]],[[8,4,46,4],[21,4,46,16],[29,4,46,24]],[[12,4,47,6],[19,4,47,13],[23,4,47,17],[31,4,47,31],[32,4,47,32],[41,4,47,41]],[[16,4,48,8],[20,4,48,12],[21,4,48,13],[27,4,48,19],[38,4,48,30]],[[20,4,49,10],[27,4,49,17],[31,4,49,21],[37,4,49,27]],[[20,4,50,10]],[[16,4,51,8]],[[16,4,53,8],[22,4,53,14],[40,4,53,32],[50,4,53,42]],[[16,4,54,8],[22,4,54,14],[38,4,54,30],[47,4,54,39],[63,4,54,55],[64,4,55,10],[65,4,55,11],[92,4,55,38],[94,4,55,40],[103,4,55,49],[134,4,55,80],[136,4,55,82],[145,4,55,91],[176,4,55,122],[178,4,55,124],[194,4,55,140],[225,4,55,171],[227,4,55,173],[243,4,55,189],[246,4,55,192],[247,4,55,193]],[[16,4,58,8],[20,4,58,12],[34,4,58,26],[40,4,58,32],[45,4,58,37],[48,4,58,40]],[[20,4,59,10],[27,4,59,17],[31,4,59,21],[37,4,59,27],[38,4,59,28],[70,4,59,60],[72,4,59,62],[82,4,59,72]],[[20,4,60,10]],[[16,4,61,8]],[[16,4,63,8],[22,4,63,14],[29,4,63,21],[38,4,63,30],[51,4,63,43],[52,4,63,44]],[[16,4,64,8],[21,4,64,13],[24,4,64,16],[27,4,64,19]],[[16,4,66,8],[20,4,66,12],[30,4,66,22],[39,4,66,31],[40,4,66,32],[48,4,66,40],[49,4,66,41],[61,4,66,53]],[[20,4,67,10],[102,4,67,92]],[[20,4,68,10],[106,4,68,96]],[[20,4,69,10],[22,4,69,12]],[[20,4,70,10],[105,4,70,95]],[[20,4,71,10],[22,4,71,12]],[[20,4,72,10],[104,4,72,94]],[[20,4,73,10],[113,4,73,103]],[[20,4,74,10],[25,4,74,15],[29,4,74,19],[32,4,74,22],[35,4,74,25],[44,4,74,34],[48,4,74,38],[50,4,74,40],[55,4,74,45],[58,4,74,48],[62,4,74,52]],[[16,4,75,8],[23,4,75,15]],[[20,4,76,10],[25,4,76,15],[29,4,76,19],[32,4,76,22]],[[16,4,77,8]],[[16,4,79,8],[21,4,79,13],[28,4,79,20],[31,4,79,23]],[[20,4,80,10]],[[16,4,81,8]],[[16,4,82,8],[21,4,82,13],[27,4,82,19],[30,4,82,22]],[[20,4,83,10],[94,4,83,84]],[[20,4,84,10],[92,4,84,82]],[[20,4,85,10],[43,4,85,33]],[[20,4,86,10],[25,4,86,15],[31,4,86,21],[47,4,86,37],[53,4,86,43],[57,4,86,47],[58,4,86,48],[73,4,87,12],[86,4,87,25],[92,4,87,31]],[[20,4,89,10],[91,4,89,81]],[[20,4,90,10],[40,4,90,30]],[[20,4,91,10]],[[16,4,92,8]],[[16,4,94,8],[88,4,94,80]],[[16,4,95,8],[44,4,95,36]],[[16,4,96,8],[29,4,96,21],[30,4,96,22],[32,4,96,24],[33,4,96,25],[46,4,96,38],[47,4,96,40],[59,4,96,52],[60,4,97,10],[66,4,98,10],[79,4,98,23],[80,4,98,24],[82,4,98,26],[83,4,98,27],[94,4,98,38]],[[12,4,100,6]],[[8,4,101,4]],[[8,4,103,4],[17,4,103,13],[21,4,103,19],[26,4,103,24],[34,4,103,32],[35,4,103,33],[41,4,103,39]],[[4,4,104,2]],[[4,4,106,2],[13,4,106,11],[28,4,106,26],[36,4,106,44]],[[8,4,107,4],[23,4,107,19],[29,4,107,25],[30,4,107,26]],[[4,4,108,2]],[[0,4,109,0],[1,4,109,1]],[[0,4,111,0],[9,4,111,9],[15,4,111,15],[17,4,111,17],[21,4,111,21],[23,4,111,23],[26,4,111,26],[28,4,111,28],[31,4,111,31],[33,4,111,56]],[[4,4,112,2],[12,4,112,10],[13,4,112,11],[31,4,112,29],[33,4,112,31],[43,4,113,4],[52,4,113,13],[58,4,113,19],[61,4,113,22],[79,4,113,40],[85,4,113,46],[100,4,114,5]],[[4,4,115,2],[8,4,115,6],[13,4,115,11]],[[8,4,116,4],[16,4,116,12],[17,4,116,13],[83,4,116,79],[85,4,116,81],[90,4,117,6],[164,4,117,80]],[[8,4,118,6],[51,4,118,49]],[[8,4,119,6],[17,4,119,15],[36,4,119,34],[44,4,120,7]],[[4,4,121,2]],[[4,4,123,2],[39,4,123,37]],[[4,4,124,2],[11,4,124,9],[16,4,124,14]],[[0,4,125,0]]]}}