{"id":"295c9e4ca024f76b3f09229aede48b68eb64a959","url":"http://localhost:3000/_next/static/chunks/%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js","source":"(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === \"object\" ? document.currentScript : undefined,\n\"[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-client] (ecmascript)\", ((__turbopack_context__) => {\n\"use strict\";\n\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-globals.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-protocol.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-extensions.ts\" />\n__turbopack_context__.s([\n    \"connect\",\n    ()=>connect,\n    \"setHooks\",\n    ()=>setHooks,\n    \"subscribeToUpdate\",\n    ()=>subscribeToUpdate\n]);\nfunction connect({ addMessageListener, sendMessage, onUpdateError = console.error }) {\n    addMessageListener((msg)=>{\n        switch(msg.type){\n            case 'turbopack-connected':\n                handleSocketConnected(sendMessage);\n                break;\n            default:\n                try {\n                    if (Array.isArray(msg.data)) {\n                        for(let i = 0; i < msg.data.length; i++){\n                            handleSocketMessage(msg.data[i]);\n                        }\n                    } else {\n                        handleSocketMessage(msg.data);\n                    }\n                    applyAggregatedUpdates();\n                } catch (e) {\n                    console.warn('[Fast Refresh] performing full reload\\n\\n' + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' + 'Fast Refresh requires at least one parent function component in your React tree.');\n                    onUpdateError(e);\n                    location.reload();\n                }\n                break;\n        }\n    });\n    const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS;\n    if (queued != null && !Array.isArray(queued)) {\n        throw new Error('A separate HMR handler was already registered');\n    }\n    globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n        push: ([chunkPath, callback])=>{\n            subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n        }\n    };\n    if (Array.isArray(queued)) {\n        for (const [chunkPath, callback] of queued){\n            subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n        }\n    }\n}\nconst updateCallbackSets = new Map();\nfunction sendJSON(sendMessage, message) {\n    sendMessage(JSON.stringify(message));\n}\nfunction resourceKey(resource) {\n    return JSON.stringify({\n        path: resource.path,\n        headers: resource.headers || null\n    });\n}\nfunction subscribeToUpdates(sendMessage, resource) {\n    sendJSON(sendMessage, {\n        type: 'turbopack-subscribe',\n        ...resource\n    });\n    return ()=>{\n        sendJSON(sendMessage, {\n            type: 'turbopack-unsubscribe',\n            ...resource\n        });\n    };\n}\nfunction handleSocketConnected(sendMessage) {\n    for (const key of updateCallbackSets.keys()){\n        subscribeToUpdates(sendMessage, JSON.parse(key));\n    }\n}\n// we aggregate all pending updates until the issues are resolved\nconst chunkListsWithPendingUpdates = new Map();\nfunction aggregateUpdates(msg) {\n    const key = resourceKey(msg.resource);\n    let aggregated = chunkListsWithPendingUpdates.get(key);\n    if (aggregated) {\n        aggregated.instruction = mergeChunkListUpdates(aggregated.instruction, msg.instruction);\n    } else {\n        chunkListsWithPendingUpdates.set(key, msg);\n    }\n}\nfunction applyAggregatedUpdates() {\n    if (chunkListsWithPendingUpdates.size === 0) return;\n    hooks.beforeRefresh();\n    for (const msg of chunkListsWithPendingUpdates.values()){\n        triggerUpdate(msg);\n    }\n    chunkListsWithPendingUpdates.clear();\n    finalizeUpdate();\n}\nfunction mergeChunkListUpdates(updateA, updateB) {\n    let chunks;\n    if (updateA.chunks != null) {\n        if (updateB.chunks == null) {\n            chunks = updateA.chunks;\n        } else {\n            chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks);\n        }\n    } else if (updateB.chunks != null) {\n        chunks = updateB.chunks;\n    }\n    let merged;\n    if (updateA.merged != null) {\n        if (updateB.merged == null) {\n            merged = updateA.merged;\n        } else {\n            // Since `merged` is an array of updates, we need to merge them all into\n            // one, consistent update.\n            // Since there can only be `EcmascriptMergeUpdates` in the array, there is\n            // no need to key on the `type` field.\n            let update = updateA.merged[0];\n            for(let i = 1; i < updateA.merged.length; i++){\n                update = mergeChunkListEcmascriptMergedUpdates(update, updateA.merged[i]);\n            }\n            for(let i = 0; i < updateB.merged.length; i++){\n                update = mergeChunkListEcmascriptMergedUpdates(update, updateB.merged[i]);\n            }\n            merged = [\n                update\n            ];\n        }\n    } else if (updateB.merged != null) {\n        merged = updateB.merged;\n    }\n    return {\n        type: 'ChunkListUpdate',\n        chunks,\n        merged\n    };\n}\nfunction mergeChunkListChunks(chunksA, chunksB) {\n    const chunks = {};\n    for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)){\n        const chunkUpdateB = chunksB[chunkPath];\n        if (chunkUpdateB != null) {\n            const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB);\n            if (mergedUpdate != null) {\n                chunks[chunkPath] = mergedUpdate;\n            }\n        } else {\n            chunks[chunkPath] = chunkUpdateA;\n        }\n    }\n    for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)){\n        if (chunks[chunkPath] == null) {\n            chunks[chunkPath] = chunkUpdateB;\n        }\n    }\n    return chunks;\n}\nfunction mergeChunkUpdates(updateA, updateB) {\n    if (updateA.type === 'added' && updateB.type === 'deleted' || updateA.type === 'deleted' && updateB.type === 'added') {\n        return undefined;\n    }\n    if (updateA.type === 'partial') {\n        invariant(updateA.instruction, 'Partial updates are unsupported');\n    }\n    if (updateB.type === 'partial') {\n        invariant(updateB.instruction, 'Partial updates are unsupported');\n    }\n    return undefined;\n}\nfunction mergeChunkListEcmascriptMergedUpdates(mergedA, mergedB) {\n    const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries);\n    const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks);\n    return {\n        type: 'EcmascriptMergedUpdate',\n        entries,\n        chunks\n    };\n}\nfunction mergeEcmascriptChunkEntries(entriesA, entriesB) {\n    return {\n        ...entriesA,\n        ...entriesB\n    };\n}\nfunction mergeEcmascriptChunksUpdates(chunksA, chunksB) {\n    if (chunksA == null) {\n        return chunksB;\n    }\n    if (chunksB == null) {\n        return chunksA;\n    }\n    const chunks = {};\n    for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)){\n        const chunkUpdateB = chunksB[chunkPath];\n        if (chunkUpdateB != null) {\n            const mergedUpdate = mergeEcmascriptChunkUpdates(chunkUpdateA, chunkUpdateB);\n            if (mergedUpdate != null) {\n                chunks[chunkPath] = mergedUpdate;\n            }\n        } else {\n            chunks[chunkPath] = chunkUpdateA;\n        }\n    }\n    for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)){\n        if (chunks[chunkPath] == null) {\n            chunks[chunkPath] = chunkUpdateB;\n        }\n    }\n    if (Object.keys(chunks).length === 0) {\n        return undefined;\n    }\n    return chunks;\n}\nfunction mergeEcmascriptChunkUpdates(updateA, updateB) {\n    if (updateA.type === 'added' && updateB.type === 'deleted') {\n        // These two completely cancel each other out.\n        return undefined;\n    }\n    if (updateA.type === 'deleted' && updateB.type === 'added') {\n        const added = [];\n        const deleted = [];\n        const deletedModules = new Set(updateA.modules ?? []);\n        const addedModules = new Set(updateB.modules ?? []);\n        for (const moduleId of addedModules){\n            if (!deletedModules.has(moduleId)) {\n                added.push(moduleId);\n            }\n        }\n        for (const moduleId of deletedModules){\n            if (!addedModules.has(moduleId)) {\n                deleted.push(moduleId);\n            }\n        }\n        if (added.length === 0 && deleted.length === 0) {\n            return undefined;\n        }\n        return {\n            type: 'partial',\n            added,\n            deleted\n        };\n    }\n    if (updateA.type === 'partial' && updateB.type === 'partial') {\n        const added = new Set([\n            ...updateA.added ?? [],\n            ...updateB.added ?? []\n        ]);\n        const deleted = new Set([\n            ...updateA.deleted ?? [],\n            ...updateB.deleted ?? []\n        ]);\n        if (updateB.added != null) {\n            for (const moduleId of updateB.added){\n                deleted.delete(moduleId);\n            }\n        }\n        if (updateB.deleted != null) {\n            for (const moduleId of updateB.deleted){\n                added.delete(moduleId);\n            }\n        }\n        return {\n            type: 'partial',\n            added: [\n                ...added\n            ],\n            deleted: [\n                ...deleted\n            ]\n        };\n    }\n    if (updateA.type === 'added' && updateB.type === 'partial') {\n        const modules = new Set([\n            ...updateA.modules ?? [],\n            ...updateB.added ?? []\n        ]);\n        for (const moduleId of updateB.deleted ?? []){\n            modules.delete(moduleId);\n        }\n        return {\n            type: 'added',\n            modules: [\n                ...modules\n            ]\n        };\n    }\n    if (updateA.type === 'partial' && updateB.type === 'deleted') {\n        // We could eagerly return `updateB` here, but this would potentially be\n        // incorrect if `updateA` has added modules.\n        const modules = new Set(updateB.modules ?? []);\n        if (updateA.added != null) {\n            for (const moduleId of updateA.added){\n                modules.delete(moduleId);\n            }\n        }\n        return {\n            type: 'deleted',\n            modules: [\n                ...modules\n            ]\n        };\n    }\n    // Any other update combination is invalid.\n    return undefined;\n}\nfunction invariant(_, message) {\n    throw new Error(`Invariant: ${message}`);\n}\nconst CRITICAL = [\n    'bug',\n    'error',\n    'fatal'\n];\nfunction compareByList(list, a, b) {\n    const aI = list.indexOf(a) + 1 || list.length;\n    const bI = list.indexOf(b) + 1 || list.length;\n    return aI - bI;\n}\nconst chunksWithIssues = new Map();\nfunction emitIssues() {\n    const issues = [];\n    const deduplicationSet = new Set();\n    for (const [_, chunkIssues] of chunksWithIssues){\n        for (const chunkIssue of chunkIssues){\n            if (deduplicationSet.has(chunkIssue.formatted)) continue;\n            issues.push(chunkIssue);\n            deduplicationSet.add(chunkIssue.formatted);\n        }\n    }\n    sortIssues(issues);\n    hooks.issues(issues);\n}\nfunction handleIssues(msg) {\n    const key = resourceKey(msg.resource);\n    let hasCriticalIssues = false;\n    for (const issue of msg.issues){\n        if (CRITICAL.includes(issue.severity)) {\n            hasCriticalIssues = true;\n        }\n    }\n    if (msg.issues.length > 0) {\n        chunksWithIssues.set(key, msg.issues);\n    } else if (chunksWithIssues.has(key)) {\n        chunksWithIssues.delete(key);\n    }\n    emitIssues();\n    return hasCriticalIssues;\n}\nconst SEVERITY_ORDER = [\n    'bug',\n    'fatal',\n    'error',\n    'warning',\n    'info',\n    'log'\n];\nconst CATEGORY_ORDER = [\n    'parse',\n    'resolve',\n    'code generation',\n    'rendering',\n    'typescript',\n    'other'\n];\nfunction sortIssues(issues) {\n    issues.sort((a, b)=>{\n        const first = compareByList(SEVERITY_ORDER, a.severity, b.severity);\n        if (first !== 0) return first;\n        return compareByList(CATEGORY_ORDER, a.category, b.category);\n    });\n}\nconst hooks = {\n    beforeRefresh: ()=>{},\n    refresh: ()=>{},\n    buildOk: ()=>{},\n    issues: (_issues)=>{}\n};\nfunction setHooks(newHooks) {\n    Object.assign(hooks, newHooks);\n}\nfunction handleSocketMessage(msg) {\n    sortIssues(msg.issues);\n    handleIssues(msg);\n    switch(msg.type){\n        case 'issues':\n            break;\n        case 'partial':\n            // aggregate updates\n            aggregateUpdates(msg);\n            break;\n        default:\n            // run single update\n            const runHooks = chunkListsWithPendingUpdates.size === 0;\n            if (runHooks) hooks.beforeRefresh();\n            triggerUpdate(msg);\n            if (runHooks) finalizeUpdate();\n            break;\n    }\n}\nfunction finalizeUpdate() {\n    hooks.refresh();\n    hooks.buildOk();\n    // This is used by the Next.js integration test suite to notify it when HMR\n    // updates have been completed.\n    // TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)\n    if (globalThis.__NEXT_HMR_CB) {\n        globalThis.__NEXT_HMR_CB();\n        globalThis.__NEXT_HMR_CB = null;\n    }\n}\nfunction subscribeToChunkUpdate(chunkListPath, sendMessage, callback) {\n    return subscribeToUpdate({\n        path: chunkListPath\n    }, sendMessage, callback);\n}\nfunction subscribeToUpdate(resource, sendMessage, callback) {\n    const key = resourceKey(resource);\n    let callbackSet;\n    const existingCallbackSet = updateCallbackSets.get(key);\n    if (!existingCallbackSet) {\n        callbackSet = {\n            callbacks: new Set([\n                callback\n            ]),\n            unsubscribe: subscribeToUpdates(sendMessage, resource)\n        };\n        updateCallbackSets.set(key, callbackSet);\n    } else {\n        existingCallbackSet.callbacks.add(callback);\n        callbackSet = existingCallbackSet;\n    }\n    return ()=>{\n        callbackSet.callbacks.delete(callback);\n        if (callbackSet.callbacks.size === 0) {\n            callbackSet.unsubscribe();\n            updateCallbackSets.delete(key);\n        }\n    };\n}\nfunction triggerUpdate(msg) {\n    const key = resourceKey(msg.resource);\n    const callbackSet = updateCallbackSets.get(key);\n    if (!callbackSet) {\n        return;\n    }\n    for (const callback of callbackSet.callbacks){\n        callback(msg);\n    }\n    if (msg.type === 'notFound') {\n        // This indicates that the resource which we subscribed to either does not exist or\n        // has been deleted. In either case, we should clear all update callbacks, so if a\n        // new subscription is created for the same resource, it will send a new \"subscribe\"\n        // message to the server.\n        // No need to send an \"unsubscribe\" message to the server, it will have already\n        // dropped the update stream before sending the \"notFound\" message.\n        updateCallbackSets.delete(key);\n    }\n}\n}),\n]);\n\n//# sourceMappingURL=%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js.map","sourceMap":{"version":3,"sources":["turbopack:///[turbopack]/browser/dev/hmr-client/hmr-client.ts"],"sections":[{"offset":{"line":4,"column":0},"map":{"version":3,"sources":["turbopack:///[turbopack]/browser/dev/hmr-client/hmr-client.ts"],"sourcesContent":["/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-globals.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-protocol.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-extensions.ts\" />\n\ntype SendMessage = (msg: any) => void\nexport type WebSocketMessage =\n  | {\n      type: 'turbopack-connected'\n    }\n  | {\n      type: 'turbopack-message'\n      data: Record<string, any>\n    }\n\nexport type ClientOptions = {\n  addMessageListener: (cb: (msg: WebSocketMessage) => void) => void\n  sendMessage: SendMessage\n  onUpdateError: (err: unknown) => void\n}\n\nexport function connect({\n  addMessageListener,\n  sendMessage,\n  onUpdateError = console.error,\n}: ClientOptions) {\n  addMessageListener((msg) => {\n    switch (msg.type) {\n      case 'turbopack-connected':\n        handleSocketConnected(sendMessage)\n        break\n      default:\n        try {\n          if (Array.isArray(msg.data)) {\n            for (let i = 0; i < msg.data.length; i++) {\n              handleSocketMessage(msg.data[i] as ServerMessage)\n            }\n          } else {\n            handleSocketMessage(msg.data as ServerMessage)\n          }\n          applyAggregatedUpdates()\n        } catch (e: unknown) {\n          console.warn(\n            '[Fast Refresh] performing full reload\\n\\n' +\n              \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n              'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n              'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n              'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n              'Fast Refresh requires at least one parent function component in your React tree.'\n          )\n          onUpdateError(e)\n          location.reload()\n        }\n        break\n    }\n  })\n\n  const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS\n  if (queued != null && !Array.isArray(queued)) {\n    throw new Error('A separate HMR handler was already registered')\n  }\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n    push: ([chunkPath, callback]: [ChunkListPath, UpdateCallback]) => {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback)\n    },\n  }\n\n  if (Array.isArray(queued)) {\n    for (const [chunkPath, callback] of queued) {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback)\n    }\n  }\n}\n\ntype UpdateCallbackSet = {\n  callbacks: Set<UpdateCallback>\n  unsubscribe: () => void\n}\n\nconst updateCallbackSets: Map<ResourceKey, UpdateCallbackSet> = new Map()\n\nfunction sendJSON(sendMessage: SendMessage, message: ClientMessage) {\n  sendMessage(JSON.stringify(message))\n}\n\ntype ResourceKey = string\n\nfunction resourceKey(resource: ResourceIdentifier): ResourceKey {\n  return JSON.stringify({\n    path: resource.path,\n    headers: resource.headers || null,\n  })\n}\n\nfunction subscribeToUpdates(\n  sendMessage: SendMessage,\n  resource: ResourceIdentifier\n): () => void {\n  sendJSON(sendMessage, {\n    type: 'turbopack-subscribe',\n    ...resource,\n  })\n\n  return () => {\n    sendJSON(sendMessage, {\n      type: 'turbopack-unsubscribe',\n      ...resource,\n    })\n  }\n}\n\nfunction handleSocketConnected(sendMessage: SendMessage) {\n  for (const key of updateCallbackSets.keys()) {\n    subscribeToUpdates(sendMessage, JSON.parse(key))\n  }\n}\n\n// we aggregate all pending updates until the issues are resolved\nconst chunkListsWithPendingUpdates: Map<ResourceKey, PartialServerMessage> =\n  new Map()\n\nfunction aggregateUpdates(msg: PartialServerMessage) {\n  const key = resourceKey(msg.resource)\n  let aggregated = chunkListsWithPendingUpdates.get(key)\n\n  if (aggregated) {\n    aggregated.instruction = mergeChunkListUpdates(\n      aggregated.instruction,\n      msg.instruction\n    )\n  } else {\n    chunkListsWithPendingUpdates.set(key, msg)\n  }\n}\n\nfunction applyAggregatedUpdates() {\n  if (chunkListsWithPendingUpdates.size === 0) return\n  hooks.beforeRefresh()\n  for (const msg of chunkListsWithPendingUpdates.values()) {\n    triggerUpdate(msg)\n  }\n  chunkListsWithPendingUpdates.clear()\n  finalizeUpdate()\n}\n\nfunction mergeChunkListUpdates(\n  updateA: ChunkListUpdate,\n  updateB: ChunkListUpdate\n): ChunkListUpdate {\n  let chunks\n  if (updateA.chunks != null) {\n    if (updateB.chunks == null) {\n      chunks = updateA.chunks\n    } else {\n      chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks)\n    }\n  } else if (updateB.chunks != null) {\n    chunks = updateB.chunks\n  }\n\n  let merged\n  if (updateA.merged != null) {\n    if (updateB.merged == null) {\n      merged = updateA.merged\n    } else {\n      // Since `merged` is an array of updates, we need to merge them all into\n      // one, consistent update.\n      // Since there can only be `EcmascriptMergeUpdates` in the array, there is\n      // no need to key on the `type` field.\n      let update = updateA.merged[0]\n      for (let i = 1; i < updateA.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateA.merged[i]\n        )\n      }\n\n      for (let i = 0; i < updateB.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateB.merged[i]\n        )\n      }\n\n      merged = [update]\n    }\n  } else if (updateB.merged != null) {\n    merged = updateB.merged\n  }\n\n  return {\n    type: 'ChunkListUpdate',\n    chunks,\n    merged,\n  }\n}\n\nfunction mergeChunkListChunks(\n  chunksA: Record<ChunkPath, ChunkUpdate>,\n  chunksB: Record<ChunkPath, ChunkUpdate>\n): Record<ChunkPath, ChunkUpdate> {\n  const chunks: Record<ChunkPath, ChunkUpdate> = {}\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<\n    [ChunkPath, ChunkUpdate]\n  >) {\n    const chunkUpdateB = chunksB[chunkPath]\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB)\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<\n    [ChunkPath, ChunkUpdate]\n  >) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB\n    }\n  }\n\n  return chunks\n}\n\nfunction mergeChunkUpdates(\n  updateA: ChunkUpdate,\n  updateB: ChunkUpdate\n): ChunkUpdate | undefined {\n  if (\n    (updateA.type === 'added' && updateB.type === 'deleted') ||\n    (updateA.type === 'deleted' && updateB.type === 'added')\n  ) {\n    return undefined\n  }\n\n  if (updateA.type === 'partial') {\n    invariant(updateA.instruction, 'Partial updates are unsupported')\n  }\n\n  if (updateB.type === 'partial') {\n    invariant(updateB.instruction, 'Partial updates are unsupported')\n  }\n\n  return undefined\n}\n\nfunction mergeChunkListEcmascriptMergedUpdates(\n  mergedA: EcmascriptMergedUpdate,\n  mergedB: EcmascriptMergedUpdate\n): EcmascriptMergedUpdate {\n  const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries)\n  const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks)\n\n  return {\n    type: 'EcmascriptMergedUpdate',\n    entries,\n    chunks,\n  }\n}\n\nfunction mergeEcmascriptChunkEntries(\n  entriesA: Record<ModuleId, EcmascriptModuleEntry> | undefined,\n  entriesB: Record<ModuleId, EcmascriptModuleEntry> | undefined\n): Record<ModuleId, EcmascriptModuleEntry> {\n  return { ...entriesA, ...entriesB }\n}\n\nfunction mergeEcmascriptChunksUpdates(\n  chunksA: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined,\n  chunksB: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined\n): Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined {\n  if (chunksA == null) {\n    return chunksB\n  }\n\n  if (chunksB == null) {\n    return chunksA\n  }\n\n  const chunks: Record<ChunkPath, EcmascriptMergedChunkUpdate> = {}\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    const chunkUpdateB = chunksB[chunkPath]\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeEcmascriptChunkUpdates(\n        chunkUpdateA,\n        chunkUpdateB\n      )\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB\n    }\n  }\n\n  if (Object.keys(chunks).length === 0) {\n    return undefined\n  }\n\n  return chunks\n}\n\nfunction mergeEcmascriptChunkUpdates(\n  updateA: EcmascriptMergedChunkUpdate,\n  updateB: EcmascriptMergedChunkUpdate\n): EcmascriptMergedChunkUpdate | undefined {\n  if (updateA.type === 'added' && updateB.type === 'deleted') {\n    // These two completely cancel each other out.\n    return undefined\n  }\n\n  if (updateA.type === 'deleted' && updateB.type === 'added') {\n    const added = []\n    const deleted = []\n    const deletedModules = new Set(updateA.modules ?? [])\n    const addedModules = new Set(updateB.modules ?? [])\n\n    for (const moduleId of addedModules) {\n      if (!deletedModules.has(moduleId)) {\n        added.push(moduleId)\n      }\n    }\n\n    for (const moduleId of deletedModules) {\n      if (!addedModules.has(moduleId)) {\n        deleted.push(moduleId)\n      }\n    }\n\n    if (added.length === 0 && deleted.length === 0) {\n      return undefined\n    }\n\n    return {\n      type: 'partial',\n      added,\n      deleted,\n    }\n  }\n\n  if (updateA.type === 'partial' && updateB.type === 'partial') {\n    const added = new Set([...(updateA.added ?? []), ...(updateB.added ?? [])])\n    const deleted = new Set([\n      ...(updateA.deleted ?? []),\n      ...(updateB.deleted ?? []),\n    ])\n\n    if (updateB.added != null) {\n      for (const moduleId of updateB.added) {\n        deleted.delete(moduleId)\n      }\n    }\n\n    if (updateB.deleted != null) {\n      for (const moduleId of updateB.deleted) {\n        added.delete(moduleId)\n      }\n    }\n\n    return {\n      type: 'partial',\n      added: [...added],\n      deleted: [...deleted],\n    }\n  }\n\n  if (updateA.type === 'added' && updateB.type === 'partial') {\n    const modules = new Set([\n      ...(updateA.modules ?? []),\n      ...(updateB.added ?? []),\n    ])\n\n    for (const moduleId of updateB.deleted ?? []) {\n      modules.delete(moduleId)\n    }\n\n    return {\n      type: 'added',\n      modules: [...modules],\n    }\n  }\n\n  if (updateA.type === 'partial' && updateB.type === 'deleted') {\n    // We could eagerly return `updateB` here, but this would potentially be\n    // incorrect if `updateA` has added modules.\n\n    const modules = new Set(updateB.modules ?? [])\n\n    if (updateA.added != null) {\n      for (const moduleId of updateA.added) {\n        modules.delete(moduleId)\n      }\n    }\n\n    return {\n      type: 'deleted',\n      modules: [...modules],\n    }\n  }\n\n  // Any other update combination is invalid.\n\n  return undefined\n}\n\nfunction invariant(_: never, message: string): never {\n  throw new Error(`Invariant: ${message}`)\n}\n\nconst CRITICAL = ['bug', 'error', 'fatal']\n\nfunction compareByList(list: any[], a: any, b: any) {\n  const aI = list.indexOf(a) + 1 || list.length\n  const bI = list.indexOf(b) + 1 || list.length\n  return aI - bI\n}\n\nconst chunksWithIssues: Map<ResourceKey, Issue[]> = new Map()\n\nfunction emitIssues() {\n  const issues = []\n  const deduplicationSet = new Set()\n\n  for (const [_, chunkIssues] of chunksWithIssues) {\n    for (const chunkIssue of chunkIssues) {\n      if (deduplicationSet.has(chunkIssue.formatted)) continue\n\n      issues.push(chunkIssue)\n      deduplicationSet.add(chunkIssue.formatted)\n    }\n  }\n\n  sortIssues(issues)\n\n  hooks.issues(issues)\n}\n\nfunction handleIssues(msg: ServerMessage): boolean {\n  const key = resourceKey(msg.resource)\n  let hasCriticalIssues = false\n\n  for (const issue of msg.issues) {\n    if (CRITICAL.includes(issue.severity)) {\n      hasCriticalIssues = true\n    }\n  }\n\n  if (msg.issues.length > 0) {\n    chunksWithIssues.set(key, msg.issues)\n  } else if (chunksWithIssues.has(key)) {\n    chunksWithIssues.delete(key)\n  }\n\n  emitIssues()\n\n  return hasCriticalIssues\n}\n\nconst SEVERITY_ORDER = ['bug', 'fatal', 'error', 'warning', 'info', 'log']\nconst CATEGORY_ORDER = [\n  'parse',\n  'resolve',\n  'code generation',\n  'rendering',\n  'typescript',\n  'other',\n]\n\nfunction sortIssues(issues: Issue[]) {\n  issues.sort((a, b) => {\n    const first = compareByList(SEVERITY_ORDER, a.severity, b.severity)\n    if (first !== 0) return first\n    return compareByList(CATEGORY_ORDER, a.category, b.category)\n  })\n}\n\nconst hooks = {\n  beforeRefresh: () => {},\n  refresh: () => {},\n  buildOk: () => {},\n  issues: (_issues: Issue[]) => {},\n}\n\nexport function setHooks(newHooks: typeof hooks) {\n  Object.assign(hooks, newHooks)\n}\n\nfunction handleSocketMessage(msg: ServerMessage) {\n  sortIssues(msg.issues)\n\n  handleIssues(msg)\n\n  switch (msg.type) {\n    case 'issues':\n      // issues are already handled\n      break\n    case 'partial':\n      // aggregate updates\n      aggregateUpdates(msg)\n      break\n    default:\n      // run single update\n      const runHooks = chunkListsWithPendingUpdates.size === 0\n      if (runHooks) hooks.beforeRefresh()\n      triggerUpdate(msg)\n      if (runHooks) finalizeUpdate()\n      break\n  }\n}\n\nfunction finalizeUpdate() {\n  hooks.refresh()\n  hooks.buildOk()\n\n  // This is used by the Next.js integration test suite to notify it when HMR\n  // updates have been completed.\n  // TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)\n  if (globalThis.__NEXT_HMR_CB) {\n    globalThis.__NEXT_HMR_CB()\n    globalThis.__NEXT_HMR_CB = null\n  }\n}\n\nfunction subscribeToChunkUpdate(\n  chunkListPath: ChunkListPath,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n): () => void {\n  return subscribeToUpdate(\n    {\n      path: chunkListPath,\n    },\n    sendMessage,\n    callback\n  )\n}\n\nexport function subscribeToUpdate(\n  resource: ResourceIdentifier,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n) {\n  const key = resourceKey(resource)\n  let callbackSet: UpdateCallbackSet\n  const existingCallbackSet = updateCallbackSets.get(key)\n  if (!existingCallbackSet) {\n    callbackSet = {\n      callbacks: new Set([callback]),\n      unsubscribe: subscribeToUpdates(sendMessage, resource),\n    }\n    updateCallbackSets.set(key, callbackSet)\n  } else {\n    existingCallbackSet.callbacks.add(callback)\n    callbackSet = existingCallbackSet\n  }\n\n  return () => {\n    callbackSet.callbacks.delete(callback)\n\n    if (callbackSet.callbacks.size === 0) {\n      callbackSet.unsubscribe()\n      updateCallbackSets.delete(key)\n    }\n  }\n}\n\nfunction triggerUpdate(msg: ServerMessage) {\n  const key = resourceKey(msg.resource)\n  const callbackSet = updateCallbackSets.get(key)\n  if (!callbackSet) {\n    return\n  }\n\n  for (const callback of callbackSet.callbacks) {\n    callback(msg)\n  }\n\n  if (msg.type === 'notFound') {\n    // This indicates that the resource which we subscribed to either does not exist or\n    // has been deleted. In either case, we should clear all update callbacks, so if a\n    // new subscription is created for the same resource, it will send a new \"subscribe\"\n    // message to the server.\n    // No need to send an \"unsubscribe\" message to the server, it will have already\n    // dropped the update stream before sending the \"notFound\" message.\n    updateCallbackSets.delete(key)\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}}],"sourcesContent":["/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-globals.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-protocol.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-extensions.ts\" />\n\ntype SendMessage = (msg: any) => void\nexport type WebSocketMessage =\n  | {\n      type: 'turbopack-connected'\n    }\n  | {\n      type: 'turbopack-message'\n      data: Record<string, any>\n    }\n\nexport type ClientOptions = {\n  addMessageListener: (cb: (msg: WebSocketMessage) => void) => void\n  sendMessage: SendMessage\n  onUpdateError: (err: unknown) => void\n}\n\nexport function connect({\n  addMessageListener,\n  sendMessage,\n  onUpdateError = console.error,\n}: ClientOptions) {\n  addMessageListener((msg) => {\n    switch (msg.type) {\n      case 'turbopack-connected':\n        handleSocketConnected(sendMessage)\n        break\n      default:\n        try {\n          if (Array.isArray(msg.data)) {\n            for (let i = 0; i < msg.data.length; i++) {\n              handleSocketMessage(msg.data[i] as ServerMessage)\n            }\n          } else {\n            handleSocketMessage(msg.data as ServerMessage)\n          }\n          applyAggregatedUpdates()\n        } catch (e: unknown) {\n          console.warn(\n            '[Fast Refresh] performing full reload\\n\\n' +\n              \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n              'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n              'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n              'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n              'Fast Refresh requires at least one parent function component in your React tree.'\n          )\n          onUpdateError(e)\n          location.reload()\n        }\n        break\n    }\n  })\n\n  const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS\n  if (queued != null && !Array.isArray(queued)) {\n    throw new Error('A separate HMR handler was already registered')\n  }\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n    push: ([chunkPath, callback]: [ChunkListPath, UpdateCallback]) => {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback)\n    },\n  }\n\n  if (Array.isArray(queued)) {\n    for (const [chunkPath, callback] of queued) {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback)\n    }\n  }\n}\n\ntype UpdateCallbackSet = {\n  callbacks: Set<UpdateCallback>\n  unsubscribe: () => void\n}\n\nconst updateCallbackSets: Map<ResourceKey, UpdateCallbackSet> = new Map()\n\nfunction sendJSON(sendMessage: SendMessage, message: ClientMessage) {\n  sendMessage(JSON.stringify(message))\n}\n\ntype ResourceKey = string\n\nfunction resourceKey(resource: ResourceIdentifier): ResourceKey {\n  return JSON.stringify({\n    path: resource.path,\n    headers: resource.headers || null,\n  })\n}\n\nfunction subscribeToUpdates(\n  sendMessage: SendMessage,\n  resource: ResourceIdentifier\n): () => void {\n  sendJSON(sendMessage, {\n    type: 'turbopack-subscribe',\n    ...resource,\n  })\n\n  return () => {\n    sendJSON(sendMessage, {\n      type: 'turbopack-unsubscribe',\n      ...resource,\n    })\n  }\n}\n\nfunction handleSocketConnected(sendMessage: SendMessage) {\n  for (const key of updateCallbackSets.keys()) {\n    subscribeToUpdates(sendMessage, JSON.parse(key))\n  }\n}\n\n// we aggregate all pending updates until the issues are resolved\nconst chunkListsWithPendingUpdates: Map<ResourceKey, PartialServerMessage> =\n  new Map()\n\nfunction aggregateUpdates(msg: PartialServerMessage) {\n  const key = resourceKey(msg.resource)\n  let aggregated = chunkListsWithPendingUpdates.get(key)\n\n  if (aggregated) {\n    aggregated.instruction = mergeChunkListUpdates(\n      aggregated.instruction,\n      msg.instruction\n    )\n  } else {\n    chunkListsWithPendingUpdates.set(key, msg)\n  }\n}\n\nfunction applyAggregatedUpdates() {\n  if (chunkListsWithPendingUpdates.size === 0) return\n  hooks.beforeRefresh()\n  for (const msg of chunkListsWithPendingUpdates.values()) {\n    triggerUpdate(msg)\n  }\n  chunkListsWithPendingUpdates.clear()\n  finalizeUpdate()\n}\n\nfunction mergeChunkListUpdates(\n  updateA: ChunkListUpdate,\n  updateB: ChunkListUpdate\n): ChunkListUpdate {\n  let chunks\n  if (updateA.chunks != null) {\n    if (updateB.chunks == null) {\n      chunks = updateA.chunks\n    } else {\n      chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks)\n    }\n  } else if (updateB.chunks != null) {\n    chunks = updateB.chunks\n  }\n\n  let merged\n  if (updateA.merged != null) {\n    if (updateB.merged == null) {\n      merged = updateA.merged\n    } else {\n      // Since `merged` is an array of updates, we need to merge them all into\n      // one, consistent update.\n      // Since there can only be `EcmascriptMergeUpdates` in the array, there is\n      // no need to key on the `type` field.\n      let update = updateA.merged[0]\n      for (let i = 1; i < updateA.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateA.merged[i]\n        )\n      }\n\n      for (let i = 0; i < updateB.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateB.merged[i]\n        )\n      }\n\n      merged = [update]\n    }\n  } else if (updateB.merged != null) {\n    merged = updateB.merged\n  }\n\n  return {\n    type: 'ChunkListUpdate',\n    chunks,\n    merged,\n  }\n}\n\nfunction mergeChunkListChunks(\n  chunksA: Record<ChunkPath, ChunkUpdate>,\n  chunksB: Record<ChunkPath, ChunkUpdate>\n): Record<ChunkPath, ChunkUpdate> {\n  const chunks: Record<ChunkPath, ChunkUpdate> = {}\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<\n    [ChunkPath, ChunkUpdate]\n  >) {\n    const chunkUpdateB = chunksB[chunkPath]\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB)\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<\n    [ChunkPath, ChunkUpdate]\n  >) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB\n    }\n  }\n\n  return chunks\n}\n\nfunction mergeChunkUpdates(\n  updateA: ChunkUpdate,\n  updateB: ChunkUpdate\n): ChunkUpdate | undefined {\n  if (\n    (updateA.type === 'added' && updateB.type === 'deleted') ||\n    (updateA.type === 'deleted' && updateB.type === 'added')\n  ) {\n    return undefined\n  }\n\n  if (updateA.type === 'partial') {\n    invariant(updateA.instruction, 'Partial updates are unsupported')\n  }\n\n  if (updateB.type === 'partial') {\n    invariant(updateB.instruction, 'Partial updates are unsupported')\n  }\n\n  return undefined\n}\n\nfunction mergeChunkListEcmascriptMergedUpdates(\n  mergedA: EcmascriptMergedUpdate,\n  mergedB: EcmascriptMergedUpdate\n): EcmascriptMergedUpdate {\n  const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries)\n  const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks)\n\n  return {\n    type: 'EcmascriptMergedUpdate',\n    entries,\n    chunks,\n  }\n}\n\nfunction mergeEcmascriptChunkEntries(\n  entriesA: Record<ModuleId, EcmascriptModuleEntry> | undefined,\n  entriesB: Record<ModuleId, EcmascriptModuleEntry> | undefined\n): Record<ModuleId, EcmascriptModuleEntry> {\n  return { ...entriesA, ...entriesB }\n}\n\nfunction mergeEcmascriptChunksUpdates(\n  chunksA: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined,\n  chunksB: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined\n): Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined {\n  if (chunksA == null) {\n    return chunksB\n  }\n\n  if (chunksB == null) {\n    return chunksA\n  }\n\n  const chunks: Record<ChunkPath, EcmascriptMergedChunkUpdate> = {}\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    const chunkUpdateB = chunksB[chunkPath]\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeEcmascriptChunkUpdates(\n        chunkUpdateA,\n        chunkUpdateB\n      )\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB\n    }\n  }\n\n  if (Object.keys(chunks).length === 0) {\n    return undefined\n  }\n\n  return chunks\n}\n\nfunction mergeEcmascriptChunkUpdates(\n  updateA: EcmascriptMergedChunkUpdate,\n  updateB: EcmascriptMergedChunkUpdate\n): EcmascriptMergedChunkUpdate | undefined {\n  if (updateA.type === 'added' && updateB.type === 'deleted') {\n    // These two completely cancel each other out.\n    return undefined\n  }\n\n  if (updateA.type === 'deleted' && updateB.type === 'added') {\n    const added = []\n    const deleted = []\n    const deletedModules = new Set(updateA.modules ?? [])\n    const addedModules = new Set(updateB.modules ?? [])\n\n    for (const moduleId of addedModules) {\n      if (!deletedModules.has(moduleId)) {\n        added.push(moduleId)\n      }\n    }\n\n    for (const moduleId of deletedModules) {\n      if (!addedModules.has(moduleId)) {\n        deleted.push(moduleId)\n      }\n    }\n\n    if (added.length === 0 && deleted.length === 0) {\n      return undefined\n    }\n\n    return {\n      type: 'partial',\n      added,\n      deleted,\n    }\n  }\n\n  if (updateA.type === 'partial' && updateB.type === 'partial') {\n    const added = new Set([...(updateA.added ?? []), ...(updateB.added ?? [])])\n    const deleted = new Set([\n      ...(updateA.deleted ?? []),\n      ...(updateB.deleted ?? []),\n    ])\n\n    if (updateB.added != null) {\n      for (const moduleId of updateB.added) {\n        deleted.delete(moduleId)\n      }\n    }\n\n    if (updateB.deleted != null) {\n      for (const moduleId of updateB.deleted) {\n        added.delete(moduleId)\n      }\n    }\n\n    return {\n      type: 'partial',\n      added: [...added],\n      deleted: [...deleted],\n    }\n  }\n\n  if (updateA.type === 'added' && updateB.type === 'partial') {\n    const modules = new Set([\n      ...(updateA.modules ?? []),\n      ...(updateB.added ?? []),\n    ])\n\n    for (const moduleId of updateB.deleted ?? []) {\n      modules.delete(moduleId)\n    }\n\n    return {\n      type: 'added',\n      modules: [...modules],\n    }\n  }\n\n  if (updateA.type === 'partial' && updateB.type === 'deleted') {\n    // We could eagerly return `updateB` here, but this would potentially be\n    // incorrect if `updateA` has added modules.\n\n    const modules = new Set(updateB.modules ?? [])\n\n    if (updateA.added != null) {\n      for (const moduleId of updateA.added) {\n        modules.delete(moduleId)\n      }\n    }\n\n    return {\n      type: 'deleted',\n      modules: [...modules],\n    }\n  }\n\n  // Any other update combination is invalid.\n\n  return undefined\n}\n\nfunction invariant(_: never, message: string): never {\n  throw new Error(`Invariant: ${message}`)\n}\n\nconst CRITICAL = ['bug', 'error', 'fatal']\n\nfunction compareByList(list: any[], a: any, b: any) {\n  const aI = list.indexOf(a) + 1 || list.length\n  const bI = list.indexOf(b) + 1 || list.length\n  return aI - bI\n}\n\nconst chunksWithIssues: Map<ResourceKey, Issue[]> = new Map()\n\nfunction emitIssues() {\n  const issues = []\n  const deduplicationSet = new Set()\n\n  for (const [_, chunkIssues] of chunksWithIssues) {\n    for (const chunkIssue of chunkIssues) {\n      if (deduplicationSet.has(chunkIssue.formatted)) continue\n\n      issues.push(chunkIssue)\n      deduplicationSet.add(chunkIssue.formatted)\n    }\n  }\n\n  sortIssues(issues)\n\n  hooks.issues(issues)\n}\n\nfunction handleIssues(msg: ServerMessage): boolean {\n  const key = resourceKey(msg.resource)\n  let hasCriticalIssues = false\n\n  for (const issue of msg.issues) {\n    if (CRITICAL.includes(issue.severity)) {\n      hasCriticalIssues = true\n    }\n  }\n\n  if (msg.issues.length > 0) {\n    chunksWithIssues.set(key, msg.issues)\n  } else if (chunksWithIssues.has(key)) {\n    chunksWithIssues.delete(key)\n  }\n\n  emitIssues()\n\n  return hasCriticalIssues\n}\n\nconst SEVERITY_ORDER = ['bug', 'fatal', 'error', 'warning', 'info', 'log']\nconst CATEGORY_ORDER = [\n  'parse',\n  'resolve',\n  'code generation',\n  'rendering',\n  'typescript',\n  'other',\n]\n\nfunction sortIssues(issues: Issue[]) {\n  issues.sort((a, b) => {\n    const first = compareByList(SEVERITY_ORDER, a.severity, b.severity)\n    if (first !== 0) return first\n    return compareByList(CATEGORY_ORDER, a.category, b.category)\n  })\n}\n\nconst hooks = {\n  beforeRefresh: () => {},\n  refresh: () => {},\n  buildOk: () => {},\n  issues: (_issues: Issue[]) => {},\n}\n\nexport function setHooks(newHooks: typeof hooks) {\n  Object.assign(hooks, newHooks)\n}\n\nfunction handleSocketMessage(msg: ServerMessage) {\n  sortIssues(msg.issues)\n\n  handleIssues(msg)\n\n  switch (msg.type) {\n    case 'issues':\n      // issues are already handled\n      break\n    case 'partial':\n      // aggregate updates\n      aggregateUpdates(msg)\n      break\n    default:\n      // run single update\n      const runHooks = chunkListsWithPendingUpdates.size === 0\n      if (runHooks) hooks.beforeRefresh()\n      triggerUpdate(msg)\n      if (runHooks) finalizeUpdate()\n      break\n  }\n}\n\nfunction finalizeUpdate() {\n  hooks.refresh()\n  hooks.buildOk()\n\n  // This is used by the Next.js integration test suite to notify it when HMR\n  // updates have been completed.\n  // TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)\n  if (globalThis.__NEXT_HMR_CB) {\n    globalThis.__NEXT_HMR_CB()\n    globalThis.__NEXT_HMR_CB = null\n  }\n}\n\nfunction subscribeToChunkUpdate(\n  chunkListPath: ChunkListPath,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n): () => void {\n  return subscribeToUpdate(\n    {\n      path: chunkListPath,\n    },\n    sendMessage,\n    callback\n  )\n}\n\nexport function subscribeToUpdate(\n  resource: ResourceIdentifier,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n) {\n  const key = resourceKey(resource)\n  let callbackSet: UpdateCallbackSet\n  const existingCallbackSet = updateCallbackSets.get(key)\n  if (!existingCallbackSet) {\n    callbackSet = {\n      callbacks: new Set([callback]),\n      unsubscribe: subscribeToUpdates(sendMessage, resource),\n    }\n    updateCallbackSets.set(key, callbackSet)\n  } else {\n    existingCallbackSet.callbacks.add(callback)\n    callbackSet = existingCallbackSet\n  }\n\n  return () => {\n    callbackSet.callbacks.delete(callback)\n\n    if (callbackSet.callbacks.size === 0) {\n      callbackSet.unsubscribe()\n      updateCallbackSets.delete(key)\n    }\n  }\n}\n\nfunction triggerUpdate(msg: ServerMessage) {\n  const key = resourceKey(msg.resource)\n  const callbackSet = updateCallbackSets.get(key)\n  if (!callbackSet) {\n    return\n  }\n\n  for (const callback of callbackSet.callbacks) {\n    callback(msg)\n  }\n\n  if (msg.type === 'notFound') {\n    // This indicates that the resource which we subscribed to either does not exist or\n    // has been deleted. In either case, we should clear all update callbacks, so if a\n    // new subscription is created for the same resource, it will send a new \"subscribe\"\n    // message to the server.\n    // No need to send an \"unsubscribe\" message to the server, it will have already\n    // dropped the update stream before sending the \"notFound\" message.\n    updateCallbackSets.delete(key)\n  }\n}\n"],"names":[],"decodedMappings":[[],[],[],[],[[0,0,0,0],[59,0,0,59]],[[0,0,1,0],[60,0,1,60]],[[0,0,2,0],[61,0,2,61]],[[0,0,3,0],[61,0,3,61]],[],[],[],[],[],[],[],[],[[0,0,21,7],[9,0,21,16],[17,0,21,24],[19,0,22,2],[37,0,22,20],[39,0,23,2],[50,0,23,13],[52,0,24,2],[68,0,24,18],[76,0,24,26],[81,0,24,31],[83,0,25,16]],[[4,0,26,2],[23,0,26,21],[24,0,26,22]],[[8,0,27,4],[15,0,27,12],[19,0,27,16],[23,0,27,20]],[[12,0,28,6],[17,0,28,11]],[[16,0,29,8],[38,0,29,30]],[[16,0,30,8]],[[12,0,31,6]],[[16,0,32,8],[20,0,32,12]],[[20,0,33,10],[24,0,33,14],[30,0,33,20],[37,0,33,27],[38,0,33,28],[42,0,33,32],[46,0,33,36],[49,0,33,39]],[[24,0,34,12],[28,0,34,17],[32,0,34,21],[36,0,34,25],[39,0,34,28],[43,0,34,32],[47,0,34,36],[51,0,34,40],[52,0,34,41],[58,0,34,47],[60,0,34,49],[64,0,34,54]],[[28,0,35,14],[48,0,35,34],[52,0,35,38],[56,0,35,42],[57,0,35,43],[59,0,35,45]],[[24,0,36,12]],[[20,0,37,10],[27,0,37,17]],[[24,0,38,12],[44,0,38,32],[48,0,38,36],[52,0,38,40]],[[20,0,39,10]],[[20,0,40,10]],[[16,0,41,8],[18,0,41,10],[25,0,41,17],[28,0,41,29]],[[20,0,42,10],[28,0,42,18],[32,0,42,22],[33,0,43,12],[79,0,44,14],[210,0,45,14],[343,0,46,14],[454,0,47,14],[580,0,48,14]],[[20,0,50,10],[34,0,50,24]],[[20,0,51,10],[29,0,51,19],[35,0,51,25]],[[16,0,52,8]],[[16,0,53,8]],[[8,0,54,4]],[[4,0,55,2]],[[4,0,57,2],[10,0,57,8],[19,0,57,17],[30,0,57,28],[62,0,57,60]],[[4,0,58,2],[8,0,58,6],[18,0,58,16],[26,0,58,24],[27,0,58,25],[33,0,58,31],[40,0,58,38],[41,0,58,39],[50,0,58,48]],[[8,0,59,4],[14,0,59,10],[18,0,59,14],[24,0,59,20]],[[4,0,60,2]],[[4,0,61,2],[15,0,61,13],[47,0,61,45],[50,0,61,48]],[[8,0,62,4],[14,0,62,10],[15,0,62,11],[16,0,62,12],[27,0,62,23],[36,0,62,65]],[[12,0,63,6],[35,0,63,29],[46,0,63,40],[59,0,63,53]],[[8,0,64,4]],[[4,0,65,2]],[[4,0,67,2],[8,0,67,6],[14,0,67,12],[21,0,67,19],[22,0,67,20],[31,0,67,29]],[[8,0,68,4],[13,0,68,9],[19,0,68,15],[20,0,68,16],[31,0,68,27],[40,0,68,36],[44,0,68,40],[51,0,68,48]],[[12,0,69,6],[35,0,69,29],[46,0,69,40],[59,0,69,53]],[[8,0,70,4]],[[4,0,71,2]],[[0,0,72,0]],[[0,0,79,0],[6,0,79,6],[27,0,79,64],[31,0,79,68]],[[0,0,81,0],[9,0,81,9],[18,0,81,18],[29,0,81,42],[31,0,81,44],[38,0,81,66]],[[4,0,82,2],[16,0,82,14],[21,0,82,19],[30,0,82,28],[31,0,82,29]],[[0,0,83,0]],[[0,0,87,0],[9,0,87,9],[21,0,87,21],[29,0,87,49]],[[4,0,88,2],[11,0,88,9],[16,0,88,14],[25,0,88,23],[26,0,88,24]],[[8,0,89,4],[14,0,89,10],[23,0,89,19],[27,0,89,23]],[[8,0,90,4],[17,0,90,13],[26,0,90,22],[33,0,90,29],[37,0,90,33]],[[4,0,91,2]],[[0,0,92,0]],[[0,0,94,0],[9,0,94,9],[28,0,95,2],[39,0,95,26],[41,0,96,2],[49,0,96,30]],[[4,0,98,2],[13,0,98,11],[26,0,98,24]],[[8,0,99,4],[14,0,99,10]],[[8,0,100,4],[11,0,100,7],[19,0,100,15]],[[4,0,101,2]],[[4,0,103,2],[11,0,103,9]],[[8,0,104,4],[17,0,104,13],[30,0,104,26]],[[12,0,105,6],[18,0,105,12]],[[12,0,106,6],[15,0,106,9],[23,0,106,17]],[[8,0,107,4]],[[4,0,108,2]],[[0,0,109,0]],[[0,0,111,0],[9,0,111,9],[31,0,111,31],[42,0,111,55]],[[4,0,112,2],[9,0,112,7],[15,0,112,13],[22,0,112,20],[41,0,112,39],[45,0,112,43],[48,0,112,47]],[[8,0,113,4],[27,0,113,23],[40,0,113,36],[45,0,113,41],[50,0,113,46],[51,0,113,47]],[[4,0,114,2]],[[0,0,115,0]],[[0,0,117,0],[65,0,117,65]],[[0,0,118,0],[6,0,118,6],[37,0,119,2],[41,0,119,6]],[[0,0,121,0],[9,0,121,9],[26,0,121,26],[29,0,121,51]],[[4,0,122,2],[10,0,122,8],[16,0,122,14],[28,0,122,26],[32,0,122,30],[40,0,122,38]],[[4,0,123,2],[8,0,123,6],[21,0,123,19],[50,0,123,48],[53,0,123,51],[54,0,123,52]],[[4,0,125,2],[8,0,125,6],[20,0,125,18]],[[8,0,126,4],[19,0,126,15],[30,0,126,26],[33,0,126,29],[55,0,127,6],[66,0,127,17],[77,0,127,28],[79,0,128,6],[83,0,128,10],[94,0,128,21]],[[4,0,130,2],[11,0,130,9]],[[8,0,131,4],[37,0,131,33],[40,0,131,36],[41,0,131,37],[46,0,131,42]],[[4,0,132,2]],[[0,0,133,0]],[[0,0,135,0],[9,0,135,9]],[[4,0,136,2],[8,0,136,6],[37,0,136,35],[41,0,136,39],[46,0,136,44],[49,0,136,47]],[[4,0,137,2],[10,0,137,8],[23,0,137,21]],[[4,0,138,2],[9,0,138,7],[15,0,138,13],[22,0,138,20],[51,0,138,49],[57,0,138,55],[60,0,138,59]],[[8,0,139,4],[22,0,139,18]],[[4,0,140,2]],[[4,0,141,2],[33,0,141,31],[38,0,141,36]],[[4,0,142,2]],[[0,0,143,0]],[[0,0,145,0],[9,0,145,9],[31,0,146,2],[38,0,146,26],[40,0,147,2],[47,0,147,26]],[[4,0,149,2],[8,0,149,6]],[[4,0,150,2],[8,0,150,6],[16,0,150,14],[22,0,150,20],[26,0,150,24],[32,0,150,30]],[[8,0,151,4],[12,0,151,8],[20,0,151,16],[26,0,151,22],[30,0,151,26],[36,0,151,32]],[[12,0,152,6],[21,0,152,15],[29,0,152,23],[35,0,152,29]],[[8,0,153,4],[15,0,153,11]],[[12,0,154,6],[21,0,154,15],[42,0,154,36],[50,0,154,44],[56,0,154,50],[58,0,154,52],[66,0,154,60],[72,0,154,66]],[[8,0,155,4]],[[4,0,156,2],[11,0,156,9],[15,0,156,13],[23,0,156,21],[29,0,156,27],[33,0,156,31],[39,0,156,37]],[[8,0,157,4],[17,0,157,13],[25,0,157,21],[31,0,157,27]],[[4,0,158,2]],[[4,0,160,2],[8,0,160,6]],[[4,0,161,2],[8,0,161,6],[16,0,161,14],[22,0,161,20],[26,0,161,24],[32,0,161,30]],[[8,0,162,4],[12,0,162,8],[20,0,162,16],[26,0,162,22],[30,0,162,26],[36,0,162,32]],[[12,0,163,6],[21,0,163,15],[29,0,163,23],[35,0,163,29]],[[8,0,164,4],[15,0,164,11]],[[12,0,165,6],[84,0,165,78]],[[12,0,166,6],[38,0,166,32]],[[12,0,167,6],[86,0,167,80]],[[12,0,168,6],[50,0,168,44]],[[12,0,169,6],[16,0,169,10],[25,0,169,19],[33,0,169,27],[39,0,169,33],[40,0,169,34],[42,0,169,36]],[[12,0,170,6],[16,0,170,11],[20,0,170,15],[24,0,170,19],[27,0,170,22],[31,0,170,26],[39,0,170,34],[45,0,170,40],[46,0,170,41],[52,0,170,47],[54,0,170,49],[58,0,170,54]],[[16,0,171,8],[25,0,171,17],[63,0,172,10],[71,0,173,10],[79,0,173,18],[85,0,173,24],[86,0,173,25],[88,0,173,27]],[[12,0,175,6]],[[12,0,177,6],[16,0,177,11],[20,0,177,15],[24,0,177,19],[27,0,177,22],[31,0,177,26],[39,0,177,34],[45,0,177,40],[46,0,177,41],[52,0,177,47],[54,0,177,49],[58,0,177,54]],[[16,0,178,8],[25,0,178,17],[63,0,179,10],[71,0,180,10],[79,0,180,18],[85,0,180,24],[86,0,180,25],[88,0,180,27]],[[12,0,182,6]],[[12,0,184,6],[21,0,184,15]],[[16,0,184,16]],[[13,0,184,23]],[[8,0,185,4]],[[4,0,186,2],[11,0,186,9],[15,0,186,13],[23,0,186,21],[29,0,186,27],[33,0,186,31],[39,0,186,37]],[[8,0,187,4],[17,0,187,13],[25,0,187,21],[31,0,187,27]],[[4,0,188,2]],[[4,0,190,2],[11,0,190,9]],[[8,0,191,4],[14,0,191,10]],[[8,0,192,4]],[[8,0,193,4]],[[4,0,194,2]],[[0,0,195,0]],[[0,0,197,0],[9,0,197,9],[30,0,198,2],[37,0,198,41],[39,0,199,2],[46,0,199,41]],[[4,0,201,2],[10,0,201,8],[19,0,201,49],[20,0,201,50]],[[4,0,203,2],[9,0,203,7],[15,0,203,13],[16,0,203,14],[27,0,203,25],[40,0,203,38],[44,0,203,42],[51,0,203,49],[58,0,203,56],[59,0,203,57],[68,0,205,5]],[[8,0,206,4],[14,0,206,10],[29,0,206,25],[36,0,206,32],[37,0,206,33],[47,0,206,43]],[[8,0,207,4],[12,0,207,8],[28,0,207,24],[34,0,207,30]],[[12,0,208,6],[18,0,208,12],[33,0,208,27],[51,0,208,45],[65,0,208,59]],[[12,0,209,6],[16,0,209,10],[32,0,209,26],[38,0,209,32]],[[16,0,210,8],[22,0,210,14],[23,0,210,15],[33,0,210,25],[36,0,210,28]],[[12,0,211,6]],[[8,0,212,4],[15,0,212,11]],[[12,0,213,6],[18,0,213,12],[19,0,213,13],[29,0,213,23],[32,0,213,26]],[[8,0,214,4]],[[4,0,215,2]],[[4,0,217,2],[9,0,217,7],[15,0,217,13],[16,0,217,14],[27,0,217,25],[40,0,217,38],[44,0,217,42],[51,0,217,49],[58,0,217,56],[59,0,217,57],[68,0,219,5]],[[8,0,220,4],[12,0,220,8],[18,0,220,14],[19,0,220,15],[29,0,220,25],[33,0,220,29],[39,0,220,35]],[[12,0,221,6],[18,0,221,12],[19,0,221,13],[29,0,221,23],[32,0,221,26]],[[8,0,222,4]],[[4,0,223,2]],[[4,0,225,2],[11,0,225,9]],[[0,0,226,0]],[[0,0,228,0],[9,0,228,9],[27,0,229,2],[34,0,229,22],[36,0,230,2],[43,0,230,22]],[[4,0,232,2],[8,0,233,4],[8,0,233,5],[16,0,233,13],[20,0,233,17],[25,0,233,22],[36,0,233,33],[44,0,233,41],[48,0,233,45],[53,0,233,50],[66,0,234,5],[74,0,234,13],[78,0,234,17],[83,0,234,22],[96,0,234,35],[104,0,234,43],[108,0,234,47],[113,0,234,52],[122,0,235,4]],[[8,0,236,4],[15,0,236,11]],[[4,0,237,2]],[[4,0,239,2],[8,0,239,6],[16,0,239,14],[20,0,239,18],[25,0,239,23],[36,0,239,34]],[[8,0,240,4],[18,0,240,14],[26,0,240,22],[37,0,240,33],[39,0,240,35]],[[4,0,241,2]],[[4,0,243,2],[8,0,243,6],[16,0,243,14],[20,0,243,18],[25,0,243,23],[36,0,243,34]],[[8,0,244,4],[18,0,244,14],[26,0,244,22],[37,0,244,33],[39,0,244,35]],[[4,0,245,2]],[[4,0,247,2],[11,0,247,9]],[[0,0,248,0]],[[0,0,250,0],[9,0,250,9],[47,0,251,2],[54,0,251,33],[56,0,252,2],[63,0,252,33]],[[4,0,254,2],[10,0,254,8],[20,0,254,18],[48,0,254,46],[56,0,254,54],[63,0,254,61],[65,0,254,63],[73,0,254,71],[80,0,254,78]],[[4,0,255,2],[10,0,255,8],[19,0,255,17],[48,0,255,46],[56,0,255,54],[62,0,255,60],[64,0,255,62],[72,0,255,70],[78,0,255,76]],[[4,0,257,2],[11,0,257,9]],[[8,0,258,4],[14,0,258,10]],[[8,0,259,4]],[[8,0,260,4]],[[4,0,261,2]],[[0,0,262,0]],[[0,0,264,0],[9,0,264,9],[37,0,265,2],[45,0,265,63],[47,0,266,2],[55,0,266,63]],[[4,0,268,2],[11,0,268,9]],[[8,0,268,11],[11,0,268,14],[19,0,268,22]],[[8,0,268,24],[11,0,268,27],[19,0,268,35]],[[4,0,268,36]],[[0,0,269,0]],[[0,0,271,0],[9,0,271,9],[38,0,272,2],[45,0,272,69],[47,0,273,2],[54,0,273,69]],[[4,0,275,2],[8,0,275,6],[19,0,275,17],[25,0,275,23]],[[8,0,276,4],[15,0,276,11]],[[4,0,277,2]],[[4,0,279,2],[8,0,279,6],[19,0,279,17],[25,0,279,23]],[[8,0,280,4],[15,0,280,11]],[[4,0,281,2]],[[4,0,283,2],[10,0,283,8],[19,0,283,65],[20,0,283,66]],[[4,0,285,2],[9,0,285,7],[15,0,285,13],[16,0,285,14],[27,0,285,25],[40,0,285,38],[44,0,285,42],[51,0,285,49],[58,0,285,56],[59,0,285,57],[68,0,287,5]],[[8,0,288,4],[14,0,288,10],[29,0,288,25],[36,0,288,32],[37,0,288,33],[47,0,288,43]],[[8,0,289,4],[12,0,289,8],[28,0,289,24],[34,0,289,30]],[[12,0,290,6],[18,0,290,12],[33,0,290,27],[61,0,291,8],[75,0,292,8]],[[12,0,294,6],[16,0,294,10],[32,0,294,26],[38,0,294,32]],[[16,0,295,8],[22,0,295,14],[23,0,295,15],[33,0,295,25],[36,0,295,28]],[[12,0,296,6]],[[8,0,297,4],[15,0,297,11]],[[12,0,298,6],[18,0,298,12],[19,0,298,13],[29,0,298,23],[32,0,298,26]],[[8,0,299,4]],[[4,0,300,2]],[[4,0,302,2],[9,0,302,7],[15,0,302,13],[16,0,302,14],[27,0,302,25],[40,0,302,38],[44,0,302,42],[51,0,302,49],[58,0,302,56],[59,0,302,57],[68,0,304,5]],[[8,0,305,4],[12,0,305,8],[18,0,305,14],[19,0,305,15],[29,0,305,25],[33,0,305,29],[39,0,305,35]],[[12,0,306,6],[18,0,306,12],[19,0,306,13],[29,0,306,23],[32,0,306,26]],[[8,0,307,4]],[[4,0,308,2]],[[4,0,310,2],[8,0,310,6],[15,0,310,13],[19,0,310,17],[20,0,310,18],[28,0,310,26],[34,0,310,32],[39,0,310,37],[42,0,310,40]],[[8,0,311,4],[15,0,311,11]],[[4,0,312,2]],[[4,0,314,2],[11,0,314,9]],[[0,0,315,0]],[[0,0,317,0],[9,0,317,9],[37,0,318,2],[44,0,318,38],[46,0,319,2],[53,0,319,38]],[[4,0,321,2],[8,0,321,6],[16,0,321,14],[20,0,321,18],[25,0,321,23],[36,0,321,34],[44,0,321,42],[48,0,321,46],[53,0,321,51],[64,0,321,62]],[[8,0,322,4],[54,0,322,50]],[[8,0,323,4],[15,0,323,11]],[[4,0,324,2]],[[4,0,326,2],[8,0,326,6],[16,0,326,14],[20,0,326,18],[25,0,326,23],[38,0,326,36],[46,0,326,44],[50,0,326,48],[55,0,326,53],[64,0,326,62]],[[8,0,327,4],[14,0,327,10],[22,0,327,18],[24,0,327,20]],[[8,0,328,4],[14,0,328,10],[24,0,328,20],[26,0,328,22]],[[8,0,329,4],[14,0,329,10],[31,0,329,27],[35,0,329,31],[39,0,329,35],[47,0,329,43],[54,0,329,50],[58,0,329,54],[60,0,329,56]],[[8,0,330,4],[14,0,330,10],[29,0,330,25],[33,0,330,29],[37,0,330,33],[45,0,330,41],[52,0,330,48],[56,0,330,52],[58,0,330,54]],[[8,0,332,4],[13,0,332,9],[19,0,332,15],[31,0,332,27],[44,0,332,41]],[[12,0,333,6],[16,0,333,10],[17,0,333,11],[32,0,333,26],[35,0,333,29],[36,0,333,30],[47,0,333,41]],[[16,0,334,8],[22,0,334,14],[26,0,334,18],[27,0,334,19]],[[12,0,335,6]],[[8,0,336,4]],[[8,0,338,4],[13,0,338,9],[19,0,338,15],[31,0,338,27],[46,0,338,43]],[[12,0,339,6],[16,0,339,10],[17,0,339,11],[30,0,339,24],[33,0,339,27],[34,0,339,28],[45,0,339,39]],[[16,0,340,8],[24,0,340,16],[28,0,340,20],[29,0,340,21]],[[12,0,341,6]],[[8,0,342,4]],[[8,0,344,4],[12,0,344,8],[18,0,344,14],[24,0,344,20],[29,0,344,25],[34,0,344,30],[42,0,344,38],[48,0,344,44],[53,0,344,49],[56,0,344,52]],[[12,0,345,6],[19,0,345,13]],[[8,0,346,4]],[[8,0,348,4],[15,0,348,11]],[[12,0,349,6],[18,0,349,12]],[[12,0,350,6]],[[12,0,351,6]],[[8,0,352,4]],[[4,0,353,2]],[[4,0,355,2],[8,0,355,6],[16,0,355,14],[20,0,355,18],[25,0,355,23],[38,0,355,36],[46,0,355,44],[50,0,355,48],[55,0,355,53],[66,0,355,64]],[[8,0,356,4],[14,0,356,10],[22,0,356,18],[26,0,356,22],[30,0,356,26]],[[15,0,356,31],[23,0,356,39],[28,0,356,44],[32,0,356,48],[34,0,356,50]],[[15,0,356,57],[23,0,356,65],[28,0,356,70],[32,0,356,74],[34,0,356,76]],[[9,0,356,78]],[[8,0,357,4],[14,0,357,10],[24,0,357,20],[28,0,357,24],[32,0,357,28]],[[15,0,358,10],[23,0,358,18],[30,0,358,25],[34,0,358,29],[36,0,358,31]],[[15,0,359,10],[23,0,359,18],[30,0,359,25],[34,0,359,29],[36,0,359,31]],[[9,0,360,5]],[[8,0,362,4],[12,0,362,8],[20,0,362,16],[25,0,362,21],[29,0,362,25],[35,0,362,31]],[[12,0,363,6],[17,0,363,11],[23,0,363,17],[35,0,363,29],[43,0,363,37],[48,0,363,42],[49,0,363,44]],[[16,0,364,8],[24,0,364,16],[30,0,364,22],[31,0,364,23]],[[12,0,365,6]],[[8,0,366,4]],[[8,0,368,4],[12,0,368,8],[20,0,368,16],[27,0,368,23],[31,0,368,27],[37,0,368,33]],[[12,0,369,6],[17,0,369,11],[23,0,369,17],[35,0,369,29],[43,0,369,37],[50,0,369,44],[51,0,369,46]],[[16,0,370,8],[22,0,370,14],[28,0,370,20],[29,0,370,21]],[[12,0,371,6]],[[8,0,372,4]],[[8,0,374,4],[15,0,374,11]],[[12,0,375,6],[18,0,375,12]],[[12,0,376,6],[19,0,376,13]],[[19,0,376,17]],[[13,0,376,23]],[[12,0,377,6],[21,0,377,15]],[[19,0,377,19]],[[13,0,377,27]],[[8,0,378,4]],[[4,0,379,2]],[[4,0,381,2],[8,0,381,6],[16,0,381,14],[20,0,381,18],[25,0,381,23],[36,0,381,34],[44,0,381,42],[48,0,381,46],[53,0,381,51],[64,0,381,62]],[[8,0,382,4],[14,0,382,10],[24,0,382,20],[28,0,382,24],[32,0,382,28]],[[15,0,383,10],[23,0,383,18],[30,0,383,25],[34,0,383,29],[36,0,383,31]],[[15,0,384,10],[23,0,384,18],[28,0,384,23],[32,0,384,27],[34,0,384,29]],[[9,0,385,5]],[[8,0,387,4],[13,0,387,9],[19,0,387,15],[31,0,387,27],[39,0,387,35],[46,0,387,42],[50,0,387,46],[52,0,387,48],[53,0,387,50]],[[12,0,388,6],[20,0,388,14],[26,0,388,20],[27,0,388,21]],[[8,0,389,4]],[[8,0,391,4],[15,0,391,11]],[[12,0,392,6],[18,0,392,12]],[[12,0,393,6],[21,0,393,15]],[[19,0,393,19]],[[13,0,393,27]],[[8,0,394,4]],[[4,0,395,2]],[[4,0,397,2],[8,0,397,6],[16,0,397,14],[20,0,397,18],[25,0,397,23],[38,0,397,36],[46,0,397,44],[50,0,397,48],[55,0,397,53],[66,0,397,64]],[[8,0,398,4],[80,0,398,76]],[[8,0,399,4],[52,0,399,48]],[[8,0,401,4],[14,0,401,10],[24,0,401,20],[28,0,401,24],[32,0,401,28],[40,0,401,36],[47,0,401,43],[51,0,401,47],[53,0,401,49]],[[8,0,403,4],[12,0,403,8],[20,0,403,16],[25,0,403,21],[29,0,403,25],[35,0,403,31]],[[12,0,404,6],[17,0,404,11],[23,0,404,17],[35,0,404,29],[43,0,404,37],[48,0,404,42],[49,0,404,44]],[[16,0,405,8],[24,0,405,16],[30,0,405,22],[31,0,405,23]],[[12,0,406,6]],[[8,0,407,4]],[[8,0,409,4],[15,0,409,11]],[[12,0,410,6],[18,0,410,12]],[[12,0,411,6],[21,0,411,15]],[[19,0,411,19]],[[13,0,411,27]],[[8,0,412,4]],[[4,0,413,2]],[[4,0,415,2],[47,0,415,45]],[[4,0,417,2],[11,0,417,9]],[[0,0,418,0]],[[0,0,420,0],[9,0,420,9],[19,0,420,19],[20,0,420,27],[22,0,420,29],[29,0,420,44]],[[4,0,421,2],[10,0,421,8],[14,0,421,12],[20,0,421,18],[21,0,421,19],[32,0,421,30],[34,0,421,32],[43,0,421,41]],[[0,0,422,0]],[[0,0,424,0],[6,0,424,6],[17,0,424,17]],[[4,0,424,18]],[[4,0,424,25]],[[4,0,424,34]],[[1,0,424,42]],[[0,0,426,0],[9,0,426,9],[23,0,426,23],[27,0,426,34],[29,0,426,36],[30,0,426,42],[32,0,426,44],[33,0,426,50]],[[4,0,427,2],[10,0,427,8],[15,0,427,13],[20,0,427,18],[27,0,427,25],[28,0,427,26],[33,0,427,31],[38,0,427,36],[43,0,427,41],[49,0,427,47]],[[4,0,428,2],[10,0,428,8],[15,0,428,13],[20,0,428,18],[27,0,428,25],[28,0,428,26],[33,0,428,31],[38,0,428,36],[43,0,428,41],[49,0,428,47]],[[4,0,429,2],[11,0,429,9],[16,0,429,14]],[[0,0,430,0]],[[0,0,432,0],[6,0,432,6],[25,0,432,52],[29,0,432,56]],[[0,0,434,0],[9,0,434,9]],[[4,0,435,2],[10,0,435,8],[19,0,435,17],[21,0,435,19]],[[4,0,436,2],[10,0,436,8],[29,0,436,27],[33,0,436,31]],[[4,0,438,2],[9,0,438,7],[15,0,438,13],[16,0,438,14],[19,0,438,17],[31,0,438,29],[35,0,438,33],[52,0,438,51]],[[8,0,439,4],[13,0,439,9],[19,0,439,15],[33,0,439,29],[45,0,439,42]],[[12,0,440,6],[16,0,440,10],[33,0,440,27],[36,0,440,30],[37,0,440,31],[48,0,440,42],[57,0,440,51],[60,0,440,54]],[[12,0,442,6],[19,0,442,13],[23,0,442,17],[24,0,442,18]],[[12,0,443,6],[29,0,443,23],[32,0,443,26],[33,0,443,27],[44,0,443,38],[53,0,443,47]],[[8,0,444,4]],[[4,0,445,2]],[[4,0,447,2],[15,0,447,13]],[[4,0,449,2],[10,0,449,8],[16,0,449,14],[17,0,449,15]],[[0,0,450,0]],[[0,0,452,0],[9,0,452,9],[22,0,452,22],[25,0,452,40]],[[4,0,453,2],[10,0,453,8],[16,0,453,14],[28,0,453,26],[32,0,453,30],[40,0,453,38]],[[4,0,454,2],[8,0,454,6],[28,0,454,26]],[[4,0,456,2],[9,0,456,7],[15,0,456,13],[24,0,456,22],[28,0,456,26],[34,0,456,32],[35,0,456,34]],[[8,0,457,4],[12,0,457,8],[21,0,457,17],[29,0,457,25],[30,0,457,26],[36,0,457,32],[44,0,457,40],[47,0,457,43]],[[12,0,458,6],[32,0,458,26]],[[8,0,459,4]],[[4,0,460,2]],[[4,0,462,2],[8,0,462,6],[12,0,462,10],[18,0,462,16],[19,0,462,17],[25,0,462,23],[28,0,462,26],[31,0,462,29]],[[8,0,463,4],[25,0,463,21],[28,0,463,24],[29,0,463,25],[34,0,463,30],[38,0,463,34],[44,0,463,40]],[[4,0,464,2],[11,0,464,9],[15,0,464,13],[32,0,464,30],[35,0,464,33],[36,0,464,34],[42,0,464,40]],[[8,0,465,4],[25,0,465,21],[31,0,465,27],[32,0,465,28]],[[4,0,466,2]],[[4,0,468,2]],[[4,0,470,2],[11,0,470,9]],[[0,0,471,0]],[[0,0,473,0],[6,0,473,6],[23,0,473,23]],[[4,0,473,24]],[[4,0,473,31]],[[4,0,473,40]],[[4,0,473,49]],[[4,0,473,60]],[[4,0,473,68]],[[1,0,473,74]],[[0,0,474,0],[6,0,474,6],[23,0,474,23]],[[4,0,475,2]],[[4,0,476,2]],[[4,0,477,2]],[[4,0,478,2]],[[4,0,479,2]],[[4,0,480,2]],[[1,0,481,1]],[[0,0,483,0],[9,0,483,9],[20,0,483,20],[26,0,483,35]],[[4,0,484,2],[11,0,484,9],[15,0,484,13],[16,0,484,14],[17,0,484,15],[20,0,484,18]],[[8,0,485,4],[14,0,485,10],[22,0,485,18],[36,0,485,32],[52,0,485,48],[54,0,485,50],[62,0,485,58],[64,0,485,60],[66,0,485,62],[74,0,485,70]],[[8,0,486,4],[12,0,486,8],[22,0,486,18],[25,0,486,21],[32,0,486,28]],[[8,0,487,4],[15,0,487,11],[29,0,487,25],[45,0,487,41],[47,0,487,43],[55,0,487,51],[57,0,487,53],[59,0,487,55],[67,0,487,63]],[[4,0,488,2]],[[0,0,489,0]],[[0,0,491,0],[6,0,491,6],[14,0,491,14]],[[4,0,492,2],[19,0,492,17],[24,0,492,24]],[[4,0,493,2],[13,0,493,11],[18,0,493,18]],[[4,0,494,2],[13,0,494,11],[18,0,494,18]],[[4,0,495,2],[12,0,495,10],[13,0,495,11],[24,0,495,33]],[[0,0,496,0]],[[0,0,498,7],[9,0,498,16],[18,0,498,25],[26,0,498,47]],[[4,0,499,2],[11,0,499,9],[17,0,499,15],[18,0,499,16],[25,0,499,23]],[[0,0,500,0]],[[0,0,502,0],[9,0,502,9],[29,0,502,29],[32,0,502,47]],[[4,0,503,2],[15,0,503,13],[19,0,503,17],[25,0,503,23]],[[4,0,505,2],[17,0,505,15]],[[4,0,507,2],[11,0,507,10],[15,0,507,14],[19,0,507,18]],[[8,0,508,4],[13,0,508,9]],[[12,0,510,6]],[[8,0,511,4],[13,0,511,9]],[[12,0,512,6],[32,0,512,26]],[[12,0,513,6],[29,0,513,23]],[[12,0,514,6]],[[8,0,515,4]],[[12,0,516,6],[32,0,516,26]],[[12,0,517,6],[18,0,517,12],[29,0,517,23],[58,0,517,52],[62,0,517,56],[67,0,517,61]],[[12,0,518,6],[16,0,518,10],[26,0,518,20],[32,0,518,26],[45,0,518,39]],[[12,0,519,6],[26,0,519,20]],[[12,0,520,6],[16,0,520,10],[26,0,520,20]],[[12,0,521,6]],[[4,0,522,2]],[[0,0,523,0]],[[0,0,525,0],[9,0,525,9]],[[4,0,526,2],[10,0,526,8],[17,0,526,15]],[[4,0,527,2],[10,0,527,8],[17,0,527,15]],[[4,0,529,2],[79,0,529,77]],[[4,0,530,2],[35,0,530,33]],[[4,0,531,2],[88,0,531,86]],[[4,0,532,2],[8,0,532,6],[19,0,532,17],[32,0,532,30],[34,0,532,32]],[[8,0,533,4],[19,0,533,15],[32,0,533,28]],[[8,0,534,4],[19,0,534,15],[32,0,534,28],[35,0,534,31]],[[4,0,535,2]],[[0,0,536,0]],[[0,0,538,0],[9,0,538,9],[32,0,539,2],[45,0,539,30],[47,0,540,2],[58,0,540,26],[60,0,541,2],[68,0,541,26]],[[4,0,543,2],[11,0,543,9],[29,0,544,4]],[[8,0,545,6],[14,0,545,12]],[[4,0,546,4],[7,0,547,4],[20,0,548,4]],[[0,0,550,0]],[[0,0,552,7],[9,0,552,16],[27,0,553,2],[35,0,553,30],[37,0,554,2],[48,0,554,26],[50,0,555,2],[58,0,555,26]],[[4,0,557,2],[10,0,557,8],[16,0,557,14],[28,0,557,26]],[[4,0,558,2],[8,0,558,6]],[[4,0,559,2],[10,0,559,8],[32,0,559,30],[51,0,559,49],[54,0,559,52],[55,0,559,53]],[[4,0,560,2],[8,0,560,6],[9,0,560,7],[30,0,560,28]],[[8,0,561,4],[22,0,561,18]],[[12,0,562,6],[23,0,562,17],[27,0,562,21],[31,0,562,25]],[[16,0,562,26]],[[13,0,562,35]],[[12,0,563,6],[25,0,563,19],[44,0,563,38],[57,0,563,51]],[[8,0,564,4]],[[8,0,565,4],[27,0,565,23],[30,0,565,26],[31,0,565,27],[36,0,565,32]],[[4,0,566,2],[11,0,566,9]],[[8,0,567,4],[28,0,567,24],[37,0,567,33],[38,0,567,34],[41,0,567,37],[42,0,567,38]],[[8,0,568,4],[22,0,568,18]],[[4,0,569,2]],[[4,0,571,2],[11,0,571,9]],[[8,0,572,4],[20,0,572,16],[29,0,572,25],[30,0,572,26],[36,0,572,32],[37,0,572,33]],[[8,0,574,4],[12,0,574,8],[24,0,574,20],[33,0,574,29],[34,0,574,30],[38,0,574,34],[43,0,574,39],[46,0,574,42]],[[12,0,575,6],[24,0,575,18],[35,0,575,29]],[[12,0,576,6],[31,0,576,25],[37,0,576,31],[38,0,576,32]],[[8,0,577,4]],[[4,0,578,2]],[[0,0,579,0]],[[0,0,581,0],[9,0,581,9],[23,0,581,23],[26,0,581,41]],[[4,0,582,2],[10,0,582,8],[16,0,582,14],[28,0,582,26],[32,0,582,30],[40,0,582,38]],[[4,0,583,2],[10,0,583,8],[24,0,583,22],[43,0,583,41],[46,0,583,44],[47,0,583,45]],[[4,0,584,2],[8,0,584,6],[9,0,584,7],[22,0,584,20]],[[8,0,585,4]],[[4,0,586,2]],[[4,0,588,2],[9,0,588,7],[15,0,588,13],[27,0,588,25],[39,0,588,37],[48,0,588,46],[49,0,588,48]],[[8,0,589,4],[17,0,589,13]],[[4,0,590,2]],[[4,0,592,2],[8,0,592,6],[12,0,592,10],[16,0,592,14],[21,0,592,19],[33,0,592,31]],[[8,0,593,4],[91,0,593,87]],[[8,0,594,4],[90,0,594,86]],[[8,0,595,4],[92,0,595,88]],[[8,0,596,4],[33,0,596,29]],[[8,0,597,4],[87,0,597,83]],[[8,0,598,4],[75,0,598,71]],[[8,0,599,4],[27,0,599,23],[33,0,599,29],[34,0,599,30]],[[4,0,600,2]],[[0,0,601,0]]]}}