#!/usr/bin/env python
"""Colored coverage report for the backend.

Reads ``coverage.json`` (generated by ``pytest --cov-report=json``) and prints
a Jest-style colored table to the terminal.

Color thresholds (matching the frontend Jest config):
    - Green  : > 80 %
    - Yellow : 50 – 80 %
    - Red    : < 50 %

Usage::

    # After running pytest (which already generates coverage.json via pytest.ini):
    python scripts/colored_coverage.py

    # Or with a custom path:
    python scripts/colored_coverage.py --json path/to/coverage.json
"""

import argparse
import json
import os
import sys
from collections import defaultdict

# ── ANSI color codes ────────────────────────────────────────────────
GREEN = '\033[92m'
YELLOW = '\033[93m'
RED = '\033[91m'
WHITE = '\033[97m'
DIM = '\033[2m'
RESET = '\033[0m'
BOLD = '\033[1m'

# ── Thresholds ──────────────────────────────────────────────────────
HIGH = 80   # > 80 → green
LOW = 50    # < 50 → red  ;  50–80 → yellow

# ── Fixed column widths (matches Jest screenshot) ───────────────────
W_FILE = 36
W_PCT = 8
W_MISS = 20


def _color_for(pct):
    """Return the ANSI color code for a given percentage."""
    if pct > HIGH:
        return GREEN
    if pct >= LOW:
        return YELLOW
    return RED


def _fmt_pct(pct):
    """Format a percentage value with color and right-alignment."""
    color = _color_for(pct)
    text = f'{pct:>{W_PCT}.2f}'
    return f'{color}{text}{RESET}'


def _fmt_missing(missing_lines):
    """Format the uncovered-lines column with red color when non-empty."""
    if not missing_lines:
        return ''
    text = _collapse_ranges(missing_lines)
    if len(text) > W_MISS:
        text = text[:W_MISS - 3] + '...'
    return f'{RED}{text}{RESET}'


def _collapse_ranges(lines):
    """Collapse a sorted list of ints into range strings (e.g. '3-7,10')."""
    if not lines:
        return ''
    lines = sorted(set(lines))
    ranges = []
    start = prev = lines[0]
    for n in lines[1:]:
        if n == prev + 1:
            prev = n
        else:
            ranges.append(f'{start}-{prev}' if start != prev else str(start))
            start = prev = n
    ranges.append(f'{start}-{prev}' if start != prev else str(start))
    return ','.join(ranges)


def _compute_file_stats(file_data):
    """Compute coverage stats for a single file entry from coverage.json."""
    summary = file_data.get('summary', {})
    num_stmts = summary.get('num_statements', 0)
    miss_stmts = summary.get('missing_lines', 0)
    num_branches = summary.get('num_branches', 0)
    miss_branches = summary.get('missing_branches', 0)
    pct_cover = summary.get('percent_covered', 0)

    pct_stmts = ((num_stmts - miss_stmts) / num_stmts * 100) if num_stmts else 100
    pct_branch = ((num_branches - miss_branches) / num_branches * 100) if num_branches else 100

    missing = file_data.get('missing_lines', [])

    return {
        'stmts': num_stmts,
        'miss': miss_stmts,
        'pct_stmts': pct_stmts,
        'branches': num_branches,
        'miss_branches': miss_branches,
        'pct_branch': pct_branch,
        'pct_cover': pct_cover,
        'missing': missing,
    }


def _aggregate_stats(children):
    """Aggregate stats from a list of file stat dicts (for directory rows)."""
    total_stmts = sum(c['stmts'] for c in children)
    total_miss = sum(c['miss'] for c in children)
    total_branches = sum(c['branches'] for c in children)
    total_miss_br = sum(c['miss_branches'] for c in children)

    pct_stmts = ((total_stmts - total_miss) / total_stmts * 100) if total_stmts else 100
    pct_branch = ((total_branches - total_miss_br) / total_branches * 100) if total_branches else 100
    pct_cover = pct_stmts

    return {
        'stmts': total_stmts,
        'miss': total_miss,
        'pct_stmts': pct_stmts,
        'branches': total_branches,
        'miss_branches': total_miss_br,
        'pct_branch': pct_branch,
        'pct_cover': pct_cover,
        'missing': [],
    }


# ── Table rendering ────────────────────────────────────────────────

SEP_CHAR = '-'
PIPE = f'{DIM}|{RESET}'
TOTAL_W = W_FILE + 1 + (W_PCT + 3) * 3 + W_MISS + 3


def _divider():
    return f'{DIM}{SEP_CHAR * TOTAL_W}{RESET}'


def _header():
    f = f'{"File":<{W_FILE}}'
    s = f'{"% Stmts":>{W_PCT}}'
    b = f'{"% Branch":>{W_PCT}}'
    l = f'{"% Lines":>{W_PCT}}'
    m = f'{"Uncovered Line #s":<{W_MISS}}'
    return (
        f' {WHITE}{BOLD}{f}{RESET} {PIPE} '
        f'{WHITE}{BOLD}{s}{RESET} {PIPE} '
        f'{WHITE}{BOLD}{b}{RESET} {PIPE} '
        f'{WHITE}{BOLD}{l}{RESET} {PIPE} '
        f'{WHITE}{BOLD}{m}{RESET}'
    )


def _row(label, stats, indent=0):
    """Format a single data row."""
    name = ' ' * indent + label
    if len(name) > W_FILE:
        name = name[:W_FILE - 3] + '...'

    color = _color_for(stats['pct_cover'])
    padded = f'{name:<{W_FILE}}'
    miss_str = _fmt_missing(stats.get('missing', []))

    return (
        f' {color}{padded}{RESET} {PIPE} '
        f'{_fmt_pct(stats["pct_stmts"])} {PIPE} '
        f'{_fmt_pct(stats["pct_branch"])} {PIPE} '
        f'{_fmt_pct(stats["pct_cover"])} {PIPE} '
        f'{miss_str}'
    )


def _build_tree(file_stats, base_path):
    """Organize flat file stats into a directory tree for grouped display."""
    tree = defaultdict(list)
    for fpath, stats in sorted(file_stats.items()):
        rel = os.path.relpath(fpath, base_path)
        parts = rel.split(os.sep)
        if len(parts) > 1:
            directory = os.sep.join(parts[:-1])
            filename = parts[-1]
        else:
            directory = ''
            filename = parts[0]
        tree[directory].append((filename, stats))
    return tree


def print_report(coverage_json_path):
    """Load coverage.json and print the colored report."""
    if not os.path.isfile(coverage_json_path):
        print(f'{RED}Error: {coverage_json_path} not found.{RESET}')
        print('Run pytest first to generate the coverage JSON report.')
        sys.exit(1)

    with open(coverage_json_path, 'r') as f:
        data = json.load(f)

    files = data.get('files', {})
    if not files:
        print(f'{YELLOW}No file coverage data found in {coverage_json_path}.{RESET}')
        sys.exit(0)

    # Determine common base path
    all_paths = list(files.keys())
    base_path = (
        os.path.commonpath(all_paths)
        if len(all_paths) > 1
        else os.path.dirname(all_paths[0])
    )

    # Compute per-file stats
    file_stats = {}
    for fpath, fdata in files.items():
        file_stats[fpath] = _compute_file_stats(fdata)

    # Build tree
    tree = _build_tree(file_stats, base_path)

    # Compute totals
    all_stats = list(file_stats.values())
    totals = _aggregate_stats(all_stats)

    # Print table
    print()
    print(_divider())
    print(_header())
    print(_divider())
    print(_row('All files', totals))

    for directory in sorted(tree.keys()):
        entries = tree[directory]
        if directory:
            dir_stats = _aggregate_stats([s for _, s in entries])
            print(_row(directory, dir_stats, indent=1))
        for filename, stats in entries:
            print(_row(filename, stats, indent=3 if directory else 1))

    print(_divider())
    print()

    # Summary box
    ts = totals['stmts']
    ms = totals['miss']
    tb = totals['branches']
    mb = totals['miss_branches']
    bar = '=' * 79
    print(f'{BOLD}{bar}{RESET}')
    print(f'{BOLD}{"Coverage summary":^79}{RESET}')
    print(f'{BOLD}{bar}{RESET}')
    cs = _color_for(totals['pct_stmts'])
    cb = _color_for(totals['pct_branch'])
    cl = _color_for(totals['pct_cover'])
    print(f'Statements   : {cs}{totals["pct_stmts"]:.2f}%{RESET}  ( {ts - ms}/{ts} )')
    print(f'Branches     : {cb}{totals["pct_branch"]:.2f}%{RESET}  ( {tb - mb}/{tb} )')
    print(f'Lines        : {cl}{totals["pct_cover"]:.2f}%{RESET}')
    print(f'{BOLD}{bar}{RESET}')
    print()


def main():
    parser = argparse.ArgumentParser(description='Colored backend coverage report')
    parser.add_argument(
        '--json',
        default='coverage.json',
        help='Path to coverage.json (default: coverage.json)',
    )
    args = parser.parse_args()
    print_report(args.json)


if __name__ == '__main__':
    main()
